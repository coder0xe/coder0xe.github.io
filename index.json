[{"content":"CPP:STL库 C++泛型编程和STL技术\n1.模版 学习模版并不是为了写模版，而是在STL中能够运用系统提供的模版\n1.1 函数模版 模版就是建立通用的模具，大大提高复用性 C++中另一种编程思想称为泛型编程，主要利用的技术就是模版 C++中提供两种模版机制：函数模版和类模版 1.1.1 函数模版语法 建立一个通用函数，其函数的返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表\n语法：template关键字声明一个通用数据类型T\n1 2 template\u0026lt;typename T\u0026gt; 函数声明或定义 template声明创建模版 typename表明其后面的符号是一种数据类型，可以用class代替 T：通用的数据类型，名称可以替换 1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; void swap(T \u0026amp;a, T \u0026amp;b) { T temp = a; a = b; b = temp; } 自动类型推导：我们在模版中使用通用类型T，当传入具体的数据类型时，根据该数据类型推导出T的类型\n1 swap(a,b); 显示指定类型：在调用时指定数据类型\n1 swap\u0026lt;int\u0026gt;(a,b); 将类型参数化，提高复用性\n1.1.2 函数模版注意事项 自动类型推导：必须推导出一致的数据类型T才可以使用(传入一致的数据类型) 模版必须要确定出T的数据类型才可以使用 1.1.3 普通函数和函数模版的区别 普通函数调用时可以发生自动类型转换（隐式类型转换）\n函数模版调用时，用自动类型推导不可以发生隐式类型转换，因为不知道往哪里转\n函数模版用显示指定类型，可以发生隐式类型转换，指定了转换到一个数据类型\n1 myAdd\u0026lt;int\u0026gt;(a, \u0026#39;c\u0026#39;); 隐式类型转换：例如char和Int，Int与double之间的转换\n建议使用指定显示类型的方式\n1.1.4 普通函数和函数模版的调用规则 普通函数与函数模版发生重载时\n如果普通函数和函数模版都可以实现，优先调用普通函数\n可以通过空模版参数列表来强制调用函数模版\n1 2 myPrint(a,b); // 调用普通函数 myPrint\u0026lt;\u0026gt;(a,b); // 调用模板函数 函数模版可以发生函数重载\n函数模版可以产生更好地匹配，优先调用函数模版，例如使用普通函数需要隐式类型转换时\n1 2 3 char c = \u0026#39;c\u0026#39;; char d = \u0026#39;d\u0026#39;; myPrint(c,d); // 调用函数模版 一般来说实际开发中不会出现同时有普通函数和函数模版\n1.1.5 模版的局限性 例如\n1 2 3 4 5 template \u0026lt;class T\u0026gt; void f(T a, T b) { a = b; } 如果传入的是数组，则无法实现 可以为特定的类型指定具体的模版\n例如以下函数模版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Person { public: string name; int age; Person (string name, int age) { this-\u0026gt;name = name; this-\u0026gt;age = age; } }; template \u0026lt;class T\u0026gt; bool myCompare(T \u0026amp;a, T \u0026amp;b) { if (a == b) { return true; } else { return false; } } 解决方案一：运算符重载operator==\n1 2 3 4 5 6 7 bool operator == (Person \u0026amp;a, Person \u0026amp;b) { if (a.name == b.name \u0026amp;\u0026amp; a.age == b.age) { return true; } else { return false; } } 解决方法二：若是多种运算符，则多次运算符重载，麻烦！\n可以针对特殊数据类型进行模版重载，具体化Person的模版实现 1 2 3 4 5 6 7 template \u0026lt;\u0026gt; bool myCompare(Person \u0026amp;a, Person \u0026amp;b) { if (a.name == b.name \u0026amp;\u0026amp; a.age == b.age) { return true; } else { return false; } } 1.2 类模版 1.2.1 类模版语法 建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表\n语法\n1 2 3 4 5 6 template \u0026lt;class NameType, class AgeType\u0026gt; // 指定多通用数据类型的方式在函数模版中同样适用 class Person{ public : NameType name; AgeType age; } 说明\ntemplate声明创建模版 class后跟通用数据类型（多个） 指定模版参数列表\n1 Person\u0026lt;string, int\u0026gt;p1(\u0026#34;孙悟空\u0026#34;,999); 1.2.2 类模版与函数模版区别 类模版没有自动类型推导的使用方式，必须显示指定数据类型\n类模版在模版参数列表中可以有默认参数，即可以指定通用数据类型的默认类型\n1 2 template \u0026lt;class NameType = string, class AgeType = int\u0026gt; // 给默认的数据类型 Person p(\u0026#34;dqr\u0026#34;,20); 此时可以缺省已经给定的数据类型，不必指定数据类型 1.2.3 类模版中成员函数创建时机 普通类中的成员函数一开始就可以创建 类模版中的成员函数在调用时才创建 1.2.4 类模版对象做函数参数 类模版实例化出的对象，向函数传参\n指定传入的类型：直接显示对象的数据类型\n1 2 3 void printPerson1(Person\u0026lt;string, int\u0026gt;\u0026amp; p) { p.showPerson(); } 参数模版化：将对象中的参数变为模版进行传递\n1 2 3 4 5 6 template\u0026lt;class T1, class T2\u0026gt; void printPerson2(Person \u0026lt;T1, T2\u0026gt;\u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;T1 \u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2 \u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; p.showPerson(); } 整个类模版化：将这个对象类型模版化进行传递，我认为最方便\n1 2 3 4 5 template\u0026lt;class T\u0026gt; void printPerson3(T\u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;T \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; endl; p.showPerson(); } 查看自动类型推导中转换的数据类型\n1 typeid(T1).name 1.2.5 类模版与继承 当子类继承的父类是一个类模版时，子类在声明时，需要指定出父类中的数据类型\n1 2 3 4 5 6 7 template \u0026lt;class T\u0026gt; class Base { T m; }; class Son : public Base\u0026lt;int\u0026gt; { }; 如果想要灵活的指定父类中的通用数据类型，子类也需要变为类模版\n1 2 3 4 5 6 7 8 template \u0026lt;class T\u0026gt; class Base { T m; }; template \u0026lt;class T1, class T2\u0026gt; class Son : public Base\u0026lt;T1\u0026gt; { // 指定父类中通用数据类型用T1表示 T2 obj; }; 子类指定父类中通用数据类型为通用数据类型T1，子类中通用数据类型为T2 1.2.6 类模版成员函数类外实现 函数类内实现与类外实现\n类外实现：\n类内声明 类外实现，指定作用域为类模版(参数列表) 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;class T1, class T2\u0026gt; class Person { public: T1 name; T2 age; Person(T1 name, T2 age); }; template \u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age) { this-\u0026gt;name = name; this-\u0026gt;age = age; } 1.2.7 类模版分文件编写 问题：类模版中成员函数创建时机是在调用阶段，导致分文件编写时链接不到\n回顾：普通类的分文件编写 .h中编写类的声明(成员函数声明) .cpp中编写类中成员函数的定义 普通类成员函数一开始就创建，类模版中成员函数在调用时创建 即调用时候才创建这个函数，编译时候找不到会发生错误 解决方式1：直接包含.cpp文件，包含什么相当于让编译器看什么\n1 2 #include \u0026#34;Person.h\u0026#34; // error #include \u0026#34;Person.cpp\u0026#34; // success 解决方式2：将声明和实现写到同一个文件中，并将后缀名更改为.hpp，表明这是类模版\n.hpp是约定的名称 小tips：vscode快捷键\n一段代码改为注释：ctrl + K + C 取消注释：ctrl + K +U 1.2.8 类模版与友元 全局函数类内实现\n直接在类内声明友元即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;class T1, class T2\u0026gt; class Person { friend void printPerson(Person\u0026lt;T1, T2\u0026gt; p) { cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; p.name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; } public: Person(T1 name, T2 age) { this-\u0026gt;name = name; this-\u0026gt;age = age; } private: T1 name; T2 age; }; 全局函数类外实现：较麻烦，需要让编译器知道全局函数的存在\n此时全局函数需要模版化\n编译器需要提前知道有这个全局函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;class T1, class T2\u0026gt; // 函数中用到这个类，让这个函数知道这个类 class Person; template \u0026lt;class T1, class T2\u0026gt; // 让类知道这个函数 void printPerson(Person\u0026lt;T1, T2\u0026gt; p) { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; p.name \u0026lt;\u0026lt; \u0026#34; age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; } template \u0026lt;class T1, class T2\u0026gt; class Person { friend void printPerson\u0026lt;\u0026gt;(Person\u0026lt;T1, T2\u0026gt; p); // 函数模版声明 public: Person(T1 name, T2 age) { this-\u0026gt;name = name; this-\u0026gt;age = age; } private: T1 name; T2 age; }; 2. STL初识 2.1 STL基本概念 为了建立数据结构和算法的一套标准，诞生了STL\nSTL:Standard Template Library\nSTL从广义上分为：容器(container) 算法(algorithm) 迭代器(iterator)\n容器和算法之间通过迭代器进行无缝连接\nSTL几乎所有代码都采用了模版类或模版函数\nSTL六大组件\n容器：各种数据结构 序列式容器：强调值的排序，元素有固定的位置 关联式容器：二叉树结构，元素之间没有严格的物理顺序关系 算法：各种常用算法 质变算法：运算过程中改变区间内的元素内容，拷贝、删除、替换等 非质变算法：运算过程中不会改变区间内的元素内容，查找、计数、遍历、寻找极值 迭代器：容器和算法之间的胶合剂 算法通过迭代器访问容器中的元素 每个容器都有专属的迭代器 迭代器种类：常用的为双向迭代器和随机访问迭代器 输入迭代器：只读 输出迭代器：只写 前向迭代器：读写、向前推进 双向迭代器：读写，向前和向后推进 随机访问迭代器：读写、跳跃方式访问任意数据，功能最强 仿函数：类似函数，可作为函数的某种策略 适配器：用来修饰容器或仿函数或迭代器接口的东西 空间配置器：负责空间的配置与管理 2.2 容器算法迭代器初识 使用某种容器需要包含对应的头文件\n1 #include \u0026lt;vector\u0026gt; 使用STL中提供的某种算法需要包含算法库\n1 #include \u0026lt;algorithm\u0026gt; 2.2.1 vector存放内置数据类型 容器：vector\n算法：for_each\n迭代器：vector\u0026lt;int\u0026gt; :: iterator，可以按照指针理解\n三种迭代方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 1 vector\u0026lt;int\u0026gt;::iterator itBegin = v.begin(); vector\u0026lt;int\u0026gt;::iterator itEnd = v.end(); // end是容器中最后一个元素的下一个位置 while (itBegin != itEnd) { cout \u0026lt;\u0026lt; *itBegin \u0026lt;\u0026lt; \u0026#34; \u0026#34;; itBegin++; } // 2 for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // 3 for_each(v.begin(), v.end(), [](int val) {cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;;}); 2.2.2 vector存放自定义数据类型 例如自定义Person类\n1 2 3 for (vector\u0026lt;Person\u0026gt; :: iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;age \u0026lt;\u0026lt; endl; } 可以把迭代器变量当做一个指针理解，指针解引用的类型即为\u0026lt;\u0026gt;中的类型\n2.2.3 vector容器嵌套容器 容器中嵌套容器，类似于二维数组\n1 2 3 4 5 6 for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { for (vector\u0026lt;int\u0026gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { cout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 3. STL常用容器 3.1 string容器 3.1.1 string基本概念 string是C++风格的字符串，本质上是一个类 string和char *的区别 char *是一个指针 string是一个类，类内部封装了char * string类中封装了很多成员方法 find,copy,delete,replace,insert 3.1.2 string构造函数 构造函数原形\n1 2 3 4 string(); // 创建一个空的字符串，例如 string str; string(const char *s); // 使用字符串s初始化 string(const char \u0026amp;s); // 使用一个string对象初始化另一个string对象 string(int n, char c); // 使用n个字符c初始化 3.1.3 string赋值操作 给string字符串赋值 重载=运算符，使用operator= 使用assign 3.1.4 string字符串拼接 在字符串末尾拼接字符串\n重载+=运算符，使用operator+=\n1 2 3 4 string str1; str1 = \u0026#34;hello\u0026#34;; str1 += \u0026#34;world\u0026#34;; cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; 使用append\n3.1.5 string查找和替换 查找：查找指定字符串是否存在\nfind\n1 int pos = find(\u0026#34;dqr\u0026#34;, 0); 从指定的位置从左往右查找字符串 如果有该子字符串，返回位置，没有则返回-1 rfind\n1 int pos = rfind(\u0026#34;dqr\u0026#34;, 10); 从指定位置从右往左查找字符串 替换：在指定的位置替换字符串\nreplace\n1 2 string str1 = \u0026#34;abcdefg\u0026#34;; str1.replace(1, 3, \u0026#34;1111\u0026#34;); 从起始位置pos后n个字符替换为字符串\n3.1.6 string字符串比较 使用compare进行比较：按照ASCII码值的大小逐个字符对比\n=返回0\n\u0026gt;返回1\n\u0026lt;返回-1\n1 2 3 4 5 6 7 if (str1.compare(str2) == 0) { cout \u0026lt;\u0026lt; \u0026#34;str1 == str2\u0026#34; \u0026lt;\u0026lt; endl; } else if (str1.compare(str2) \u0026gt; 0) { cout \u0026lt;\u0026lt; \u0026#34;str1 \u0026gt; str2\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;str1 \u0026lt; str2\u0026#34; \u0026lt;\u0026lt; endl; } 3.1.7 string字符存取 通过[]方式存取，即重载operator[] 通过at(int n)方式 3.1.8 string插入和删除 插入字符串insert\n1 insert(int pos, const char * s); 从某位置插入字符串 删除字符串erase\n1 erase(int pos, int n); 删除从Pos开始的n个字符 3.1.9 string子串 从字符串中获取需要的子串substr\n1 substr(int pos, int n) 从pos开始的n个字符组成的字符串 3.2 vector容器 3.2.1 vector基本概念 vector数据结构和数组非常相似，也称为单端数组\n不同之处在于数组为静态空间，vector可以动态扩展\n动态扩展：并不是在原空间之后续接新空间，而是找到更大的内存空间，然后将原数据拷贝到新空间，释放原空间\nvector是单端数组，只能在尾部操作，而不能在头部操作\nvector容器的迭代器是支持随机访问的迭代器：常用的几个迭代器\nv.begin()指向第一个元素 v.end()指向最后一个元素后一个位置 3.2.2 vector构造函数 创建vector容器，构造函数原形\n1 2 3 4 vector \u0026lt;T\u0026gt; v; // 默认构造函数 vector (v.begin(), v.end());// 将区间中的元素拷贝给自身 vector (n,elem); // 将n个elem拷贝给自身 vector (const vector\u0026amp; vec); //拷贝构造函数 例如\n1 2 3 4 5 6 7 vector\u0026lt;int\u0026gt; v1; for (int i = 0; i \u0026lt; 10; i++) { v1.push_back(i); } vector\u0026lt;int\u0026gt; v2(v1.begin(), v1.end()); vector\u0026lt;int\u0026gt; v3(10, 100); vector\u0026lt;int\u0026gt; v4(v3); 3.2.3 vector赋值操作 使用=，即重载等号运算符operator= assign(begin, end) assign(n, elem) 3.2.4 vector容量和大小 对vector容器的容量和大小进行操作 empty()：判断容器是否为空 capacity()：容器的容量 size()：返回容器中元素的个数 resize(int num)：重新指定容器的长度为num 如果容器变长，则以默认值填充新位置 如果容器变短，则超出容器长度部分被删除 resize(int num, elem) 如果容器变长，则以elem填充新位置 如果容器变短，则超出容器长度部分被删除 3.2.5 vector插入和删除 push_back(ele)：尾部插入元素ele pop_back()：删除最后一个元素 insert(const_iterator pos, ele):向指定位置pos插入元素ele insert(const_iterator pos, int count, ele)：向指定位置pos插入count个ele erase(const_iterator pos);：删除迭代器指向的元素 erase(const_iterator start, const_iterator end)：删除迭代器从start到end之间的元素 clear()：删除容器中所有元素 3.2.6 vector数据存取 at(int idx)：返回idx所指的数据 operator[]：返回索引idx所指的数据 front()：返回容器中第一个元素 back()：返回容器中最后一个元素 3.2.7 vector互换容器 swap函数进行交换，相当于两个指向vector的指针交换\n巧用swap可以收缩内存空间\n1 vector\u0026lt;int\u0026gt;(v).swap(v); vector是一种动态数组，capacity \u0026gt;= size，一般来说capacity \u0026gt; size，这里的富裕空间大小随size增大，为了减少多出来的空间，需要内存收缩 vector\u0026lt;int\u0026gt;(v)：用v初始化一个匿名对象，大小即为v.size() swap进行指针交换，匿名对象被回收 3.2.8 vector预留空间 减少vector在动态扩展容量时的扩展次数 reserve(int len)：预留len个元素长度，预留位置不初始化，元素不可访问 如果能提前知道大概的元素个数，可以提前预留大致大小的空间，减少vector的动态扩展次数 3.3 deque容器 3.3.1 deque容器基本概念 双端数组：可以对头端和尾端进行插入删除操作\ndeque与vector区别\nvector对头部插入删除效率低，数据量越大效率越低 deque相对而言对头部插入删除速度更快 vector访问元素速度更快，与两者内部实现有关 结构图\ndeque内部工作原理：deque内部有一个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据，中控器维护的是每个缓冲区的地址，使得使用deque像一片连续的内存空间\ndeque容器的迭代器支持随机访问\n3.3.2 deque构造函数 函数原型\n1 2 3 4 5 #include \u0026lt;deque\u0026gt; deque\u0026lt;T\u0026gt; deqT; deque(begin, end); // 构造函数将(begin, end)区间中的元素拷贝给本身 deque(n, elem); // 构造函数将n个elem拷贝给本身 deque(const deque \u0026amp;deq); // 拷贝构造函数 常量(只读)迭代器const_iterator\n1 2 3 4 5 6 void printDeque(const deque\u0026lt;int\u0026gt; \u0026amp;d) { for (deque\u0026lt;int\u0026gt; :: const_iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 3.3.3 deque赋值操作 函数原型 =运算符重载，operator= assign(begin, end) assign(n, elem) 3.3.4 deque大小操作 deque.empty()：判断容器是否为空\ndeque.size()：返回容器中元素的个数\ndeque.resize(num)：重新指定容器的长度\ndeque.resize(num, elem)\n没有容量概念\n3.3.5 deque插入和删除 两端插入操作\npush_back(elem)：尾插\npush_front(elem)：头插\npop_back()：尾删\npop_front()：头删\n指定位置操作：提供的位置是迭代器，而不是索引值1,2,3\ninsert(pos, elem)：在pos位置插入一个elem元素的拷贝，返回新数据位置 insert(pos,n,elem)：在pos位置插入n个elem，无返回值 insert(pos,begin,end)：在pos位置插入[begin, end)区间的数据，无返回值 clear()：清空所有数据 erase(begin,end)：删除区间内的所有数据，返回下一个数据位置 erase(pos)：删除pos位置元素，返回下一个数据的位置 3.3.6 deque数据存取 at(int idx) operator[] front() back() 3.3.7 deque排序 算法：sort(iterator begin, iterator end)，对begin和end之间的元素进行排序\nSTL中提供的sort算法\n默认是升序\n3.4 stack容器 3.4.1 stack基本概念 stack是一种先进后出的数据结构，只有一个出口\n栈不允许有遍历的行为，只能访问栈顶的元素\n入栈push\n出栈pop\n3.4.2 stack常用接口 构造 stack\u0026lt;T\u0026gt; stk; stack(const stakc \u0026amp;s) 赋值 重载等号运算符operator= 数据存取 push(elem)：栈顶添加元素 pop()：栈顶移除元素 top()：返回栈顶元素 大小操作 empty()是否为空 size()返回大小 3.5 queue容器 3.5.1 queue基本概念 队列是一种先进先出的数据结构，有一个入口和一个出口\n从队尾入队(push)，从队头出队(pop)\n只有队头和队尾元素可见，不可以被遍历\n3.5.2 queue常用接口 构造函数\nqueue\u0026lt;T\u0026gt; que queue(const queue \u0026amp;q) 赋值操作：重载等号运算符opearator=\n数据存取\npush(elem)：在队尾添加元素 pop()：从队头移出第一个元素 back()：返回最后一个元素 front()：返回第一个元素 大小操作\nempty() size() 3.6 list容器 3.6.1 list基本概念 即链表，非连续存储结构\n链表的组成：节点(数据域+指针域)\n便于插入/删除，但遍历速度慢\n链表中的迭代器只支持前移和后移，是双向迭代器\n3.6.2 list构造函数 list\u0026lt;T\u0026gt; list list(l.begin(), l.end()) list(const list \u0026amp; l) list(n ,elem) 3.6.3 list赋值和交换 赋值 operator= assign 交换：swap函数 3.6.4 list大小操作 empty() size() resize(num) resize(num, elem) 3.6.5 list插入和删除 ​\t注意提供的位置为迭代器，而不是数字索引\npush_back(elem) pop_back() push_front(elem) pop_front() insert(pos,elem) insert(pos,n,elem) insert(pos,begin,end) clear() erase(begin,end) erase(pos) remove(elem):删除所有与elem值匹配的元素 3.6.6 list 数据存取 front()：第一个元素\nback()：最后一个元素\n因为不支持随机访问迭代器，没有at()和[]\nlist为双向迭代器\n1 2 3 list\u0026lt;int\u0026gt;:: iterator it = l1.begin(); it++; // ok it = it + 1; // error 双向迭代器：支持++/--，不支持+1等 小tips：用迭代器操作检验迭代器类型\n3.6.7 list 反转和排序 反转链表：reverse()\n链表排序：sort()，默认为升序\n以上两个函数均为list类内部的成员函数\n对于不支持随机访问迭代器的数据结构，类内部提供相应的成员函数\n支持随机访问迭代器的数据结构则实现为全局函数\n对于需要自定义数据类型(多关键字排序)，需要指定排序规则\n3.7 set/multiset 容器 3.7.1 set 基本概念 集合容器：所有元素在插入时自动被排序 set/multiset属于关联式容器，底层结构使用二叉树实现 set：不允许重复 multiset：多重集 3.7.2 set 构造和赋值 构造set\u0026lt;T\u0026gt; set,set(const set \u0026amp; s)\n赋值：operator=\n插入insert()时，重复元素保留一个\n3.7.3 set 大小和交换 size()\nempty()\nswap(s)\n不允许resize\n3.7.4 set 插入和删除 insert(elem) clear() erase(pos) erase(begin, end) erase(elem) 3.7.5 set 查找和统计 查找：find(key)查找key是否存在，若存在返回该键元素的迭代器，若不存在返回set.end() 统计：count(key)统计key的元素个数 3.7.6 set和multiset区别 单重集和多重集的区别 3.7.7 pair 对组创建 成对出现的数据，可以利用对组返回两个数据 pair \u0026lt;type, type\u0026gt; p (value1, value2) pair \u0026lt;type, type\u0026gt; p = make_pair(value1, value2) 1 2 pair\u0026lt;string, int\u0026gt; p = make_pair(\u0026#34;Tom\u0026#34;, 20); cout \u0026lt;\u0026lt; \u0026#34;first: \u0026#34; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34; second: \u0026#34; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; 使用.first/.second访问对组中第一个元素/第二个元素 3.7.8 set 容器排序 仿函数：使一个类的使用看上去像一个函数，其实现就是在类中实现一个operator()\nset容器默认排序从小到大，利用仿函数可以改变排序规则\nset容器中存放内置数据类型：在创建容器时指定排序规则，在排序之前\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyCompare { public: bool operator()(int v1, int v2) { // 降序 return v1 \u0026gt; v2; } }; void test01() { set\u0026lt;int, MyCompare\u0026gt; s; s.insert(10); s.insert(20); s.insert(30); s.insert(40); s.insert(50); for (set\u0026lt;int, MyCompare\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } set容器中存放自定义数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyCompare { public: bool operator()(const Person \u0026amp;p1, const Person \u0026amp;p2) { return p1.m_Age \u0026lt; p2.m_Age; } }; void test01() { set\u0026lt;Person, MyCompare\u0026gt; s; s.insert(Person(\u0026#34;刘\u0026#34;, 24)); s.insert(Person(\u0026#34;关\u0026#34;, 28)); s.insert(Person(\u0026#34;张\u0026#34;, 25)); s.insert(Person(\u0026#34;赵\u0026#34;, 31)); for (set\u0026lt;Person\u0026gt;::iterator it = s.begin(); it != s.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;姓名: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Name \u0026lt;\u0026lt; \u0026#34; 年龄: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;m_Age \u0026lt;\u0026lt; endl; } } 3.8 map/multimap 容器 3.8.1 map基本概念 map中所有元素都是pair pair中第一个元素为key(.first)，第二个元素为value(.second) 所有元素都会根据元素的键值自动排序 3.8.2 map构造和赋值 默认构造函数map\u0026lt;T1,T2\u0026gt; map\n拷贝构造函数map(const map \u0026amp;m)\n赋值operator=\n3.8.3 map 大小和交换 size() empty() swap() 3.8.4 map 插入和删除 insert(pair)：插入对组\n1 2 3 m.insert(pair\u0026lt;int, int\u0026gt;(4, 40)); m.insert(make_pair(5, 50)); m[6] = 60; // 不建议 当访问该key不存在时会创建 主要用来访问 clear()\nerase(pos)：迭代器位置\nerase(begin, end)\nerase(key)：按照键值删除\n3.8.5 map 查找和统计 find(key)：返回迭代器，没找到则map.end() count(key) 3.8.6 map 容器排序 默认为从小到大排序 利用仿函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MyCompare { public: bool operator() (int v1, int v2) { return v1 \u0026gt; v2; } }; void printMap(const map\u0026lt;int, int, MyCompare\u0026gt; \u0026amp;m) { for (map\u0026lt;int, int\u0026gt;::const_iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; \u0026#34;key: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; value: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void test01() { map\u0026lt;int, int, MyCompare\u0026gt; m; m.insert(pair\u0026lt;int, int\u0026gt;(1, 10)); m.insert(pair\u0026lt;int, int\u0026gt;(2, 20)); m.insert(pair\u0026lt;int, int\u0026gt;(3, 30)); m.insert(pair\u0026lt;int, int\u0026gt;(4, 40)); m.insert(make_pair(5, 50)); printMap(m); } 4. STL-函数对象 4.1 函数对象 **重载函数调用操作符operator()**的类，其对象通常称为函数对象\n函数对象使用重载的()时，行为类似函数调用，也叫仿函数\n函数对象使用时类似普通函数\n1 2 3 4 5 6 7 8 9 10 11 class Myadd { public: int operator()(int a, int b) { return a + b; } }; void test01() { Myadd myadd; cout \u0026lt;\u0026lt; myadd(10, 10) \u0026lt;\u0026lt; endl; } 函数对象可以有自己的状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Myprint { public: int count; Myprint() { count = 0; } void operator()(string s) { count++; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } }; void test02() { Myprint myprint; myprint(\u0026#34;hello world\u0026#34;); myprint(\u0026#34;hello world\u0026#34;); myprint(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;myprint count: \u0026#34; \u0026lt;\u0026lt; myprint.count \u0026lt;\u0026lt; endl; } 函数对象可以作为参数传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Myprint { public: int count; Myprint() { count = 0; } void operator()(string s) { count++; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } }; void doPrint(Myprint \u0026amp; mp, string s) { mp(s); } 4.2 谓词 4.2.1 谓词概念 返回bool类型的仿函数称为谓词\n如果operator()接受一个参数，则称为一元谓词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class GreaterFive { public: bool operator()(int val) { return val \u0026gt; 5; } }; void test01() { vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; i++) { v.push_back(i); } vector\u0026lt;int\u0026gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); //匿名函数对象 if (it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;未找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到大于5的元素为: \u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } 如果operator()接受两个参数，则称为二元谓词，例如定义排序规则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyCompare { public: bool operator()(int v1, int v2) { return v1 \u0026gt; v2; } }; void test01() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); v.push_back(50); sort(v.begin(), v.end(), MyCompare()); } 4.3 内建函数对象 STL内建了一些函数对象\n算数仿函数 关系仿函数 逻辑仿函数 1 #include \u0026lt;functional\u0026gt; 4.3.1 算数仿函数 实现四则运算\n其中negate(取反)是一元运算，其他都是二元运算\n例子\n1 2 3 4 5 negate\u0026lt;int\u0026gt; n; cout \u0026lt;\u0026lt; n(50) \u0026lt;\u0026lt; endl; plus\u0026lt;int\u0026gt; p; cout \u0026lt;\u0026lt; p(10, 20) \u0026lt;\u0026lt; endl; 仿函数原型\n1 2 3 4 5 6 template \u0026lt;class T\u0026gt; T plus\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; T minus\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; T multiplies\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; T divides\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; T modules\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; T negate\u0026lt;T\u0026gt;; 4.3.2 关系仿函数 仿函数原型\n1 2 3 4 5 6 template \u0026lt;class T\u0026gt; bool equal_to\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; bool not_equal_to\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; bool greater\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; bool greater_equal\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; bool less\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; bool less_equal\u0026lt;T\u0026gt;; 知道关系仿函数之后就不再需要在排序中定义降序仿函数\n1 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); 4.3.3 逻辑仿函数 仿函数原型\n1 2 3 template \u0026lt;class T\u0026gt; bool logical_and\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; bool logical_or\u0026lt;T\u0026gt;; template \u0026lt;class T\u0026gt; bool logical_not\u0026lt;T\u0026gt;; 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;bool\u0026gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector\u0026lt;bool\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; vector\u0026lt;bool\u0026gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not\u0026lt;bool\u0026gt;()); for (vector\u0026lt;bool\u0026gt;::iterator it = v2.begin(); it != v2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 5. STL常用算法 算法主要是由头文件\u0026lt;algorithm\u0026gt;\u0026lt;functional\u0026gt;\u0026lt;numeric\u0026gt;组成 \u0026lt;algorithm\u0026gt;是所有STL头文件中最大的一个，设计到比较、交换、查找、遍历、复制、修改等 \u0026lt;numeric\u0026gt;体积很小，包含几个在序列上进行简单数学运算的模版函数 \u0026lt;functional\u0026gt;定义了一些模版类，用以声明函数对象 5.1 常用遍历算法 5.1.1 for_each 遍历容器\n函数原型：需要传入一个回调函数(函数对象、仿函数)用来实现功能\n1 for_each(iterator begin, iterator end, _func); 5.1.2 transform 搬运一个容器到另一个容器中\n函数原型：需要传入一个回调函数，用来实现在搬运过程中的功能，例如上面的搬运过程中取反\n1 transform(iterator begin1, iterator end1, iterator begin2, _func) 需要注意的是创建目标容器后，需要为目标容器提前开辟空间\n1 2 3 vector \u0026lt;int\u0026gt; target; target.resize(v.size()); transform(v.begin(), v.end(), target.begin(), MyTransform()); 5.2 常用查找算法 5.2.1 find 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()\n函数原型\n1 find(iterator begin,iterator end, value); 对于自定义数据类型需要进行重载operator==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; bool operator==(const Person \u0026amp;p) { // !!! if(this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return true; } else { return false; } } }; void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find(v.begin(), v.end(), p2); if(it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;Not found\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Found\u0026#34; \u0026lt;\u0026lt; endl; } } 5.2.2 find_if 按条件查找元素\n函数原型：_Pred函数或者谓词\n1 find_if(iterator begin, iterator end, _Pred); 查找自定义数据类型时需要定义谓词或比较函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; } string m_Name; int m_Age; }; bool myCompare(const Person \u0026amp;p) { if(p.m_Age \u0026gt; 20) { return true; } else { return false; } } void test02() { vector\u0026lt;Person\u0026gt; v; Person p1(\u0026#34;aaa\u0026#34;, 10); Person p2(\u0026#34;bbb\u0026#34;, 20); Person p3(\u0026#34;ccc\u0026#34;, 30); Person p4(\u0026#34;ddd\u0026#34;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector\u0026lt;Person\u0026gt;::iterator it = find_if(v.begin(), v.end(), myCompare); if(it == v.end()) { cout \u0026lt;\u0026lt; \u0026#34;Not found\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Found\u0026#34; \u0026lt;\u0026lt; endl; } } 5.2.3 adjacent_find 查找相邻重复元素，返回相邻重复元素的第一个位置的迭代器\n函数原型\n1 adjacent_find(iterator begin, iterator end); 5.2.4 binary_search 二分查找指定元素是否存在\n函数原型\n1 bool binary_search(iterator begin, iterator end, value); 速度快，但只能在有序序列中使用\n5.2.5 count 统计区间中元素个数\n函数原型\n1 int count(iterator begin, iterator end, value) 统计自定义数据类型个数需要进行==重载operator==\n5.2.6 count_if 按条件统计元素个数\n函数原型\n1 count_if(iterator begin, iterator end, _Pred) 提供谓词来表示条件_Pred\n5.3 常用排序算法 5.3.1 sort 对容器内元素进行排序，默认是升序\n函数原型\n1 sort(iterator begin, iterator end, _Pred); 其中谓词部分指定排序规则，例如使用内置关系仿函数greater\u0026lt;T\u0026gt;()\n1 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); 5.3.2 random_shuffle 洗牌，将指定范围内的元素打乱顺序，随机调整\n函数原型\n1 random_shuffle(v.begin(),v.end()); 可以加入系统时间戳实现真正随机\n1 2 #include \u0026lt;ctime\u0026gt; srand((unsigned int)time(NULL)); 5.3.3 merge 将两个有序容器元素合并为一个有序序列\n函数原型\n1 merge(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator dest); 注意：两个序列必须是有序的，且都是升序的或者都是降序的\n对于目标容器要提前分配大小\n1 2 v3.resize(v1.size() + v2.size()); merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()); 5.3.4 reverse 将容器中元素进行翻转\n函数原型\n1 reverse(iterator begin, iterator end); 5.4 常用拷贝和替换算法 5.4.1 copy 容器内指定范围内的元素拷贝到另一个容器中\n函数原型\n1 copy(iterator begin, iterator end, iterator dest); 同样需要为目标容器提前分配空间\n5.4.2 replace 将容器内指定范围内的旧元素修改为新元素\n函数原型\n1 replace(iterator begin, iterator end, oldvalue, newvalue); 5.4.3 replace_if 区间内满足条件的元素替换为新元素\n函数原型\n1 replace_if(iterator begin, iterator end, _Pred, newvalue); 用谓词表达条件\n5.4.4 swap 交换两个容器中的元素\n函数原型\n1 swap() 5.5 常用算术生成算法 1 #include\u0026lt;numeric\u0026gt; 5.5.1 accumulate 计算容器元素累计总和\n函数原型\n1 accumulate(iterator begin, iterator end, initvalue); 第三个参数为容器内元素累加之前的起始值\n5.5.2 fill 向容器中填充指定的元素\n函数原型：value是填充的值\n1 fill(iterator begin, iterator end, value); 5.6 常用集合算法 5.6.1 set_intersection 求两个容器的交集\n两个原容器必须为有序序列\n函数原型：\n1 set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); 需要为交集集合提前开辟空间，取两个容器大小的最小值就够用\n1 target.resize(min(v1.size(), v2.size())); 返回的迭代器为容器结束位置\n1 vector\u0026lt;int\u0026gt;::iterator end = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), target); 5.6.2 set_union 求两个容器的并集\n两个原容器必须为有序序列\n函数原型\n1 set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); 需要为并集集合提前开辟空间，取两个容器大小之和\ntarget.resize(v1.size() + v2.size()); 返回的迭代器为容器结束位置\n1 vector\u0026lt;int\u0026gt;::iterator end = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), target); 5.6.3 set_difference 求两个集合的差集：必须为有序序列\nV1和V2差集/V2和V1差集\n函数原型\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); 差集集合提前开辟空间，取最大大小\n1 target.resize(max(v1.size(), v2.size())); 返回的迭代器为容器结束位置\n1 vector\u0026lt;int\u0026gt;::iterator end = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), target); ","permalink":"https://coder0xe.github.io/posts/cpp-stl%E5%BA%93/","summary":"\u003ch1 id=\"cppstl库\"\u003eCPP:STL库\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eC++泛型编程和STL技术\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"1模版\"\u003e1.模版\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e学习模版并不是为了写模版，而是在STL中能够运用系统提供的模版\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"11-函数模版\"\u003e1.1 函数模版\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e模版就是建立通用的模具，大大提高复用性\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eC++中另一种编程思想称为泛型编程，主要利用的技术就是模版\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eC++中提供两种模版机制：函数模版和类模版\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"111-函数模版语法\"\u003e1.1.1 函数模版语法\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e建立一个通用函数，其函数的返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e语法：\u003cstrong\u003e\u003ccode\u003etemplate\u003c/code\u003e关键字声明一个通用数据类型T\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e函数声明或定义\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etemplate\u003c/code\u003e声明创建模版\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etypename\u003c/code\u003e表明其后面的符号是一种数据类型，可以用\u003ccode\u003eclass\u003c/code\u003e代替\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eT\u003c/code\u003e：通用的数据类型，名称可以替换\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003etemplate\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e swap(T \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003ea, T \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003eb) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    T temp \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e a;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    a \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    b \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e temp;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e自动类型推导\u003c/strong\u003e：我们在模版中使用通用类型\u003ccode\u003eT\u003c/code\u003e，当传入具体的数据类型时，根据该数据类型推导出\u003ccode\u003eT\u003c/code\u003e的类型\u003c/p\u003e","title":"CPP:STL库"},{"content":"CPP面向对象 1. 内存分区模型 代码区：二进制代码 全局区：全局变量和静态变量以及常量 栈区：编译器自动分配释放，存放局部变量 堆区：程序员分配和释放 1.1 程序运行前 ​\t程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n代码区\n存放CPU执行的机器指令 代码区是共享的 代码区是只读的 全局区\n全局变量、静态变量(static) 常量区：字符串常量和const修饰的全局变量 该区域的数据在程序结束后由操作系统回收 1.2 程序运行后 栈区：由编译器自动分配释放，存放函数的参数值和局部变量\n不要返回局部变量的地址\n1 2 3 4 int * func() { int a = 10; // 函数中的局部变量，存放在栈区，栈区的数据在函数执行完后自动释放 return \u0026amp;a; } 局部变量：在函数中定义；全局变量：在函数外定义\n在函数中定义的局部变量存放在内存中的栈区，在函数运行结束后编译器自动释放\n回想MIPS函数调用规范中的分配栈\n堆区：由程序员分配释放\n在c++中由new关键字在堆区中申请内存\n1 int * p = new int(10); 该局部变量不会随函数结束被回收，即堆区的变量与栈区的变量有不同的生命周期\n1.3 new操作符 用new操作符在堆区开辟数据\n基本语法：new 数据类型 (初始值)|[元素个数]，返回该数据类型的指针\n1 2 3 4 int *p = new int(10); // 创建int型变量 int *arr = new int[10]; // 创建一个数组 [] delete p; delete[] arr; 用delete操作释放内存，释放数组加[]\n2. 引用 2.1 引用语法 引用：给变量起别名\n语法：数据类型 \u0026amp;别名 = 原名\n1 int \u0026amp;b = a; 引用必须要进行初始化，且初始化后不可修改\n1 2 3 int \u0026amp;b;// 未初始化错误 int \u0026amp;b = a; int \u0026amp;b = c;//修改别名错误 对于c++中的引用理解可以参考java中的理解，即这两个名字都是指向同一片内存的指针，或者说是浅克隆\n2.2 引用做函数参数 函数参数：值传递/地址(指针)传递\n利用引用让形参修改实参，避免使用指针\n1 2 3 4 5 void swap(int \u0026amp;a, int \u0026amp;b) { int temp = a; a = b; b = temp; } 2.3 引用做函数返回值 不要返回局部变量的引用(函数运行结束，局部变量回收)\n1 2 3 4 int\u0026amp; test() { int a = 10; return a; } 函数的调用可以作为左值，给返回的引用赋值\n1 2 3 4 5 6 int\u0026amp; test() { static int a = 10; return a; } test() = 1000; 2.4 引用的本质 引用的本质在c++内部实现是一个指针常量(指针指向不变，指针指向的值可以修改)\n2.5 常量引用 用来修饰形参，防止误操作\n1 const int \u0026amp; b = a; 常量引用的值不可被修改\n1 2 3 void print(const int \u0026amp;val) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } 3. 函数提高 3.1 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的\n语法返回值类型 函数名 (参数 = 默认值){}\n例如\n1 2 3 4 5 6 7 8 9 10 int sum (int a = 10, int b = 20) { return a + b; } int main() { cout \u0026lt;\u0026lt; sum() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sum(5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sum(5, 15) \u0026lt;\u0026lt; endl; return 0; } 不传参使用默认值，传参则使用传入的值\n注意：如果某个位置已经有了默认值，则从这个位置往后都必须要默认值\n函数声明和实现只能有一个有默认参数\n3.2 函数占位参数 在参数列表中只写数据类型\n返回值类型 函数名 (数据类型){}\n1 2 3 void test(int) { cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34;; } 现阶段没用\n3.3 函数重载 函数名可以相同，提高复用性(overloaded)\n同一个作用域下，函数名称相同，参数不同，根据传入的参数选择重载的函数\n例子\n1 2 3 4 5 6 7 int sum (int a = 10, int b = 20) { return a + b; } int sum (int a, int b, int c) { return a + b + c; } 函数的返回值不可以作为重载的条件\n注意：引用作为重载的条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; void func(int \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;func(int \u0026amp;)\u0026#34; \u0026lt;\u0026lt; endl; } void func(const int \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;func(const int \u0026amp;)\u0026#34; \u0026lt;\u0026lt; endl; } int main() { int a = 10; const int b = 20; func(a); // \u0026#34;func(int \u0026amp;)\u0026#34; func(b); // \u0026#34;func(const int \u0026amp;)\u0026#34; return 0; } 两个重载中的参数仅在const修饰上有区别 在两个函数都可以运行时，变量选择变量重载，常量选择常量重载 重载碰到默认参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 void func(int a, int b = 10) { cout \u0026lt;\u0026lt; \u0026#34;func(int a, int b = 10)\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;func(int a)\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func(10); return 0; } 出现二义性 4. 类和对象 面向对象三大特性：封装、继承、多态\n4.1 封装 将属性和行为作为一个整体表现生活中的事物\n将属性和行为加以权限控制\n可见性通过public/private/protected定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; class Circle { public : double radius; double compute_area() { return 3.14 * radius * radius; } private : /*code */ protected : /*code */ }; int main() { Circle obj; obj.radius = 5.0; cout \u0026lt;\u0026lt; \u0026#34;Area is: \u0026#34; \u0026lt;\u0026lt; obj.compute_area() \u0026lt;\u0026lt; endl; return 0; } 公共权限public：类内可以访问，类外可以访问\n保护权限protected：类内可以访问，类外不可以访问，子类可以访问父类中的protected\n私有属性private：类内可以访问，类外不可以访问\n默认权限为private\n4.2 对象的初始化和清理 4.2.1 构造函数和析构函数 构造函数：创建对象时为对象的成员属性赋值，被自动调用\n析构函数：对象销毁前系统自动调用，执行清理操作\n如果不自行实现，编译器提供空实现\n构造函数语法：类名(参数列表){}\n1 2 3 4 public : Circle(double r) { radius = r; } 析构函数语法：~类名(){}，不能有参数\n1 2 3 ~Circle() { cout \u0026lt;\u0026lt; \u0026#34;Circle object is destroyed\u0026#34; \u0026lt;\u0026lt; endl; } 4.2.2 构造函数的分类和使用 按照参数分类：无参构造/有参构造\n按照类型分类：普通构造/拷贝构造\n拷贝构造函数\n1 2 3 Circle(const Circle\u0026amp; circle) { radius = circle.radius; } 构造函数调用\n括号法\n1 Circle circle(5.0); 显示法\n1 Circle circle = Circle(5.0); 隐式转换法\n1 Circle circle = 5.0; 拷贝构造函数调用时机\n使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 构造函数调用规则：c++编译器至少给一个类添加三个函数\n默认构造函数(无参、函数体为空) 默认析构函数(无参、函数体为空) 默认拷贝构造函数，值拷贝 如果用户有定义，则不使用默认构造\n4.2.3 深拷贝和浅拷贝 浅拷贝：简单的赋值操作，例如编译器提供的拷贝构造函数\n1 2 3 4 5 Person (const Person \u0026amp;p) { this-\u0026gt;age = p.age; this-\u0026gt;height = p.height; cout \u0026lt;\u0026lt; \u0026#34;拷贝\u0026#34; \u0026lt;\u0026lt; endl; } 深拷贝：在堆区重新申请空间，自己写拷贝构造函数，在堆区申请空间\n1 2 3 4 5 Person (const Person \u0026amp;p) { this-\u0026gt;age = p.age; this-\u0026gt;height = new int(*p.height); cout \u0026lt;\u0026lt; \u0026#34;拷贝\u0026#34; \u0026lt;\u0026lt; endl; } 当我们的构造函数使用new关键字在堆区申请空间时，需要在析构函数中用delete关键字进行释放\n1 2 3 4 5 ~Person () { delete this-\u0026gt;height; this-\u0026gt;height = NULL; cout \u0026lt;\u0026lt; \u0026#34;析构\u0026#34; \u0026lt;\u0026lt; endl; } 4.2.4 初始化列表 一种构造函数的新写法，没大用\n语法：构造函数():属性1(值1)，属性2(值2)...{}\n1 Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c) {} 4.2.5 类对象作为类成员 一个类中的成员可以为另一个类的对象\n先构造成员类的对象再构造自身\n先析构自身再析构成员类的对象\n4.2.6 静态成员 静态成员变量，不属于类的对象上\n类的所有对象共享同一份数据\n在编译阶段分配内存\n类内声明，类外初始化：这是必须的，需要使用解析符指定命名空间(该类)\n1 2 3 4 5 6 class Person{ public: static int num; }; int Person::num = 100; 访问方式：通过类/对象进行访问\n1 2 Person :: num person.num 静态成员函数\n类的所有对象共享同一个函数 静态成员函数只能访问静态成员变量 通过对象访问/通过类名访问 4.3 C++对象模型和this指针 4.3.1 成员变量和成员函数分开存储 空对象占用内存空间：1字节\nC++编译器会给每个空对象分配一个字节空间，用来区别空对象占用的位置\n1 2 3 4 5 6 class Person{ int m_A; // 非静态成员变量 属于类的对象上 static int m_B; // 静态成员变量 不属于类的对象上 void func() {} // 非静态成员函数 不属于类的对象上 即代码只有一份 static void func2() {} // 静态成员函数 不属于类的对象上 } 只有非静态成员变量属于类的对象 4.3.2 this指针 由于成员函数不属于类的对象，多个同类型的对象共用同一块代码\n这个代码块如何区分是哪个对象调用自己？\n通过this指针可以解决这个问题，指向调用对象，对象本身即*this\nthis指针的作用\n当形参和成员变量重名时，可以通过this指针进行区分 在类的非静态成员函数中返回对象本身，可以使用return *this 注意当想要返回自身时，要返回自身的引用，不要返回相应的数据类型\n1 2 3 Person \u0026amp; func() { return *this; } 我们知道函数中的变量位于栈区，运行结束后会被回收，如果返回相应的数据类型，会创建一个新的对象返回,原来的对象被销毁.\n4.3.3 空指针访问成员函数 C++中允许空指针调用成员函数，但要注意有没有用到this指针（因为此时this为空）\n例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void showClass() { cout \u0026lt;\u0026lt; \u0026#34;220617\u0026#34; \u0026lt;\u0026lt; endl; } void showName() { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } void showAge() { if (this == NULL) { return; } cout \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } Person p = NULL; p.showClass(); // success p.showName(); // failed p.showAge(); // success 4.3.4 const修饰成员函数 常函数\n成员函数后加const即为常函数，这个const实际是加在this指针上，不允许修改this指向的值\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后在常函数中依然可以修改\n1 2 3 4 5 6 7 8 9 10 class Person { public : void showPerson() const { m_A = 100; // failed m_B = 200; // success } int m_A; mutable int m_B; // mutable关键字 }; 常对象\n声明对象前加const该对象即为常对象\n常对象只能调用常函数\n常对象中不允许修改普通变量，允许修改mutable修饰的变量\n1 2 3 const Person p; p.m_A = 100; // failed p.m_B = 100; // success 4.4 友元 生活中你的家有客厅(public)，你的卧室(private)\n客厅所有的客人都可以进去，但是你的卧室是私有的，也就是说只有你自己能进去\n但是，你可以允许你的朋友进入卧室\n在程序里，有些私有属性也想要类外特殊的一些函数或类进行访问，就需要用到友元的技术\n友元：让一个函数或类访问另一个类中的私有成员\n友元的关键字为friend\n友元的三种实现\n全局函数做友元：在类中加入friend 全局函数定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Building { friend void goodGay(Building \u0026amp;building); // 声明全局函数做友元 friend public : string sittingRoom; private : string bedRoom; public : Building () { sittingRoom = \u0026#34;客厅\u0026#34;; bedRoom = \u0026#34;卧室\u0026#34;; } }; void goodGay(Building \u0026amp;building) { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问：\u0026#34; \u0026lt;\u0026lt; building.sittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问：\u0026#34; \u0026lt;\u0026lt; building.bedRoom \u0026lt;\u0026lt; endl; } 类做友元：在类中加入friend class 类名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Building { friend class GoodGay; // 声明类做友元 public : string sittingRoom; private : string bedRoom; public : Building () { sittingRoom = \u0026#34;客厅\u0026#34;; bedRoom = \u0026#34;卧室\u0026#34;; } }; class GoodGay{ Building *building; public : GoodGay() { building = new Building; } void visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;sittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;bedRoom \u0026lt;\u0026lt; endl; } }; 成员函数做友元\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Building; class GoodGay{ Building *building; public : GoodGay(); void visit(); }; class Building { friend void GoodGay::visit(); // friend声明该类下成员函数为友元 public : string sittingRoom; private : string bedRoom; public : Building () { sittingRoom = \u0026#34;客厅\u0026#34;; bedRoom = \u0026#34;卧室\u0026#34;; } }; GoodGay::GoodGay() { // 方法在类外实现，需要指明作用域 building = new Building; } void GoodGay::visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;sittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问：\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;bedRoom \u0026lt;\u0026lt; endl; } 4.5 运算符重载(overloaded) 运算符重载：对已有的运算符进行重新定义，赋予其另一种功能，适应不同的数据类型\n类似于java中override\n4.5.1 加号运算符重载 operator+ 实现两个自定义数据类型相加的运算\n1 person1 + person2 ? 编译器给了一个通用名称operator+\n1 2 Person p3 = p1.operator+(p2); Person p3 = p1 + p2; 通过成员函数重载+号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Person { public : int a; int b; // 1.成员函数重载 Person operator+(Person \u0026amp;p) { Person temp; temp.a = this-\u0026gt;a + p.a; temp.b = this-\u0026gt;b + p.b; return temp; } }; 通过全局函数重载+号\n1 2 3 4 5 6 Person operator+(Person \u0026amp;p1, Person \u0026amp;p2) { Person temp; temp.a = p1.a + p2.a; temp.b = p1.b + p2.b; return temp; } 运算符重载也可以进行函数重载\n对于内置的数据类型的表达式的运算符不可以进行重载\n4.5.2 左移运算符重载operator\u0026lt;\u0026lt; cout \u0026laquo; person \u0026laquo; endl; 输出自定义数据类型\n全局函数重载左移运算符\n1 2 3 4 ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, Person \u0026amp;p) { cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; p.a \u0026lt;\u0026lt; \u0026#34; b = \u0026#34; \u0026lt;\u0026lt; p.b; return cout; } ostream标注输出流\n链式编程：返回自身\n4.5.3 递增运算符重载operator++ 前置递增，成员函数重载，返回引用，保证操作的是同一个值\n1 2 3 4 MyInteger\u0026amp; operator++() { num++; return *this; } 后置递增，利用占位参数int进行函数重载，区分前置和后置，返回值\n1 2 3 4 5 MyInteger operator++(int) { MyInteger temp = *this; num++; return temp; } 前置递增返回引用，后置递增返回值\n4.5.4 赋值运算符重载operator= c++默认给类添加operator=，对值进行拷贝，这个拷贝是浅拷贝，注意指针问题\n将默认的浅拷贝重载为深拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Person{ public : int * age; Person(int age){ this-\u0026gt;age = new int(age); } ~Person(){ delete this-\u0026gt;age; this-\u0026gt;age = NULL; } Person \u0026amp; operator=(Person \u0026amp;p){ if(this-\u0026gt;age != NULL){ delete this-\u0026gt;age; this-\u0026gt;age = NULL; } this-\u0026gt;age = new int(*p.age); return *this; } }; 4.5.5 关系运算符重载 == \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= != 等等\n成员函数重载\n1 2 3 4 5 6 bool operator==(Person \u0026amp;p) { if (this-\u0026gt;name == p.name \u0026amp;\u0026amp; this-\u0026gt;age == p.age) { return true; } return false; } 4.5.6 函数调用运算符重载operator() 函数调用运算符()可以进行重载\n重载后使用的方式非常像函数的调用，又称为仿函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyPrint { public : void operator()(string str) { cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } void operator()(string str, int num) { cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } }; void test01() { MyPrint myPrint; myPrint(\u0026#34;Hello World\u0026#34;); myPrint(\u0026#34;Hello World\u0026#34;, 100); } 仿函数没有固定的写法，非常灵活，可以通过函数的重载定义不同的函数\n匿名函数对象：当前行执行完后直接释放，避免创建对象\n1 2 3 void test02() { MyPrint()(\u0026#34;hello world\u0026#34;); } 4.6 继承 4.6.1 继承的基本语法 减少重复的代码\n语法：class 子类 : 继承方式 父类\n1 2 3 class Java : public Basepage { /*code*/ } 子类中包含从父类中继承的内容和自己增加的成员\n4.6.2 继承方式 公共继承：子类继承属性不改变 保护继承：子类继承父类中public和protected均为protected，private不变 私有继承：子类继承父类中全部属性转换为private ​\t可以用一张图来概括：不同的继承方式会改变子类中的成员属性\n4.6.3 继承中的对象模型 子类中包含父类中继承的属性和自身新增的属性 4.6.4 继承中的构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数 构造：先构造父类后构造子类 析构：先析构子类后析构父类 4.6.5 继承中同名成员处理方式 例如同名成员属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Base1 { public : int a; Base1() { a = 10; } }; class Son : public Base1 { public : int a; Son() { a = 20; } }; 如果通过子类对象，访问父类中同名成员，需要增加作用域\n1 son.Base::a; 如果通过子类对象，访问子类中同名成员，直接访问即可\n同名成员函数同理\n4.6.6 继承中同名静态成员处理 访问子类中同名成员，直接访问即可\n访问父类同名成员，需要增加作用域\n静态：通过对象/类进行访问\n4.6.7 多继承语法 不同于java，C++中允许多继承\n语法：class 子类 ： 继承方式 父类1 ，继承方式 父类2 ... 加作用域区分同名变量 4.6.8 菱形继承问题 两个类继承同一个父类 又有某个类继承两个子类 问题描述：动物类中有一个属性age，羊和驼继承动物类，羊驼继承羊和驼后就会有两个age属性\n1 2 3 4 5 6 7 8 9 10 11 class Animal { public: int m_age; }; class Sheep : public Animal {}; class Tuo : public Animal {}; class SheepTuo : public Sheep, public Tuo {}; 利用虚继承解决菱形继承问题：加virtual关键字，此时Animal称为虚基类\n1 2 class Sheep : virtual public Animal {}; class Tuo : virtual public Animal {}; 虚继承中继承了虚基类指针，两个继承的子类指向同一个虚基类表\n4.7 多态 4.7.1 基本概念 静态多态：函数重载和运算符重载\n地址早绑定：编译阶段确定函数地址 动态多态：派生类和虚函数实现运行时多态\n地址晚绑定：运行阶段确定函数地址\n有继承关系\n子类要重写(override)父类中的虚函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Animal { public: virtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;动物在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat : public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; 使用：父类的引用或指针指向子类\n当在有子类的父类中声明虚函数时，父类对象的存储空间中会增加一个vfptr：虚函数表指针\n该指针指向一个虚函数表 虚函数表内部记录虚函数地址 当子类重写父类的虚函数，子类中的虚函数表内部会替换为子类的虚函数地址 当父类的指针或引用指向之类对象时，发生运行时多态\n4.7.2 纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法 virtual 返回值类型 函数名 (参数列表) = 0； 当类中有了纯虚函数，这个类也称为抽象类 抽象类特点 无法实例化对象 抽象类的子类必须要重写父类中的纯虚函数 4.7.3 虚析构和纯虚析构 父类指针在析构时，不会调用子类中的析构函数，如果子类中有属性开辟到堆区，会造成内存泄漏\n将父类中的析构函数改为虚析构或纯虚析构，从而调用子类的析构函数\n1 2 3 virtual ~Animal() { /*code*/ } 与纯虚函数不同的是，纯虚析构同样需要代码实现\n1 2 3 4 5 virtual ~Animal() = 0; // 在类中声明纯虚析构 Animal::~Animal() { // 在类外进行纯虚析构定义 /*code*/ } 5. C++文件操作 对文件进行操作需要包含头文件 \u0026lt;fstream\u0026gt;\n文件 文本文件：以ASCII码形式存储 二进制文件：以二进制形式存储 操作文件 ofstream写操作 ifstream读操作 fstream读写操作 5.1 文本文件 ​\t写文件步骤如下\n包含头文件\n1 #include\u0026lt;fstream\u0026gt; 创建流对象\n1 ofstream ofs; // 输出流对象 打开文件\n1 ofs.open(\u0026#34;文件路径\u0026#34;，打开方式); 文件打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios:app 追加方式写文件 ios::trunc 如果文件存在则先删除后创建 ios::binary 二进制方式 可以利用|操作符配合使用文件打开方式\n写数据\n1 ofs \u0026lt;\u0026lt; \u0026#34;写入的数据\u0026#34;; 关闭文件\n1 ofs.close(); ​\t读文件步骤\n创建流对象\n1 ifstream ifs; 打开文件\n读数据\n第一种\n1 2 3 4 char buffer[1024] = {0}; while (ifs \u0026gt;\u0026gt; buffer) { cout \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; } 第二种\n1 2 3 4 char buffer2[1024] = {0}; while (ifs.getline(buffer2, 1024)) { cout \u0026lt;\u0026lt; buffer2 \u0026lt;\u0026lt; endl; } 第三种\n1 2 3 4 string buffer3; while (getline(ifs, buffer3)) { cout \u0026lt;\u0026lt; buffer3 \u0026lt;\u0026lt; endl; } 第四种\n1 2 3 4 char ch; while ((ch = ifs.get()) != EOF) { cout \u0026lt;\u0026lt; ch; } 5.2 二进制文件 二进制方式进行读写操作\n打开方式指定为ios::binary | ios::out[ios::in]\n写文件：ostream \u0026amp; write(const char *buffer, int len);\n1 ofs.write(buffer, sizeof(buffer)); 读文件：isteam \u0026amp; read(char * buffer, int len)\n","permalink":"https://coder0xe.github.io/posts/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","summary":"\u003ch1 id=\"cpp面向对象\"\u003eCPP面向对象\u003c/h1\u003e\n\u003ch2 id=\"1-内存分区模型\"\u003e1. 内存分区模型\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e代码区：二进制代码\u003c/li\u003e\n\u003cli\u003e全局区：全局变量和静态变量以及常量\u003c/li\u003e\n\u003cli\u003e栈区：编译器自动分配释放，存放局部变量\u003c/li\u003e\n\u003cli\u003e堆区：程序员分配和释放\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"11-程序运行前\"\u003e1.1 程序运行前\u003c/h3\u003e\n\u003cp\u003e​\t程序编译后，生成了exe可执行程序，\u003cstrong\u003e未执行该程序前分为两个区域\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e代码区\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e存放CPU执行的机器指令\u003c/li\u003e\n\u003cli\u003e代码区是共享的\u003c/li\u003e\n\u003cli\u003e代码区是只读的\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e全局区\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e全局变量、静态变量(\u003ccode\u003estatic\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e常量区：字符串常量和\u003ccode\u003econst\u003c/code\u003e修饰的全局变量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e该区域的数据在程序结束后由操作系统回收\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"12-程序运行后\"\u003e1.2 程序运行后\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e栈区：由编译器自动分配释放，存放函数的参数值和局部变量\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e不要返回局部变量的地址\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003efunc\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e; \u003cspan style=\"color:#6272a4\"\u003e// 函数中的局部变量，存放在栈区，栈区的数据在函数执行完后自动释放\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003ea;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e局部变量：在函数中定义；全局变量：在函数外定义\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e在函数中定义的局部变量存放在内存中的栈区，在函数运行结束后编译器自动释放\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e回想MIPS函数调用规范中的分配栈\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e堆区：由程序员分配释放\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在c++中由\u003ccode\u003enew\u003c/code\u003e关键字在堆区中申请内存\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e p \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e该局部变量不会随函数结束被回收，\u003cstrong\u003e即堆区的变量与栈区的变量有不同的生命周期\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"13-new操作符\"\u003e1.3 new操作符\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e用\u003ccode\u003enew\u003c/code\u003e操作符在堆区开辟数据\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e基本语法：\u003ccode\u003enew 数据类型 (初始值)|[元素个数]\u003c/code\u003e，返回该数据类型的指针\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ep \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e); \u003cspan style=\"color:#6272a4\"\u003e// 创建int型变量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003earr \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e[\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e]; \u003cspan style=\"color:#6272a4\"\u003e// 创建一个数组 []\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003edelete\u003c/span\u003e p;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003edelete\u003c/span\u003e[] arr;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e用\u003ccode\u003edelete\u003c/code\u003e操作释放内存，\u003cstrong\u003e释放数组加\u003ccode\u003e[]\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e","title":"CPP面向对象"},{"content":"OO第四单元总结——UML 一.正向建模与开发 ​\t在本单元中，主要的训练目的是通过画UML图进行正向建模与开发，即首先通过画UML图(类图/状态图/顺序图)等设计程序的架构，然后进行代码实现。\n​\t在本单元作业中，我主要通过类图进行正向建模与开发。在进行代码实现之前，首先画类图来确定出大致的属性、方法、交互关系等，关于一些比较具体的实现例如参数等先略去，在完成代码过程中进行补充。\n二.架构设计 ​\t本单元的架构设计在三次迭代中保持的相对稳定，除了类中的方法等细节变动，在类的层面上遵循着面向对象的奥义，对于出现的每一个事物都建一个类，在第二次作业中新增漂流角类。\n第一次作业\n第二次作业\n第三次作业\n​\t在三次作业中，我首先进行大略的UML类图的绘制，然后根据第一版类图进行代码构建，在编写代码的过程中不断完善细节和类之间的交互关系，反过来对UML图中的关系进行修改，达到了代码设计和UML模型之间的追踪关系。\n三.架构设计思维演进 ​\t第一单元聚焦于层次化设计，通过表达式计算这一实际问题来引导同学们进行表达式-\u0026gt;项-\u0026gt;因子的递归下降建模。在第一单元中，我对于递归下降的理解是不断深入的，在架构设计上，针对递归下降的结构进行设计，即对表达式、项、因子三个层次进行建模，其中因子设计为一个接口，不同种因子设置为接口的实现。\n​\t第二单元聚焦于多线程设计，通过新主楼电梯运行这一实际问题来引导同学们进行多部电梯之间的多线程协作编程实践(个人体感上第二单元是最难的，难以复现的bug让人恼火)。在第二单元中，我的架构设计主要在于多线程之间的交互关系上：输入线程、调度器线程、电梯线程之间使用怎样的数据结构，怎样降低耦合度，提高内聚度。\n​\t第三单元聚焦于JML规格化设计，通过迷你社交网络这一实际问题来引导同学们根据JML代码来编写实际的JAVA代码。这一单元实际上对于架构设计没有要求，同学们要完成的任务在于根据已经给出的架构进行规格化代码编写，主要的问题是规格与实现分离：给定了JML规格，但不指定具体实现，这其中的算法效率需要同学们进行设计。我感触比较深的点除了使用复杂度较优的算法之外还有进行复杂度分摊：对于一个常使用的复杂度较高的算法可以将他的复杂度分摊在其他较少使用的方法中，达到全局优化的效果。\n​\t第四单元聚焦于UML正向建模与设计，在这单元中我尝试首先通过UML类图进行代码架构的建模与设计，然后在代码编写的过程中优化类之间的协作关系以及数据结构，最后反过头来完善UML图中的细节以及修改与代码不符的设计。在第四单元中，我更加深刻地感受到架构设计的重要性，一个好的架构设计可以为代码实现减小实现难度同时维持较好的扩展性，而架构设计的奥义在于高内聚低耦合，在OOpre以及OO课程中我的感受就是“对每一种事物都建一个类来完成对应的职责”。\n四.测试思维演进 ​\t在四个单元中，我都是采用边缘数据测试+大量随机数据压力测试的方法，在第三单元中，采用了参数化JUnit测试。\n​\t在代码编写过程中，我会编写一些简单的样例对已经编写好的代码进行测试，相当于对每一个方法都进行一个小测试，在过程中不断debug，防止最后bug堆积增加debug难度。\n​\t完成代码编写后(首先跑样例)，手动构造一些从简单到极端数据测试数据范围、运行时间、算法效率等(当然本机运行时间和评测机完全不同，只是进行不同实现间的比较)。然后进行大量随机数据压力测试，这里要感谢DPO的评测机以及Kai_ker的评测机支持。\n​\t以上都是进行黑盒测试，在时间充裕的情况下，我还会进行白盒测试，即从头到尾读几遍自己的代码，再推敲一遍实现细节，往往白盒测试能够触碰到一些黑盒测试碰不到的角落bug。\n五.课程收获 ​\t从OOpre初次接触JAVA编程，到OO课程结束已经可以独立编写千行级别有一定质量的代码，我在一次次代码作业中提高编程能力，在一次次博客作业中总结编程经验。从赤手空拳到满载而归，这是一个充满艰辛的过程。\n​\t面向对象思想是一种好用且高效的思想，理解面向对象思想并不难，通俗的说就是对每一种事物都理解为一个类，有属于自己的职责；但是要想真正写好面向对象代码则需要在不断实践中掌握各种设计模式、不断提高架构设计能力、不断体会高内聚低耦合的设计思路，这也正是课程组在作业中要求我们掌握的。\n​\t彼时的少年，站在成长的巅峰，回首来时，满路崎岖。诚实地说学习OO的过程于我而言是痛苦的，难忘深夜新主楼debug的种种艰辛，但是带给我的代码能力的成长也是非常之大的。\n​\t在写OO的过程中，我喜欢用Pomodoro Logger记录自己努力的时间，hhhhh真是花了很多时间(只展示时间最长的两次作业)。\n​\t如今在OO课程结束的节点，我很赞同OO是一门绝世好课，无论从课程制度还是难度设置上都越来越合理(可以实实在在地给予同学们一个完整的青春)。感谢老师、助教、研讨课上高谈阔论的同学、Kai_ker哥在我的OO课程中赠予的帮助。写完了这篇博客，我就要和2024春季的OO课程说再见了，心头感慨万分，甚至有些舍不得，我深知对我能力提高这样大的课程恐怕再难遇到，诚惶诚恐，用每一行代码，每一篇博客小心翼翼地记录下属于我的OO时光。\n","permalink":"https://coder0xe.github.io/posts/oo-unit4/","summary":"\u003ch1 id=\"oo第四单元总结uml\"\u003eOO第四单元总结——UML\u003c/h1\u003e\n\u003ch2 id=\"一正向建模与开发\"\u003e一.正向建模与开发\u003c/h2\u003e\n\u003cp\u003e​\t在本单元中，主要的训练目的是通过画UML图进行正向建模与开发，即首先通过画UML图(类图/状态图/顺序图)等设计程序的架构，然后进行代码实现。\u003c/p\u003e\n\u003cp\u003e​\t在本单元作业中，我主要通过类图进行正向建模与开发。在进行代码实现之前，首先画类图来确定出大致的属性、方法、交互关系等，关于一些比较具体的实现例如参数等先略去，在完成代码过程中进行补充。\u003c/p\u003e\n\u003ch2 id=\"二架构设计\"\u003e二.架构设计\u003c/h2\u003e\n\u003cp\u003e​\t本单元的架构设计在三次迭代中保持的相对稳定，除了类中的方法等细节变动，在类的层面上遵循着面向对象的奥义，对于出现的每一个事物都建一个类，在第二次作业中新增漂流角类。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e第一次作业\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240610222202964\" loading=\"lazy\" src=\"/img/image-20240610222202964.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e第二次作业\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240610222238973\" loading=\"lazy\" src=\"/img/image-20240610222238973.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e第三次作业\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240610222305495\" loading=\"lazy\" src=\"/img/image-20240610222305495.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t在三次作业中，我首先进行大略的UML类图的绘制，然后根据第一版类图进行代码构建，在编写代码的过程中不断完善细节和类之间的交互关系，反过来对UML图中的关系进行修改，达到了代码设计和UML模型之间的追踪关系。\u003c/p\u003e\n\u003ch2 id=\"三架构设计思维演进\"\u003e三.架构设计思维演进\u003c/h2\u003e\n\u003cp\u003e​\t第一单元聚焦于层次化设计，通过表达式计算这一实际问题来引导同学们进行\u003cstrong\u003e表达式-\u0026gt;项-\u0026gt;因子\u003c/strong\u003e的递归下降建模。在第一单元中，我对于递归下降的理解是不断深入的，在架构设计上，针对递归下降的结构进行设计，\u003cstrong\u003e即对表达式、项、因子三个层次进行建模\u003c/strong\u003e，其中因子设计为一个接口，不同种因子设置为接口的实现。\u003c/p\u003e\n\u003cp\u003e​\t第二单元聚焦于多线程设计，通过新主楼电梯运行这一实际问题来引导同学们进行多部电梯之间的多线程协作编程实践(\u003cdel\u003e个人体感上第二单元是最难的，难以复现的bug让人恼火\u003c/del\u003e)。在第二单元中，我的架构设计主要在于多线程之间的交互关系上：输入线程、调度器线程、电梯线程之间使用怎样的数据结构，怎样降低耦合度，提高内聚度。\u003c/p\u003e\n\u003cp\u003e​\t第三单元聚焦于JML规格化设计，通过迷你社交网络这一实际问题来引导同学们根据JML代码来编写实际的JAVA代码。这一单元实际上对于架构设计没有要求，同学们要完成的任务在于根据已经给出的架构进行规格化代码编写，主要的问题是\u003cstrong\u003e规格与实现分离\u003c/strong\u003e：给定了JML规格，但不指定具体实现，这其中的算法效率需要同学们进行设计。我感触比较深的点除了\u003cstrong\u003e使用复杂度较优的算法\u003c/strong\u003e之外还有\u003cstrong\u003e进行复杂度分摊\u003c/strong\u003e：对于一个常使用的复杂度较高的算法可以将他的复杂度分摊在其他较少使用的方法中，达到全局优化的效果。\u003c/p\u003e\n\u003cp\u003e​\t第四单元聚焦于UML正向建模与设计，在这单元中我尝试首先通过UML类图进行代码架构的建模与设计，然后在代码编写的过程中优化类之间的协作关系以及数据结构，最后反过头来完善UML图中的细节以及修改与代码不符的设计。在第四单元中，我更加深刻地感受到架构设计的重要性，一个好的架构设计可以为代码实现减小实现难度同时维持较好的扩展性，而架构设计的奥义在于\u003cstrong\u003e高内聚低耦合\u003c/strong\u003e，在\u003ccode\u003eOOpre\u003c/code\u003e以及\u003ccode\u003eOO\u003c/code\u003e课程中我的感受就是“对每一种事物都建一个类来完成对应的职责”。\u003c/p\u003e\n\u003ch2 id=\"四测试思维演进\"\u003e四.测试思维演进\u003c/h2\u003e\n\u003cp\u003e​\t在四个单元中，我都是采用\u003cstrong\u003e边缘数据测试+大量随机数据压力测试\u003c/strong\u003e的方法，在第三单元中，采用了参数化\u003ccode\u003eJUnit\u003c/code\u003e测试。\u003c/p\u003e\n\u003cp\u003e​\t在代码编写过程中，我会编写一些简单的样例对已经编写好的代码进行测试，相当于对每一个方法都进行一个小测试，在过程中不断\u003ccode\u003edebug\u003c/code\u003e，防止最后\u003ccode\u003ebug\u003c/code\u003e堆积增加\u003ccode\u003edebug\u003c/code\u003e难度。\u003c/p\u003e\n\u003cp\u003e​\t完成代码编写后(\u003cdel\u003e首先跑样例\u003c/del\u003e)，手动构造一些从简单到极端数据测试数据范围、运行时间、算法效率等(当然本机运行时间和评测机完全不同，只是进行不同实现间的比较)。然后进行大量随机数据压力测试，这里要感谢\u003ccode\u003eDPO\u003c/code\u003e的评测机以及\u003ccode\u003eKai_ker\u003c/code\u003e的评测机支持。\u003c/p\u003e\n\u003cp\u003e​\t以上都是进行黑盒测试，在时间充裕的情况下，我还会进行白盒测试，即从头到尾读几遍自己的代码，再推敲一遍实现细节，往往白盒测试能够触碰到一些黑盒测试碰不到的角落\u003ccode\u003ebug\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"五课程收获\"\u003e五.课程收获\u003c/h2\u003e\n\u003cp\u003e​\t从\u003ccode\u003eOOpre\u003c/code\u003e初次接触JAVA编程，到\u003ccode\u003eOO\u003c/code\u003e课程结束已经可以独立编写千行级别有一定质量的代码，我在一次次代码作业中提高编程能力，在一次次博客作业中总结编程经验。从赤手空拳到满载而归，这是一个充满艰辛的过程。\u003c/p\u003e\n\u003cp\u003e​\t面向对象思想是一种好用且高效的思想，理解面向对象思想并不难，通俗的说就是对每一种事物都理解为一个类，有属于自己的职责；但是要想真正写好面向对象代码则需要在不断实践中掌握各种设计模式、不断提高架构设计能力、不断体会高内聚低耦合的设计思路，这也正是课程组在作业中要求我们掌握的。\u003c/p\u003e\n\u003cp\u003e​\t彼时的少年，站在成长的巅峰，回首来时，满路崎岖。诚实地说学习OO的过程于我而言是痛苦的，难忘深夜新主楼debug的种种艰辛，但是带给我的代码能力的成长也是非常之大的。\u003c/p\u003e\n\u003cp\u003e​\t在写OO的过程中，我喜欢用\u003ccode\u003ePomodoro Logger\u003c/code\u003e记录自己努力的时间，hhhhh真是花了很多时间(只展示时间最长的两次作业)。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240610231415076\" loading=\"lazy\" src=\"/img/image-20240610231415076.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240610231534511\" loading=\"lazy\" src=\"/img/image-20240610231534511.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t如今在OO课程结束的节点，我很赞同OO是一门绝世好课，无论从课程制度还是难度设置上都越来越合理(\u003cdel\u003e可以实实在在地给予同学们一个完整的青春\u003c/del\u003e)。感谢老师、助教、研讨课上高谈阔论的同学、\u003ccode\u003eKai_ker\u003c/code\u003e哥在我的OO课程中赠予的帮助。写完了这篇博客，我就要和2024春季的OO课程说再见了，心头感慨万分，甚至有些舍不得，我深知对我能力提高这样大的课程恐怕再难遇到，诚惶诚恐，用每一行代码，每一篇博客小心翼翼地记录下属于我的OO时光。\u003c/p\u003e","title":"OO-Unit4"},{"content":"Shell挑战性任务设计文档:MOS_SUDO_SHELL 一.实现不带.b的后缀指令 ​\t实现不带.b的后缀指令同时兼容带有.b后缀的指令，这一点可以通过**首先尝试打开不带后缀的指令名，例如ls，失败后再尝试打开带后缀的指令名ls.b实现。**修改spawn.c/spawn函数中的打开文件逻辑即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int spawn(char *prog, char **argv) { // Step 1: Open the file \u0026#39;prog\u0026#39; (the path of the program). // Return the error if \u0026#39;open\u0026#39; fails. int fd; if ((fd = open(prog, O_RDONLY)) \u0026lt; 0) { /*Shell Challenge: *.b*/ char *ext = \u0026#34;.b\u0026#34;; char prog_b[1024]; strcpy(prog_b, prog); // strcat for (int i = strlen(prog_b), j = 0; j \u0026lt; strlen(ext); i++, j++) { prog_b[i] = ext[j]; } if ((fd = open(prog_b, O_RDONLY)) \u0026lt; 0) { return fd; } } //... } 二.实现指令条件执行 ​\t需要实现Linux Shell中的\u0026amp;\u0026amp;与||，需要满足短路原则。\n对于command1 \u0026amp;\u0026amp; command2，commmand2被执行当且仅当command1返回0 对于command1 | command2，command2被执行当且仅当command1返回1 并且\u0026amp;\u0026amp;和||的优先级相同，从左向右执行 ​\t课程组已经给出了测试程序true.c和false.c，其中true.c返回0,false.c返回1,可以增加适当的输出信息用于测试。\n​\t首先应当想到在解析命令时新增两种token：\u0026amp;\u0026amp;和||，分别用首字母a和o表示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int _gettoken(char *s, char **p1, char **p2) { //... if (strchr(SYMBOLS, *s)) { // 修改此处逻辑 识别 \u0026amp;\u0026amp; || ; int t = *s; *p1 = s; /*Shell Challenge*/ char *s1 = s + 1; if (*s1 == *s \u0026amp;\u0026amp; *s1 == \u0026#39;\u0026amp;\u0026#39;) { s++; t = \u0026#39;a\u0026#39;; } else if (*s1 == *s \u0026amp;\u0026amp; *s1 == \u0026#39;|\u0026#39;) { s++; t = \u0026#39;o\u0026#39;; } *s++ = 0; *p2 = s; return t; } //... } ​\t当我们在parsecmd中解析到\u0026amp;\u0026amp;或||时，我们的思路是先fork一下，首先运行左侧的指令，是否运行右边的指令由左边指令的返回值确定，返回值需要通过进程间通信实现。大致梳理一下这个过程：\nparent child spawn : grandson ​\t我们可以看出这个通信过程是一个由底向上的过程，我们知道指令的具体执行是由子shell进行spawn后的“孙子”进程完成的，那么就要由“晚辈的”一层层向“长辈”靠拢，这其间的通信我们使用ipc实现。\n​\tgrandson的返回值在libos.c/libmain中接收，并返回给child，需要注意的是除了这里debugf.c/user_panic中也要进行通信，我选择返回-1表示指令错误执行。\n​\t这里需要注意的是，需要新建用于传递返回值的系统调用和新的返回值字段，否则会与文件系统的ipc发生冲突。\n为env结构体添加用于接受返回值的成员return_value和是否处于接受返回值的状态量waiting_return_value\n1 2 3 4 5 6 7 struct Env { //... // Shell Challenge u_int waiting_return_value; u_int return_value; }; 仿照ipc完成进行返回值传递和接受的系统调用\nsys_send_return_value：发送返回值 sys_recv_return_value：接受返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int sys_send_return_value(u_int envid, u_int value, u_int srcva, u_int perm) { struct Env *e; struct Page *p; if (srcva != 0 \u0026amp;\u0026amp; is_illegal_va(srcva)) { return -E_INVAL; } try(envid2env(envid,\u0026amp;e,0)); if (e-\u0026gt;waiting_return_value != 1) { return -E_IPC_NOT_RECV; } e-\u0026gt;env_ipc_value = value; e-\u0026gt;env_ipc_from = curenv-\u0026gt;env_id; e-\u0026gt;env_ipc_perm = PTE_V | perm; e-\u0026gt;env_ipc_recving = 0; e-\u0026gt;waiting_return_value = 0; e-\u0026gt;return_value = value; e-\u0026gt;env_status = ENV_RUNNABLE; TAILQ_INSERT_TAIL(\u0026amp;env_sched_list,e,env_sched_link); if (srcva != 0) { p = page_lookup(curenv-\u0026gt;env_pgdir,srcva,NULL); if (!p) { return -E_INVAL; } try(page_insert(e-\u0026gt;env_pgdir,e-\u0026gt;env_asid,p,e-\u0026gt;env_ipc_dstva,perm)); } return 0; } int sys_recv_return_value() { curenv-\u0026gt;waiting_return_value = 1; curenv-\u0026gt;env_status = ENV_NOT_RUNNABLE; TAILQ_REMOVE(\u0026amp;env_sched_list,curenv,env_sched_link); ((struct Trapframe *)KSTACKTOP - 1)-\u0026gt;regs[2] = 0; schedule(1); } 传递返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // libos.c void libmain(int argc, char **argv) { // set env to point at our env structure in envs[]. env = \u0026amp;envs[ENVX(syscall_getenvid())]; // call user main routine u_int r = main(argc, argv); //syscall_ipc_try_send(env-\u0026gt;env_parent_id, r, 0, 0); syscall_send_return_value(env-\u0026gt;env_parent_id, r, 0, 0); syscall_set_job_done(env-\u0026gt;env_id); // exit gracefully exit(); } // debugf.c void _user_panic(const char *file, int line, const char *fmt, ...) { debugf(\u0026#34;panic at %s:%d: \u0026#34;, file, line); va_list ap; va_start(ap, fmt); vdebugf(fmt, ap); va_end(ap); syscall_send_return_value(env-\u0026gt;env_parent_id, -1, 0, 0); debugf(\u0026#34;\\n\u0026#34;); exit(); } child进程使用ipc_recv接收返回值，这里需要注意的是，使用syscall_recv_return_value后，并不需要再进行wait，因为接收到返回值已经说明子进程执行完毕。\n另外需要注意的是，当我们遇到\u0026amp;\u0026amp; ||时child需要向parent进行通信，其他时候不需要，我们可以设置一个标志flag进行区分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void runcmd(char *s) { // ... int child = spawn(argv[0], argv); // spawn a new process to run the command // if succeeds, child is the envid of the new process. // if fails, child is the error code. if (child \u0026gt;= 0) { if (flag == 1) { syscall_recv_return_value(); syscall_send_return_value(env-\u0026gt;env_parent_id, env-\u0026gt;return_value, 0, 0); } else if (job_flag == 1) { // 需要创建后台任务 syscall_create_job(child, cmd); syscall_recv_return_value(); } else { syscall_recv_return_value(); } } //... } ​\t考虑到一种比较复杂的情况是cmd1 || cmd2 || cmd3 等可能省略中间部分指令的情况，我选择给parsecmd增加一个参数mark来表示这条指令是否需要执行，经过梳理运行逻辑，一种可行的解决办法是：当我们遇到短路原则时，下一条指令是一定不需要执行的，我们将mark标记为0，当return时，若mark标记为0,则return 0，否则return argc。在runcmd原有的逻辑中，return 0 说明后面没有命令，会退出命令运行，但在此时，我们不能够退出，我们的目标是跳过一条指令，还需要判断后边的指令是否需要执行。我们可以对return 0的情况进行分析\n命令末尾：return 0 \u0026amp;\u0026amp; argv[0] = \u0026quot;\u0026quot; 若是省略命令：return 0 \u0026amp;\u0026amp; argv[0] != \u0026quot;\u0026quot; ​\t因此我们可以利用argv[0]是否为空串来对这两种情况进行区分，当是第一种情况时，直接退出；当是第二种情况时，我们需要与代表着cmd3的父进程进行通信，这时我们将前两个已经短路的指令看作一个整体，返回0。\nparsecmd中注意细节，每一个return都要对mark进行判断。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 int parsecmd(char **argv, int *rightpipe, int mark) { int argc = 0; while (1) { //... case \u0026#39;a\u0026#39;:; // \u0026amp;\u0026amp; flag = 1; int child2 = fork(); if (child2 == 0) { // child shell return mark ? argc : 0; } else { // parent shell syscall_recv_return_value(); if (env-\u0026gt;return_value == 0) { return parsecmd(argv, rightpipe, 1); } else { return parsecmd(argv, rightpipe, 0); } } break; case \u0026#39;o\u0026#39;:; // || flag = 1; int child3 = fork(); if (child3 == 0) { return mark ? argc : 0; } else { syscall_recv_return_value(); if (env-\u0026gt;return_value != 0) { return parsecmd(argv, rightpipe, 1); } else { return parsecmd(argv, rightpipe, 0); } } break; } } return argc; } void runcmd(char *s) { //... if (argc == 0) { if (argv[0]) { // 后边还有指令 syscall_send_return_value(env-\u0026gt;env_parent_id, 0, 0, 0); } return; } argv[argc] = 0; //... } 这里有一个很奇怪的点，可能和我的设计有关，我必须将close_all移动到后面，否则不能即使recv返回值，导致返回值丢失进入死锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int child = spawn(argv[0], argv); // spawn a new process to run the command if (child \u0026gt;= 0) { if (flag == 1) { syscall_recv_return_value(); syscall_send_return_value(env-\u0026gt;env_parent_id, env-\u0026gt;return_value, 0, 0); } else if (job_flag == 1) { // 需要创建后台任务 syscall_create_job(child, cmd); syscall_recv_return_value(); } else { syscall_recv_return_value(); } } else { debugf(\u0026#34;spawn %s: %d\\n\u0026#34;, argv[0], child); } if (rightpipe) { wait(rightpipe); } close_all(); // close all file descriptors !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 三.实现更多指令 3.1 touch touch \u0026lt;file\u0026gt;：不会出现创建多个文件的情况 ​\t新建touch.c并在include.mk中加入touch.b，检查文件是否存在的方式为先尝试打开，若不能成功打开则进行创建。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // touch.c #include\u0026lt;lib.h\u0026gt; void touch(char *path) { int fd = open(path, O_RDONLY); // 首先检查文件是否存在 if (fd \u0026gt; 0) { close(fd); return; } else { // 文件不存在，创建文件 fd = open(path, O_CREAT); if (fd \u0026lt; 0) { printf(\u0026#34;touch: cannot touch \u0026#39;%s\u0026#39;: No such file or directory\\n\u0026#34;, path); return; } close(fd); } } int main(int argc, char **argv) { int i; if (argc \u0026lt; 2) { printf(\u0026#34;touch: missing file operand\\n\u0026#34;); return 0; } touch(argv[1]); } 3.2 mkdir mkdir \u0026lt;dir\u0026gt; mkdir -p \u0026lt;dir\u0026gt; ​\tmkdir的实现方式与touch类似，在open时传入O_MKDIR，需要注意的是要在文件系统服务函数serv.c中打开函数时相应加入对于O_MKDIR的判断。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void serve_open(u_int envid, struct Fsreq_open *rq) { //... if ((rq-\u0026gt;req_omode \u0026amp; O_CREAT) \u0026amp;\u0026amp; (r = file_create(rq-\u0026gt;req_omode, rq-\u0026gt;req_path, \u0026amp;f)) \u0026lt; 0 \u0026amp;\u0026amp; r != -E_FILE_EXISTS) { ipc_send(envid, r, 0, 0); return; } else if ((rq-\u0026gt;req_omode \u0026amp; O_MKDIR) \u0026amp;\u0026amp; (r = file_create(rq-\u0026gt;req_omode, rq-\u0026gt;req_path, \u0026amp;f)) \u0026lt; 0 \u0026amp;\u0026amp; r != -E_FILE_EXISTS) { ipc_send(envid, r, 0, 0); return; } //... } ​\t同时应当修改file_create函数，增加传入参数rq-\u0026gt;req_mode，区分创建文件还是目录，为结构体的type字段赋值。\n1 2 3 4 5 6 7 8 9 10 int file_create(u_int req_mode, char *path, struct File **file) { //... /*Shell Challenge*/ if (req_mode == O_MKDIR) { f-\u0026gt;f_type = FTYPE_DIR; } else { f-\u0026gt;f_type = FTYPE_REG; } //... } ​\t具体的mkdir逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;lib.h\u0026gt; void mkdir(char *path, int flag) { int fd = open(path, O_RDONLY); // 首先检查文件是否存在 if (fd \u0026gt; 0) { close(fd); if (!flag) { printf(\u0026#34;mkdir: cannot create directory \u0026#39;%s\u0026#39;: File exists\\n\u0026#34;, path); } return; } else { // 文件不存在，创建文件 fd = open(path, O_MKDIR); if (fd \u0026lt; 0) { if (!flag) { printf(\u0026#34;mkdir: cannot create directory \u0026#39;%s\u0026#39;: No such file or directory\\n\u0026#34;, path); return; } else { // 递归创建目录,例如 \u0026#34;/nonexist/dqr/123\u0026#34; char *p = path; if (*p == \u0026#39;/\u0026#39;) { // 跳过开头的\u0026#39;/\u0026#39; p++; } while (1) { if (*p == \u0026#39;/\u0026#39;) { *p = \u0026#39;\\0\u0026#39;; mkdir(path, 1); *p = \u0026#39;/\u0026#39;; } else if (*p == \u0026#39;\\0\u0026#39;) { mkdir(path, 1); break; } p++; } } } close(fd); } } int main(int argc, char **argvs) { if (argc \u0026lt; 2) { printf(\u0026#34;mkdir: missing operand\\n\u0026#34;); return 0; } // 需要考虑参数p忽略错误 if (strcmp(argvs[1], \u0026#34;-p\u0026#34;) == 0) { mkdir(argvs[2], 1); } else { mkdir(argvs[1], 0); } return 0; } 3.3 rm rm \u0026lt;file\u0026gt; rm \u0026lt;dir\u0026gt; rm -r \u0026lt;dir\u0026gt;|\u0026lt;file\u0026gt; rm -rf \u0026lt;dir\u0026gt;|\u0026lt;file\u0026gt; ​\t对于rm指令处理的关键在于对于参数的处理，我们知道删除目录时需要-r/-rf参数，所以需要特殊判断无参数删除目录文件的情况。我采用的方法是在文件系统删除请求结构体中加入一个模式字段，用来表示参数情况(无参数为0，-r为1，-rf为2)。\n1 2 3 4 struct Fsreq_remove { char req_path[MAXPATHLEN]; u_int remove_type; }; ​\t对于这个参数的传递，我选择了一种不太“优雅“的方式，由于不能修改remove函数的传参(remove函数在test中有引用，评测时替换为标准文件，若修改会导致编译不过)，我选择将模式数字拼接在路径字符串的\\0之后，这样我们既可以读取模式数字，又可以保证读取路径的正确性。\n​\t在remove函数中将这个数字取出，沿着调用链进行传递。\n1 2 3 4 5 6 7 8 int remove(const char *path) { // Call fsipc_remove. // 最后一位为模式 int len = strlen(path); int type = path[++len] - \u0026#39;0\u0026#39;; /* Exercise 5.13: Your code here. */ return fsipc_remove(path, type); } ​\t在fsipc_remove中构建请求结构体时对新增字段赋值，达到通过结构体传参的目的。\n1 2 3 4 5 int fsipc_remove(const char *path, u_int type) { //... req-\u0026gt;remove_type = type; //... } ​\t在文件系统服务函数中，为file_remove新增模式参数\n1 2 3 4 void serve_remove(u_int envid, struct Fsreq_remove *rq) { r = file_remove(rq-\u0026gt;req_path, rq-\u0026gt;remove_type); ipc_send(envid, r, 0, 0); } ​\t修改具体的文件删除逻辑，当要删除的文件为目录但传递的参数为N(0)时，返回一种新的错误码(E_IS_DIR=14,新增定义在error.h中)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int file_remove(char *path, u_int type) { int r; struct File *f; // Step 1: find the file on the disk. if ((r = walk_path(path, 0, \u0026amp;f, 0)) \u0026lt; 0) { return r; } /*Shell Challenge*/ if (f-\u0026gt;f_type == FTYPE_DIR \u0026amp;\u0026amp; type == 0) { return -E_IS_DIR; } //... } ​\t具体的remove逻辑：这里返回小于0值说明一定是N模式下删除了目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;lib.h\u0026gt; #define N 0 #define R 1 #define RF 2 void rm(char *path, int flag) { int fd = open(path, O_RDONLY); if (fd \u0026lt; 0) { if (flag != RF) { printf(\u0026#34;rm: cannot remove \u0026#39;%s\u0026#39;: No such file or directory\\n\u0026#34;, path); } } else { close(fd); /*为了避免传参问题 将模式拼接在路径末尾\\0之后*/ char path1[MAXPATHLEN+1]; strcpy(path1, path); int len = strlen(path1); path1[++len] = flag + \u0026#39;0\u0026#39;; /********************/ fd = remove(path1); if (fd \u0026lt; 0) { printf(\u0026#34;rm: cannot remove \u0026#39;%s\u0026#39;: Is a directory\\n\u0026#34;, path); } } } int main(int argc, char **argv) { if (argc \u0026lt; 2) { printf(\u0026#34;rm: missing operand\\n\u0026#34;); } if (strcmp(argv[1], \u0026#34;-r\u0026#34;) == 0) { rm(argv[2], R); } else if (strcmp(argv[1], \u0026#34;-rf\u0026#34;) == 0) { rm(argv[2], RF); } else { rm(argv[1], N); } return 0; } 四.实现反引号 ​\t使用反引号实现指令替换，只需要考虑echo进行的输出，需要将反引号内指令执行的所有标准输出替换为echo的参数。\n换句话说，执行一下反引号里边的内容 ​\t首先增加反引号token\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int _gettoken(char *s, char **p1, char **p2) { //... if(*s == \u0026#39;`\u0026#39;) { // 识别反引号 *s = 0; s++; *p1 = s; while(*s \u0026amp;\u0026amp; (*s != \u0026#39;`\u0026#39;)){ s++; } *s++ = 0; *p2 = s; return \u0026#39;f\u0026#39;; } //... } ​\t在parsecmd中增加对应逻辑，这时反引号中间的指令已经被保存在字符串指针t中。\n1 2 3 4 5 6 7 8 9 10 11 int parsecmd(char **argv, int *rightpipe, int mark) { int argc = 0; while (1) { //... case \u0026#39;f\u0026#39;:; // 反引号 runcmd(t); break; } //... } } 五.实现注释功能 ​\t使用#实现注释功能也就是对#后面的内容进行忽略，可以在进行执行指令时对字符串#后面的部分进行截断。\n1 2 3 4 5 6 7 8 9 10 11 //sh.c void runcmd(char *s) { /*Shell Challenge: #*/ char *p = s; while (*p \u0026amp;\u0026amp; *p != \u0026#39;#\u0026#39;) { p++; } *p = 0; gettoken(s, 0); //... } 六.实现历史指令 启动shell时创建.mosh_history文件 运行命令时将命令保存到.mosh_history history命令输出文件内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void create_history() { int fd; if ((fd = open(\u0026#34;.mosh_history\u0026#34;, O_CREAT)) \u0026lt; 0) { printf(\u0026#34;create history file failed\\n\u0026#34;); } return; } void save_history_cmd(char * cmd) { int fd; if ((fd = open(\u0026#34;.mosh_history\u0026#34;, O_WRONLY)) \u0026lt; 0) { printf(\u0026#34;open history file failed\\n\u0026#34;); } struct Stat st; stat(\u0026#34;.mosh_history\u0026#34;, \u0026amp;st); seek(fd, st.st_size); write(fd, cmd, strlen(cmd)); write(fd, \u0026#34;\\n\u0026#34;, 1); close(fd); return; } void print_history() { int fd; if ((fd = open(\u0026#34;.mosh_history\u0026#34;, O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;open history file failed\\n\u0026#34;); } char ch; while (read(fd, \u0026amp;ch, 1)) { printf(\u0026#34;%c\u0026#34;, ch); } close(fd); return; } 七.实现一行多指令 ​\t实现使用;将多条指令隔开从而从左至右依顺序执行每条指令的功能，通过修改parsecmd()函数使其增添对;的处理能力。在parsecmd的字符串解析过程中，若读到一个;，则进行一次fork，产生一个子shell，让子shell执行左边的命令，父shell等待子shell执行完成后执行右边的命令。\n1 2 3 4 5 6 7 8 9 case \u0026#39;;\u0026#39;:; int child = fork(); if (child == 0) { // child shell return argc; } else { // parent shell wait(child); return parsecmd(argv, rightpipe); } break; 八.实现追加重定向 实现\u0026gt;\u0026gt;的追加重定向的功能 ​\t首先增加一种token为\u0026gt;\u0026gt;，在_gettoken中实现，标记为z。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int _gettoken(char *s, char **p1, char **p2) { //... if (strchr(SYMBOLS, *s)) { // 修改此处逻辑 识别 \u0026amp;\u0026amp; || ; int t = *s; *p1 = s; /*Shell Challenge*/ char *s1 = s + 1; if (*s1 == *s \u0026amp;\u0026amp; *s1 == \u0026#39;\u0026amp;\u0026#39;) { s++; t = \u0026#39;a\u0026#39;; } else if (*s1 == *s \u0026amp;\u0026amp; *s1 == \u0026#39;|\u0026#39;) { s++; t = \u0026#39;o\u0026#39;; } else if (*s1 == *s \u0026amp;\u0026amp; *s1 == \u0026#39;\u0026gt;\u0026#39;) { s++; t = \u0026#39;z\u0026#39;; } *s++ = 0; *p2 = s; return t; } //... } ​\t在parsecmd中进行修改，为文件设置好偏移量后进行dup\nstat获取文件信息 seek设置文件偏移量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int parsecmd(char **argv, int *rightpipe, int mark) { int argc = 0; while (1) { //... case \u0026#39;z\u0026#39;:; // 实现追加重定向 if (gettoken(0, \u0026amp;t) != \u0026#39;w\u0026#39;) { debugf(\u0026#34;syntax error: \u0026gt; not followed by word\\n\u0026#34;); exit(); } if ((fd = open(t, O_RDONLY | O_WRONLY | O_CREAT)) \u0026lt; 0) { debugf(\u0026#34;failed to open %s\\n\u0026#34;, t); exit(); } struct Stat st; if (fstat(fd, \u0026amp;st) \u0026lt; 0) { debugf(\u0026#34;failed to fstat %s\\n\u0026#34;, t); exit(); } seek(fd, st.st_size); if ((r = dup(fd, 1)) \u0026lt; 0) { debugf(\u0026#34;failed to duplicate file to \u0026lt;stdout\u0026gt;\\n\u0026#34;); exit(); } close(fd); break;\t} } return argc; } 九.实现引号支持 ​\tshell在解析时需要将双引号内的内容看作是单个字符串，在解析字符串时加了一种token为字符串，修改_gettoken中的逻辑。\n1 2 3 4 5 6 7 8 9 10 11 /*Shell Challenge : \u0026#34;content\u0026#34;*/ if (*s == \u0026#39;\u0026#34;\u0026#39;) { // read until the next \u0026#39;\u0026#34;\u0026#39; *s++; *p1 = s; while (*s \u0026amp;\u0026amp; *s != \u0026#39;\u0026#34;\u0026#39;) { s++; } *(s++) = 0; // *s = \u0026#39;\u0026#34;\u0026#39; *p2 = s; return \u0026#39;w\u0026#39;; } 十.实现前后台任务管理 10.1 实现后台任务并行 ​\t此功能的实现与实现一行多指令类似，后台运行任务即在fork之后父进程不会等待子进程运行完成。\n1 2 3 4 5 6 7 8 9 case \u0026#39;\u0026amp;\u0026#39;:; job_flag = 1; int child = fork(); if (child == 0) { // child shell return argc; } else { // parent shell return parsecmd(argv, rightpipe); }\tbreak;\t10.2 实现jobs指令 关于后台任务的三个指令我们需要实现为内置指令，shell中分为内置指令和外部指令，外部指令需要fork一个子进程进行执行，而内置指令不会，效率更高。\n基本的实现思路为我们在runcmd时检查指令，如果为内置指令不再进行spawn而是直接调用sh.c中写好的函数执行。 为了实现进程间的共享，我选择在内核态对后台进程进行管理，通过系统调用syscall_*进行更新 加系统调用的流程上机考试早已熟悉 ​\t首先：如何实现内置指令，区别于外部指令，内部指令执行时不会进行fork，效率更高，当我们在runcmd时应当特判遇到的内置指令，调用sh.c中写好的处理函数执行。\n1 2 3 4 5 6 7 8 9 10 11 12 if (strcmp(argv[0], \u0026#34;jobs\u0026#34;) == 0) { execute_jobs(); exit(); } else if (strcmp(argv[0], \u0026#34;fg\u0026#34;) == 0) { int jobId = parseJobId(argv[1]); execute_fg(jobId); exit(); } else if (strcmp(argv[0], \u0026#34;kill\u0026#34;) == 0) { int jobId = parseJobId(argv[1]); execute_kill(jobId); exit(); } ​\t为了更好的管理工作的信息，我选择新建一个Job结构体，定义在env.h中\n1 2 3 4 5 6 struct Job { int job_id; int job_status; // 0 for Done; 1 for Running int envid; char cmd[1024]; }; ​\t在内核态对struct Job数组进行管理，将数组定义在env.c中便于操作。\n1 2 struct Job jobs[32]; int jobCnt = 0; ​\t**重点在于何时将进程放入后台：**我们设置一个全局变量job_flag读到\u0026amp;时置为1,在runcmd时，对这个标记进行特判，从而将进程放到后台，这里需要注意的是，recv应当在syscall_create_job之后，否则会一直阻塞，不能加入到后台，直到进程运行完毕才能加入到后台。\n1 2 3 4 5 6 7 8 9 10 11 if (child \u0026gt;= 0) { if (flag == 1) { syscall_recv_return_value(); syscall_send_return_value(env-\u0026gt;env_parent_id, env-\u0026gt;return_value, 0, 0); } else if (job_flag == 1) { // 需要创建后台任务 syscall_create_job(child, cmd); syscall_recv_return_value(); } else { syscall_recv_return_value(); } } ​\t这里创建后台任务也是通过系统调用实现，实际上是对内核态jobs数组赋值的操作，这样就实现了加入后台任务。\n1 2 3 4 5 6 7 8 //env.c void env_create_job(u_int envid, char * cmd) { jobs[jobCnt].envid = envid; jobs[jobCnt].job_status = 1; // Running strcpy(jobs[jobCnt].cmd, cmd); jobs[jobCnt].job_id = jobCnt + 1; jobCnt++; } ​\t加入后台时，将运行状态status设置为1(Running)，0(Done).\n​\tjobs操作实际上是一个“输出”操作，我们通过系统调用实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //sh.c void execute_jobs() { // 约等于无用封装 syscall_print_jobs(); } //env.c void env_print_jobs() { for (int i = 0; i \u0026lt; jobCnt; i++) { if (jobs[i].job_status == 1) { printk(\u0026#34;[%d] %-10s 0x%08x %s\\n\\r\u0026#34;, jobs[i].job_id, \u0026#34;Running\u0026#34;, jobs[i].envid, jobs[i].cmd); } else { printk(\u0026#34;[%d] %-10s 0x%08x %s\\n\\r\u0026#34;, jobs[i].job_id, \u0026#34;Done\u0026#34;, jobs[i].envid, jobs[i].cmd); } } } ​\t这里还有很重要的一点是：后台进程状态的变化，当后台进程结束时，应当设置状态为Done，而我们知道后台进程结束点是在libmain，在libmain中通过系统调用更改job_status = 0(Done)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // libos.c void libmain(int argc, char **argv) { //... syscall_set_job_done(env-\u0026gt;env_id); // exit gracefully exit(); } //env.c void env_set_job_done(u_int envid) { for (int i = 0; i \u0026lt; jobCnt; i++) { if (jobs[i].envid == envid) { jobs[i].job_status = 0; break; } } } 10.3 实现fg指令 首先构建一个简单的辅助函数，用来将argv[1]转换为\u0026lt;jobid\u0026gt;\n1 2 3 4 5 6 7 8 int parseJobId(char *s) { int jobId = 0; while (*s) { jobId = jobId * 10 + (*s - \u0026#39;0\u0026#39;); s++; } return jobId; } fg命令同样通过系统调用实现，并不需要从后台jobs中删除jobid的目录项，只需到前台运行该进程，或者说当前运行进程wait这个后台进程。\n说个题外话，我是没想到不用从jobs列表中删除该项的，因为linux中的行为是进行删除，而课程组的建议是仿照linux行为实现，并且挑战性任务说明书一坨，MOS居然有了这么离谱的举动，居然也不在挑战性任务中说明或给出样例，等大家猜吗\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //sh.c void execute_fg(int jobId) { int envid = syscall_fg_job(jobId); if (envid == -1) { printf(\u0026#34;fg: job (%d) do not exist\\n\u0026#34;, jobId); } else if (envs[ENVX(envid)].env_status != ENV_RUNNABLE) { printf(\u0026#34;fg: (0x%08x) not running\\n\u0026#34;, envid); } else { wait(envid); } } //env.c int env_fg_job(int jobId) { for (int i = 0; i \u0026lt; jobCnt; i++) { if (jobs[i].job_id == jobId) { return jobs[i].envid; } } return -1; } 10.4 实现kill指令 kill命令同样通过系统调用实现，杀死后台进程\n同样不需要从Jobs列表中删除\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // sh.c void execute_kill(int jobId) { syscall_kill_job(jobId); } // env.c void env_kill_job(int jobId) { for (int i = 0; i \u0026lt; jobCnt; i++) { if (jobs[i].job_id == jobId) { if (envs[ENVX(jobs[i].envid)].env_status != ENV_RUNNABLE) { printk(\u0026#34;fg: (0x%08x) not running\\n\u0026#34;, jobs[i].envid); return; } else { env_destroy(\u0026amp;envs[ENVX(jobs[i].envid)]); jobs[i].job_status = 0; return; } } } printk(\u0026#34;fg: job (%d) do not exist\\n\u0026#34;, jobId); return; } ","permalink":"https://coder0xe.github.io/posts/os-shell%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1/","summary":"\u003ch1 id=\"shell挑战性任务设计文档mos_sudo_shell\"\u003eShell挑战性任务设计文档:MOS_SUDO_SHELL\u003c/h1\u003e\n\u003ch2 id=\"一实现不带b的后缀指令\"\u003e一.实现不带\u003ccode\u003e.b\u003c/code\u003e的后缀指令\u003c/h2\u003e\n\u003cp\u003e​\t实现不带\u003ccode\u003e.b\u003c/code\u003e的后缀指令同时兼容带有\u003ccode\u003e.b\u003c/code\u003e后缀的指令，这一点可以通过**首先尝试打开不带后缀的指令名，例如\u003ccode\u003els\u003c/code\u003e，失败后再尝试打开带后缀的指令名\u003ccode\u003els.b\u003c/code\u003e实现。**修改\u003ccode\u003espawn.c/spawn\u003c/code\u003e函数中的打开文件逻辑即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003espawn\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003eprog, \u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e**\u003c/span\u003eargv) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e// Step 1: Open the file \u0026#39;prog\u0026#39; (the path of the program).\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e// Return the error if \u0026#39;open\u0026#39; fails.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e fd;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((fd \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eopen\u003c/span\u003e(prog, O_RDONLY)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#6272a4\"\u003e/*Shell Challenge: *.b*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003eext \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;.b\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e prog_b[\u003cspan style=\"color:#bd93f9\"\u003e1024\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#50fa7b\"\u003estrcpy\u003c/span\u003e(prog_b, prog);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#6272a4\"\u003e// strcat\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003estrlen\u003c/span\u003e(prog_b), j \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; j \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003estrlen\u003c/span\u003e(ext); i\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e, j\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tprog_b[i] \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e ext[j];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((fd \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eopen\u003c/span\u003e(prog_b, O_RDONLY)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e fd;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"二实现指令条件执行\"\u003e二.实现指令条件执行\u003c/h2\u003e\n\u003cp\u003e​\t需要实现\u003ccode\u003eLinux Shell\u003c/code\u003e中的\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e与\u003ccode\u003e||\u003c/code\u003e，需要满足短路原则。\u003c/p\u003e","title":"OS:Shell挑战性任务"},{"content":"OS:lab6实验报告 Thinking 6.1 示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想 让父进程作为“读者”，代码应当如何修改？\n父进程关掉写端fildes[1]，打开读端fildes[0]\n子进程关掉读端fildes[0]，打开写端fildes[1]\nThinking 6.2 上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中 的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出 现预想之外的情况？ 原理同pipe_close一致，都是在一个函数两个相关的页面map或者unmap的之间发生了时钟中断，所以会导致不一致的现象。 dup函数中有两次map，将newfd所在的虚拟页映射到oldfd所在的物理页，将newfd的数据所在的虚拟页映射到oldfd的数据所在的物理页 Thinking 6.3 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是 所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。\n系统调用一定是原子操作，进程切换是通过定时器产生时钟中断，触发时钟中断切换进程。但是syscall跳转到内核态时，CPU将SR寄存其的IE位置0，关闭了时钟中断。\nThinking 6.4 按照上述说法控制 pipe_close 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程 在两个unmap之间发生时钟中断时，若先解除pipe再解除fd，会导致pageref(pipe)==pageref(fd)，写端关闭的错误判断。不会若调换顺序，可以总保证pageref(pipe) \u0026gt; pageref(fd)发生错判。 我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件描述符。 试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。 原来dup的map顺序为首先映射fd再映射pipe即fd的映射次数先+1，此时若在两个map之间发生时钟中断，会导致pageref(pipe)==pageref(fd)的错判，因此需要调整顺序，首先映射pipe再映射fd。 Thinking 6.5 认真回看 Lab5 文件系统相关代码，弄清打开文件的过程 spawn 函数是通过和文件系统交互，取得文件描述块，进而找到 ELF 在“硬盘”中的位置，进而读取。 回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件 在 Lab3 中填写了 load_icode 函数，实现了 ELF 可执行文件中读取数据并加载到内存空间，其中通过调用 elf_load_seg 函数来加载各个程序段。在 Lab3 中我们要填写 load_icode_mapper 回调函数，在内核态下加载 ELF 数据到内存空间；相应地，在 Lab6 中 spawn 函数也需要在用户态下使用系统调用为 ELF 数据分配空间。 在 Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和filesize ，我们在 Note1.3.4中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper()函数是如何确保加载 ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？ bss段应该与text段data段连续的放在一起，但是ELF中没有空间，在分配映射页面时，text段与data段没有占满的空间置为0给了bss段，然后再给他另外分配的时候，只使用syscall_mem_alloc而不映射。 Thinking 6.6 通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要 我们将其 dup 到 0 或 1 号文件描述符（fd）。那么问题来了：在哪步，0 和 1 被“安排”为 标准输入和标准输出？请分析代码执行流程，给出答案。\nuser/init.c\n1 2 3 4 5 6 7 8 // stdin should be 0, because no file descriptors are open yet if ((r = opencons()) != 0) { user_panic(\u0026#34;opencons: %d\u0026#34;, r); } // stdout if ((r = dup(0, 1)) \u0026lt; 0) { user_panic(\u0026#34;dup: %d\u0026#34;, r); } Thinking 6.7 **在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不 需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork 一个子 shell，然后子 shell 去执行这条命令。 据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么 Linux 的 cd 命令是内部命令而不是外部命令？ **\n在MOS中，执行命令前都会fork一下，通过子进程完成命令，所以是外部命令\ncd命令需要改变父进程的状态，即所在的路径，通过fork之后只能够改变子进程，所以需要是内部命令\nThinking 6.8 在你的 shell 中输入命令 ls.b | cat.b \u0026gt; motd\n请问你可以在你的 shell 中观察到几次 spawn ？分别对应哪个进程？\n两次，分别打开了ls.b和cat.b\n请问你可以在你的 shell 中观察到几次进程销毁？分别对应哪个进程？\n四个，左指令的执行进程，右指令的执行进程，spawn打开的两个执行进程\n实验难点分析 ​\t本次实验主要实现了进程间通信的匿名管道机制和shell命令行解释程序。主要的难点在于理解管道的机制和命令行解释程序的编写。\n内核启动的进程user/icode.b调用了spawn，创建了init.b进程init.b进程首先打开控制台(console)作为0号和1号文件描述符，即进程的标准输入和输出。然后spawn创建了sh.b进程，也就是我们的shell，通过共享页面机制，fork和spawn创建的子进程继承了父进程持有的fd。 shell进程负责解析命令行程序，通过spawn生成可执行程序进程(*.b)，在解析命令行命令时，子shell会将重定向文件及管道等dup到子shell的标准输入或输出。然后spawn时将标准输入和输出通过共享内存映射给可执行程序。 实验心得体会 ​\t通过本次实验，我学习了通信的管道机制和shell的编写，更好地将理论课中学到的理论知识与实验代码进行融合理解。lab6是OS实验的最后一部分，通过lab6我们建立了一个简易的shell程序，后续计划做Shell挑战性任务来加深自己对于lab6的理解。\n","permalink":"https://coder0xe.github.io/posts/os-lab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","summary":"\u003ch1 id=\"oslab6实验报告\"\u003eOS:lab6实验报告\u003c/h1\u003e\n\u003ch2 id=\"thinking-61\"\u003eThinking 6.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想 让父进程作为“读者”，代码应当如何修改？\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e父进程关掉写端\u003ccode\u003efildes[1]\u003c/code\u003e，打开读端\u003ccode\u003efildes[0]\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e子进程关掉读端\u003ccode\u003efildes[0]\u003c/code\u003e，打开写端\u003ccode\u003efildes[1]\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-62\"\u003eThinking 6.2\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中 的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出 现预想之外的情况？\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e原理同\u003ccode\u003epipe_close\u003c/code\u003e一致，都是在一个函数两个相关的页面map或者unmap的之间发生了时钟中断，所以会导致不一致的现象。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edup\u003c/code\u003e函数中有两次\u003ccode\u003emap\u003c/code\u003e，将newfd所在的虚拟页映射到oldfd所在的物理页，将newfd的数据所在的虚拟页映射到oldfd的数据所在的物理页\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-63\"\u003eThinking 6.3\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是 所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e系统调用一定是原子操作，进程切换是通过定时器产生时钟中断，触发时钟中断切换进程。但是syscall跳转到内核态时，CPU将SR寄存其的IE位置0，关闭了时钟中断。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-64\"\u003eThinking 6.4\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e按照上述说法控制 pipe_close 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e在两个\u003ccode\u003eunmap\u003c/code\u003e之间发生时钟中断时，若先解除\u003ccode\u003epipe\u003c/code\u003e再解除\u003ccode\u003efd\u003c/code\u003e，会导致\u003ccode\u003epageref(pipe)==pageref(fd)\u003c/code\u003e，写端关闭的错误判断。不会若调换顺序，可以总保证\u003ccode\u003epageref(pipe) \u0026gt; pageref(fd)\u003c/code\u003e发生错判。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件描述符。 试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e原来\u003ccode\u003edup\u003c/code\u003e的\u003ccode\u003emap\u003c/code\u003e顺序为首先映射\u003ccode\u003efd\u003c/code\u003e再映射\u003ccode\u003epipe\u003c/code\u003e即\u003ccode\u003efd\u003c/code\u003e的映射次数先+1，此时若在两个\u003ccode\u003emap\u003c/code\u003e之间发生时钟中断，会导致\u003ccode\u003epageref(pipe)==pageref(fd)\u003c/code\u003e的错判，因此需要调整顺序，首先映射\u003ccode\u003epipe\u003c/code\u003e再映射\u003ccode\u003efd\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-65\"\u003eThinking 6.5\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e认真回看 Lab5 文件系统相关代码，弄清打开文件的过程\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003espawn 函数是通过和文件系统交互，取得文件描述块，进而找到 ELF 在“硬盘”中的位置，进而读取。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e在 Lab3 中填写了 load_icode 函数，实现了 ELF 可执行文件中读取数据并加载到内存空间，其中通过调用 elf_load_seg 函数来加载各个程序段。在 Lab3 中我们要填写 load_icode_mapper 回调函数，在内核态下加载 ELF 数据到内存空间；相应地，在 Lab6 中 spawn 函数也需要在用户态下使用系统调用为 ELF 数据分配空间。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e在 Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和filesize ，我们在 Note1.3.4中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper()函数是如何确保加载 ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003ebss段应该与text段data段连续的放在一起，但是ELF中没有空间，在分配映射页面时，text段与data段没有占满的空间置为0给了bss段，然后再给他另外分配的时候，只使用syscall_mem_alloc而不映射。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-66\"\u003eThinking 6.6\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要 我们将其 dup 到 0 或 1 号文件描述符（fd）。那么问题来了：在哪步，0 和 1 被“安排”为 标准输入和标准输出？请分析代码执行流程，给出答案。\u003c/strong\u003e\u003c/p\u003e","title":"OS:lab6实验报告"},{"content":"OS:lab6课下基础 1. 管道 1.1 初窥管道 ​\t管道是一种典型的进程间单向通信的方式，分为有名管道和匿名管道两种，匿名管道只能在有公共祖先的进程间使用，在MOS中，我们要实现匿名管道。\n​\t管道是一种只存在于内存中的文件，在MOS中，父进程调用pipe函数时会打开两个新的文件描述符：一个表示只读端，一个表示只写端，两个描述符都映射到同一片内存区域。\n​\t在fork的配合下，子进程会复制父进程的两个文件描述符，从而在==父子进程间形成了四个(父子各有一读一写)的指向同一片内存区域的文件描述符，父子进程可根据需要关掉自己不用的一个，从而实现单向管道通信。==\n1.2 MOS中pipe的使用与实现 ​\tMOS中pipe的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 int pipe(int pfd[2]) { int r; void *va; struct Fd *fd0, *fd1; /* Step 1: Allocate the file descriptors. */ if ((r = fd_alloc(\u0026amp;fd0)) \u0026lt; 0 || (r = syscall_mem_alloc(0, fd0, PTE_D | PTE_LIBRARY)) \u0026lt; 0) { goto err; } if ((r = fd_alloc(\u0026amp;fd1)) \u0026lt; 0 || (r = syscall_mem_alloc(0, fd1, PTE_D | PTE_LIBRARY)) \u0026lt; 0) { goto err1; } /* Step 2: Allocate and map the page for the \u0026#39;Pipe\u0026#39; structure. */ va = fd2data(fd0); if ((r = syscall_mem_alloc(0, (void *)va, PTE_D | PTE_LIBRARY)) \u0026lt; 0) { goto err2; } if ((r = syscall_mem_map(0, (void *)va, 0, (void *)fd2data(fd1), PTE_D | PTE_LIBRARY)) \u0026lt; 0) { goto err3; } /* Step 3: Set up \u0026#39;Fd\u0026#39; structures. */ fd0-\u0026gt;fd_dev_id = devpipe.dev_id; fd0-\u0026gt;fd_omode = O_RDONLY; fd1-\u0026gt;fd_dev_id = devpipe.dev_id; fd1-\u0026gt;fd_omode = O_WRONLY; debugf(\u0026#34;[%08x] pipecreate \\n\u0026#34;, env-\u0026gt;env_id, vpt[VPN(va)]); /* Step 4: Save the result. */ pfd[0] = fd2num(fd0); pfd[1] = fd2num(fd1); return 0; err3: syscall_mem_unmap(0, (void *)va); err2: syscall_mem_unmap(0, fd1); err1: syscall_mem_unmap(0, fd0); err: return r; } 首先为fd0和fd1两个文件描述符分配空间(物理页)\n然后给fd0对应的虚拟地址分配一页物理内存并将fd1对应的虚拟地址映射到这一页物理内存\n通过管道pipe进行共享的实际上是共享页面机制PTE_LIBRARY\n1.3 管道的读写 ​\t关于管道结构体Pipe的定义如下\n1 2 3 4 5 struct Pipe { u_int p_rpos;\t// read position u_int p_wpos;\t// write position u_char p_buf[PIPE_SIZE]; // data buffer }; p_rpos：下一个要从管道读的数据的位置，读者更新\np_wpos：下一个要向管道写的数据的位置，写者更新\np_buf：缓冲区，类似于环形缓冲区，读写的位置i实际上是i%PAGE_SIZE\n​\t当读者从管道读取数据时，要将p_buf[p_rpos%PIPE_SIZE]拷贝走，然后读自增一。==需要注意的是，管道的缓冲区此时可能还没有被写入数据，所以如果管道数据为空，即当p_rpos\u0026gt;=p_wpos时，进程切换到写者运行。==\n​\t当写者相管道中写入数据时，将数据存入p_buf[p_wpos%PIPE_SIZE]，然后写自增一。==需要注意缓冲区可能存在满溢的情况，所以需要在p_wpos-p_rpos\u0026lt;PIPE_SIZE时方可运行。==\n​\t当缓冲区出现空或满的情况时，我们还需要根据另一端是否关闭来判断是否要返回，另一端已经关闭则返回0即可，否则切换进程运行。\n​\t判断管道另一端是否关闭_pipe_is_closed：对于一个匿名管道，我们分配了三页空间：读数据的文件描述符rfd一页，写数据的文件描述符wfd一页，剩下一页是被两个文件描述符共享的管道数据缓冲区pipe.\n​\t则有pageref(rfd)+pageref(wfd)=pageref(pipe)，若另一端关闭则有pageref(rfd)=pageref(pipe)或pageref(wfd)==pageref(pipe)\nExercise 6.1 pipe_read, pipe_write, _pipe_is_closed\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 static int _pipe_is_closed(struct Fd *fd, struct Pipe *p) { int fd_ref, pipe_ref, runs; /* Exercise 6.1: Your code here. (1/3) */ do { runs = env-\u0026gt;env_runs; fd_ref = pageref(fd); pipe_ref = pageref(p); } while (runs != env-\u0026gt;env_runs); return fd_ref == pipe_ref; } static int pipe_read(struct Fd *fd, void *vbuf, u_int n, u_int offset) { int i; struct Pipe *p; char *rbuf; /* Exercise 6.1: Your code here. (2/3) */ p = (struct Pipe *)fd2data(fd); rbuf = (char *)vbuf; for (i = 0; i \u0026lt; n; i++) { while (p-\u0026gt;p_rpos \u0026gt;= p-\u0026gt;p_wpos) { if (i \u0026gt;= 1 || _pipe_is_closed(fd, p)) { return i; } else { syscall_yield(); } } rbuf[i] = p-\u0026gt;p_buf[(p-\u0026gt;p_rpos++) % PIPE_SIZE]; } return n; } static int pipe_write(struct Fd *fd, const void *vbuf, u_int n, u_int offset) { int i; struct Pipe *p; char *wbuf; /* Exercise 6.1: Your code here. (3/3) */ p = (struct Pipe *)fd2data(fd); wbuf = (char *)vbuf; for (i = 0; i \u0026lt; n; i++) { while (p-\u0026gt;p_wpos - p-\u0026gt;p_rpos \u0026gt;= PIPE_SIZE) { if (_pipe_is_closed(fd, p)) { return i; } else { syscall_yield(); } } p-\u0026gt;p_buf[(p-\u0026gt;p_wpos++) % PIPE_SIZE] = wbuf[i]; } return n; } 1.4 管道关闭的正确判断 ​\tMOS采用时间片轮转的进程调度算法，抢占式的进程管理意味着用户进程随时可能会被打断。\n​\t由于管道的共享性质，无法保证_pipe_is_closed用于管道另一端的判断一定返回正确的结果。\n​\t进程使用pipe_close来关闭管道的端口，该函数的实质是通过两次系统调用unmap来解除文件描述符fd和数据缓存区pipe的映射。由于进程切换的存在，并不能保证两次系统调用可以在==同一进程时间片内被执行==，两次系统调用之间可能因为进程切换而被打断，故fd和对pipe的pp_ref也不能保证同步被写入，影响了管道是否关闭的正确性。\n在MOS中只有syscall_*开头的系统调用函数是原子操作\n​\t_pipe_is_closed函数返回正确结果的条件为\n写端关闭pageref(p[0]) == pageref(pipe) 读端关闭pageref(p[1]) == pageref(pipe) ​\t对于更一般的情况，pageref(p[0]) +pageref(p[1]) = pageref(pipe)，**也就是说pipe的引用次数总比pipe要高。**在close函数中\n1 2 3 4 5 6 static int pipe_close(struct Fd *fd) { // Unmap \u0026#39;fd\u0026#39; and the referred Pipe. syscall_mem_unmap(0, (void *)fd2data(fd)); syscall_mem_unmap(0, fd); return 0; } ​\t先解除pipe映射再解除fd映射，会使pipe引用次数-1先于fd，在两个unmap间隙导致pageref(pipe)=pageref(fd)，这一点可以通过控制fd与pipe的map/unmap顺序解决进程竞争导致的非同步写入问题：使fd的引用次数-1先于pipe，这样即使在两个unmap的间隙，也有pageref(pipe) \u0026gt; pageref(fd)成立。\n​\t==或者说改变map/unmap顺序使得pageref(pipe) \u0026gt; pageref(fd)在非管道关闭时恒成立==\nExercise 6.2 调整pipe_close中的umap顺序\n先解除fd 再解除pipe 1 2 3 4 5 6 static int pipe_close(struct Fd *fd) { // Unmap \u0026#39;fd\u0026#39; and the referred Pipe. syscall_mem_unmap(0, fd); syscall_mem_unmap(0, (void *)fd2data(fd)); return 0; } Exercise 6.3 调整dup函数中的map顺序\n先映射pipe 后映射fd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 int dup(int oldfdnum, int newfdnum) { int i, r; void *ova, *nva; u_int pte; struct Fd *oldfd, *newfd; /* Step 1: Check if \u0026#39;oldnum\u0026#39; is valid. if not, return an error code, or get \u0026#39;fd\u0026#39;. */ if ((r = fd_lookup(oldfdnum, \u0026amp;oldfd)) \u0026lt; 0) { return r; } /* Step 2: Close \u0026#39;newfdnum\u0026#39; to reset content. */ close(newfdnum); /* Step 3: Get \u0026#39;newfd\u0026#39; reffered by \u0026#39;newfdnum\u0026#39;. */ newfd = (struct Fd *)INDEX2FD(newfdnum); /* Step 4: Get data address. */ ova = fd2data(oldfd); nva = fd2data(newfd); /* Step 5: Dunplicate the data and \u0026#39;fd\u0026#39; self from old to new. */ if (vpd[PDX(ova)]) { for (i = 0; i \u0026lt; PDMAP; i += PTMAP) { pte = vpt[VPN(ova + i)]; if (pte \u0026amp; PTE_V) { // should be no error here -- pd is already allocated if ((r = syscall_mem_map(0, (void *)(ova + i), 0, (void *)(nva + i), pte \u0026amp; (PTE_D | PTE_LIBRARY))) \u0026lt; 0) { goto err; } } } } if ((r = syscall_mem_map(0, oldfd, 0, newfd, vpt[VPN(oldfd)] \u0026amp; (PTE_D | PTE_LIBRARY))) \u0026lt;0) { goto err; } return newfdnum; err: /* If error occurs, cancel all map operations. */ panic_on(syscall_mem_unmap(0, newfd)); for (i = 0; i \u0026lt; PDMAP; i += PTMAP) {\tpanic_on(syscall_mem_unmap(0, (void *)(nva + i))); } return r; } 2. Shell shell指“为使用者提供操作界面”的软件，他接受用户的命令然后调用相关的应用程序，MOS实现了CLI shell\n2.1 完善spawn函数 ​\tspawn函数的作用是帮助我们调用文件系统中的可执行文件并执行(初步观察我们的命令就是通过spawn函数运行的，例如输入ls.b，调用可执行文件ls.b)。\nExercise 6.5 spawn\n文件系统打开对应的文件(二进制ELF，*.b) 申请新的进程控制块 将目标程序加载到子进程的地址空间中并为他们分配物理页面 为子进程初始化地址空间 设置子进程的寄存器 将父进程的共享页面映射到子进程的地址空间 设置子进程可执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 int spawn(char *prog, char **argv) { // Step 1: Open the file \u0026#39;prog\u0026#39; (the path of the program). // Return the error if \u0026#39;open\u0026#39; fails. int fd; if ((fd = open(prog, O_RDONLY)) \u0026lt; 0) { return fd; } // Step 2: Read the ELF header (of type \u0026#39;Elf32_Ehdr\u0026#39;) from the file into \u0026#39;elfbuf\u0026#39; using // \u0026#39;readn()\u0026#39;. // If that fails (where \u0026#39;readn\u0026#39; returns a different size than expected), // set \u0026#39;r\u0026#39; and \u0026#39;goto err\u0026#39; to close the file and return the error. int r; u_char elfbuf[512]; /* Exercise 6.4: Your code here. (1/6) */ if ((r = readn(fd, elfbuf, sizeof(Elf32_Ehdr))) != sizeof(Elf32_Ehdr)) { if (r \u0026gt;= 0) { r = -E_NOT_EXEC; } goto err; } const Elf32_Ehdr *ehdr = elf_from(elfbuf, sizeof(Elf32_Ehdr)); if (!ehdr) { r = -E_NOT_EXEC; goto err; } u_long entrypoint = ehdr-\u0026gt;e_entry; // Step 3: Create a child using \u0026#39;syscall_exofork()\u0026#39; and store its envid in \u0026#39;child\u0026#39;. // If the syscall fails, set \u0026#39;r\u0026#39; and \u0026#39;goto err\u0026#39;. u_int child; /* Exercise 6.4: Your code here. (2/6) */ if ((child = syscall_exofork()) \u0026lt; 0) { r = child; goto err; } // Step 4: Use \u0026#39;init_stack(child, argv, \u0026amp;sp)\u0026#39; to initialize the stack of the child. // \u0026#39;goto err1\u0026#39; if that fails. u_int sp; /* Exercise 6.4: Your code here. (3/6) */ if ((r = init_stack(child, argv, \u0026amp;sp)) \u0026lt; 0) { goto err1; } // Step 5: Load the ELF segments in the file into the child\u0026#39;s memory. // This is similar to \u0026#39;load_icode()\u0026#39; in the kernel. size_t ph_off; ELF_FOREACH_PHDR_OFF (ph_off, ehdr) { // Read the program header in the file with offset \u0026#39;ph_off\u0026#39; and length // \u0026#39;ehdr-\u0026gt;e_phentsize\u0026#39; into \u0026#39;elfbuf\u0026#39;. // \u0026#39;goto err1\u0026#39; on failure. // You may want to use \u0026#39;seek\u0026#39; and \u0026#39;readn\u0026#39;. /* Exercise 6.4: Your code here. (4/6) */ if ((r = seek(fd, ph_off)) \u0026lt; 0) { goto err1; } if ((r = read(fd, elfbuf, ehdr-\u0026gt;e_phentsize)) != ehdr-\u0026gt;e_phentsize) { if (r \u0026gt;= 0) { r = -E_NOT_EXEC; goto err1; } } Elf32_Phdr *ph = (Elf32_Phdr *)elfbuf; if (ph-\u0026gt;p_type == PT_LOAD) { void *bin; // Read and map the ELF data in the file at \u0026#39;ph-\u0026gt;p_offset\u0026#39; into our memory // using \u0026#39;read_map()\u0026#39;. // \u0026#39;goto err1\u0026#39; if that fails. /* Exercise 6.4: Your code here. (5/6) */ if ((r = read_map(fd, ph-\u0026gt;p_offset, \u0026amp;bin)) \u0026lt; 0) { goto err1; } // Load the segment \u0026#39;ph\u0026#39; into the child\u0026#39;s memory using \u0026#39;elf_load_seg()\u0026#39;. // Use \u0026#39;spawn_mapper\u0026#39; as the callback, and \u0026#39;\u0026amp;child\u0026#39; as its data. // \u0026#39;goto err1\u0026#39; if that fails. /* Exercise 6.4: Your code here. (6/6) */ if ((r = elf_load_seg(ph, bin, spawn_mapper, \u0026amp;child)) != 0) { goto err1; } } } close(fd); struct Trapframe tf = envs[ENVX(child)].env_tf; tf.cp0_epc = entrypoint; tf.regs[29] = sp; if ((r = syscall_set_trapframe(child, \u0026amp;tf)) != 0) { goto err2; } // Pages with \u0026#39;PTE_LIBRARY\u0026#39; set are shared between the parent and the child. for (u_int pdeno = 0; pdeno \u0026lt;= PDX(USTACKTOP); pdeno++) { if (!(vpd[pdeno] \u0026amp; PTE_V)) { continue; } for (u_int pteno = 0; pteno \u0026lt;= PTX(~0); pteno++) { u_int pn = (pdeno \u0026lt;\u0026lt; 10) + pteno; u_int perm = vpt[pn] \u0026amp; ((1 \u0026lt;\u0026lt; PGSHIFT) - 1); if ((perm \u0026amp; PTE_V) \u0026amp;\u0026amp; (perm \u0026amp; PTE_LIBRARY)) { void *va = (void *)(pn \u0026lt;\u0026lt; PGSHIFT); if ((r = syscall_mem_map(0, va, child, va, perm)) \u0026lt; 0) { debugf(\u0026#34;spawn: syscall_mem_map %x %x: %d\\n\u0026#34;, va, child, r); goto err2; } } } } if ((r = syscall_set_env_status(child, ENV_RUNNABLE)) \u0026lt; 0) { debugf(\u0026#34;spawn: syscall_set_env_status %x: %d\\n\u0026#34;, child, r); goto err2; } return child; err2: syscall_env_destroy(child); return r; err1: syscall_env_destroy(child); err: close(fd); return r; } 2.2 解释shell命令 ​\t我们在user目录下提供了ls.c , cat.c , echo.c等几个用户程序模拟Linux下同名命令(后续Shell挑战性任务可以参考MIT-xv6中其他命令的实现)，当我们输入命令时，Shell程序sh.c调用了spawn函数，使其能够读取相应的可执行文件，并加载到新进程中运行。\n​\t解释shell命令通过parsecmd完成，或者说就是解析输入的字符串。\n如果碰到重定向符号 \u0026lt; | \u0026gt; 读下一个单词，打开这个单词代表的文件，然后将文件内容复制给标准输入或标准输出 如果碰到管道符号| 首先建立管道pipe，然后fork 对于父进程，将管道的写者复制给标准输出 对于子进程，将管道的读者复制给标准输入 Exercise 6.5 parsecmd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 int parsecmd(char **argv, int *rightpipe) { int argc = 0; while (1) { char *t; int fd, r; int c = gettoken(0, \u0026amp;t); switch (c) { case 0: return argc; case \u0026#39;w\u0026#39;: if (argc \u0026gt;= MAXARGS) { debugf(\u0026#34;too many arguments\\n\u0026#34;); exit(); } argv[argc++] = t; break; case \u0026#39;\u0026lt;\u0026#39;: if (gettoken(0, \u0026amp;t) != \u0026#39;w\u0026#39;) { debugf(\u0026#34;syntax error: \u0026lt; not followed by word\\n\u0026#34;); exit(); } // Open \u0026#39;t\u0026#39; for reading, dup it onto fd 0, and then close the original fd. // If the \u0026#39;open\u0026#39; function encounters an error, // utilize \u0026#39;debugf\u0026#39; to print relevant messages, // and subsequently terminate the process using \u0026#39;exit\u0026#39;. /* Exercise 6.5: Your code here. (1/3) */ if ((fd = open(t, O_RDONLY)) \u0026lt; 0) { debugf(\u0026#34;failed to open %s\\n\u0026#34;); exit(); } if ((r = dup(fd, 0)) \u0026lt; 0) { debugf(\u0026#34;failed to duplicate file to \u0026lt;stdin\u0026gt;\\n\u0026#34;); exit(); } close(fd); break; case \u0026#39;\u0026gt;\u0026#39;: if (gettoken(0, \u0026amp;t) != \u0026#39;w\u0026#39;) { debugf(\u0026#34;syntax error: \u0026gt; not followed by word\\n\u0026#34;); exit(); } // Open \u0026#39;t\u0026#39; for writing, create it if not exist and trunc it if exist, dup // it onto fd 1, and then close the original fd. // If the \u0026#39;open\u0026#39; function encounters an error, // utilize \u0026#39;debugf\u0026#39; to print relevant messages, // and subsequently terminate the process using \u0026#39;exit\u0026#39;. /* Exercise 6.5: Your code here. (2/3) */ if ((fd = open(t, O_WRONLY)) \u0026lt; 0) { debugf(\u0026#34;failed to open %s\\n\u0026#34;); exit(); } if ((r = dup(fd, 1)) \u0026lt; 0) { debugf(\u0026#34;failed to duplicate file to \u0026lt;stdout\u0026gt;\\n\u0026#34;); exit(); } close(fd); break; case \u0026#39;|\u0026#39;:; /* * First, allocate a pipe. * Then fork, set \u0026#39;*rightpipe\u0026#39; to the returned child envid or zero. * The child runs the right side of the pipe: * - dup the read end of the pipe onto 0 * - close the read end of the pipe * - close the write end of the pipe * - and \u0026#39;return parsecmd(argv, rightpipe)\u0026#39; again, to parse the rest of the * command line. * The parent runs the left side of the pipe: * - dup the write end of the pipe onto 1 * - close the write end of the pipe * - close the read end of the pipe * - and \u0026#39;return argc\u0026#39;, to execute the left of the pipeline. */ int p[2]; /* Exercise 6.5: Your code here. (3/3) */ if ((r = pipe(p)) \u0026lt; 0) { debugf(\u0026#34;failed to create pipe\\n\u0026#34;); exit(); } if ((*rightpipe = fork()) == 0) { dup(p[0], 0); close(p[0]); close(p[1]); return parsecmd(argv, rightpipe); } else { dup(p[1], 1); close(p[1]); close(p[0]); return argc; } break; } } return argc; } ","permalink":"https://coder0xe.github.io/posts/os-lab6%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"oslab6课下基础\"\u003eOS:lab6课下基础\u003c/h1\u003e\n\u003ch2 id=\"1-管道\"\u003e1. 管道\u003c/h2\u003e\n\u003ch3 id=\"11-初窥管道\"\u003e1.1 初窥管道\u003c/h3\u003e\n\u003cp\u003e​\t管道是一种典型的进程间单向通信的方式，分为有名管道和匿名管道两种，\u003cstrong\u003e匿名管道只能在有公共祖先的进程间使用\u003c/strong\u003e，在MOS中，我们要实现匿名管道。\u003c/p\u003e\n\u003cp\u003e​\t\u003cstrong\u003e管道是一种只存在于内存中的文件\u003c/strong\u003e，在MOS中，父进程调用\u003ccode\u003epipe\u003c/code\u003e函数时会\u003cstrong\u003e打开两个新的文件描述符：一个表示只读端，一个表示只写端\u003c/strong\u003e，两个描述符都映射到同一片内存区域。\u003c/p\u003e\n\u003cp\u003e​\t在\u003ccode\u003efork\u003c/code\u003e的配合下，子进程会复制父进程的两个文件描述符，从而在==\u003cstrong\u003e父子进程间形成了四个(父子各有一读一写)的指向同一片内存区域的文件描述符，父子进程可根据需要关掉自己不用的一个，从而实现单向管道通信。\u003c/strong\u003e==\u003c/p\u003e\n\u003ch3 id=\"12-mos中pipe的使用与实现\"\u003e1.2 MOS中pipe的使用与实现\u003c/h3\u003e\n\u003cp\u003e​\tMOS中\u003ccode\u003epipe\u003c/code\u003e的实现\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e46\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e47\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003epipe\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e pfd[\u003cspan style=\"color:#bd93f9\"\u003e2\u003c/span\u003e]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003eva;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e Fd \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003efd0, \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003efd1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e/* Step 1: Allocate the file descriptors. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003efd_alloc\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003efd0)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003e (r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003esyscall_mem_alloc\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, fd0, PTE_D \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e PTE_LIBRARY)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003egoto\u003c/span\u003e err;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003efd_alloc\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003efd1)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003e (r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003esyscall_mem_alloc\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, fd1, PTE_D \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e PTE_LIBRARY)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003egoto\u003c/span\u003e err1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e/* Step 2: Allocate and map the page for the \u0026#39;Pipe\u0026#39; structure. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tva \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003efd2data\u003c/span\u003e(fd0);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003esyscall_mem_alloc\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, (\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e)va, PTE_D \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e PTE_LIBRARY)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003egoto\u003c/span\u003e err2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003esyscall_mem_map\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, (\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e)va, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, (\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e)\u003cspan style=\"color:#50fa7b\"\u003efd2data\u003c/span\u003e(fd1), PTE_D \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e PTE_LIBRARY)) \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t    \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003egoto\u003c/span\u003e err3;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e/* Step 3: Set up \u0026#39;Fd\u0026#39; structures. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tfd0\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003efd_dev_id \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e devpipe.dev_id;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tfd0\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003efd_omode \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e O_RDONLY;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tfd1\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003efd_dev_id \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e devpipe.dev_id;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tfd1\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003efd_omode \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e O_WRONLY;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#50fa7b\"\u003edebugf\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;[%08x] pipecreate \u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;\u003c/span\u003e, env\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003eenv_id, vpt[\u003cspan style=\"color:#50fa7b\"\u003eVPN\u003c/span\u003e(va)]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e/* Step 4: Save the result. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tpfd[\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003efd2num\u003c/span\u003e(fd0);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tpfd[\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003efd2num\u003c/span\u003e(fd1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eerr3\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#50fa7b\"\u003esyscall_mem_unmap\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, (\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e)va);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eerr2\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#50fa7b\"\u003esyscall_mem_unmap\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, fd1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eerr1\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#50fa7b\"\u003esyscall_mem_unmap\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, fd0);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eerr\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e首先为\u003ccode\u003efd0\u003c/code\u003e和\u003ccode\u003efd1\u003c/code\u003e两个文件描述符分配空间(物理页)\u003c/p\u003e","title":"OS:lab6课下基础"},{"content":"OS理论期末复习 一. 引论 ==1. 批处理系统== 把用户提交的作业成批送入计算机 由作业调度程序自动选择作业运行 目的 缩短作业之间的交接时间 减少处理机的空闲等待，提高系统效率 1.1 联机批处理系统 作业的输入输出由CPU处理 **优点：**监督程序不停地处理各个作业，实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间 不足：在作业输入和结果输出时，主机的高速CPU仍然处于空闲状态，等待慢速的输入输出设备完成工作 1.2 脱机批处理系统 作业的输入输出脱离CPU处理\n**优点：**主机不与慢速的输入输出设备打交道，而是与速度相对较快的磁带机发生关系，缓解了主机与设备的矛盾\n**缺点：**每次主机内存中仅存放一道作业，每当它运行期间发出I/O请求后，高速的CPU处于等待低速的I/O完成状态，CPU空闲\n2. 多道程序系统 **多道程序设计技术：**允许多个程序同时进入内存并运行\n当一道程序因I/O请求暂停时，CPU便立即转去运行另一道程序\n宏观上并行，微观上串行\n**优点：**使CPU得到充分利用，同时也改善I/O设备和内存的利用率，提高了整个系统的资源利用率和系统吞吐量\n单道程序系统：I/O时CPU空闲\n多道程序系统：交替使用CPU\n3. 多道批处理系统 优点： 系统吞吐量大 资源利用率高 缺点： 平均周转时间长 ==不能提供交互能力== 4. 分时系统 多个用户分享使用同一台计算机，多个程序分时共享硬件和软件资源\n多路性：多路连接，宏观上用户共享，微观上分时\n独立性：用户相互不干扰\n及时性：响应时间\n交互性：人机对话\n分时技术：处理机的运行时间分成很短的时间片，轮流分配给各联机作业使用\n5. 实时系统 及时响应\n高可靠性和安全性\n实时信息处理、实时控制\n6. 异常、陷阱和中断 同步异常：执行指令的过程中发生\n系统调用为一种同步异常:自陷指令(trap)\n二.引导 加载BIOS 读取MBR BootLoader 加载内核 \u0026hellip; 三. 内存管理 地址空间：逻辑地址空间\n存储空间：物理地址空间\n1.单道程序的内存管理 静态地址翻译：在程序运行之前就计算出所有物理地址\n优点：\n最简单，单用户、单任务的OS 执行过程中无需进行地址翻译，程序运行速度快 缺点：\n比物理内存大的程序无法加载 资源浪费 2.多道程序的存储管理 分区式分配：把内存分为一些大小相等或不等的分区，每个应用程序占用一个或几个分区\n2.1 固定式分区 当系统初始化时，把存储空间划分为若干个任意大小的区域，然后把这些区域分配给每个用户作业\n**优点：**易于实现，开销小\n缺点：\n内碎片造成浪费 分区总数固定，限制了并发执行的程序数目 数据结构：分区表\n分配方式\n单一队列：大分区小程序 多队列：按程序大小对应分区块排队\n2.2 可变式分区 分区的边界可以移动，分区的大小可变\n优点：没有内碎片\n缺点：产生外碎片\n==外部碎片是造成内存系统性能下降的主要原因==\n消除外碎片：紧凑技术\n内碎片已经被分配给程序，外碎片是没被分配给程序的碎片\n2.3 闲置空间的管理 跟踪内存的使用：位图表示法/链表表示法 2.3.1 位图表示法 为每个分配单元赋予一个字位，用来记录单元是否闲置\n优点\n空间成本固定：不依赖于内存中程序数量 时间成本低 缺点\n没有容错能力 2.3.2 链表表示法 空闲链表\n优点\n有一定容错能力 缺点\n时间成本：链表扫描较慢 空间成本：取决于程序的数量 2.4 回收内存 尽可能合并回收分区上下的空闲分区 2.5 基于顺序搜索的内存分配 首次适应(Fisrt Fit)：从空闲链表的始端开始查找，选择第一个满足请求的空白块 下次适应(Next Fit)：总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去 最佳适应(Best Fit)：找到大小最接近于作业要求的分区 最坏适应(Worst Fit)：为作业选择存储区域时，总是寻找最大的空白区 2.6 基于索引搜索的内存分配 较大系统遍历空闲链表比较慢\n快速适应算法(分类搜索法)：把空闲分区按照容量大小进行分类，经常用到长度的空闲区设立单独的空闲区链表，系统为多个空闲链表设立一张管理索引表。 优点 查找效率高，依据长度寻找能容纳他的最小空闲区链表取下第一块进行分配 缺点 分区归还主存时算法复杂，系统开销大 伙伴系统(二进制伙伴系统)：在分配存储块时将一个大的存储块分裂成两个大小相等的小块 大小为$2^k$ 分配给进程大于或等于所申请尺寸的最小的2的幂次的空闲块 内存释放时，首先考虑将被释放块与其伙伴合并成一个大的空闲块，然后继续合并下去，直到不能合并为止 ==2.7 程序编译和程序段== 编译(compile)：由编译程序将用户源程序编译为若干个目标模块\n链接(linking)：由链接程序将目标模块和对应的库函数连接成可装载模块\n装入(loading)：由装载程序将可装载模块装入内存\n==程序段==\nbss段：存放程序中未初始化的全局变量或静态变量 data段：存放程序中已初始化的全局变量静态变量 text段：存放程序执行代码 ==栈(stack)==\n存放程序局部变量 保存/恢复调用现场 向下生长 ==堆(heap)==\nmalloc/free 向下生长 2.8 ELF可执行文件 2.9 链接 2.10 装载 对于每一个段，根据其在内存中的大小，分配足够的物理页并映射到指定的虚地址上 若ELF中记录的段在内存中大小大于在文件中大小，多出来部分用0填充 未初始化全局变量为0 2.11 页式内存管理 程序：程序是静止的，是存放在磁盘上的可执行文件\n进程：进程是动态的，进程包括程序和程序处理对象，是一个程序对某个数据集的执行过程\n作业：作业是用户需要计算机完成的某项任务\n分页地址结构：页号P+位移量W\n逻辑地址：虚拟页号+页内偏移量\n物理地址：物理页号+页内偏移量\n虚拟页面大小与物理页面大小相等\n地址转换机构：MMU\n一级页表\n逻辑地址空间大，划分的页面多，页表占用的存储空间大\n虚拟页号转换到对应的物理页号 需要访存两次(页表一次，访问数据一次) 两级页表\n给一级页表设置页表 一级页表(页目录) 地址结构：p1 | p2 | offset 二级页表访存次数：三次 2.12 快表TLB 解决页表的访存性能下降问题，建立快表(页表的Cache)\nMMU首先在TLB中查找，若没有则到外部页表查询，然后置换进TLB\n访存：TLB命中情况下：一次Cache+一次内存\n多个进程的标识符：ASID\n2.13 改进页表 2.13.1 哈希页表 建立虚拟页号与物理页号的哈希表，提高查找速度 2.13.2 反置页表 反置页表不是根据进程的逻辑页号来组织，而是依据该进程在内存中的物理页号来组织\n按照进程在内存中的物理页面号来组织，表项的内容是逻辑页号P及隶属进程标志符pid\n反置页表的大小只与物理内存的大小有关\n可以使用哈希表进行优化\n2.14 页共享与保护 页共享：物理页面出现在A和B两个进程的地址空间\n页保护：地址越界保护，在页表中设置保护位\n2.15 分段存储管理 一个段可以定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的，例如代码段、数据段等。\n优点：\n方便编程 信息共享 信息保护 动态增长 动态链接 地址结构：段号+位移量\n==分页的地址空间为一维的，分段的地址空间为二维的==\n对比\n页是信息的物理单位，大小固定 段是信息的逻辑单位，长度不固定 分页活动用户看不见，分段是用户可见的 段页式：先分段，再分页\n2.16 虚拟存储管理 2.16.1 覆盖 节约，时间上扩展\n把一个大的程序划分为一系列的覆盖，每个覆盖是一个独立的程序单位，程序执行时并不要求同时装入主存的覆盖组成一组 缺点：编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度。 2.16.2 交换 借用，空间上扩展\n把暂时不用的某个程序及其数据的部分或全部从主存移到辅存中去，腾出必要的存储空间，接着把指定程序或数据从辅存读到相应的主存中。 2.16.3 ==局部性原理== 程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址局限于一定区域 ==时间局部性==：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内 ==空间局部性==：当前指令和临近的几条指令，当前访问的数据和临近的数据都集中在一个较小区域内 2.16.4 虚拟存储 所有进程一致的地址空间，每个进程都认为自己在独占使用单机系统的存储资源 隔离进程地址访问 缺页中断：进程执行过程中需访问的页面不在物理存储器中，发生缺页中断 ==页面置换算法== ==2.16.5 页面置换策略== 最佳策略(OPT)：从主存中移出永远不再需要的页面，如无这样的页面存在，应选择最长时间不需要访问的页面(理论参考，==无法被实现==)\n先进先出(FIFO)：总选择作业在主存中驻留时间最长的一页淘汰\n最近最久不用的页面置换算法(LRUR)：选择在最近一段时间内最久不用的页面予以淘汰\n改进的FIFO算法：二次机会算法(Second Chance)：如果被淘汰的数据之前被访问过，则给其第二次机会\n每个页面增加一个访问标志位，标识此数据放入缓存队列后是否再次被访问过\n对于队列中最旧的页面\n若其放入队列后没有被再次访问，则立即被淘汰 如果放入队列后被访问过，则移动到FIFO队列头，并清除访问标志位 若所有页面都被访问过，按照FIFO淘汰 改进的FIFO算法：Clock(最近未使用算法NRU，Not Recently Used)，环形队列\n==FIFO类算法命中率比其他算法要低，实际中很少使用==\n==最近最少使用(LRU:Least Recently Used)：局部性原理的合理近似，性能接近最优算法==\n硬件开销比较大 近似实现：设置栈保存当前使用的各个页面的页面号，当进程访问某页面时压入栈顶 老化算法(Aging)：LRU的简化\n为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入\n选择寄存器值小的移出\n2.16.6 Belady现象(期中考过) 在使用FIFO算法作为缺页置换算法时，分配的页面增多，缺页率反而提高\n理想的情况：缺页率随页框数增加而下降\nBelady现象\n2.16.7 工作集与驻留集 进程的==工作集(Working Set)==：当前正在使用的页面的集合\n进程的==驻留集==：每个进程驻留在内存的页面集合(分配的物理页)\n工作集策略：依据进程在过去的一段时间内访问的页面来调整常驻集大小\n工作集可以用一个二元函数$WS(k,t)$表示 $k$表示窗口尺寸 $t$表示执行时刻 工作集为$[t-k,t]$时间段内访问的页面的集合 驻留集的管理：系统应当为每个活跃进程分配多少个页框\n分配给每个活跃进程的页框数越少，同时驻留内存的活跃进程数就越多，进程调度就绪进程的概率就越大，但是将导致缺页中断率增大 全局置换算法：程序无法控制自己的缺页率，在内存中的页面不仅取决于该进程的页面走向，也取决于其他进程\n可变分配策略+局部置换：可增加或减少分配给每个活跃进程的页框数，当进程的页框全部用完，而需要装入一个新的页面，==系统在该进程的当前驻留集中选择一个页面换出内存==\n==抖动问题(期中考过)==\n随着驻留内存的进程数目增加，处理器利用率先是上升，然后下降 原因是：每个进程的常驻集不断减小，缺页率不断上升，频繁发生缺页中断 选择适当的进程数目，平衡并发水平和缺页率 ==消除抖动==： 局部置换策略 工作集算法 预留部分页面 挂起若干进程 2.16.8 写时复制技术 实验中的理解已经足够 ==2.17 页目录自映射== 一个进程的4GB地址空间被划分为4GB/4KB=1M页，即需要1M个页表项来记录逻辑-物理关系\n每个页表项需要4B，1M个页表项需要4MB，即整个页表占用的地址空间大小为4MB\n4MB页表需要1024个页面存储，每一页中存储1024个页表项\n一个页表项对应4KB内存，则个页表页对应4MB内存\n页目录占一页空间，有1024项，每一项指向一个页表页，==则必有一项指向自己，即页目录也是上述4MB页表中的一页==\n一个页目录项指向一个页表页，映射到4MB物理内存\n假设进程页表的基地址为$PT_{base}$，几个经典计算\n==页目录基地址$PD_{base}$​：页目录中第一项映射第一个页表页==\n$PD_{n} : 10bits | PT_n : 10bits | offset:12bits$\n$PD_{base}=PT_{base}+(PT_{base} \u0026raquo; 12)*4=PT_{base}+PT_{base}\u0026raquo;10$\n解释：映射第一个页表页的页表项编号为PT_base \u0026raquo; 12，也就是页目录项的编号，每个PDE大小为4B，基地址+偏移量\n==映射页目录自身的页目录项==\n$页目录基地址PD_{base}=PT_{base}+PT_{base}\u0026raquo;10$\n$PDE_{self-mapping}=PT_{base}+(PD_{base}\u0026raquo;12)*4=PT_{base}|PT_{base}\u0026raquo;10|PT_{base}\u0026raquo;20$\n==根本思想：计算出映射到该页表页的是第几个页表项==\n四.进程管理 1. 进程与线程 并发：有两个活动a1,a2，如果在某一指定的时间t，无论a1和a2是在同一处理机上还是在不同的处理机上执行，只要a1和a2都处在各自的起点和终点之间的某一处，即称为并发的\n并行：两个程序在同一时间度量下运行在不同的处理机上\n竞争：多个进程在读写一个共享数据时，结果依赖于他们执行的相对时间，这种情形叫竞争\n==1.1 Bernstein条件== $R(S_{i})$：Si的读子集 $W(S_i)$：Si的写子集 两个进程可并发的条件为 R(S1)^W(S2)=null W(S1)^R(S2)=null W(S1)^W(S2)=null ==或者说可并发条件为除了读读之外交集都为空== 1.2 进程 进程是一个程序及其数据在处理机上顺序执行所发生的活动\n==进程是系统进行资源分配和调度的一个基本单位==\n动态性：==程序是静态实体，进程具有生命周期==\n并发性：多个进程在内存中同时运行\n独立性：==传统OS中==，进程是独立运行的基本单位\n异步性\n进程的结构\n程序段、数据段、进程控制块PCB 1.3 进程控制 ==由内核来实现==\n进程控制的实现——原语：由若干条指令所组成的指令序列，来实现某个特定的操作功能，连续不可被分割，必须在内核态执行\nfork()执行一次，父子进程两个返回值\n==进程的状态(期中考过)==\n就绪状态：已经获得所需资源，分配CPU就可运行 执行状态：占用CPU运行，进程数小于等于CPU数目 阻塞状态：正在执行的进程，由于发生某种事件而无法执行，放弃CPU处于暂停状态 ==状态转换==\n就绪-\u0026gt;运行：调度程序选择进程运行 运行-\u0026gt;就绪：运行进程用完了时间片，或因为高优先级进程处于就绪状态而中断 运行-\u0026gt;阻塞：当进程需要的资源必须等待 阻塞-\u0026gt;就绪：所等待的事件发生 进程控制块PCB\n进程标识符：每个进程唯一的标识符 程序和数据地址 现行状态 现场保留区：trapframe寄存器等等 优先级 父进程 同步互斥机制 \u0026hellip; ==进程上下文切换vs陷入内核：陷入内核开销更小==\n进程上下文切换：\n调度器执行 保存进程执行断点 保存执行现场 切换内存映射 陷入内核\n中断/异常/trap 保存执行现场 ==用户态到内核态的切换(mode switch)消耗要比进程上下文切换(Process Context Switch)消耗小得多==\n1.4 线程 进程：资源拥有者+可执行单元\n线程：可执行单元\n优点\n减小进程切换开销 提高进程内的并发程度 共享资源 ==基本上不拥有资源，和同进程的线程共享进程拥有的所有资源==\n==进程是资源分配的基本单位，线程是处理机调度的基本单位==\n用户级线程：线程在用户空间，通过用户库模拟thread\n优点 上下文切换快 ==线程切换与内核无关== ==线程调度由应用决定，容易进行优化== 缺点： 系统调用会引起阻塞，因为内核只能看到一个进程，所以会阻塞所有相关的线程 内核只能将处理器分配给进程，即使有多个处理器也无法实现多线程并行执行 内核级线程：kernel有好几个分身，一个分身处理一件事\n优点 阻塞发生在线程级别 内核可以在多个处理器上调度一个进程的多个线程 缺点 线程切换需要内核参与 ==切换效率较低== 线程安全：对象\n多个线程访问同一个对象时，如果不用考虑线程的调度和交替执行，也不需要进行额外的同步，或者调用方进行任何操作，行为都可以获得正确的结果 可重入：代码\n即当该副程序正在运作时，执行线程可以再次进入并执行它，仍然可得到符合设计时所预期的结果 ==可重入不一定线程安全，线程安全不一定可重入==\n1.5 同步与互斥 wty课件例题\n**临界资源：**我们将一次仅允许一个进程访问的资源称为临界资源\n**临界区：**访问临界资源的代码\n互斥：某一资源同时只允许一个访问者对其进行访问，无法限制访问顺序，无序访问\n同步：在互斥的基础上通过其他机制实现对资源的有序访问\n==基于忙等待的互斥方法（暂时跳过，期中考过）==\n浪费CPU时间 1.6 信号量机制 必须置一次且只能置一次初值\n只能由P、V操作改变\nP操作分配资源\n无法分配则阻塞(wait)：避免忙等 V操作释放资源\n有等待进程则唤醒(signal) S.value为正表示资源个数\nS.value为负表示等待进程个数\n信号量实现互斥：S=1\n1 2 3 P(S) // 临界区 V(S) 信号量实现同步：S=0\n1 2 3 4 5 6 7 8 9 process1(){ P(s) // code } process2(){ //code V(s) } 前驱关系\n有限并发：S=n\n多进程同步原语(Barriers)\ncount到达汇合点的线程数 信号量集：同时需要多个资源时的信号量操作\nAND型信号量集：将进程需要的所有共享资源一次分配给他，使用完后一起释放(每种资源分配一个) SP(S1,S2,\u0026hellip;,Sn) 一般信号量集：Si的测试值为ti，低于ti不进行分配，占用值为di SP(S1,t1,d1,\u0026hellip;,Sn,tn,dn) 1.7 基于管程的同步互斥 把分散的临界区集中起来，为每个可共享资源设计一个专门机构来统一管理各进程对该资源的访问\n==管程是高级同步原语==\n互斥：任意时刻，管程中只能有一个活跃进程\n管程中的特殊类型变量：条件变量\n每个条件变量表示一种等待原因，==并不取具体数值== 条件变量与信号量的区别\n条件变量的值不可增减，信号量可增减\nwait操作一定会阻塞当前进程，P操作只有当信号量值小于0才会阻塞\n没有wait线程则signal会丢失，V操作不会丢失\n当一个进入管程的进程执行等待操作时，应当释放管程的互斥权，后面进入的进程执行唤醒，则管程中有两个同时处于活动状态的进程\nsignal(x)时如何避免管程中有两个活跃进程 Hoare：执行signal的进程等待，直到被释放进程退出管程 Mesa：被释放进程等待，直到执行signal的进程退出管程 Hansen：执行signal的进程立即退出管程 1.8 进程间通信 IPC 低级通信：传递状态和整数值\n==高级通信：管道，共享内存，消息系统==\n1.8.1 无名管道 半双工：==数据只能向一个方向流动==，双方通信建立两个管道\n==只能用于父子进程或兄弟进程之间==\n单独构成独立的文件系统，管道对于管道两端的进程而言是一个文件\n数据读出和写入：从末尾写入，从头部读出(数据单向流动的原因)\n1.8.2 有名管道(FIFO) ==名字打破了无名管道只能在有亲缘关系的进程间通信的限制，不相关进程可以交换数据== FIFO提供了路径名与之关联，访问路径通过FIFO通信 以FIFO文件的形式存在于文件系统中 从末尾写入，从开始读出 1.8.3 消息传递 系统调用send/receive 阻塞调用/非阻塞调用 ==内核消息缓冲区== 1.8.4 共享内存 ==最有效的进程间通信机制，最快== 同一块物理内存被映射到A,B各自的进程地址空间 2.经典同步互斥问题 课件\u0026amp;作业 3. 进程调度 高级调度：作业调度，从工作流程角度对每个作业进行调度\n中级调度：从存储器资源的角度将进程的部分或全部换出到外存上\n==低级调度：从CPU资源的角度对进程/线程进行调度==\n抢占式 非抢占式 何时进行切换 用户调用 陷阱 中断 ==进程切换的步骤== 保存处理器上下文，程序计数器和其他寄存器 用新状态和其他相关信息更新正在运行进程的PCB 把进程移到合适的队列：就绪/阻塞 选择另一个要执行的进程 更新被选中进程的PCB 从被选中进程中重装入CPU上下文 ==3.1 调度性能准则== ==周转时间：作业从提交到完成所经历的时间== 响应时间：用户输入一个请求到系统给出首次响应的时间(分时系统) 截止时间：开始截止时间和完成截止时间(实时系统) 优先级 公平性 ==吞吐量：单位时间内完成的作业数(批处理系统)== 作业/小时 ==平均周转时间不是吞吐量的倒数，并发执行的作业在时间上可以重叠== 处理机利用率：忙碌时间/总时间 各种资源的均衡利用 ==3.2 批处理系统中常用的调度算法== 有关指标\n==$吞吐量=\\frac {作业数} {总执行时间}$ 即单位CPU时间完成的作业量==\n==$周转时间=完成时刻-提交时刻(小时为单位)$==\n$平均周转时间=\\frac {作业周转时间之和} {作业数}$\n==$带权周转时间=\\frac {周转时间} {执行时间}$==\n$平均带权周转时间=\\frac {作业带权周转时间之和} {作业数}$\n有关调度方式\n抢占式：就绪队列中有优先级高于当前运行进程优先级的进程，立即进行进程调度\n非抢占式：一个进程一直占用处理器知道时间片用完或I/O等原因进入阻塞状态才让出处理器\n3.2.1 FCFS 先来先服务 按照作业提交或进程变为就绪状态的先后次序分派CPU ==非抢占式== 有利于长作业，不利于短作业 有利于CPU繁忙的作业，不利于I/O繁忙的作业 3.2.2 SJF 短作业优先 对预计执行时间短的作业优先分派处理机 通常后来的短作业==不抢占==正在执行的作业 优点 ==改善平均周转时间和平均带权周转时间==，缩短作业等待时间 提高系统吞吐量 缺点 对长作业不友好，饥饿现象 没有优先级划分 3.2.3 SRTF 最短剩余时间优先 ==抢占式== 一个新就绪的进程如果比当前运行进程具有更短的完成时间，则系统抢占当前进程，选择新就绪的进程运行 长任务饥饿现象 3.2.4 HRRF 最高响应比优先 ==非抢占式==\n每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP，然后选择最大的投入运行\n$RP=\\frac {已等待时间+要求运行时间} {要求运行时间}$\n==3.3 交互式系统调度算法== 3.3.1 RR 时间片轮转算法 ==抢占式==\n所有进程按照FCFS原则排成队列，每次调度将CPU分派给队首进程，让其执行一个时间片，一个时间片执行完后，发生时钟中断，将当前进程送到就绪队列末尾\n系统的响应时间\n$T=N(进程数目)*q(时间片)$\n数目越多时间片越小\n3.3.2 PS 优先级算法 平衡进程对响应时间的要求\n静态优先级：创建进程时就确定，直到进程终止前都不改变\n动态优先级：创建进程时赋予的优先级，在进程运行过程中可以自动改变，获得更好的调度性能\n3.3.3 MLQ 多级队列算法 引入多个就绪队列，通过对各队列的区别对待，到达综合的调度目标 不同队列有不同的优先级，时间片长度，调度策略 优先执行高优先级，高优先级队列为空再执行低优先级 3.3.4 RRMF 多级反馈队列算法 设置多个就绪队列，分别赋予不同的优先级，每个队列执行时间片的长度也不同，优先级越低时间片越长\n新进程进入内存后，先投入队列1的末尾，按时间片轮转算法调度，若按队列1的一个时间片未能执行完，则降低优先级投入到队列2的末尾，同样按时间片轮转算法调度\u0026hellip;降低到最后的队列，则按照FCFS算法调度直到完成。\n当较高优先级的队列为空，才调度较低优先级队列中的进程执行，若进程执行时有新进程进入较高优先级的队列，则==抢先==执行新进程，并把被抢先的进程投入到原队列末尾\n3.3.5 优先级倒置 问题背景：有三个进程 taskA taskB taskC 优先级依次降低\ntaskA和taskC共享临界资源，但是由于taskB优先级比taskC高，taskB抢占处理机，这样C得不到处理，优先级最高的A也被阻塞\n==解决关键：提高C优先级，不允许B抢占CPU==\n优先级置顶：给C最高的优先级，A也抢不过来 缺点：如果临界区较长，则A仍会等待很长的时间 优先级继承：C继承A的优先级 3.4 实时系统调度算法 实时系统是一种时间起主导作用的系统，计算机必须在一个确定的时间范围内做出反应 ==抢先式调度== 快速中断响应：中断处理时间尽量短 实时系统问题描述：\n假设一任务集S={t1,t2,\u0026hellip;tn}，周期分别为T1,T2,\u0026hellip;,Tn，执行时间分别为C1,C2,..Cn\n截止周期为D1,D2,\u0026hellip;,Dn通常Di=Ti\n所有的任务都是周期性的(Ti)，必须在时限Di内完成\n==$CPU利用率 U= \\Sigma {\\frac {C_i} {T_i}}$​==\n3.4.1 静态表调度算法 对所有周期性任务进行分析预测，==事先确定一个固定的调度方案== 无任何计算，无灵活性 3.4.2 RMS 单调速率调度 (2106被拷打过) 优先级静态固定分配：优先级与周期成反比，周期越短优先级越高，优先级越高的任务先被调度，优先级相同随机调度\n==抢占式，静态优先级：最优静态优先级调度算法==\n3.4.3 EDF 最早截止期优先 任务的绝对截止时间越早优先级越高，优先级越高先被调度(动态优先级)\n3.5 多处理机调度(略) 4. 死锁 一组进程中，每个进程都无限等待被该组进程中其他进程所占有的资源 ==4.1 死锁发生的四个必要条件== 互斥条件：进程对分配到的资源进排他性使用\n请求且占有条件：进程已经占有至少一个资源，但又提出新的请求，但该资源已经被其他进程占有，此时进程阻塞，且对已获得的资源保持不放\n不可剥夺条件：进程已经获得的资源在使用完之前不能被剥夺\n==环路等待条件==：发生死锁时，必定存在一个“进程-资源”的环形链，或者说循环等待条件\n{P0,P1,..Pn}中P0等待P1的资源，P1等待P2\u0026hellip;\n4.2 死锁预防 ==排除死锁的静态策略==\n打破互斥条件：有些资源不允许被同时访问\n打破申请且占有条件：实行资源预先分配策略，只有系统能够满足当前全部资源请求时，才一次性将所申请的资源分配给该进程，否则不分配\n打破不可剥夺条件：允许进程从占有者处强行夺取\n打破循环等待条件：实行资源有序分配策略，资源事先分类编号，按号分配，进程占用了小号资源才申请大号资源，例如多层锁的顺序性\n1 2 3 P(mutex1); P(mutex2); //... 4.3 死锁避免 ==排除死锁的动态策略==\n安全序列：一个进程序列\u0026lt;P1,P2,...,Pn\u0026gt;是安全的，是指对于每一个进程Pi，他需要的附加资源可以被系统中当前可用资源加上所有进程Pj(j\u0026lt;i)当前占有的资源之和满足，则进程序列是一个安全序列\n安全状态：系统存在一个安全序列(则所有进程均可顺利完成)\n==系统进入不安全状态也不一定会死锁，死锁一定处于不安全状态==\n==4.3.1 银行家算法== n为进程数量，m为资源类型数量\n可利用资源向量Available：m维向量\n最大需求矩阵Max：n*m矩阵\n分配矩阵Allocation：n*m矩阵\n需求矩阵Need：n*m矩阵\n进程的请求向量Request\n系统试探部分分配\n1 2 3 Available = Available - Requesti; Allocation = Allocation + Requesti; Needi = Needi - Requesti; 每次分配需要检查安全状态(请求向量不一定等于Need，部分分配)，利用安全性算法(核心)，能否找到安全序列\n==4.3.2 安全性算法== ==保证分配的资源数=Need==\n工作向量Work：系统可提供给各进程运行继续使用资源数目，初始为Available\n完成向量Finish：表示系统是否有足够的资源分配给进程，使之运行完成\n初始时Finish[i]=false 有足够的资源分配给进程使之运行完成后Finish[i]=true 进程获得资源并运行完成后，释放出分配给他的资源\nWork += Allocation Finish[i] = true 再不断寻找下一个能完成分配的进程，最后如果有所进程的Finish[i]=true则系统处于安全状态，否则处于不安全状态\n表格模版\nWork Need Allocation Finish 4.4 死锁检测 ==4.4.1 资源分配图== 圆圈表示进程，矩形表示一类资源，资源中的小圈代表每个资源 请求边：从进程指向资源 分配边：从资源指向进程 4.4.2 检测死锁 资源分配图中有环路不一定存在死锁 封锁进程：某个进程由于请求了超过了系统中现有的未分配资源数目的资源，而被系统封锁的进程 资源分配图的化简方法：假设图中存在一个进程Pi，Pi为非封锁进程 Pi有请求边时，将请求边变为分配边 一旦所有资源都得到满足，Pi释放所有资源(Pi此时只有分配边)，删去这些分配边 Pi此时为孤立点 反复进行 ==死锁定理==：资源分配图不可完全化简：不能使所有进程都成为孤立节点 4.5 死锁解除 撤销进程 剥夺资源 五.输入输出系统 1. I/O设备分类 低速、中速、高速 ==块设备、字符设备== 独占设备、共享设备、虚拟设备 2 .I/O控制方式 2.1 轮询方式 应用程序提出读数据请求 驱动程序检查设备状态 状态正常则发出相应的控制命令 不断测试设备是否完成了这次执行过程，轮询 完成操作 缺点：CPU不断查询设备状态来检查是否完成，浪费CPU时间 2.2 中断驱动方式 优点 在外设进行数据处理时，CPU不必等待，继续执行其他程序，提高了CPU利用率 外设准备好数据给CPU发中断，可以将外设和CPU视作并行执行 ==具有异常事件处理能力== 缺点 每次输入/输出一个数据都要中断CPU，多次中断浪费CPU时间，==只适合数据传输率较低的设备== ==每个数据传送完成后中断CPU== 中断处理陷入内核 2.3 直接存储访问方式(DMA) 程序设置DMA控制器中的若干寄存器值：内存始址、传送字节数 DMA控制器完成内存与外设的成批数据交换 操作完成后，DMA控制器向CPU发出中断 优点 CPU只干预I/O开始与结束，进行成批数据读写 ==适合传输数据块== ==适合高速设备== 缺点 数据传输方向、地址、长度等由CPU设置占用CPU时间 每个设备占用一个DMA控制器，设备增加时新增DMA控制器 2.4 I/O通道控制方式 I/O通道是专门负责输入输出的处理器，独立于CPU 执行由通道指令组成的通道程序，进行复杂I/O控制 优点： 执行一个通道程序可以完成几组I/O操作，与DMA相比，减少CPU干预 同时控制多种设备 3. 缓冲技术 匹配CPU与外设的不同处理速度，减少CPU中断次数，提高CPU与I/O设备之间的并行性\n3.1 单缓冲 一个缓冲区，CPU与外设轮流使用 3.2 双缓冲 两个缓冲区，CPU和外设都可以连续处理而无需等待对方 CPU和外设速度相近 3.4 环形缓冲 CPU和外设的处理速度可以相差较大 3.5 缓冲池 空闲缓冲区、输入缓冲区、输出缓冲区 关于缓冲区计算：采用画条形图的方式解决\n完整画出一个执行流程，观察可以并行的部分并在图中进行“遮盖“\n去除可并行阶段之后的图即为“优化时间”，或者说近似的平均时间\n可认为每次都按照优化时间运行，最后加上没办法优化的尾巴(最后一次并行部分不能得到优化)\n关于单缓冲并行部分\n磁盘放到缓冲区，缓冲区放到内存，必须顺序执行 ==CPU计算可以和磁盘放到缓冲区并行，不能和缓冲区放到内存并行(会改变计算数据)== 关于双缓冲区并行部分\nCPU计算+内存读入与磁盘读入并行 ==单缓冲每块数据时间：max(T,C)+M C为并行段==\n==双缓冲每块数据时间：max(T,C+M) M+C为并行段==\n==或者说并行部分的最大值+非并行部分==\n==总时间=n*每块时间+并行部分时间==\n六.磁盘存储管理 1.磁盘结构 扇区 磁道 柱面 每个磁盘有两个面，每个面都有一个磁盘 ==2.磁盘访问时间== 2.1 寻道时间 把磁头从当前位置移动到指定磁道上所经历的时间 启动磁盘的时间S与磁头移动n条磁道所花费的时间之和 $T_s=m*n+s$ 2.2 旋转延迟时间 平均旋转延迟时间为旋转一圈周期的一半 设转速为r(单位为Rounds Per Second) 平均旋转延迟时间为$T_r=\\frac 1 {2r}$ 2.3 传输时间 传输时间是指把数据从磁盘读出或者向磁盘写入数据所经历的时间 与每次读写的字节数b，旋转速度r，以及磁道上的字节数N有关 计算方法为：转的圈数*每圈周期 $T_t = \\frac b n * \\frac 1 r = \\frac b {rn}$​ 2.4 总访问时间 寻道时间+旋转延迟时间+传输时间 ==3. 磁盘调度算法== 3.1 FCFS 请求到达先后次序服务 3.2 SSTF 最短寻道时间优先 优先选择距当前磁头最近的访问请求进行服务 3.3 SCAN扫描算法 按照一个方向移动，移动过程中对遇到的访问请求进行服务 判断该方向上是否还有访问请求，如果有则继续扫描，否则改变移动方向 这是课件上的表述，但这实际上是LOOK算法，正常的SCAN是要扫描到头的。。。 3.4 C-SCAN 循环扫描算法 移动到最后一个柱面后，立即带动读写磁头返回0号柱面 4. RAID 七.文件系统 略 重在计算 文件大小：直接索引+简介索引 访问磁盘次数：具体问题具体分析 ：文件组织方式有关 ","permalink":"https://coder0xe.github.io/posts/os%E7%90%86%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","summary":"\u003ch1 id=\"os理论期末复习\"\u003eOS理论期末复习\u003c/h1\u003e\n\u003ch2 id=\"一-引论\"\u003e一. 引论\u003c/h2\u003e\n\u003ch3 id=\"1-批处理系统\"\u003e==1. 批处理系统==\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e把用户提交的作业\u003cstrong\u003e成批\u003c/strong\u003e送入计算机\u003c/li\u003e\n\u003cli\u003e由作业调度程序自动选择作业运行\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e目的\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e缩短作业之间的交接时间\u003c/li\u003e\n\u003cli\u003e减少处理机的空闲等待，提高系统效率\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"11-联机批处理系统\"\u003e1.1 联机批处理系统\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e作业的输入输出由CPU处理\u003c/li\u003e\n\u003cli\u003e\u003cimg alt=\"image-20240603200219167\" loading=\"lazy\" src=\"/img/image-20240603200219167.png\"\u003e\u003c/li\u003e\n\u003cli\u003e**优点：**监督程序不停地处理各个作业，实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不足\u003c/strong\u003e：在作业输入和结果输出时，主机的高速CPU仍然处于空闲状态，等待慢速的输入输出设备完成工作\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"12-脱机批处理系统\"\u003e1.2 脱机批处理系统\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e作业的输入输出脱离CPU处理\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240603200518486\" loading=\"lazy\" src=\"/img/image-20240603200518486.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240603201014462\" loading=\"lazy\" src=\"/img/image-20240603201014462.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e**优点：**主机不与慢速的输入输出设备打交道，而是与速度相对较快的磁带机发生关系，缓解了主机与设备的矛盾\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e**缺点：**每次主机内存中仅存放一道作业，每当它运行期间发出I/O请求后，高速的CPU处于等待低速的I/O完成状态，CPU空闲\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-多道程序系统\"\u003e2. 多道程序系统\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e**多道程序设计技术：**允许多个程序同时进入内存并运行\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e当一道程序因I/O请求暂停时，CPU便立即转去运行另一道程序\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e宏观上并行，微观上串行\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e**优点：**使CPU得到充分利用，同时也改善I/O设备和内存的利用率，\u003cstrong\u003e提高了整个系统的资源利用率和系统吞吐量\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e单道程序系统：I/O时CPU空闲\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240603201620364\" loading=\"lazy\" src=\"/img/image-20240603201620364.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e多道程序系统：交替使用CPU\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240603201647414\" loading=\"lazy\" src=\"/img/image-20240603201647414.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-多道批处理系统\"\u003e3. 多道批处理系统\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e优点：\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e系统吞吐量大\u003c/li\u003e\n\u003cli\u003e资源利用率高\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缺点：\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e平均周转时间长\u003c/li\u003e\n\u003cli\u003e==\u003cstrong\u003e不能提供交互能力\u003c/strong\u003e==\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4-分时系统\"\u003e4. 分时系统\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e多个用户分享使用同一台计算机，多个程序分时共享硬件和软件资源\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240603202224263\" loading=\"lazy\" src=\"/img/image-20240603202224263.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e多路性：多路连接，宏观上用户共享，微观上分时\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e独立性：用户相互不干扰\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e及时性：响应时间\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e交互性：人机对话\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e分时技术：处理机的运行时间分成很短的时间片，轮流分配给各联机作业使用\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"5-实时系统\"\u003e5. 实时系统\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e及时响应\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e高可靠性和安全性\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e实时信息处理、实时控制\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"6-异常陷阱和中断\"\u003e6. 异常、陷阱和中断\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240603203445951\" loading=\"lazy\" src=\"/img/image-20240603203445951.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e同步异常：执行指令的过程中发生\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e系统调用为一种同步异常:自陷指令(trap)\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"二引导\"\u003e二.引导\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e加载BIOS\u003c/li\u003e\n\u003cli\u003e读取MBR\u003c/li\u003e\n\u003cli\u003eBootLoader\u003c/li\u003e\n\u003cli\u003e加载内核\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"三-内存管理\"\u003e三. 内存管理\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e地址空间：逻辑地址空间\u003c/p\u003e\n\u003cp\u003e存储空间：物理地址空间\u003c/p\u003e","title":"OS理论期末复习"},{"content":"OS第六次理论作业 分析磁盘访问数据的时间。假设磁盘请求以柱面10、35、20、70、2、 3 和 38 的次序进入磁盘驱动器。寻道时磁头每移动一个柱面需要 5ms，以下各算法所需的寻道时间是多少： （1） 先来先服务 （2） 最短寻道时间优先 （3） SCAN算法 （4） LOOK算法 说明：假设以上三种情况磁头初始位置为15。对于（3）和（4）， 磁头 当前向大柱面号方向运行，磁盘最大柱面号为85。 寻道时间：是把磁头从当前位置移动到指定磁道上所经历的时间\n该时间是启动磁盘的时间s与磁头移动n条磁道所花费的时间之和\nTs = m * n + s\n先来先服务：\n$5*(5+25+15+50+68+1+35)=995ms$ 最短寻道时间优先：\n这里起始位置是15，距离10和20距离相等\n若首先访问10，序列为：$15,10,3,2,20,35,38,70$\n$5*(5+7+1+18+15+3+32)=405ms$​\n若首先访问20，序列为：$15,20,10,3,2,35,38,70$\n$5*(5+10+7+1+33+3+32)=455ms$\nSCAN电梯算法\n序列为：$15,20,35,38,70,85,10,3,2$ $5*(5+15+3+32+15+75+7+1)=765ms$ LOOK算法\n序列为：$15,20,35,38,70,10,3,2$ $5*(5+15+3+32+60+7+1)=615ms$ 在I/O系统中引入缓冲区的主要目标是什么？某文件占8个磁盘块， 现要把该文件的磁盘块逐个读入主存缓冲区，并送用户区进行分析。一个缓冲区与磁盘块大小相等。把一个磁盘块读入缓冲区的时间为 100μs，缓冲区数据传送到用户区的时间是50μs，CPU对一块数据 进行分析的时间为50μs。分别计算在单缓冲区和双缓冲区结构下， 分析完该文件的时间是多少？ 在I/O系统中，CPU计算速度较快，而外设I/O速度较慢，为了解决CPU与外设速度不匹配的问题，提高CPU的利用率，减少CPU的忙等状态，设计了缓冲区\n使用单缓冲区：第一块磁盘读入缓冲区的时间为100us，而后的磁盘读入和CPU进行分析的50us可以并行执行，对过程进行简单分析，第一块磁盘读入到传送到用户区：150us，此时CPU对第一块数据进行计算，并行地，第二块磁盘开始读入，需要50+50+50完成对第二块磁盘的计算，后边的磁盘同理。即第一块磁盘从读入到完成分析需要200us,后边每一块需要150us，总体$150*7+200=1250us$\n使用双缓冲区：CPU和I/O设备分别使用一块缓冲区，一块缓冲区由I/O设备进行磁盘块读入后将数据传送到CPU并由CPU进行分析，并行地，另一个缓冲区进行磁盘块读取，即第一块磁盘需要200us，后边每块磁盘需要100us，总体$200+100*7=900us$\n请结合操作系统课所学习的内容总结从哪些方面可以提高文件系统 的性能。 可以采用目录项分解、当前目录、磁盘碎片整理、块高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、RAID等技术 简述文件控制块（FCB-File Control Block）中所管理的主要信息 基本信息：文件名、物理位置、文件逻辑结构、文件物理结构 访问控制信息：文件所有者、访问权限 使用信息：创建时间、上一次修改时间、当前使用信息 在文件系统中，访问一个文件f时首先需要从目录中找到与f对应 的目录项。假设磁盘物理块的大小为1KB，一个目录项的大小为128 字节，文件的平均大小为100KB。该 文 件 系 统 的 目 录 结 构 如 下图所示。 假定不考虑磁盘块的提前读和缓存等加速磁盘访问技术。 请回答以下问题： （1） 按照当前的目录结构，且采用串联文件方式对数据块进行组织，并且根目录的目录项已读入内存中。如果目标文件f 在第三级目录下， 且其对应的第三级目录的目录项可以一次从磁盘读出，访问文件f中的 一个块平均需要访问几次磁盘？ （2） 如果采用i节点的方法来构建文件目录，假定文件名占14个字 节，i节点的指针占2个字节。如果仅采用直接索引，每个第三级目录 下的文件数不超过50个，且根目录的i节点已读入内存，访问第三级 目录下的一个文件的一个块平均需要访问几次磁盘？ （3） 假设该文件系统的空间最大容量为16ZB(1ZB=$2^{70}$B)。如 果 文 件 的 FCB 中包括512字节的索引区，且允许采用一级索引进行组织，那么该 文件系统支持的最大文件是多少字节？ 第三级目录在usr2下，根目录的目录项已在内存，因此可以直接读取到对应usr2的根目录项，进而需要访问磁盘读取usr2目录的内容(d0-d127的目录项)，每个目录项的大小为$2^7B$，每个磁盘可以放8个目录项，故要读取128个目录项需要访问16次磁盘，平均需要访问$(1+16)/2=8.5$次磁盘。若要读取第三级目录的内容(对应目标文件f的目录项)，可以一次从磁盘中读出。文件占用的磁盘块数为100块，按照串联方式进行访问，访问一个块平均需要访问磁盘$(1+100)/2=50.5$次。故总共需要$8.5+1+50.5=60$​次\n一个目录项占16个字节，因此一个磁盘块可以放64个目录项。\n读取根目录的内容需要读取一次磁盘：根目录i节点已经读入磁盘，根目录下只有三个目录项，可以一次读取 读取usr2的inode需要读取一次磁盘：从对应usr2的目录项中可获得usr2的inode号，进而通过读取磁盘可获得usr2的inode 读取usr2目录的内容(d0-d127的目录项)需要读取1.5次磁盘：读取整个第三级目录所对应的目录项需要访问磁盘$128/64=2$次，因此平均需要$(1+2)/2=1.5$次 读取第三级目录的inode需要读取一次磁盘 读取第三级目录的内容需要读取一次磁盘：由于第三级目录下的文件不超过50个，可以读取一次磁盘将全部文件目录项取出 读取文件的inode需读取一次磁盘 读取文件的一个块需要读取一次磁盘：采用直接索引，根据inode可以直接读取磁盘块 $1+1+1.5+1+1+1+1=7.5$次 文件系统可以存储的数据块数为$\\frac {162^{70}} {2^{10}}=2^{64}$块，表示这些磁盘块需要8字节(64位)，故索引区可存放512/8=64个磁盘块号，在一级索引方式下，最大文件即为这直接存储的64个磁盘块全部存储磁盘号，$642^{10}/8*2^{10=8MB}$\n","permalink":"https://coder0xe.github.io/posts/os-%E7%AC%AC%E5%85%AD%E6%AC%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/","summary":"\u003ch1 id=\"os第六次理论作业\"\u003eOS第六次理论作业\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e分析磁盘访问数据的时间。假设磁盘请求以柱面10、35、20、70、2、 3 和 38 的次序进入磁盘驱动器。寻道时磁头每移动一个柱面需要 5ms，以下各算法所需的寻道时间是多少：\n\u003cul\u003e\n\u003cli\u003e（1） 先来先服务\u003c/li\u003e\n\u003cli\u003e（2） 最短寻道时间优先\u003c/li\u003e\n\u003cli\u003e（3） SCAN算法\u003c/li\u003e\n\u003cli\u003e（4） LOOK算法\u003c/li\u003e\n\u003cli\u003e说明：假设以上三种情况磁头初始位置为15。对于（3）和（4）， 磁头 当前向大柱面号方向运行，磁盘最大柱面号为85。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e寻道时间：是把磁头从当前位置移动到指定磁道上所经历的时间\u003c/p\u003e\n\u003cp\u003e该时间是启动磁盘的时间s与磁头移动n条磁道所花费的时间之和\u003c/p\u003e\n\u003cp\u003eTs = m * n + s\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e先来先服务：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$5*(5+25+15+50+68+1+35)=995ms$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e最短寻道时间优先：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e这里起始位置是15，距离10和20距离相等\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e若首先访问10，序列为：$15,10,3,2,20,35,38,70$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e$5*(5+7+1+18+15+3+32)=405ms$​\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e若首先访问20，序列为：$15,20,10,3,2,35,38,70$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e$5*(5+10+7+1+33+3+32)=455ms$\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSCAN电梯算法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e序列为：$15,20,35,38,70,85,10,3,2$\u003c/li\u003e\n\u003cli\u003e$5*(5+15+3+32+15+75+7+1)=765ms$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eLOOK算法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e序列为：$15,20,35,38,70,10,3,2$\u003c/li\u003e\n\u003cli\u003e$5*(5+15+3+32+60+7+1)=615ms$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e在I/O系统中引入缓冲区的主要目标是什么？某文件占8个磁盘块， 现要把该文件的磁盘块\u003cstrong\u003e逐个读入\u003c/strong\u003e主存缓冲区，并送用户区进行分析。\u003cstrong\u003e一个缓冲区与磁盘块大小相等\u003c/strong\u003e。把一个磁盘块读入缓冲区的时间为 100μs，缓冲区数据传送到用户区的时间是50μs，CPU对一块数据 进行分析的时间为50μs。分别计算在单缓冲区和双缓冲区结构下， 分析完该文件的时间是多少？\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在I/O系统中，CPU计算速度较快，而外设I/O速度较慢，为了解决CPU与外设速度不匹配的问题，提高CPU的利用率，减少CPU的忙等状态，设计了缓冲区\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用单缓冲区：第一块磁盘读入缓冲区的时间为100us，而后的磁盘读入和CPU进行分析的50us可以并行执行，对过程进行简单分析，第一块磁盘读入到传送到用户区：150us，此时CPU对第一块数据进行计算，并行地，第二块磁盘开始读入，需要50+50+50完成对第二块磁盘的计算，后边的磁盘同理。\u003cstrong\u003e即第一块磁盘从读入到完成分析需要200us,后边每一块需要150us\u003c/strong\u003e，总体$150*7+200=1250us$\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用双缓冲区：CPU和I/O设备分别使用一块缓冲区，一块缓冲区由I/O设备进行磁盘块读入后将数据传送到CPU并由CPU进行分析，并行地，另一个缓冲区进行磁盘块读取，\u003cstrong\u003e即第一块磁盘需要200us，后边每块磁盘需要100us\u003c/strong\u003e，总体$200+100*7=900us$\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e请结合操作系统课所学习的内容总结从哪些方面可以提高文件系统 的性能。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e可以采用目录项分解、当前目录、磁盘碎片整理、块高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、RAID等技术\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e简述文件控制块（FCB-File Control Block）中所管理的主要信息\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e基本信息：文件名、物理位置、文件逻辑结构、文件物理结构\u003c/li\u003e\n\u003cli\u003e访问控制信息：文件所有者、访问权限\u003c/li\u003e\n\u003cli\u003e使用信息：创建时间、上一次修改时间、当前使用信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e在文件系统中，访问一个文件f时首先需要从目录中找到与f对应 的目录项。假设磁盘物理块的大小为1KB，一个目录项的大小为128 字节，文件的平均大小为100KB。该 文 件 系 统 的 目 录 结 构 如 下图所示。 假定不考虑磁盘块的提前读和缓存等加速磁盘访问技术。\n\u003cul\u003e\n\u003cli\u003e请回答以下问题：\u003c/li\u003e\n\u003cli\u003e（1） 按照当前的目录结构，且\u003cstrong\u003e采用串联文件方式对数据块进行组织\u003c/strong\u003e，\u003cstrong\u003e并且根目录的目录项已读入内存中\u003c/strong\u003e。如果目标文件f 在第三级目录下， 且其对应的第三级目录的目录项可以一次从磁盘读出，访问文件f中的 一个块平均需要访问几次磁盘？\u003c/li\u003e\n\u003cli\u003e（2） 如果采用i节点的方法来构建文件目录，假定文件名占14个字 节，i节点的指针占2个字节。如果\u003cstrong\u003e仅采用直接索引\u003c/strong\u003e，每个第三级目录 下的文件数不超过50个，且根目录的i节点已读入内存，访问第三级 目录下的一个文件的一个块平均需要访问几次磁盘？\u003c/li\u003e\n\u003cli\u003e（3） 假设该文件系统的\u003cstrong\u003e空间最大容量为16ZB(1ZB=$2^{70}$B)\u003c/strong\u003e。如 果 文 件 的 FCB 中包括512字节的索引区，且允许采用一级索引进行组织，那么该 文件系统支持的最大文件是多少字节？\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240525143432172\" loading=\"lazy\" src=\"/img/image-20240525143432172.png\"\u003e\u003c/p\u003e","title":"OS:第六次理论作业"},{"content":"OS:lab5实验报告 Thinking 5.1 如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是 一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做 这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和IDE磁盘）的操作会 有差异吗？可以从缓存的性质和缓存更新的策略来考虑 当外部设备自身更新数据时，如果此时CPU写入外设的数据仍然保留在Cache中，而没有被及时写入到设备，则缓存的数据会在外设自身更新后再写入外设，发生错误 串口设备读写频繁，而IDE磁盘读写频率相对较小，因此串口设备发生错误的概率要远大于IDE磁盘 Thinking 5.2 查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制 块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？\n一个磁盘块的大小为4KB，一个文件控制块的大小为256B，故能存储16个\n一个目录文件最多可以使用1024个磁盘块存储文件控制块，故最多有16384个文件\n一个文件最多使用1024个磁盘块存储数据，1024*4KB=4MB\nThinking 5.3 请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？\n块缓存的地址空间大小为DISKMAX即0x4000_0000页即为1GB大小\n故实验支持的的最大磁盘大小为1GB\nThinking 5.4 在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义， 试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处\n比较重要的一个宏定义是FILE_STRUCT_SIZE\n1 #define FILE_STRUCT_SIZE 256 这个宏定义指出了file结构体的大小\n在f_pad域对file结构体空闲空间进行补全时用到，让整数个结构体占用一个磁盘块\nThinking 5.5 在Lab4“系统调用与fork”的实验中我们实现了极为重要的fork函数。那 么fork前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上 编写一个程序进行验证。\n一个进程所有的文件描述符都存储在[FDTABLE, FILEBASE)这一地址空间中。在fork函数执行时，会将KSTACKTOP以下的地址空间复制到子进程地址空间中，因此fork前后的父子进程会共享文件描述符和定位指针。\nThinking 5.6 请解释File,Fd,Filefd结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要 求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架\n给出以上三种结构体的定义以及解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct File { char f_name[MAXNAMELEN]; // 文件名 uint32_t f_size;\t// 文件的大小 uint32_t f_type;\t// 文件类型 uint32_t f_direct[NDIRECT]; // 存储的直接磁盘块号 uint32_t f_indirect; // 存储的间接磁盘块号，其中保存间接指向的磁盘块号 struct File *f_dir; // 文件的目录，只有在内存中有效 char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; } __attribute__((aligned(4), packed)); // 填充剩余空间，只保存整数个文件结构体 // file descriptor struct Fd { u_int fd_dev_id; // 文件对应的设备id u_int fd_offset; // 文件指针指向的位置(在设备中的偏移量) u_int fd_omode; // 文件打开模式(open mode) }; // file descriptor + file struct Filefd { struct Fd f_fd; // 文件描述符结构体 u_int f_fileid; // 文件id,表示文件在opentab中的位置 struct File f_file; //文件控制块 }; Fd结构体主要用于记录已经打开的文件的状态，便于用户直接使用文件描述符对文件进行操作和申请服务。由于文件描述符主要是为用户所用，因此它对应的是磁盘映射到内存中的数据。\nFilefd结构体：文件描述符中存储的数据毕竟是有限的，有时候我们需要将Fd*强制转换为Filefd*来获取文件控制块(File结构体)，从而获取文件更多信息\nFile结构体中主要是记录了文件的各种信息，例如名字/类型/大小/数据存储的直接磁盘块和间接磁盘块等\nThinking 5.7 图 5.9 中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们 的操作系统是如何实现对应类型的进程间通信的\nENV_CREATE(user_env)和ENV_CREATE(fs_serv)都是异步消息，由init()发出创建消息后，init()函数即可返回执行后续步骤，由fs和user进程执行自己的初始化工作\nfs初始化serv_init()和fs_init()完成后，进入serv()函数，被ipc_receive()函数阻塞为ENV_NOT_RUNNABLE，知道收到user进程的ipc_send(fsreq)被唤醒\nuser进程向fs进程ipc_send(fsreq)发送请求为同步消息，发送后自身进入阻塞ENV_NOT_RUNNABLE，等待被唤醒的fs进程服务结束时ipc_send(dst_va)，用户进程接收到数据后继续运行，fs进程再次进入阻塞，等待下次被用户唤醒\n实验难点总结 ​\tlab5中涉及到的内容主要涉及以下三个部分\n外部存储设备驱动 文件系统结构 文件系统的用户接口 ​\t可以用一张图来概括\n1.外部存储设备驱动 1.1 内存映射MMIO ​\t外设通过读写设备上的寄存器来进行数据通信，外设寄存器也称为I/O端口，主要用来访问I/O设备。外设寄存器通常包括控制寄存器、状态寄存器和数据寄存器。这些寄存器被映射到指定的物理地址空间。\n​\t实验中统一使用内存映射I/O模型，在MIPS的内核地址空间中kseg0和kseg1段实现了硬件级别的物理地址和内核虚拟地址的转换。\n​\t对kseg1段地址的读写不经过MMU映射，且不使用Cache,故在实验中在编写设备驱动时，将物理地址转换为kseg1段的虚拟地址(加上kseg1偏移量)\n​\t对设备的读写操作：syscall_write_dev和syscall_read_dev\n​\t在代码编写的过程中调用了ioread/write8()/ioread/write16()/ioread/write32()等函数进行指定大小的读写。\n​\t代码编写过程中需要注意的是对地址范围的检查以及使用先将地址转换为对应类型的指针再解引用取出对应类型的数据的取数据方法。\n1.2 IDE磁盘结构和操作 ​\t实验中我们使用一块磁盘，LBA模式进行扇区寻址，扇区编号有28位，最多可以寻址$2^{28}$个扇区。\n1.3 编写磁盘驱动程序 将外设寄存器物理地址加上kseg1偏移量映射到kseg1段内核虚拟地址 ​\t设备驱动主要需要编写ide_read和ide_write函数，其中通过系统调用完成了读取/写入外设，即调用了帮手函数syscall_read_dev和syscall_write_dev。读写磁盘的过程如图所示\n2. 文件系统结构 2.1 磁盘文件系统布局 第一个磁盘块为引导扇区和分区表 第二个磁盘块为超级块，描述文件系统的基本信息：魔数、磁盘大小、根目录位置 ​\t在文件系统中，我们使用位图法来管理空闲的磁盘资源，用一个二进制位表示磁盘中一个磁盘块的使用情况。\n​\t在fs.c中实现free_block函数，即把位图中该磁盘对应的标志位置为1，同时需要检查磁盘号是否符合范围。\n2.2 文件系统详细结构 ​\t在这一节中，需要重点理解文件控制块(FCB)，user/include/fs.h\n1 2 3 4 5 6 7 8 9 10 struct File { char f_name[MAXNAMELEN]; // filename uint32_t f_size;\t// file size in bytes uint32_t f_type;\t// file type uint32_t f_direct[NDIRECT]; uint32_t f_indirect; struct File *f_dir; // the pointer to the dir where this file is in, valid only in memory. char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; } __attribute__((aligned(4), packed)); f_direct[NDIRECT]是文件的直接指针，每个文件控制块有10个直接指针，指向10块磁盘，40KB f_indirect是文件的间接指针，指向一个磁盘，该磁盘中存储间接指向的磁盘号(实验中只有一级间接) f_dir指向文件所在的目录 ​\t对于文件内容上\n普通文件的文件内容是他所对应的数据块 目录文件的文件内容是目录下各个文件的文件控制块FCB ​\ttools/fsformat.c中实现了将文件和目录按照文件系统格式写入磁盘的功能，要求自行实现create_file\n为目录下的文件分配一个文件控制块，这段代码和理论结合的很紧密，我们知道，文件目录中的内容是目录下文件的文件控制块，这段代码的主要思路是遍历文件目录对应的所有磁盘块(注意区分磁盘号来判断是直接磁盘块还是间接磁盘块)，在每个磁盘块中遍历File结构体，这里又是一个巧妙的指针转换struct File *，如果下属的结构体有空闲的(名字为空)，则分配该文件控制块；如果没有新分配一块并与目录建立链接(make_link_block)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct File *create_file(struct File *dirf) { int nblk = dirf-\u0026gt;f_size / BLOCK_SIZE; for (int i = 0; i \u0026lt; nblk; ++i) { int bno; if (i \u0026lt; NDIRECT) { bno = dirf-\u0026gt;f_direct[i]; } else { bno = ((uint32_t *)disk[dirf-\u0026gt;f_indirect].data)[i]; } struct File *blk = (struct File *)(disk[bno].data); for (struct File *f = blk; f \u0026lt; blk + FILE2BLK; ++f) { if (f-\u0026gt;f_name[0] == \u0026#39;\\0\u0026#39;) { return f; } } } return (struct File *)disk[make_link_block(dirf, nblk)].data; } 2.3 块缓存 MOS中文件系统是一个用户进程，有4GB地址空间\n​\t将文件进程地址空间中DISKMAP到DISKMAP+DISKMAX一段的地址空间作为缓存区。\nfs.c中disk_addr函数计算指定磁盘块对应的虚拟地址(DISKMAP + SIZE * blocknumber)\n磁盘块中内容载入到内存时，需要为之分配对应的物理内存；结束使用这一磁盘块时，需要释放对应的物理内存以回收资源，通过map/unmap_block实现。\nsyscall_mem_alloc syscall_mem_unmap file_get_block函数用于将某个指定的文件指向的磁盘块读入内存\ndir_lookup函数查找某个目录下是否存在指定的文件\n3. 文件系统的用户接口 个人认为这一部分理解难度最高\n3.1 文件描述符 ​\t文件描述符(File Discripter)是系统给用户提供的整数，用于其在描述符表(Discriptor Table)中进行索引。我们在作为操作系统的使用者进行文件I/O编程时，使用open在描述符表的指定位置存放被打开文件的信息；使用close将描述符表中指定位置的文件信息释放；在write和read时修改文件描述符表中对应表项的文件信息\n​\t在用户进程试图打开一个文件时，文件系统服务进程需要一个文件描述符来存储文件的基本信息和用户进程中关于文件的状态。**同时，文件描述符也起到描述用户对于文件操作的作用，当用户进程向文件系统进程发送打开文件的请求时，文件系统进程会将这些基本信息记录在内存中，然后由操作系统将用户进程请求的地址映射到同一个存储了文件描述符的物理页上。**当用户进程获取了文件大小等基本信息后，再次向文件系统发送请求将文件内容映射到指定内存空间中。\n​\t以user/lib/file.c中的open函数为例，体会打开文件的过程。\nopen函数中传入了一个绝对路径，表示要打开的文件\n首先为要打开的文件分配一个文件描述符(fd_alloc)\n然后使用IPC机制打开文件fsipc_open，获取该文件(路径)对应的文件描述符\nfsipc_open对应着枚举类型FSREQ_OPEN的文件系统进程请求 调用fs_ipc进行请求的发送 ipc_send ipc_recv 利用返回的fd，提取出基本信息，size等\n利用fsipc_map将需要的文件内容从文件进程的地址空间映射到用户进程地址空间\n​\t当需要读取大文件中间的一小部分内容时，希望从前一次读写完毕的位置开始，因此需要维护一个文件中的定位指针。在文件中进行read,write,seek操作时，维护指针fd_offset。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int read(int fdnum, void *buf, u_int n) { int r; struct Dev *dev; struct Fd *fd; if ((r = fd_lookup(fdnum, \u0026amp;fd)) \u0026lt; 0 || (r = dev_lookup(fd-\u0026gt;fd_dev_id, \u0026amp;dev)) \u0026lt; 0 ) { return r; } if ((fd-\u0026gt;fd_omode \u0026amp; O_ACCMODE) == O_WRONLY) { return -E_INVAL; } r = dev-\u0026gt;dev_read(fd, buf, n, fd-\u0026gt;fd_offset); if (r \u0026gt; 0) { fd-\u0026gt;fd_offset += r; } return r; } 5.2 文件系统服务 ​\t文件系统进程中的服务通过IPC的形式供其他进程调用，进行文件读写操作。\nipc_send ipc_recv 上图可以展示出前一小节中的调用层次关系\n文件系统的请求如下\n1 2 3 4 5 6 7 8 9 10 enum { FSREQ_OPEN, FSREQ_MAP, FSREQ_SET_SIZE, FSREQ_CLOSE, FSREQ_DIRTY, FSREQ_REMOVE, FSREQ_SYNC, MAX_FSREQNO, }; file.c是用户操作文件的接口\nopen fsipc_open fsipc.c中定义了请求文件系统服务的IPC操作\nfsipc_action fsipc ipc_send ipc_recv fs/serv.c中定义了文件系统进程响应IPC的函数\nserve_action file_action：定义在fs/fs.c中 实验心得与体会 ​\t在lab5中，我们实现了一个简单的文件系统。我们首先实现了IDE磁盘驱动，我们使用MMIO内存映射机制将各种外设例如console，IDE磁盘等外设寄存器映射到kseg1段，另外复习了磁盘的物理结构，在此基础上选择LBA机制进行了磁盘驱动程序的编写。在文件系统结构方面，我们首先学习了磁盘文件系统布局，而后学习了块缓存等机制。在本次实验中，在文件系统的用户接口内容后代码理解难度上升，需要细致理解。\n","permalink":"https://coder0xe.github.io/posts/os-lab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","summary":"\u003ch1 id=\"oslab5实验报告\"\u003eOS:lab5实验报告\u003c/h1\u003e\n\u003ch2 id=\"thinking-51\"\u003eThinking 5.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是 一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做 这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和IDE磁盘）的操作会 有差异吗？可以从缓存的性质和缓存更新的策略来考虑\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e当外部设备自身更新数据时，如果此时CPU写入外设的数据仍然保留在Cache中，而没有被及时写入到设备，则缓存的数据会在外设自身更新后再写入外设，发生错误\u003c/li\u003e\n\u003cli\u003e串口设备读写频繁，而IDE磁盘读写频率相对较小，因此串口设备发生错误的概率要远大于IDE磁盘\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-52\"\u003eThinking 5.2\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制 块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e一个磁盘块的大小为4KB，一个文件控制块的大小为256B，故能存储16个\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e一个目录文件最多可以使用1024个磁盘块存储文件控制块，故最多有16384个文件\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e一个文件最多使用1024个磁盘块存储数据，1024*4KB=4MB\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-53\"\u003eThinking 5.3\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e块缓存的地址空间大小为\u003ccode\u003eDISKMAX\u003c/code\u003e即\u003ccode\u003e0x4000_0000\u003c/code\u003e页即为1GB大小\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e故实验支持的的最大磁盘大小为1GB\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-54\"\u003eThinking 5.4\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义， 试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e比较重要的一个宏定义是FILE_STRUCT_SIZE\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e#define FILE_STRUCT_SIZE 256\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e这个宏定义指出了file结构体的大小\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在f_pad域对file结构体空闲空间进行补全时用到，让整数个结构体占用一个磁盘块\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-55\"\u003eThinking 5.5\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e在Lab4“系统调用与fork”的实验中我们实现了极为重要的fork函数。那 么fork前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上 编写一个程序进行验证。\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e一个进程所有的文件描述符都存储在\u003ccode\u003e[FDTABLE, FILEBASE)\u003c/code\u003e这一地址空间中。在\u003ccode\u003efork\u003c/code\u003e函数执行时，会将KSTACKTOP以下的地址空间复制到子进程地址空间中，因此\u003ccode\u003efork\u003c/code\u003e前后的父子进程会共享文件描述符和定位指针。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-56\"\u003eThinking 5.6\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e请解释File,Fd,Filefd结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要 求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e给出以上三种结构体的定义以及解释\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e File {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e f_name[MAXNAMELEN]; \u003cspan style=\"color:#6272a4\"\u003e// 文件名\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003euint32_t\u003c/span\u003e f_size;\t \u003cspan style=\"color:#6272a4\"\u003e// 文件的大小\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003euint32_t\u003c/span\u003e f_type;\t \u003cspan style=\"color:#6272a4\"\u003e// 文件类型\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003euint32_t\u003c/span\u003e f_direct[NDIRECT]; \u003cspan style=\"color:#6272a4\"\u003e// 存储的直接磁盘块号\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003euint32_t\u003c/span\u003e f_indirect; \u003cspan style=\"color:#6272a4\"\u003e// 存储的间接磁盘块号，其中保存间接指向的磁盘块号\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e File \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ef_dir; \u003cspan style=\"color:#6272a4\"\u003e// 文件的目录，只有在内存中有效\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e f_pad[FILE_STRUCT_SIZE \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e MAXNAMELEN \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e (\u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e NDIRECT) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003esizeof\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e)];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} \u003cspan style=\"color:#50fa7b\"\u003e__attribute__\u003c/span\u003e((\u003cspan style=\"color:#50fa7b\"\u003ealigned\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e), packed));  \u003cspan style=\"color:#6272a4\"\u003e// 填充剩余空间，只保存整数个文件结构体\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e// file descriptor\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e Fd {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int fd_dev_id; \u003cspan style=\"color:#6272a4\"\u003e// 文件对应的设备id\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int fd_offset; \u003cspan style=\"color:#6272a4\"\u003e// 文件指针指向的位置(在设备中的偏移量)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int fd_omode; \u003cspan style=\"color:#6272a4\"\u003e// 文件打开模式(open mode)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e// file descriptor + file\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e Filefd {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e Fd f_fd; \u003cspan style=\"color:#6272a4\"\u003e// 文件描述符结构体\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int f_fileid; \u003cspan style=\"color:#6272a4\"\u003e// 文件id,表示文件在opentab中的位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e File f_file; \u003cspan style=\"color:#6272a4\"\u003e//文件控制块\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFd结构体主要用于记录已经打开的文件的状态，便于用户直接使用文件描述符对文件进行操作和申请服务。由于文件描述符主要是为用户所用，因此它对应的是磁盘映射到内存中的数据。\u003c/p\u003e","title":"OS:lab5实验报告"},{"content":"OS:lab5课下基础 1. 文件系统概述 ​\t计算机文件系统是一种存储和组织数据的方法，便于访问和查找数据。文件系统使用文件和树形目录的逻辑抽象屏蔽了底层硬盘和光盘等物理设备基于数据块进行存储和访问的复杂性。\n即用户不必关心数据实际保存在硬盘/光盘的哪个数据块上，而只需要记住这个文件所属的目录和文件名。\n在写入新数据之前，用户不必关心硬盘上哪个块是空闲的，硬盘上的存储空间管理(分配/释放)由文件系统自动完成，用户只需记住数据写入到了哪个文件\n​\t常见的文件系统通常基于硬盘和光盘等块存储设备，并维护文件在设备中的物理位置。\n​\t广义上，一切带标识的、在逻辑上有完整意义的字节序列都可以称为文件，文件系统将外部设备中的资源抽象为文件，从而可以统一管理外部设备，实现对数据的存储、组织、访问和修改。\n2. 文件系统的设计与实现 MOS是一种微内核设计\n将传统操作系统的文件系统移出内核 将一些内核数据暴露到用户空间 将传统操作系统的设备驱动移出内核 3. IDE磁盘驱动 ​\t为了在磁盘等外部设备上实现文件系统，我们必须为这些外部设备编写驱动程序。(MOS已经在kern/mechine.c中实现了一个简单的控制台驱动程序)\n​\t本次要实现的硬盘驱动程序与已经实现的串口驱动都采用MMIO内存映射技术，并且本次编写的硬盘驱动程序完全运行在用户空间(微内核)。\n3.1 内存映射I/O(MMIO) ​\t几乎每一种外设都是通过读写设备上的寄存器来进行数据通信，外设寄存器也称为I/O接口，主要用来访问I/O设备。\n外设寄存器主要包括控制寄存器、状态寄存器、数据寄存器，这些寄存器被映射到指定的物理地址空间 ​\t在MIPS的内核地址空间中(kseg0/kseg1)实现了硬件级别(高位清0)的物理地址和内核虚拟地址的转换机制，其中，对于kseg1段地址的读写不经过MMU映射，且不使用高速缓存，这正是外部设备驱动所需要的。我们可以通过简单地读写某些固定的内核虚拟地址来实现驱动程序的功能。\n在之前的实验中，我们曾经使用KADDR宏将一个物理地址转换为kseg0段的虚拟地址，即加上kseg0段的偏移量(0x8000_0000)\n​\t在编写设备驱动时，我们需要将物理地址转换为kseg1段的内核虚拟地址，即给物理地址加上kseg1的偏移值0xA000_0000\n​\t以已经编写完成的串口设备驱动为例，MALTA提供的console设备基地址为0x1800_03F8，设备寄存器映射如表所示\n​\t例如写操作：通过向kseg1段的地址写入字符，就能在shell中看到对应的输出。\nkseg0_offset + device_op_addr_base = KSEG1 + MALTA_SERIAL_DATA\n1 2 3 4 5 //写 void printcharc(char ch) { //... *((volatile uint8_t *)(KSEG1 + MALTA_SERIAL_DATA)) = ch; } ​\t在本次实验中，我们需要编写的IDE磁盘驱动位于用户空间，用户态进程若是直接读写内核虚拟地址会引发一个地址错误ADEL/S，故对于设备的读写必须通过系统调用实现\nsys_write_dev：写设备系统调用 sys_read_dev：读设备系统调用 Exercise 5.1 kern/syscall.c中的sys_write_dev以及sys_read_dev\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 int sys_write_dev(u_int va, u_int pa, u_int len) { /* Exercise 5.1: Your code here. (1/2) */ if (is_illegal_va_range(va, len)) { return -E_INVAL; } if (!((pa \u0026gt;= MALTA_IDE_BASE \u0026amp;\u0026amp; pa + len \u0026lt; MALTA_IDE_BASE + 0x8) || (pa \u0026gt;= MALTA_SERIAL_BASE \u0026amp;\u0026amp; pa + len \u0026lt; MALTA_SERIAL_BASE + 0x20))) { return -E_INVAL; } if (len == 1) { iowrite8(*(uint8_t *)va,(u_long)pa); } else if (len == 2) { iowrite16(*(uint16_t *)va,(u_long)pa); } else if (len == 4) { iowrite32(*(uint32_t *)va,(u_long)pa); } else { return -E_INVAL; } return 0; } int sys_read_dev(u_int va, u_int pa, u_int len) { /* Exercise 5.1: Your code here. (2/2) */ if (is_illegal_va_range(va, len)) { return -E_INVAL; } if (!((pa \u0026gt;= MALTA_IDE_BASE \u0026amp;\u0026amp; pa + len \u0026lt; MALTA_IDE_BASE + 0x8) || (pa \u0026gt;= MALTA_SERIAL_BASE \u0026amp;\u0026amp; pa + len \u0026lt; MALTA_SERIAL_BASE + 0x20))) { return -E_INVAL; } if (len == 1) { *(uint8_t *) va = ioread8((u_long)pa); } else if (len == 2) { *(uint16_t *) va = ioread16((u_long)pa); } else if (len == 4) { *(uint32_t *) va = ioread32((u_long)pa); } else { return -E_INVAL; } return 0; } 这里在读写虚拟地址对应的数据时涉及到对虚拟地址对应数据的读写（先转换为指针类型再解引用） Exercise 5.2 user/lib/syscall_lib.c中完成用户态的相应系统调用的接口\n（msyscall中直接调用syscall陷入内核）\n1 2 3 4 5 6 7 8 9 int syscall_write_dev(void *va, u_int dev, u_int size) { /* Exercise 5.2: Your code here. (1/2) */ return msyscall(SYS_write,va,dev,size); } int syscall_read_dev(void *va, u_int dev, u_int size) { /* Exercise 5.2: Your code here. (2/2) */ return msyscall(SYS_read,va,dev,size); } 3.2 IDE磁盘 3.2.1 磁盘物理结构 磁盘的物理结构\n扇区(sector)：磁盘盘片被划分为很多扇形的区域，这些区域叫做扇区。扇区是磁盘执行读写操作的单位，一般是512字节 磁道(track)：盘片上以盘片中心为圆心，不同大小的同心圆 柱面(cylinder)：硬盘中，不同盘面相同半径的磁道组成的圆柱面 磁头(head)：每个磁盘有两个面，每个面都有一个磁头，当对磁盘进行读写操作时，磁头在盘面上快速移动 3.2.2 IDE 磁盘操作 ​\t扇区(sector)是磁盘读写的基本单位，通过读写MALTA上PIIX4的特定寄存器，我们可以实现以扇区为最小单元的读写。MALTA平台上PIIX4磁盘控制器的基地址为0x1800_01f0，其I/O相关寄存器相对于该地址的偏移和对应的功能如下表\n在include/malta.h中定义了关于这些偏移量的宏定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define MALTA_IDE_BASE (MALTA_PCIIO_BASE + 0x01f0) #define MALTA_IDE_DATA (MALTA_IDE_BASE + 0x00) #define MALTA_IDE_ERR (MALTA_IDE_BASE + 0x01) #define MALTA_IDE_NSECT (MALTA_IDE_BASE + 0x02) #define MALTA_IDE_LBAL (MALTA_IDE_BASE + 0x03) #define MALTA_IDE_LBAM (MALTA_IDE_BASE + 0x04) #define MALTA_IDE_LBAH (MALTA_IDE_BASE + 0x05) #define MALTA_IDE_DEVICE (MALTA_IDE_BASE + 0x06) #define MALTA_IDE_STATUS (MALTA_IDE_BASE + 0x07) #define MALTA_IDE_LBA 0xE0 #define MALTA_IDE_BUSY 0x80 #define MALTA_IDE_CMD_PIO_READ 0x20 /* Read sectors with retry */ #define MALTA_IDE_CMD_PIO_WRITE 0x30 /* write sectors with retry */ ​\t在MOS中我们可以挂载编号为0/1的两块IDE磁盘，但实际上我们只使用到编号为0的一块磁盘。\n​\t对于磁盘寻址，我们可以按照柱面-磁头-扇区(Cylinder-Head-Sector, CHS)的方式来定位一个扇区。这种寻址方式符合磁盘的物理结构。\n​\t由于CHS模式下不方便进行寻址，**因此在实验中我们使用逻辑块寻址（Logical Block Addressing, LBA）的方式来进行扇区寻址。**在LBA模式下，IDE设备将磁盘看做一个线性的字节序列，每个扇区都有一个唯一的编号，只需要设置目标扇区编号，就可以完成磁盘的寻址。\n​\t在我们的实验中，扇区编号有28位，因此最多可以寻址$2^{28}$个扇区，即128GB磁盘空间。\n3.2.3 驱动程序编写 ​\t当我们在磁盘的指定位置读取或写入一个扇区时，需要调用read_sector函数将磁盘中对应的扇区的数据读到设备缓冲区中，或write_sector函数将缓冲区中的数据写入磁盘。\n​\t磁盘操作中，所有的地址操作都需要将物理地址转换为虚拟地址，磁盘设备的基地址对应在kseg1的内核虚拟地址为0xb80_01f0。读取流程如下图\n​\t由上图，在磁盘读写的过程中，我们需要反复检查IDE设备是否已经就绪。因此我们构建了一个检查IDE状态的帮手函数wait_ide_ready（用户态函数），用于等待IDE上的操作就绪。\n1 2 3 4 5 6 7 8 9 10 11 static uint8_t wait_ide_ready() { uint8_t flag; while (1) { panic_on(syscall_read_dev(\u0026amp;flag, MALTA_IDE_STATUS, 1)); if ((flag \u0026amp; MALTA_IDE_BUSY) == 0) { break; } syscall_yield(); } return flag; } ​\t当IDE就绪后，就可以对他进行读写操作了。\n首先设置操作扇区的数目，我们只操作一个扇区，因此设置为1\n接下来一次设置操作扇区号，本实验中的IDE设备无法一次性写入28位扇区号，因此需要单独设置扇区号的各位，在设置[27:24]位时，还需要同时设置扇区寻址模式和磁盘编号。\n再次等待IDE设备就绪\n通过系统调用读取或写入扇区：本实验中IDE设备每次仅能读取或写入4字节，因此需要通过一个循环完成整个扇区的读取或写入，即连续相相同的地址读取或写入4字节\n​\t读取扇区：read_sector，读取diskno号磁盘上的secno号扇区到dst指向的地址。\n​\t写入扇区：write_sector，将src指向的一个扇区的数据写入到diskno号磁盘的secno号扇区。\nExercise 5.3 fs/ide.c ide_read ide_write 实现用户态下对磁盘的读写操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 void ide_read(u_int diskno, u_int secno, void *dst, u_int nsecs) { uint8_t temp; u_int offset = 0, max = nsecs + secno; panic_on(diskno \u0026gt;= 2); // Read the sector in turn while (secno \u0026lt; max) { temp = wait_ide_ready(); // Step 1: Write the number of operating sectors to NSECT register temp = 1; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_NSECT, 1)); // Step 2: Write the 7:0 bits of sector number to LBAL register temp = secno \u0026amp; 0xff; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_LBAL, 1)); // Step 3: Write the 15:8 bits of sector number to LBAM register /* Exercise 5.3: Your code here. (1/9) */ temp = (secno \u0026gt;\u0026gt; 8) \u0026amp; 0xff; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_LBAM, 1)); // Step 4: Write the 23:16 bits of sector number to LBAH register /* Exercise 5.3: Your code here. (2/9) */ temp = (secno \u0026gt;\u0026gt; 16) \u0026amp; 0xff; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_LBAH, 1)); // Step 5: Write the 27:24 bits of sector number, addressing mode // and diskno to DEVICE register temp = ((secno \u0026gt;\u0026gt; 24) \u0026amp; 0x0f) | MALTA_IDE_LBA | (diskno \u0026lt;\u0026lt; 4); panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_DEVICE, 1)); // Step 6: Write the working mode to STATUS register temp = MALTA_IDE_CMD_PIO_READ; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_STATUS, 1)); // Step 7: Wait until the IDE is ready temp = wait_ide_ready(); // Step 8: Read the data from device for (int i = 0; i \u0026lt; SECT_SIZE / 4; i++) { panic_on(syscall_read_dev(dst + offset + i * 4, MALTA_IDE_DATA, 4)); } // Step 9: Check IDE status panic_on(syscall_read_dev(\u0026amp;temp, MALTA_IDE_STATUS, 1)); offset += SECT_SIZE; secno += 1; } } void ide_write(u_int diskno, u_int secno, void *src, u_int nsecs) { uint8_t temp; u_int offset = 0, max = nsecs + secno; panic_on(diskno \u0026gt;= 2); // Write the sector in turn while (secno \u0026lt; max) { temp = wait_ide_ready(); // Step 1: Write the number of operating sectors to NSECT register /* Exercise 5.3: Your code here. (3/9) */ temp = 1; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_NSECT, 1)); // Step 2: Write the 7:0 bits of sector number to LBAL register /* Exercise 5.3: Your code here. (4/9) */ temp = secno \u0026amp; 0xff; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_LBAL, 1)); // Step 3: Write the 15:8 bits of sector number to LBAM register /* Exercise 5.3: Your code here. (5/9) */ temp = (secno \u0026gt;\u0026gt; 8) \u0026amp; 0xff; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_LBAM, 1)); // Step 4: Write the 23:16 bits of sector number to LBAH register /* Exercise 5.3: Your code here. (6/9) */ temp = (secno \u0026gt;\u0026gt; 16) \u0026amp; 0xff; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_LBAH, 1)); // Step 5: Write the 27:24 bits of sector number, addressing mode // and diskno to DEVICE register /* Exercise 5.3: Your code here. (7/9) */ temp = ((secno \u0026gt;\u0026gt; 24) \u0026amp; 0x0f) | MALTA_IDE_LBA | (diskno \u0026lt;\u0026lt; 4); panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_DEVICE, 1)); // Step 6: Write the working mode to STATUS register /* Exercise 5.3: Your code here. (8/9) */ temp = MALTA_IDE_CMD_PIO_WRITE; panic_on(syscall_write_dev(\u0026amp;temp, MALTA_IDE_STATUS, 1)); // Step 7: Wait until the IDE is ready temp = wait_ide_ready(); // Step 8: Write the data to device for (int i = 0; i \u0026lt; SECT_SIZE / 4; i++) { /* Exercise 5.3: Your code here. (9/9) */ panic_on(syscall_write_dev(src + offset + i * 4, MALTA_IDE_DATA, 4)); } // Step 9: Check IDE status panic_on(syscall_read_dev(\u0026amp;temp, MALTA_IDE_STATUS, 1)); offset += SECT_SIZE; secno += 1; } } 4. 文件系统结构 4.1 磁盘文件系统布局 ​\t如下图\n​\t图中出现的Block是磁盘块。不同于扇区，磁盘块是一个虚拟概念，是操作系统与磁盘交互的最小单位，操作系统将相邻的扇区组合在一起，形成磁盘块进行整体操作，减小了扇区过多带来的寻址困难，磁盘块的大小由操作系统决定，一般由2的幂次个扇区构成；而扇区是真实存在的，是磁盘读写的基本单位，与操作系统无关。\n​\tMOS操作系统把磁盘最开始的一个磁盘块(4096字节)当做引导扇区和分区表使用，接下来的一个磁盘块为超级块(Super Block)，用来表述文件系统的基本信息，如Magic Number、磁盘大小以及根目录的位置。\n​\tMOS中超级块以结构体的方式进行定义\n1 2 3 4 5 struct Super { u_int s_magic; // magic number : FS_MAGIC u_int s_nblocks; // total number of blocks on disk (1024) struct File s_root; // root dictionary node } 不同于lab2/lab3中使用空闲链表法管理空闲内存资源和进程控制块，在文件系统中我们使用位图来管理空闲的磁盘资源\n​\t在文件系统中，我们使用位图法来管理空闲的磁盘资源，用一个二进制位bit标识磁盘中的一个磁盘块的使用情况(1表示空闲，0表示占用)。\n​\ttools/fsformat.c中定义了创建文件系统镜像的工具，其中init_disk函数将所有的磁盘块都标记为空闲块（tools文件夹下的程序都是运行在linux环境中，而不是MOS）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void init_disk() { int i, diff; // Step 1: Mark boot sector block. disk[0].type = BLOCK_BOOT; // Step 2: Initialize boundary. nbitblock = (NBLOCK + BLOCK_SIZE_BIT - 1) / BLOCK_SIZE_BIT; nextbno = 2 + nbitblock; // Step 2: Initialize bitmap blocks. for (i = 0; i \u0026lt; nbitblock; ++i) { disk[2 + i].type = BLOCK_BMAP; } for (i = 0; i \u0026lt; nbitblock; ++i) { memset(disk[2 + i].data, 0xff, BLOCK_SIZE); } if (NBLOCK != nbitblock * BLOCK_SIZE_BIT) { diff = NBLOCK % BLOCK_SIZE_BIT / 8; memset(disk[2 + (nbitblock - 1)].data + diff, 0x00, BLOCK_SIZE - diff); } // Step 3: Initialize super block. disk[1].type = BLOCK_SUPER; super.s_magic = FS_MAGIC; super.s_nblocks = NBLOCK; super.s_root.f_type = FTYPE_DIR; strcpy(super.s_root.f_name, \u0026#34;/\u0026#34;); } nbitblock表示为了用位图标识整个磁盘上所有块的使用情况所需要的磁盘块的(bitblock)的数量\n1 nbitblock = (NBLOCK + BLOCK_SIZE_BIT - 1) / BLOCK_SIZE_BIT; 这个表达式实际上具有一个整数除法向上取整的效果 NBLOCK：磁盘块的数量：1024 BLOCK_SIZE_BIT：每个磁盘块的bit大小：4096 * 8 disk[0]与disk[1]我们有特殊作用，不进行Bitmap初始化故遍历从disk[i+2]开始\n将所有位图块的每一位都设为1，表示处于空闲状态\n1 2 3 for (i = 0; i \u0026lt; nbitblock; ++i) { memset(disk[2 + i].data, 0xff, BLOCK_SIZE); } 如果位图还有剩余，不能将最后一个位图块中的靠后一部分内容标记为空闲，因为这些磁盘块实际上并不存在，是不可使用的。因此还要将这些剩下的部分设为0\n1 2 3 4 if (NBLOCK != nbitblock * BLOCK_SIZE_BIT) { diff = NBLOCK % BLOCK_SIZE_BIT / 8; memset(disk[2 + (nbitblock - 1)].data + diff, 0x00, BLOCK_SIZE - diff); } ​\t相应的，在MOS操作系统中，文件系统也需要根据位图来判断和标记磁盘的使用情况。fs/fs.c中的block_is_free函数就用来通过位图中的特定位来判断指定的磁盘块是否被占用。\n1 2 3 4 5 6 7 8 9 10 11 int block_is_free(u_int blockno) { if (super == 0 || blockno \u0026gt;= super-\u0026gt;s_nblocks) { return 0; } if (bitmap[blockno / 32] \u0026amp; (1 \u0026lt;\u0026lt; (blockno % 32))) { return 1; } return 0; } 这里的super是指向磁盘中Super Block的指针，指针值为0，即为零指针，没有存储任何内存地址的指针\n这里简单对bitmap涉及到的数据结构进行解释\nbitmap定义为\n1 uint32_t *bitmap; 我们可以把他看做一个32位int类型的数组看待\n这样我们的位图实际上是一个二维的结构，每一个数组元素相当于一行，一行中有32个元素\n行号：blockno / 32 | 列号 : blockno % 32\n检查二维结构中对应的位置是否为1\nExercise 5.4 free_block\n回收一个磁盘块，更改bitmap图中的标志位为1\n1 2 3 4 5 6 7 8 9 10 11 12 void free_block(u_int blockno) { // You can refer to the function \u0026#39;block_is_free\u0026#39; above. // Step 1: If \u0026#39;blockno\u0026#39; is invalid (0 or \u0026gt;= the number of blocks in \u0026#39;super\u0026#39;), return. /* Exercise 5.4: Your code here. (1/2) */ if (blockno == 0 || blockno \u0026gt;= super-\u0026gt;s_nblocks) { return; } // Step 2: Set the flag bit of \u0026#39;blockno\u0026#39; in \u0026#39;bitmap\u0026#39;. // Hint: Use bit operations to update the bitmap, such as b[n / W] |= 1 \u0026lt;\u0026lt; (n % W). /* Exercise 5.4: Your code here. (2/2) */ bitmap[blockno / 32] |= 1 \u0026lt;\u0026lt; (blockno % 32); } 4.2 文件系统详细结构 ​\tMOS操作系统中使用文件控制块(File结构体)管理文件。\n1 2 3 4 5 6 7 8 9 10 struct File { char f_name[MAXNAMELEN]; // filename; max length is 128 uint32_t f_size;\t// file size in bytes uint32_t f_type;\t// file type uint32_t f_direct[NDIRECT]; uint32_t f_indirect; struct File *f_dir; // the pointer to the dir where this file is in, valid only in memory. char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; } __attribute__((aligned(4), packed)); f_type：普通文件/目录\nf_direct[NDIRECT]：文件的直接指针，每个文件控制块设有10个直接指针，用来记录文件的数据块在磁盘上的位置，每个磁盘块的大小为4KB，也就是说这10个直接指针能表示最大为40KB的文件\nf_indirect：文件的间接指针，当文件的大小超过40KB时，f_indirect指向一个间接磁盘块，用来存储指向文件内容的磁盘块的指针(为了简化计算，我们不使用间接磁盘块的前10个指针)\nMOS 中只有一级间接指针域，实际的操作系统中往往是多级的，这是一种简化\nf_dir指向文件所属的文件目录\nf_pad为了让整数个文件结构体占用一个磁盘块，填充结构体(256字节)中剩下的字节\n​\t对普通的文件来说，其指向的磁盘块存储着文件内容，而对于目录文件来说，其指向的磁盘块存储着各个文件对应的文件控制块。\n当我们要查找某个文件时 首先从超级块中读取根目录的文件控制块 然后沿着目标路径，挨个查看当前目录所包含的文件是否与下一级目标文件同名 找到最终文件 ps : 有关镜像文件\n所谓镜像文件其实就是将特定的一系列文件按照一定的格式制作成单一的文件(类似于压缩包) 例如操作系统、游戏等，最大的特点是可以被特定的软件识别并直接刻录到光盘上 ​\t我们通过fsformat(tools/fsformat.c编译而来)程序来创建一个磁盘镜像文件target/fs.img。通过观察头文件和tools/Makefile，我们发现fsformat.c的编译过程与其他文件有所不同，其使用的是Linux下的gcc编译器，而非交叉编译器，编译生成的fsformat运行于Linux宿主机上，专门用于创建磁盘镜像文件。生成的镜像文件fs.img可以模拟与真实的磁盘文件设备的交互。\nExercise 5.5 file_create\n为目录中增加一个文件(文件控制块)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct File *create_file(struct File *dirf) { int nblk = dirf-\u0026gt;f_size / BLOCK_SIZE; // Step 1: Iterate through all existing blocks in the directory. for (int i = 0; i \u0026lt; nblk; ++i) { int bno; // the block number // If the block number is in the range of direct pointers (NDIRECT), get the \u0026#39;bno\u0026#39; // directly from \u0026#39;f_direct\u0026#39;. Otherwise, access the indirect block on \u0026#39;disk\u0026#39; and get // the \u0026#39;bno\u0026#39; at the index. /* Exercise 5.5: Your code here. (1/3) */ if (i \u0026lt; NDIRECT) { bno = dirf-\u0026gt;f_direct[i]; } else { bno = ((uint32_t *)disk[dirf-\u0026gt;f_indirect].data)[i]; } // Get the directory block using the block number. struct File *blk = (struct File *)(disk[bno].data); // Iterate through all \u0026#39;File\u0026#39;s in the directory block. for (struct File *f = blk; f \u0026lt; blk + FILE2BLK; ++f) { // If the first byte of the file name is null, the \u0026#39;File\u0026#39; is unused. // Return a pointer to the unused \u0026#39;File\u0026#39;. /* Exercise 5.5: Your code here. (2/3) */ if (f-\u0026gt;f_name[0] == \u0026#39;\\0\u0026#39;) { return f; } } } // Step 2: If no unused file is found, allocate a new block using \u0026#39;make_link_block\u0026#39; function // and return a pointer to the new block on \u0026#39;disk\u0026#39;. /* Exercise 5.5: Your code here. (3/3) */ return (struct File *)(disk[make_link_block(dirf, nblk)].data); } 如果当前目录下有空闲的文件控制块就使用空闲的，没有就新分配一个 首先计算当前目录下有多少个磁盘块，对应的块号通过区分NDIRECT查找 *在查询块号时需要注意一个小点：在块号大于10时，我们需要到间接磁盘中查询，我们的块号是32位的，而磁盘中数据的存储格式(disk[].data是一个4096B大小的每个元素为1字节大小的数组)，因此我们不能直接用i做索引，这样只能取出一个一字节大小的数据，我们需要把数组类型转换为32位，((uint32_t )disk[].data)[i] 然后通过块号拿到对应的磁盘块，遍历磁盘块中存储的所有文件控制块，如果文件名为空，即为空闲，返回该文件控制块 如果没有就新分配一个磁盘块并返回(make_link_block) 请阅读tools/fsformat.c 和fs/Makefile，掌握如何将文件和目录按照文件系统的格式写入磁盘，了解文件系统结构的 具体细节，学会添加自定义文件进入磁盘镜像。\n​\tfsformat.c中将文件系统写入磁盘的主函数如下，该函数对文件类型做了区分，是目录或是普通文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int main(int argc, char **argv) { static_assert(sizeof(struct File) == FILE_STRUCT_SIZE); init_disk(); if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;Usage: fsformat \u0026lt;img-file\u0026gt; [files or directories]...\\n\u0026#34;); exit(1); } for (int i = 2; i \u0026lt; argc; i++) { char *name = argv[i]; struct stat stat_buf; int r = stat(name, \u0026amp;stat_buf); assert(r == 0); if (S_ISDIR(stat_buf.st_mode)) { printf(\u0026#34;writing directory \u0026#39;%s\u0026#39; recursively into disk\\n\u0026#34;, name); write_directory(\u0026amp;super.s_root, name); } else if (S_ISREG(stat_buf.st_mode)) { printf(\u0026#34;writing regular file \u0026#39;%s\u0026#39; into disk\\n\u0026#34;, name); write_file(\u0026amp;super.s_root, name); } else { fprintf(stderr, \u0026#34;\u0026#39;%s\u0026#39; has illegal file mode %o\\n\u0026#34;, name, stat_buf.st_mode); exit(2); } } flush_bitmap(); finish_fs(argv[1]); return 0; } 需要注意的是，在以下两个功能函数中，我们使用到了用户编程的POSIX接口\n​\t在以上代码中，将目录写入磁盘镜像的功能函数为write_directory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void write_directory(struct File *dirf, char *path) { DIR *dir = opendir(path); if (dir == NULL) { perror(\u0026#34;opendir\u0026#34;); return; } struct File *pdir = create_file(dirf); strncpy(pdir-\u0026gt;f_name, basename(path), MAXNAMELEN - 1); if (pdir-\u0026gt;f_name[MAXNAMELEN - 1] != 0) { fprintf(stderr, \u0026#34;file name is too long: %s\\n\u0026#34;, path); // File already created, no way back from here. exit(1); } pdir-\u0026gt;f_type = FTYPE_DIR; for (struct dirent *e; (e = readdir(dir)) != NULL;) { if (strcmp(e-\u0026gt;d_name, \u0026#34;.\u0026#34;) != 0 \u0026amp;\u0026amp; strcmp(e-\u0026gt;d_name, \u0026#34;..\u0026#34;) != 0) { char *buf = malloc(strlen(path) + strlen(e-\u0026gt;d_name) + 2); sprintf(buf, \u0026#34;%s/%s\u0026#34;, path, e-\u0026gt;d_name); if (e-\u0026gt;d_type == DT_DIR) { write_directory(pdir, buf); } else { write_file(pdir, buf); } free(buf); } } closedir(dir); } ​\t在以上代码中，将普通文件写入磁盘镜像的功能函数为write_file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Write file to disk under specified dir. void write_file(struct File *dirf, const char *path) { int iblk = 0, r = 0, n = sizeof(disk[0].data); struct File *target = create_file(dirf); /* in case `create_file` is\u0026#39;t filled */ if (target == NULL) { return; } int fd = open(path, O_RDONLY); // Get file name with no path prefix. const char *fname = strrchr(path, \u0026#39;/\u0026#39;); if (fname) { fname++; } else { fname = path; } strcpy(target-\u0026gt;f_name, fname); target-\u0026gt;f_size = lseek(fd, 0, SEEK_END); target-\u0026gt;f_type = FTYPE_REG; // Start reading file. lseek(fd, 0, SEEK_SET); while ((r = read(fd, disk[nextbno].data, n)) \u0026gt; 0) { save_block_link(target, iblk++, next_block(BLOCK_DATA)); } close(fd); // Close file descriptor. } ​\t下面分析fs中Makefile制作磁盘镜像的命令\n1 2 3 4 5 6 image: $(tools_dir)/fsformat dd if=/dev/zero of=../target/fs.img bs=4096 count=1024 2\u0026gt;/dev/null dd if=/dev/zero of=../target/empty.img bs=4096 count=1024 2\u0026gt;/dev/null # using awk to remove paths with identical basename from FSIMGFILES $(tools_dir)/fsformat ../target/fs.img \\ $$(printf \u0026#39;%s\\n\u0026#39; $(FSIMGFILES) | awk -F/ \u0026#39;{ ns[$$NF]=$$0 } END { for (n in ns) { print ns[n] } }\u0026#39;) 可以看出制作磁盘镜像fs.img是在Makefile中通过image这个target完成的，使用已经编译好的fsformat程序，传入参数还不清楚\u0026hellip; 4.3 块缓存 ​\t块缓存是指借助虚拟内存来实现磁盘块缓存的设计，MOS操作系统中，文件系统服务是一个用户进程，一个进程可以拥有4GB的虚拟内存空间，将DISKMAP到DISKMAP+DISKMAX这一段虚拟地址空间作为缓冲区，当磁盘读入内存时，用来映射相关的页。\n​\t为了建立起磁盘地址空间和进程虚拟地址空间之间的缓存映射，我们采用的设计如图所示\nExercise 5.6 disk_addr函数计算指定磁盘块对应的虚存地址\n即根据一个块的序号，计算这一磁盘块对应的虚存的起始地址\nHint:我们已经知道，第一块磁盘被映射到DISKMAP，即起始虚拟地址为DISKMAP\n1 2 3 4 void *disk_addr(u_int blockno) { /* Exercise 5.6: Your code here. */ return (void*)(DISKMAP + blockno * BLOCK_SIZE); } Exercise 5.7 map_block | unmap_block\nmap_block：当一个磁盘块的内容载入到内存时，需要为之分配对应的物理内存，map_block完成了这一功能：检查指定的磁盘块是否已经映射到内存，如果没有， 分配一页内存来保存磁盘上的数据；相应地，完成unmap_block函数，用于解除磁盘块和 物理内存之间的映射关系，回收内存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Overview: // Allocate a page to cache the disk block. int map_block(u_int blockno) { // Step 1: If the block is already mapped in cache, return 0. // Hint: Use \u0026#39;block_is_mapped\u0026#39;. /* Exercise 5.7: Your code here. (1/5) */ if (block_is_mapped(blockno)) { return 0; } // Step 2: Alloc a page in permission \u0026#39;PTE_D\u0026#39; via syscall. // Hint: Use \u0026#39;disk_addr\u0026#39; for the virtual address. /* Exercise 5.7: Your code here. (2/5) */ return syscall_mem_alloc(0,disk_addr(blockno),PTE_D); } // Overview: // Unmap a disk block in cache. void unmap_block(u_int blockno) { // Step 1: Get the mapped address of the cache page of this block using \u0026#39;block_is_mapped\u0026#39;. void *va; /* Exercise 5.7: Your code here. (3/5) */ va = block_is_mapped(blockno); // Step 2: If this block is used (not free) and dirty in cache, write it back to the disk // first. // Hint: Use \u0026#39;block_is_free\u0026#39;, \u0026#39;block_is_dirty\u0026#39; to check, and \u0026#39;write_block\u0026#39; to sync. /* Exercise 5.7: Your code here. (4/5) */ if (!block_is_free(blockno) \u0026amp;\u0026amp; block_is_dirty(blockno)) { write_block(blockno); } // Step 3: Unmap the virtual address via syscall. /* Exercise 5.7: Your code here. (5/5) */ syscall_mem_unmap(0,va); user_assert(!block_is_mapped(blockno)); } 需要使用用户态的系统调用函数syscall_*进行内存的映射和解除映射 ​\tread_block和write_block函数用于读写磁盘块，read_block函数将制定编号的磁盘块读入到内存中，首先检查这块磁盘块是否已经在内存中，如果不在，先分配一页物理内存，然后调用ide_read函数来读取磁盘上的数据到对应的虚拟地址。\n​\tfile_get_block函数用于将某个指定的文件指向的磁盘块读入内存\n首先为即将读入内存的磁盘块分配物理内存 然后使用read_block函数将磁盘内容以块为单位读入内存中的相应位置 Exercise 5.8 dir_lookup 查找某个目录下是否存在指定的文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int dir_lookup(struct File *dir, char *name, struct File **file) { // Step 1: Calculate the number of blocks in \u0026#39;dir\u0026#39; via its size. u_int nblock; /* Exercise 5.8: Your code here. (1/3) */ nblock = dir-\u0026gt;f_size / BLOCK_SIZE; // Step 2: Iterate through all blocks in the directory. for (int i = 0; i \u0026lt; nblock; i++) { // Read the i\u0026#39;th block of \u0026#39;dir\u0026#39; and get its address in \u0026#39;blk\u0026#39; using \u0026#39;file_get_block\u0026#39;. void *blk; /* Exercise 5.8: Your code here. (2/3) */ try(file_get_block(dir, i, \u0026amp;blk)); struct File *files = (struct File *)blk; // Find the target among all \u0026#39;File\u0026#39;s in this block. for (struct File *f = files; f \u0026lt; files + FILE2BLK; ++f) { // Compare the file name against \u0026#39;name\u0026#39; using \u0026#39;strcmp\u0026#39;. // If we find the target file, set \u0026#39;*file\u0026#39; to it and set up its \u0026#39;f_dir\u0026#39; // field. /* Exercise 5.8: Your code here. (3/3) */ if (strcmp(name, f-\u0026gt;f_name) == 0) { *file = f; f-\u0026gt;f_dir = dir; return 0; } } } return -E_NOT_FOUND; } 通过strcmp比对文件名 文件系统结构部分的函数调用参考\n5.文件系统的用户接口 在文件系统建立之后，还需要向用户提供相关的使用接口，MOS操作系统内核是微内核设计，文件系统属于用户态进程，在其他进程与文件系统交互的过程中，涉及到进程通信问题\n5.1 文件描述符 fd : File Descripter\n文件描述符是系统给用户提供的整数，用于其在描述符表(Descripter Table)中进行索引，我们在作为操作系统的使用者进行文件IO编程时\n使用open在描述符表(FDTABLE)的指定位置存放被打开的文件的信息 使用close将描述符表中制定位置的文件信息释放 在write和read时修改描述符表指定位置的文件信息 指定位置即为文件描述符fd ​\t当用户进程试图打开一个文件时，文件系统服务进程需要一个文件描述符来存储文件的基本信息和用户进程中关于文件的状态，同时，文件描述符也起到描述用户对于文件操作的作用。\n​\t当用户进程向文件系统发送打开文件的请求时，文件系统进程会将这些基本信息记录在内存中，然后由操作系统将用户进程请求的地址映射到同一个存储了文件描述符的物理页上。因此一个文件描述符至少需要独占一页的空间。当用户进程获取了文件大小等基本信息后，再次向文件系统发送请求将文件内容映射到指定空间中。\n关于两个结构体之间的指针类型转换\n在file.c中，我们发现很多函数中都会将一个struct Fd*类型的指针转换为struct Filefd *类型的指针，这是C语言中的强制类型转换。\n强制类型转换不改变指针的值，只是改变程序对地址处数据的解释方式(指向的数据类型)\n两个结构体的定义如下\n1 2 3 4 5 6 7 8 9 10 struct Fd { u_int fd_dev_id; u_int fd_offset; u_int fd_omode; }; struct Filefd { struct Fd f_fd; u_int f_fileid; struct File f_file; }; Filefd结构体中第一个成员就是fd，因此指向Filefd的指针同样指向这个Fd的起始位置，可以进行转换\nExercise 5.9 open 打开文件或目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int open(const char *path, int mode) { int r; // Step 1: Alloc a new \u0026#39;Fd\u0026#39; using \u0026#39;fd_alloc\u0026#39; in fd.c. // Hint: return the error code if failed. struct Fd *fd; /* Exercise 5.9: Your code here. (1/5) */ try(fd_alloc(\u0026amp;fd)); // Step 2: Prepare the \u0026#39;fd\u0026#39; using \u0026#39;fsipc_open\u0026#39; in fsipc.c. /* Exercise 5.9: Your code here. (2/5) */ try(fsipc_open(path, mode, fd)); // Step 3: Set \u0026#39;va\u0026#39; to the address of the page where the \u0026#39;fd\u0026#39;\u0026#39;s data is cached, using // \u0026#39;fd2data\u0026#39;. Set \u0026#39;size\u0026#39; and \u0026#39;fileid\u0026#39; correctly with the value in \u0026#39;fd\u0026#39; as a \u0026#39;Filefd\u0026#39;. char *va; struct Filefd *ffd; u_int size, fileid; /* Exercise 5.9: Your code here. (3/5) */ va = fd2data(fd); ffd = (struct Filefd *)fd; size = ffd-\u0026gt;f_file.f_size; fileid = ffd-\u0026gt;f_fileid; // Step 4: Map the file content using \u0026#39;fsipc_map\u0026#39;. for (int i = 0; i \u0026lt; size; i += PTMAP) { /* Exercise 5.9: Your code here. (4/5) */ try(fsipc_map(fileid, i, va + i)); } // Step 5: Return the number of file descriptor using \u0026#39;fd2num\u0026#39;. /* Exercise 5.9: Your code here. (5/5) */ return fd2num(fd); } 对关键函数进行解读：该函数的作用是打开一个文件或目录\n首先为要打开的文件或目录(本质上都是文件)分配一个文件描述符，观察fd_alloc的逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int fd_alloc(struct Fd **fd) { u_int va; u_int fdno; for (fdno = 0; fdno \u0026lt; MAXFD - 1; fdno++) { va = INDEX2FD(fdno); if ((vpd[va / PDMAP] \u0026amp; PTE_V) == 0) { *fd = (struct Fd *)va; return 0; } if ((vpt[va / PTMAP] \u0026amp; PTE_V) == 0) { // the fd is not used *fd = (struct Fd *)va; return 0; } } return -E_MAX_OPEN; } 本质上是找到最小的没有被分配的文件描述符所对应的页，而一页对应一个文件描述符\nfsipc_open\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int fsipc_open(const char *path, u_int omode, struct Fd *fd) { u_int perm; struct Fsreq_open *req; req = (struct Fsreq_open *)fsipcbuf; // The path is too long. if (strlen(path) \u0026gt;= MAXPATHLEN) { return -E_BAD_PATH; } strcpy((char *)req-\u0026gt;req_path, path); req-\u0026gt;req_omode = omode; return fsipc(FSREQ_OPEN, req, fd, \u0026amp;perm); } 本质上是向文件系统发送打开文件的请求\nfsipc_map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int fsipc_map(u_int fileid, u_int offset, void *dstva) { int r; u_int perm; struct Fsreq_map *req; req = (struct Fsreq_map *)fsipcbuf; req-\u0026gt;req_fileid = fileid; req-\u0026gt;req_offset = offset; if ((r = fsipc(FSREQ_MAP, req, dstva, \u0026amp;perm)) \u0026lt; 0) { return r; } if ((perm \u0026amp; ~(PTE_D | PTE_LIBRARY)) != (PTE_V)) { user_panic(\u0026#34;fsipc_map: unexpected permissions %08x for dstva %08x\u0026#34;, perm, dstva); } return 0; } 向文件系统进程发出映射内存块的请求。\n​\t当要读取一个大文件中间的一小部分内容时，一个简单的做法是从头开始查找，但是开销较大；此外，在多次读写同一文件描述符期间，我们也希望能够从文件中前一次读写完毕的位置开始继续读写数据。因此，文件描述符中需要维护一个指针，帮助我们在文件中定位，在read/write/seek操作时，也需要更新该指针的值\nExercise 5.10 read函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int read(int fdnum, void *buf, u_int n) { int r; // Similar to the \u0026#39;write\u0026#39; function below. // Step 1: Get \u0026#39;fd\u0026#39; and \u0026#39;dev\u0026#39; using \u0026#39;fd_lookup\u0026#39; and \u0026#39;dev_lookup\u0026#39;. struct Dev *dev; struct Fd *fd; /* Exercise 5.10: Your code here. (1/4) */ if ((r = fd_lookup(fdnum, \u0026amp;fd)) \u0026lt; 0 || (r = dev_lookup(fd-\u0026gt;fd_dev_id, \u0026amp;dev)) \u0026lt; 0 ) { return r; } // Step 2: Check the open mode in \u0026#39;fd\u0026#39;. // Return -E_INVAL if the file is opened for writing only (O_WRONLY). /* Exercise 5.10: Your code here. (2/4) */ if ((fd-\u0026gt;fd_omode \u0026amp; O_ACCMODE) == O_WRONLY) { return -E_INVAL; } // Step 3: Read from \u0026#39;dev\u0026#39; into \u0026#39;buf\u0026#39; at the seek position (offset in \u0026#39;fd\u0026#39;). /* Exercise 5.10: Your code here. (3/4) */ r = dev-\u0026gt;dev_read(fd, buf, n, fd-\u0026gt;fd_offset); // Step 4: Update the offset in \u0026#39;fd\u0026#39; if the read is successful. /* Hint: DO NOT add a null terminator to the end of the buffer! * A character buffer is not a C string. Only the memory within [buf, buf+n) is safe to * use. */ /* Exercise 5.10: Your code here. (4/4) */ if (r \u0026gt; 0) { fd-\u0026gt;fd_offset += r; } return r; } 主要逻辑为调用设备的读取函数dev_read函数从文件当前的偏移位置读取数据到缓冲区中\n注意**(fd-\u0026gt;fd_omode \u0026amp; O_ACCMODE) == O_WRONLY**一定要加括号，否则运算优先级会有问题\n观察dev_read等设备函数\n1 2 3 4 5 6 7 8 9 struct Dev { int dev_id; char *dev_name; int (*dev_read)(struct Fd *, void *, u_int, u_int); int (*dev_write)(struct Fd *, const void *, u_int, u_int); int (*dev_close)(struct Fd *); int (*dev_stat)(struct Fd *, struct Stat *); int (*dev_seek)(struct Fd *, u_int); }; 在设备结构体中定义了一系列关于设备操作的函数，关于他们的具体实现可以在file.c中找到例子(不同设备的定义可能不同)\n1 2 3 4 5 6 7 8 struct Dev devfile = { .dev_id = \u0026#39;f\u0026#39;, .dev_name = \u0026#34;file\u0026#34;, .dev_read = file_read, .dev_write = file_write, .dev_close = file_close, .dev_stat = file_stat, }; 下面以file_read为例，即设备最终调用了这个函数，函数主体功能为memcpy，返回值为读取的长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static int file_read(struct Fd *fd, void *buf, u_int n, u_int offset) { u_int size; struct Filefd *f; f = (struct Filefd *)fd; // Avoid reading past the end of file. size = f-\u0026gt;f_file.f_size; if (offset \u0026gt; size) { return 0; } if (offset + n \u0026gt; size) { n = size - offset; } memcpy(buf, (char *)fd2data(fd) + offset, n); return n; } 5.2 文件系统服务 ​\tMOS操作系统中的文件服务通过IPC的方式供其他进程调用，进行文件读写操作。\n在内核启动时，启动了文件系统服务进程ENV_CREATE(fs_serv) 用户进程需要进行文件操作时，使用ipc_send,ipc_recv与fs_serv进行交互 ​\t在流程上，fs/serv.c中服务进程的主函数首先调用了serve_init函数准备好全局的文件打开记录表opentab，然后调用fs_init函数来初始化文件系统：\n首先通过读取超级块的内容获知磁盘的基本信息 然后检查磁盘是否能正常读写 最后调用read_bitmap函数检查磁盘块上的位图是否正确 ​\t执行完文件系统的初始化后，调用serve函数，文件系统服务开始运行，等待其他进程交互。\n1 2 3 4 5 6 7 8 9 10 11 int main() { user_assert(sizeof(struct File) == FILE_STRUCT_SIZE); debugf(\u0026#34;FS is running\\n\u0026#34;); serve_init(); fs_init(); serve(); return 0; } UML时序图如下(分析见实验报告)\n​\t用户进程向文件进程发送的请求如下\n1 2 3 4 5 6 7 8 9 10 enum { FSREQ_OPEN, FSREQ_MAP, FSREQ_SET_SIZE, FSREQ_CLOSE, FSREQ_DIRTY, FSREQ_REMOVE, FSREQ_SYNC, MAX_FSREQNO, }; 当用户程序发送文件系统操作请求时，将请求的内容放在对应的结构体中进行消息的传递。\nfs_serv进程收到其他进程的IPC操作后，IPC传递的消息包含了请求的类型和其他必要的参数，根据请求的类型(增/删/查/改)执行相应的文件操作\n结果重新通过IPC反馈给用户程序\nuser/lib/fsipc.c中定义了请求文件系统时用到的IPC操作\nuser/lib/file.c文件中定义了用户程序读写、创建、删除、修改文件的接口\n​\t下面三个练习实现删除指定路径文件的功能。\nExercise 5.11 fs/serv.c serve_remove\n1 2 3 4 5 6 7 8 9 void serve_remove(u_int envid, struct Fsreq_remove *rq) { // Step 1: Remove the file specified in \u0026#39;rq\u0026#39; using \u0026#39;file_remove\u0026#39; and store its return value. int r; /* Exercise 5.11: Your code here. (1/2) */ r = file_remove(rq-\u0026gt;req_path); // Step 2: Respond the return value to the caller \u0026#39;envid\u0026#39; using \u0026#39;ipc_send\u0026#39;. /* Exercise 5.11: Your code here. (2/2) */ ipc_send(envid, r, 0, 0); } Exercise 5.12 user/lib/fsipc.c fsipc_remove\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int fsipc_remove(const char *path) { // Step 1: Check the length of \u0026#39;path\u0026#39; using \u0026#39;strlen\u0026#39;. // If the length of path is 0 or larger than \u0026#39;MAXPATHLEN\u0026#39;, return -E_BAD_PATH. /* Exercise 5.12: Your code here. (1/3) */ if (strlen(path) == 0 || strlen(path) \u0026gt; MAXPATHLEN) { return -E_BAD_PATH; } // Step 2: Use \u0026#39;fsipcbuf\u0026#39; as a \u0026#39;struct Fsreq_remove\u0026#39;. struct Fsreq_remove *req = (struct Fsreq_remove *)fsipcbuf; // Step 3: Copy \u0026#39;path\u0026#39; into the path in \u0026#39;req\u0026#39; using \u0026#39;strcpy\u0026#39;. /* Exercise 5.12: Your code here. (2/3) */ strcpy(req-\u0026gt;req_path, path); // Step 4: Send request to the server using \u0026#39;fsipc\u0026#39;. /* Exercise 5.12: Your code here. (3/3) */ return fsipc(FSREQ_REMOVE, req, 0, 0); } Exercise 5.13 user/lib/file.c remove\n1 2 3 4 5 6 int remove(const char *path) { // Call fsipc_remove. /* Exercise 5.13: Your code here. */ return fsipc_remove(path); } ","permalink":"https://coder0xe.github.io/posts/os-lab5%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"oslab5课下基础\"\u003eOS:lab5课下基础\u003c/h1\u003e\n\u003ch2 id=\"1-文件系统概述\"\u003e1. 文件系统概述\u003c/h2\u003e\n\u003cp\u003e​\t\u003cstrong\u003e计算机文件系统是一种存储和组织数据的方法，便于访问和查找数据。\u003cstrong\u003e文件系统使用\u003c/strong\u003e文件\u003c/strong\u003e和\u003cstrong\u003e树形目录\u003c/strong\u003e的逻辑抽象屏蔽了底层硬盘和光盘等\u003cstrong\u003e物理设备基于数据块\u003c/strong\u003e进行存储和访问的复杂性。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e即用户不必关心数据实际保存在硬盘/光盘的哪个数据块上，而只需要记住这个文件所属的目录和文件名。\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e在写入新数据之前，用户不必关心硬盘上哪个块是空闲的，硬盘上的存储空间管理(分配/释放)由文件系统自动完成，用户只需记住数据写入到了哪个文件\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t常见的文件系统通常基于硬盘和光盘等块存储设备，并维护文件在设备中的物理位置。\u003c/p\u003e\n\u003cp\u003e​\t广义上，\u003cstrong\u003e一切带标识的、在逻辑上有完整意义的字节序列都可以称为文件\u003c/strong\u003e，文件系统将外部设备中的资源抽象为文件，从而可以统一管理外部设备，实现对数据的存储、组织、访问和修改。\u003c/p\u003e\n\u003ch2 id=\"2-文件系统的设计与实现\"\u003e2. 文件系统的设计与实现\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMOS是一种微内核设计\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将传统操作系统的文件系统移出内核\u003c/li\u003e\n\u003cli\u003e将一些内核数据暴露到用户空间\u003c/li\u003e\n\u003cli\u003e将传统操作系统的设备驱动移出内核\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240519144942685\" loading=\"lazy\" src=\"/img/image-20240519144942685.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"3-ide磁盘驱动\"\u003e3. IDE磁盘驱动\u003c/h2\u003e\n\u003cp\u003e​\t为了在磁盘等外部设备上实现文件系统，我们必须为这些外部设备编写驱动程序。(MOS已经在\u003ccode\u003ekern/mechine.c\u003c/code\u003e中实现了一个简单的控制台驱动程序)\u003c/p\u003e\n\u003cp\u003e​\t本次要实现的硬盘驱动程序与已经实现的串口驱动都采用MMIO内存映射技术，并且本次编写的\u003cstrong\u003e硬盘驱动程序完全运行在用户空间(微内核)\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"31-内存映射iommio\"\u003e3.1 内存映射I/O(MMIO)\u003c/h3\u003e\n\u003cp\u003e​\t几乎每一种外设都是通过读写设备上的寄存器来进行数据通信，外设寄存器也称为\u003cstrong\u003eI/O接口\u003c/strong\u003e，主要用来访问I/O设备。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e外设寄存器主要包括控制寄存器、状态寄存器、数据寄存器，这些寄存器被\u003cstrong\u003e映射到指定的物理地址空间\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t在MIPS的内核地址空间中(kseg0/kseg1)实现了\u003cstrong\u003e硬件级别(高位清0)的物理地址和内核虚拟地址的转换机制\u003c/strong\u003e，其中，对于kseg1段地址的读写不经过MMU映射，且不使用高速缓存，这正是外部设备驱动所需要的。\u003cstrong\u003e我们可以通过简单地读写某些固定的内核虚拟地址来实现驱动程序的功能。\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在之前的实验中，我们曾经使用KADDR宏将一个物理地址转换为kseg0段的虚拟地址，即加上kseg0段的偏移量(0x8000_0000)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e​\t\u003cstrong\u003e在编写设备驱动时，我们需要将物理地址转换为kseg1段的内核虚拟地址，即给物理地址加上kseg1的偏移值0xA000_0000\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e​\t以已经编写完成的串口设备驱动为例，MALTA提供的console设备基地址为0x1800_03F8，设备寄存器映射如表所示\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240519151254993\" loading=\"lazy\" src=\"/img/image-20240519151254993.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t例如写操作：通过向kseg1段的地址写入字符，就能在shell中看到对应的输出。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ekseg0_offset + device_op_addr_base = KSEG1 + MALTA_SERIAL_DATA\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//写\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eprintcharc\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e ch) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e((\u003cspan style=\"color:#ff79c6\"\u003evolatile\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003euint8_t\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e)(KSEG1 \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e MALTA_SERIAL_DATA)) \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e ch;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t在本次实验中，我们需要编写的IDE磁盘驱动位于用户空间，\u003cstrong\u003e用户态进程若是直接读写内核虚拟地址会引发一个地址错误ADEL/S，故对于设备的读写必须通过系统调用实现\u003c/strong\u003e\u003c/p\u003e","title":"OS:lab5课下基础"},{"content":"OO第三单元——JML 一. 单元架构设计 ​\t相比于前两单元需要自行设计架构，充当架构设计师的角色，U3不需要设计架构，需要完成的任务是依据课程组给出的架构设计合理的类协作关系以及依据JML写对应的代码(码农日常)。\n​\t关于课程组给出的架构可以简单概括如下图\n二. 算法实现与性能 ​\t本单元更加关注的是对于既定的JML或者说给定的功能要求，具体的算法实现和效率。强测中对于性能有一定要求，性能不佳会爆CTLE。我的理解中，CTLE字面意思上是CPU时间超时，换句话说其实就是**“算的次数太多“**，在本单元作业中，可以采用缓存一些计算复杂度较高的结果进行优化等，下面基于每一次作业进行分析。\n1. hw9 ​\t这一次作业中主要的性能考察点是关于query_block_sum中查询两个点是否联通的功能。在本次作业中，通过addRelation和modifyRelation可以建立起一个社交图，这其中需要注意的是modifyRelation操作可能删边。很多大佬同学实现了可以删边的并查集，我选择了实现较为简单(懒)的BFS。使用BFS进行联通查询面对大量查询指令有CTLE风险，故可以考虑对BFS进行一点简单优化，例如使用双向BFS。关于双向BFS，其实就是从起点和终点同时开始搜索，面对图中点非常多的情况可以大幅减少开销。\n​\t下面是一张摘自广度优先搜索之双向bfs（实操篇）-CSDN博客的一张很形象的图片。\n​\t双向BFS的优势其实就是大幅减少搜索宽度，减少遍历一些点，让它看上去没有那么暴力。由此还有一种优化的思路就是均衡取节点。当我们从给起点和终点分别设置的队列中取节点时，可以选择从size较小的那一个队列中取出(size较大的那一方说明他每一层中的宽度较大，遍历开销大)。下面给出我的具体实现（主要想法是起点终点两个队列两个visited数组，当前遍历如果另一边如果遍历过，结束）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.HashMap; import java.util.LinkedList; import java.util.Queue; public class BreadthFirstSearch { public static boolean isConnected(MyPerson person1,MyPerson person2) { if (person1.getId() == person2.getId()) { return true; } HashMap\u0026lt;Integer, Boolean\u0026gt; visited1 = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Integer, Boolean\u0026gt; visited2 = new HashMap\u0026lt;\u0026gt;(); visited1.put(person1.getId(),true); visited2.put(person2.getId(),true); Queue\u0026lt;MyPerson\u0026gt; queue1 = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;MyPerson\u0026gt; queue2 = new LinkedList\u0026lt;\u0026gt;(); queue1.add(person1); queue2.add(person2); while (!queue1.isEmpty() \u0026amp;\u0026amp; !queue2.isEmpty()) { if (queue1.size() \u0026lt; queue2.size()) { MyPerson now = queue1.poll(); if (next(now,visited1,visited2,queue1)) { return true; } } else { MyPerson now = queue2.poll(); if (next(now,visited2,visited1,queue2)) { return true; } } } return false; } private static boolean next(MyPerson now,HashMap\u0026lt;Integer,Boolean\u0026gt; visited, HashMap\u0026lt;Integer,Boolean\u0026gt; visited2,Queue\u0026lt;MyPerson\u0026gt; queue) { for (Person next : now.getAcquaintance().values()) { if (visited.containsKey(next.getId())) { continue; } if (visited2.containsKey(next.getId())) { return true; } queue.add((MyPerson) next); visited.put(next.getId(),true); } return false; } } ​\t对于另一个查询指令query_triple_sum也需要进行动态维护，在addRelation加边和modifyRelation删边时进行判断，并更新qts的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private void addTripleRelation(MyPerson person1,MyPerson person2) { for (Person person : person1.getAcquaintance().values()) { if (person2.isLinked(person)) { this.triple++; } } } private void deleteTripleRelation(MyPerson person1,MyPerson person2) { for (Person person : person1.getAcquaintance().values()) { if (person2.isLinked(person)) { this.triple--; } } } 2. hw10 ​\t在本次作业中主要的性能优化点主要是最短路径查询(懒人BFS)，以及一些计算结果的动态维护，最后是对于查询每个人的最好的朋友的优先队列实现。\n​\t首先是最短路径查询，无权图的最短路径查询可以用BFS算法，基于BFS的优化例如双向BFS上面已经介绍过，**但是需要注意的是，如果采用双向BFS进行最短路径查询，已经要保证起点和终点查询到的层数是一致的，即不要进行均衡取节点的优化，如果出现了查询速度不一致(起点和终点查询到的层数不一致)的问题，找到的路径不一定是最短路径。**所以本懒人果断选择写一个简单的BFS\u0026hellip;\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public static int shortestPath(MyPerson person1, MyPerson person2) { if (person1.getId() == person2.getId()) { return 0; } HashMap\u0026lt;Integer, Integer\u0026gt; visited = new HashMap\u0026lt;\u0026gt;(); visited.put(person1.getId(),0); Queue\u0026lt;MyPerson\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(person1); while (!queue.isEmpty()) { MyPerson now = queue.poll(); int step = visited.get(now.getId()); for (Person next : now.getAcquaintance().values()) { if (visited.containsKey(next.getId())) { continue; } if (next.getId() == person2.getId()) { return step + 1; } queue.add((MyPerson) next); visited.put(next.getId(),step + 1); } } return -1; } ​\t关于计算结果的动态维护，包括tag中人的年龄的均值，年龄的方差，socialValue之和，通过在MyTag类中维护年龄之和，年龄的平方和以及socialValue实现。\n​\t关于方差的计算，可以改写公式便于计算\n1 (agePowSum - 2 * ageSum * getAgeMean() +persons.size() * getAgeMean() * getAgeMean()) / persons.size(); ​\t给出一个比较典型的在向tag中加人时对于这些属性的动态维护为例子\n1 2 3 4 5 6 7 8 9 10 public void addPerson(Person person) { ageSum += person.getAge(); agePowSum += person.getAge() * person.getAge(); persons.put(person.getId(), person); for (int id : persons.keySet()) { if (person.isLinked(persons.get(id))) { valueSum += 2 * person.queryValue(persons.get(id)); } } } ​\t关于查询每个人value最高的好友，java中有很好的支持，只需要对TreeSet类重写一个compare方法实现双关键字比较。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private final TreeSet\u0026lt;Person\u0026gt; sortedAquaintance = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person o1, Person o2) { //按照value从高到低排序 id从小到大 int r = value.get(o2.getId()).compareTo(value.get(o1.getId())); if (r == 0) { return Integer.compare(o1.getId(),o2.getId()); } else { return r; } } }); public Person getBestAcquaintance() { return sortedAquaintance.first(); } ​\t比较时需要注意的是要用Integer内置的compareTo方法，有同学用减法进行比较，产生了溢出的bug(不得不说数据挺强的)\n3. hw11 ​\t这一次作业新增的功能只要老老实实实现JML，没有特殊的性能优化点（或者有我没发现），或者更笼统的说，本单元的作业中，凡是id唯一的对象(例如Person，Message等)都可以用HashMap等类进行存储，优化查询效率，算是一点补充。\n三.JUnit与测试 ​\tJUnit很好的符合了JML语言，在三次作业中编写参数化JUnit测试时，我都采用了对照JML进行翻译的方式。JUnit的编写过程主要是生成数据和进行检查两步，在进行检查时，我选择不考虑效率地按照JML描述写出对应的功能代码，将改代码的运行结果与我编写的代码的运行结果进行比较，并对调用自己编写方法后的元素进行ensures检查。\n​\t在以往的测试中，我们大都是采用黑盒测试的方法，即我们不关心代码的内部实现，给代码提供输入，检查输出的正确性，这也是我在进行自测或互测时大部分时间采用的方法。黑盒测试的弊端是，生成数据对于代码的覆盖率可能不够高，对于一些分支情况或边角细节无法覆盖，这样的缺点可以通过白盒测试解决，即我们去梳理代码内部的逻辑进行检查，并编写相应的数据进行测试，这样的测试开销是比较大的，但是可以更大程度上保证软件的安全性。\n​\t单元测试：单元测试是完成最小的软件设计单元（模块）的验证工作目标是确保模块被正确的编码，通常情况下是白盒的。\n​\t功能测试：测试代码的功能是否满足要求，即我们常说的代码正确性部分\n​\t集成测试：测试对于不同模块之间的接口，测试他们之间的协同配合工作是否正常，一般是由黑盒测试与静态白盒测试相结合。\n​\t压力测试：压力测试即面对大量数据、边界数据，软件是否能以正常的效率以及正确性完成任务，类似于我们的强测。\n​\t回归测试：回归测试是指在完成新的代码编写后对原能够通过的数据点进行检查，类似于我们的bug修复环节对于已通过测试点的检查。\n四. JML学习体会 ​\t在本单元中，对于JML语言的学习让我收获颇丰。契约式编程可以在很大程度上减少bug的产生，JML类数学化的表述避免了自然语言描述中可能产生的一千个人心中有一千个哈姆雷特的歧义问题。JML对于前置条件、副作用、后置条件的明确规定也让编程者更加清楚的知道该方法的功能实现，并利于测试工程师编写测试代码。\n​\t在本单元中另一个主题就是设计与规格分离。JML只是为我们规定该方法的规格，具体的实现、选择算法以及数据结构由我们自行设计，而这也正是相同的规格不同的执行效率差异所在。在这一单元中，我采用了一以贯之的BFS算法，一点小优化是双向BFS，说我懒的话我没有辩解的理由。我的一贯指导思想是“够用就行”，我认为在软件开发中也有借鉴意义。登峰造极的优化固然让人钦佩，但是在满足甲方的要求条件下偷懒也未尝不算英雄。\n","permalink":"https://coder0xe.github.io/posts/oo-unit3/","summary":"\u003ch1 id=\"oo第三单元jml\"\u003eOO第三单元——JML\u003c/h1\u003e\n\u003ch2 id=\"一-单元架构设计\"\u003e一. 单元架构设计\u003c/h2\u003e\n\u003cp\u003e​\t相比于前两单元需要自行设计架构，充当架构设计师的角色，U3不需要设计架构，需要完成的任务是依据课程组给出的架构设计合理的类协作关系以及依据JML写对应的代码(\u003cdel\u003e码农日常\u003c/del\u003e)。\u003c/p\u003e\n\u003cp\u003e​\t关于课程组给出的架构可以简单概括如下图\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240516111936570\" loading=\"lazy\" src=\"/img/image-20240516111936570.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"二-算法实现与性能\"\u003e二. 算法实现与性能\u003c/h2\u003e\n\u003cp\u003e​\t本单元更加关注的是对于既定的JML或者说给定的功能要求，具体的算法实现和效率。强测中对于性能有一定要求，性能不佳会爆CTLE。我的理解中，CTLE字面意思上是CPU时间超时，换句话说其实就是**“算的次数太多“**，在本单元作业中，可以采用缓存一些计算复杂度较高的结果进行优化等，下面基于每一次作业进行分析。\u003c/p\u003e\n\u003ch3 id=\"1-hw9\"\u003e1. hw9\u003c/h3\u003e\n\u003cp\u003e​\t这一次作业中主要的性能考察点是关于\u003ccode\u003equery_block_sum\u003c/code\u003e中查询两个点是否联通的功能。在本次作业中，通过\u003ccode\u003eaddRelation\u003c/code\u003e和\u003ccode\u003emodifyRelation\u003c/code\u003e可以建立起一个社交图，\u003cstrong\u003e这其中需要注意的是modifyRelation操作可能删边\u003c/strong\u003e。很多大佬同学实现了可以删边的并查集，我选择了实现较为简单(\u003cdel\u003e懒\u003c/del\u003e)的BFS。使用BFS进行联通查询面对大量查询指令有CTLE风险，故可以考虑对BFS进行一点简单优化，例如使用双向BFS。\u003cstrong\u003e关于双向BFS，其实就是从起点和终点同时开始搜索，面对图中点非常多的情况可以大幅减少开销。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e​\t下面是一张摘自\u003ca href=\"https://blog.csdn.net/asd0356/article/details/118311064\"\u003e广度优先搜索之双向bfs（实操篇）-CSDN博客\u003c/a\u003e的一张很形象的图片。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzZDAzNTY=,size_16,color_FFFFFF,t_70.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t双向BFS的优势其实就是大幅减少搜索宽度，减少遍历一些点，让它看上去没有那么暴力。由此还有一种优化的思路就是\u003cstrong\u003e均衡取节点\u003c/strong\u003e。当我们从给起点和终点分别设置的队列中取节点时，可以选择从size较小的那一个队列中取出(size较大的那一方说明他每一层中的宽度较大，遍历开销大)。下面给出我的具体实现（主要想法是起点终点两个队列两个visited数组，当前遍历如果另一边如果遍历过，结束）：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e46\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e47\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e48\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eimport\u003c/span\u003e java.util.HashMap;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eimport\u003c/span\u003e java.util.LinkedList;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eimport\u003c/span\u003e java.util.Queue;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eBreadthFirstSearch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eboolean\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eisConnected\u003c/span\u003e(MyPerson person1,MyPerson person2) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (person1.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e() \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e person2.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        HashMap\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eInteger, Boolean\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e visited1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e HashMap\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        HashMap\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eInteger, Boolean\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e visited2 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e HashMap\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        visited1.\u003cspan style=\"color:#50fa7b\"\u003eput\u003c/span\u003e(person1.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e(),\u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        visited2.\u003cspan style=\"color:#50fa7b\"\u003eput\u003c/span\u003e(person2.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e(),\u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Queue\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eMyPerson\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e queue1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e LinkedList\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Queue\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eMyPerson\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e queue2 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e LinkedList\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        queue1.\u003cspan style=\"color:#50fa7b\"\u003eadd\u003c/span\u003e(person1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        queue2.\u003cspan style=\"color:#50fa7b\"\u003eadd\u003c/span\u003e(person2);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003ewhile\u003c/span\u003e (\u003cspan style=\"color:#ff79c6\"\u003e!\u003c/span\u003equeue1.\u003cspan style=\"color:#50fa7b\"\u003eisEmpty\u003c/span\u003e() \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e!\u003c/span\u003equeue2.\u003cspan style=\"color:#50fa7b\"\u003eisEmpty\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (queue1.\u003cspan style=\"color:#50fa7b\"\u003esize\u003c/span\u003e() \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e queue2.\u003cspan style=\"color:#50fa7b\"\u003esize\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                MyPerson now \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e queue1.\u003cspan style=\"color:#50fa7b\"\u003epoll\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (next(now,visited1,visited2,queue1)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            } \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                MyPerson now \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e queue2.\u003cspan style=\"color:#50fa7b\"\u003epoll\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (next(now,visited2,visited1,queue2)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eboolean\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003enext\u003c/span\u003e(MyPerson now,HashMap\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eInteger,Boolean\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e visited,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                HashMap\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eInteger,Boolean\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e visited2,Queue\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eMyPerson\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e queue) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (Person next : now.\u003cspan style=\"color:#50fa7b\"\u003egetAcquaintance\u003c/span\u003e().\u003cspan style=\"color:#50fa7b\"\u003evalues\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (visited.\u003cspan style=\"color:#50fa7b\"\u003econtainsKey\u003c/span\u003e(next.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e())) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003econtinue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (visited2.\u003cspan style=\"color:#50fa7b\"\u003econtainsKey\u003c/span\u003e(next.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e())) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            queue.\u003cspan style=\"color:#50fa7b\"\u003eadd\u003c/span\u003e((MyPerson) next);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            visited.\u003cspan style=\"color:#50fa7b\"\u003eput\u003c/span\u003e(next.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e(),\u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t对于另一个查询指令\u003ccode\u003equery_triple_sum\u003c/code\u003e也需要进行动态维护，在\u003ccode\u003eaddRelation\u003c/code\u003e加边和\u003ccode\u003emodifyRelation\u003c/code\u003e删边时进行判断，并更新\u003ccode\u003eqts\u003c/code\u003e的值。\u003c/p\u003e","title":"OO-Unit3"},{"content":"OS第五次理论作业 有五个进程 P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表\n进程 处理器时间 优先级（数小优先级高） P1 10 3 P2 1 1 P3 2 3 P4 1 4 P5 5 2 忽略进行调度等所花费的时间，回答下列问题:\n写出采用 “先来先服务”、“短作业（进程）优先”、“非抢占式的优先数” 和 “轮转法” 等调度算法，进程执行的次序。（其中轮转法的时间片为 2）\n先来先服务: P1,P2,P3,P4,P5 短作业优先: P2,P4,P3,P5,P1 非抢占式的优先数: P2,P5,P1,P3,P4 轮转法: P1,P2,P3,P4,P5,P1,P5,P1,P5,P1 分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间\n先来先服务\n进程 周转时间 等待时间 执行时间 P1 10 0 10 P2 11 10 1 P3 13 11 2 P4 14 13 1 P5 19 14 5 平均周转时间：$(10+11+13+14+19)/5=13.4$ 短作业优先\n进程 周转时间 等待时间 执行时间 P2 1 0 1 P4 2 1 1 P3 4 2 2 P5 9 4 5 P1 19 9 10 平均周转时间：$(1+2+4+9+19)/5=7$ 非抢占式的优先数\n进程 周转时间 等待时间 执行时间 P2 1 0 1 P5 6 1 5 P1 16 6 10 P3 18 16 2 P4 19 18 1 平均周转时间：$(1+6+16+18+19)/5=12$​ 时间片轮转\n进程 周转时间 等待时间 执行时间 P1 19 9 10 P2 3 2 1 P3 5 3 2 P4 6 5 1 P5 15 10 5 平均周转时间：$(19+3+5+6+15)/5=9.6$​ 死锁产生的四个必要条件是什么？\n互斥条件：指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只能有一个进程占有 保持和请求条件：已经获得资源的线程可以请求新的资源 不剥夺条件：指进程已获得的资源，在未使用完之前不能被强制剥夺，只能在使用完时由自己释放 环路等待条件：指在发生死锁时，必然存在两个或多个进程组成的环形链，每个进程都在等待环形链中下一个节点占用的资源 某系统中有n个进程和m台打印机，系统约定：打印机只能一台一台地申请、一台一台地释 放，每个进程需要同时使用的打印机台数不超过m。如果n个进程同时需要使用打印机的总 数小于m+n，试讨论，该系统可能发生死锁吗?并简述理由。\n该系统不可能发生死锁 设n个进程中每个进程同时需要使用x个打印机,$1\u0026lt;=x\u0026lt;=m,nx\u0026lt;m+n$​ 若发生死锁，需要n个进程各取得x-1个打印机时，同时再需要最后一个打印机时没有打印机了，即$m \u0026lt; n(x-1)$，即$m+n\u0026lt;nx$矛盾 故不可能发生死锁 线程的基本概念是什么？引入线程的好处是什么？\n线程是进程中的一个实体，是CPU调度的基本单位，是可执行单元，只包含少量资源 将资源与计算分离，提高并发效率 假设具有5个进程的进程集合$P={P0,P1,P2,P3,P4}$​，系统中有三类资源A,B,C，假设在某时刻有如下状态\nAllocation Max Available A B C A B C A B C P0 0 0 3 0 0 4 1 4 0 P1 1 0 0 1 7 5 P2 1 3 5 2 3 5 P3 0 0 2 0 6 4 P4 0 0 1 0 6 5 根据上表，当前系统是否处于安全状态\n使用安全性算法进行判断(工作向量Work)，补充work和need列\n进程 work need allocation work + allocation finish A B C A B C A B C A B C P2 1 4 0 1 0 0 1 3 5 2 7 5 true P0 2 7 5 0 0 1 0 0 3 2 7 8 true P1 2 7 8 0 7 5 1 0 0 3 7 8 true P3 3 7 8 0 6 2 0 0 2 3 7 10 true P4 3 7 10 0 6 4 0 0 1 3 6 11 true 故当前系统处于安全状态\n若系统中的可利用资源Available为(0,6,2)，系统是否安全？若系统共处在安全状态，请给出安全序列；若处在非安全状态，简要说明原因。\n进程 work need allocation work + allocation finish A B C A B C A B C A B C P3 0 6 2 0 6 4 0 0 2 0 6 4 true P4 0 6 4 0 6 5 0 0 1 0 6 5 true P0 0 6 5 0 0 1 0 0 3 0 6 8 true 0 6 8 不能给出安全序列，故系统不安全\n","permalink":"https://coder0xe.github.io/posts/os%E7%AC%AC%E4%BA%94%E6%AC%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/","summary":"\u003ch1 id=\"os第五次理论作业\"\u003eOS第五次理论作业\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e有五个进程 P1、P2、P3、P4、P5，它们\u003cstrong\u003e同时\u003c/strong\u003e依次进入就绪队列，它们的优先数和需要的处理器时间如下表\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e进程\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e处理器时间\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e优先级（数小优先级高）\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e10\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e3\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP2\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP3\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e2\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e3\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP4\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e4\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP5\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e5\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e忽略进行调度等所花费的时间，回答下列问题:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e写出采用 “先来先服务”、“短作业（进程）优先”、“非抢占式的优先数” 和 “轮转法” 等调度算法，进程执行的次序。（其中轮转法的时间片为 2）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先来先服务: P1,P2,P3,P4,P5\u003c/li\u003e\n\u003cli\u003e短作业优先: P2,P4,P3,P5,P1\u003c/li\u003e\n\u003cli\u003e非抢占式的优先数: P2,P5,P1,P3,P4\u003c/li\u003e\n\u003cli\u003e轮转法: P1,P2,P3,P4,P5,P1,P5,P1,P5,P1\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e先来先服务\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e进程\u003c/th\u003e\n          \u003cth\u003e周转时间\u003c/th\u003e\n          \u003cth\u003e等待时间\u003c/th\u003e\n          \u003cth\u003e执行时间\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP1\u003c/td\u003e\n          \u003ctd\u003e10\u003c/td\u003e\n          \u003ctd\u003e0\u003c/td\u003e\n          \u003ctd\u003e10\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP2\u003c/td\u003e\n          \u003ctd\u003e11\u003c/td\u003e\n          \u003ctd\u003e10\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP3\u003c/td\u003e\n          \u003ctd\u003e13\u003c/td\u003e\n          \u003ctd\u003e11\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP4\u003c/td\u003e\n          \u003ctd\u003e14\u003c/td\u003e\n          \u003ctd\u003e13\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP5\u003c/td\u003e\n          \u003ctd\u003e19\u003c/td\u003e\n          \u003ctd\u003e14\u003c/td\u003e\n          \u003ctd\u003e5\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cul\u003e\n\u003cli\u003e平均周转时间：$(10+11+13+14+19)/5=13.4$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e短作业优先\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e进程\u003c/th\u003e\n          \u003cth\u003e周转时间\u003c/th\u003e\n          \u003cth\u003e等待时间\u003c/th\u003e\n          \u003cth\u003e执行时间\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP2\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e0\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP4\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP3\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP5\u003c/td\u003e\n          \u003ctd\u003e9\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n          \u003ctd\u003e5\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eP1\u003c/td\u003e\n          \u003ctd\u003e19\u003c/td\u003e\n          \u003ctd\u003e9\u003c/td\u003e\n          \u003ctd\u003e10\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cul\u003e\n\u003cli\u003e平均周转时间：$(1+2+4+9+19)/5=7$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e非抢占式的优先数\u003c/p\u003e","title":"OS第五次理论作业"},{"content":"OS第四次理论作业 1.读者写者问题（写者优先）: 1）共享读; 2）互斥写、读写互斥; 3）写者优先于读者（一 旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 int readcount = 0; int writecount = 0; semaphore mutex = 1;//信号量为1相当于互斥锁 semaphore write = 1; semaphore read = 1; semaphore r_wait = 1; writer() { P(write); // 保护 writecount writecount++; if(writecount == 1) { P(r_wait); // 有写入的，暂停读 } V(write); P(mutex); // 互斥写 write_data(); V(mutex); P(write); writecount--; if(writecount == 0) { // 没有写入的，恢复读 V(r_wait); } V(write); } reader() { P(r_wait); // 如果有写入的或等待写入的，暂停读，实现写优先于读 P(read); // 保护 readcount if(readcount == 0) { P(mutex); // 第一个读的，加锁 } readcount++; V(read); V(r_wait); read_data(); P(read); readcount--; if (readcount == 0) { // 最后一个读的，解锁 V(mutex); } V(read); } 2.寿司店问题。假设一个寿司店有 5 个座位，如果你到达的时候有一个空座位，你可以立 刻就坐。但是如果你到达的时候 5 个座位都是满的有人已经就坐，这就意味着这些人都是一 起来吃饭的，那么你需要等待所有的人一起离开才能就坐。编写同步原语，实现这个场景的约束。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int eating = 0, waiting = 0; Semaphore mutex = 1, queue = 1; bool must_wait = false; Customer(){ P(mutex); if (must_wait){ waiting++; V(mutex); // 对 waiting 变量的保护可以释放 P(queue); // 被阻塞，坐着等待排队，等待被唤醒 } else { eating++; must_wait = (eating == 5); V(mutex); // 对 eating 变量的保护可以释放 } // 上一部分已经解决了进店后是等待还是吃的问题 Eat_sushi();// else 的人和被唤醒的排队者成功进入这一步 P(mutex); // 开启对 eating, waiting 变量保护 eating--; // 吃的人 -1, 如果 5 个没全吃完，不可以换下一批人吃 if (eating == 0){ // 最后一个吃完的人离开才可以进顾客 int n = min(5, waiting); // 放顾客进来的数量，不超过 5 个 waiting -= n; eating +=n; must_wait = (eating == 5); for(int i = 0; i\u0026lt;n; i++){ V(queue); // 唤醒排队的 n 个人继续进程 } V(mutex); // 允许下一个吃完的人对变量和队列进行操作 } } 3.进门问题。（1）请给出P、V操作和信号量的物理意义。（2）一个软件公司有5名员工， 每人刷卡上班。员工刷卡后需要等待，直到所有员工都刷卡后才能进入公司。为了避免拥挤， 公司要求员工一个一个通过大门。所有员工都进入后，最后进入的员工负责关门。请用 P、 V 操作实现员工之间的同步关系 P操作：请求一个资源，V操作：释放一个资源\n第二问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int N; Semaphore empty = N; // 假设初始条件下缓冲区有 N 个空位 Semaphore mutex = 1; Semaphore odd = 0; Semaphore even = 0; void P1(){ int integer; while(true){ integer = produce(); // 生成一个整数 P(empty); // 若 empty 为 0 则会被阻塞（等待别人拿走） P(mutex); // 开始互斥，保护缓冲区 put(); // 放入缓冲区 V(mutex); // 访问临界区结束 if(integer %2 == 0){ V(even); // 是偶数 } else { V(odd); // 是奇数 } } } void P2(){ while(true){ P(odd); // 请求一个奇数 P(mutex); // 互斥 getodd(); V(mutex); V(empty); // 缓冲区多一个位置 countodd(); } } void P3(){ while(true){ P(even); // 请求一个偶数 P(mutex); // 互斥 geteven(); V(mutex); V(empty); // 缓冲区多一个位置 counteven(); } } 4.搜索-插入-删除问题。三个线程对一个单链表进行并发的访问，分别进行搜索、插入和删 除。搜索线程仅仅读取链表，因此多个搜索线程可以并发。插入线程把数据项插入到链表最 后的位置；多个插入线程必须互斥防止同时执行插入操作。但是，一个插入线程可以和多个 搜索线程并发执行。最后，删除线程可以从链表中任何一个位置删除数据。一次只能有一个 删除线程执行；删除线程之间，删除线程和搜索线程，删除线程和插入线程都不能同时执行。 请编写三类线程的同步互斥代码，描述这种三路的分类互斥问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Semaphore insertMutex =1, searchMutex = 1; // 保护 int 变量 Semaphore No_search = 1; // 顾名思义，为 1 时没有搜索进程访问 Semaphore No_insert = 1; // 为 1 时没有插入进程访问 // 当上述两个信号量同时为 1，删除者才可以进行删除操作 int searcher = 0, inserter = 0; void Search(){ P(searchMutex); // 保护 searcher searcher++; if (searcher == 1) // 第一个进来的搜索者加锁 P(No_search) V(searchMutex); Searching(); P(searchMutex); searcher--; if (searcher == 0) V(No_search); // 表示此时没有搜索线程在进行，解锁 V(searchMutex); } void Insert(){ P(insertMutex); inserter++; if (inserter == 1) P(No_insert) V(insertMutex); P(insertMutex); // 既然可以和搜索线程并行，那么不用管 Searcher Inserting(); // 访问临界区，多个插入者要互斥访问，一次一个 insert V(insertMutex); P(insertMutex); inserter--; if (inserter == 0) V(No_insert); // 解锁，可唤醒删除者 V(insertMutex); } void Delete(){ // 删除线程与其他任何线程互斥 P(No_search); P(No_insert); // 若为 1 则可进入，这个信号量顺便也可以当作删除者的互斥保护 Deleting(); // 搜索和插入线程都没，成功进入临界区 V(No_insert); V(No_search); } ","permalink":"https://coder0xe.github.io/posts/os%E7%AC%AC%E5%9B%9B%E6%AC%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/","summary":"\u003ch1 id=\"os第四次理论作业\"\u003eOS第四次理论作业\u003c/h1\u003e\n\u003ch3 id=\"1读者写者问题写者优先-1共享读-2互斥写读写互斥-3写者优先于读者一-旦有写者则后续读者必须等待唤醒时优先考虑写者\"\u003e1.读者写者问题（写者优先）: 1）共享读; 2）互斥写、读写互斥; 3）写者优先于读者（一 旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e46\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e readcount \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e writecount \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esemaphore mutex \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;\u003cspan style=\"color:#6272a4\"\u003e//信号量为1相当于互斥锁\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esemaphore write \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esemaphore read \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esemaphore r_wait \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#50fa7b\"\u003ewriter\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(write);   \u003cspan style=\"color:#6272a4\"\u003e// 保护 writecount\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    writecount\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(writecount \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(r_wait);      \u003cspan style=\"color:#6272a4\"\u003e// 有写入的，暂停读 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(write);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(mutex);   \u003cspan style=\"color:#6272a4\"\u003e// 互斥写 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003ewrite_data\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(mutex);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(write);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    writecount\u003cspan style=\"color:#ff79c6\"\u003e--\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(writecount \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {   \u003cspan style=\"color:#6272a4\"\u003e// 没有写入的，恢复读 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(r_wait);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(write);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#50fa7b\"\u003ereader\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(r_wait);  \u003cspan style=\"color:#6272a4\"\u003e// 如果有写入的或等待写入的，暂停读，实现写优先于读\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(read);    \u003cspan style=\"color:#6272a4\"\u003e// 保护 readcount\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(readcount \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(mutex);   \u003cspan style=\"color:#6272a4\"\u003e// 第一个读的，加锁 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    readcount\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(read);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(r_wait);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eread_data\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(read);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    readcount\u003cspan style=\"color:#ff79c6\"\u003e--\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (readcount \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {   \u003cspan style=\"color:#6272a4\"\u003e// 最后一个读的，解锁 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(mutex);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(read);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2寿司店问题假设一个寿司店有-5-个座位如果你到达的时候有一个空座位你可以立-刻就坐但是如果你到达的时候-5-个座位都是满的有人已经就坐这就意味着这些人都是一-起来吃饭的那么你需要等待所有的人一起离开才能就坐编写同步原语实现这个场景的约束\"\u003e2.寿司店问题。假设一个寿司店有 5 个座位，如果你到达的时候有一个空座位，你可以立 刻就坐。但是如果你到达的时候 5 个座位都是满的有人已经就坐，这就意味着这些人都是一 起来吃饭的，那么你需要等待所有的人一起离开才能就坐。编写同步原语，实现这个场景的约束。\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e31\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e eating \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, waiting \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eSemaphore mutex \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e, queue \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ebool\u003c/span\u003e must_wait \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#50fa7b\"\u003eCustomer\u003c/span\u003e(){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(mutex);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (must_wait){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        waiting\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(mutex); \u003cspan style=\"color:#6272a4\"\u003e// 对 waiting 变量的保护可以释放 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(queue); \u003cspan style=\"color:#6272a4\"\u003e// 被阻塞，坐着等待排队，等待被唤醒 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        eating\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        must_wait \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (eating \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(mutex); \u003cspan style=\"color:#6272a4\"\u003e// 对 eating 变量的保护可以释放 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// 上一部分已经解决了进店后是等待还是吃的问题 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eEat_sushi\u003c/span\u003e();\u003cspan style=\"color:#6272a4\"\u003e// else 的人和被唤醒的排队者成功进入这一步 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eP\u003c/span\u003e(mutex);   \u003cspan style=\"color:#6272a4\"\u003e// 开启对 eating, waiting 变量保护 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    eating\u003cspan style=\"color:#ff79c6\"\u003e--\u003c/span\u003e;  \u003cspan style=\"color:#6272a4\"\u003e// 吃的人 -1, 如果 5 个没全吃完，不可以换下一批人吃 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (eating \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e){ \u003cspan style=\"color:#6272a4\"\u003e// 最后一个吃完的人离开才可以进顾客 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003emin\u003c/span\u003e(\u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e, waiting); \u003cspan style=\"color:#6272a4\"\u003e// 放顾客进来的数量，不超过 5 个 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        waiting \u003cspan style=\"color:#ff79c6\"\u003e-=\u003c/span\u003e n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        eating \u003cspan style=\"color:#ff79c6\"\u003e+=\u003c/span\u003en;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        must_wait \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (eating \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; i\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003en; i\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(queue);  \u003cspan style=\"color:#6272a4\"\u003e// 唤醒排队的 n 个人继续进程 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#50fa7b\"\u003eV\u003c/span\u003e(mutex); \u003cspan style=\"color:#6272a4\"\u003e// 允许下一个吃完的人对变量和队列进行操作 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"3进门问题1请给出pv操作和信号量的物理意义2一个软件公司有5名员工-每人刷卡上班员工刷卡后需要等待直到所有员工都刷卡后才能进入公司为了避免拥挤-公司要求员工一个一个通过大门所有员工都进入后最后进入的员工负责关门请用-p-v-操作实现员工之间的同步关系\"\u003e3.进门问题。（1）请给出P、V操作和信号量的物理意义。（2）一个软件公司有5名员工， 每人刷卡上班。员工刷卡后需要等待，直到所有员工都刷卡后才能进入公司。为了避免拥挤， 公司要求员工一个一个通过大门。所有员工都进入后，最后进入的员工负责关门。请用 P、 V 操作实现员工之间的同步关系\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eP操作：请求一个资源，V操作：释放一个资源\u003c/p\u003e","title":"OS第四次理论作业"},{"content":"OS:lab4实验报告 Thinking 4.1 内核在保存现场的时候是如何避免破坏通用寄存器的？ 通过执行SAVE_ALL对现场中的所有寄存器进行保存 系统陷入内核调用后可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall 留下的信息吗？ 不可以，a0-a3寄存器中的参数可能会发生改变，在陷入内核时将需要传递的参数保存进了一个Trapframe中，可以从传递的trapframe指针中获取需要的参数 我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样 的参数的？ 用户调用时的参数保存进了一个Trapframe中，在do_syscall函数中从传入的trapframe指针中取出传递的参数再传入对应的系统调用处理函数sys_*中 内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是什么？ 在处理系统调用过程中改变了trapframe指针中v0寄存器(返回值寄存器)的值，这个返回值可以标志系统调用是否成功，如果失败则返回对应的错误码 Thinking 4.2 思考 envid2env函数: 为什么 envid2env中需要判断 e-\u0026gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？\n相关判断代码\n1 2 3 if (e-\u0026gt;env_status == ENV_FREE || e-\u0026gt;env_id != envid) { return -E_BAD_ENV; } 在mkenvid中，envid的生成是通过asid与在envs中的偏移地址得到的，所以可能有envid越界的情况，所以需要判断申请到的env的id是不是等于请求的envid\nThinking 4.3 思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件 中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释。\nmkenvid函数不会返回0，故不会有进程的envid为0，而IPC中其他函数有时候需要获取当前进程的PCB，故可以用0作为比较快速的索引\nThinking 4.4 关于 fork 函数的两个返回值，下面说法正确的是：C\nA、fork 在父进程中被调用两次，产生两个返回值\nB、fork 在两个进程中分别被调用一次，产生两个不同的返回值\nC、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值\nD、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值\nThinking 4.5 我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪 些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页 面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。 首先内核部分的页不需要映射，所有进程共享 从UTOP到ULIM之间存储的是内核相关的页表和进程信息，在env_alloc时会使用模版页表boot_pgdir拷贝到进程页表，不需要进行映射 从UTOP到USTACKTOP之间是异常处理栈和无效内存，父子进程不需要共享，不映射 只需要映射USTACKTOP之下的部分 Thinking 4.6 在遍历地址空间存取页表项时你需要使用到 vpd和 vpt这两个指针，请参 考user/include/lib.h 中的相关定义，思考并回答这几个问题:\nvpt 和 vpd 的作用是什么？怎样使用它们？\nvpt和vpd分别为指向用户页表与用户页目录的指针，可以视作数组首地址使用 从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？\n1 2 #define vpt ((const volatile Pte *)UVPT) #define vpd ((const volatile Pde *)(UVPT + (PDX(UVPT) \u0026lt;\u0026lt; PGSHIFT))) vpt和vpd分别指向了用户地址空间中页表的首地址和页目录的首地址\n它们是如何体现自映射设计的？\nvpd的值中对于页目录首地址的计算用到了自映射设计 进程能够通过这种方式来修改自己的页表项吗?\n不能，用户进程只能对页表项进行访问，而不能对其进行修改 Thinking 4.7 在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题： 这里实现了一个支持类似于“异常重入”的机制,而在什么时候会出现这种“异常重入”？ 当用户程序试图写入一个COW页，会触发TLB Mod异常，进入相应的异常处理程序，然后调用用户空间的cow_entry函数，若在处理过程中又尝试写入COW页，则再次触发TLB Mod，产生异常重入。 内核为什么需要将异常的现场 Trapframe复制到用户空间？ MOS内核中，异常处理是在用户态进行的，用户态只能访问kuseg区域内的数据，故需要将异常现场复制到用户空间。 Thinking 4.8 在用户态处理页写入异常，相比于在内核态处理有什么优势？ 尽量减少内核出现错误的可能，即使程序崩溃，也不会影响系统的稳定。同时微内核的模式下，用户态进行新页面的分配映射也更加灵活方便。 Thinking 4.9 请思考并回答以下几个问题 为什么需要将 syscall_set_tlb_mod_entry的调用放置在 syscall_exofork之前？ 因为这个写时复制的异常处理函数在父进程和子进程中都需要设置，先设置再执行syscall_exofork函数，这样父子进程中的异常处理出口都被设置好。 如果放置在写时复制保护机制完成之后会有怎样的效果？ 父进程在执行完syscall_exofork之后就返回了，等到写时复制机制完成后再设置的话，父进程的异常处理就不是写时复制了。 实验难点分析 结合指导书中的流程图进行分析\n1. 系统调用 系统调用是一个从用户态向内核态一层一层传递的过程\n用户态的调用函数在user/lib/syscall_lib.c中，以syscall_*命名\nsyscall_*函数调用msyscall函数(传递需要的参数)进入内核态，其实只有两行代码\nsyscall jr $ra 进入内核态后，通过异常分发向量组（8号异常），找到对应的异常处理函数handle_sys(kern/genex.S)\n进入内核态后，执行do_syscall，根据系统调用号找到对应的系统调用sys_*进行系统调用\n换句话说，用户空间中的syscall_*与内核空间的sys_*是一一对应的\n2. 进程通信IPC 我们实现的IPC机制为比较简单的IPC，是基于系统调用实现的 在user/lib/syscall_lib.c中定义了用户空间进行发送/接受信息的接口 发送信息syscall_ipc_try_send 接受信息syscall_ipc_recv 在内核态kern/syscall_all.c中定义了对应的内核调用 发送信息sys_ipc_try_find 接受信息sys_ipc_recv 这里需要注意的是，要进行一次完整成功的信息发送过程，**我们先需要对接受进程进行设置(sys_ipc_recv)，然后发送进程再进行发送(sys_ipc_try_send)，**进行设置比较重要的几个点 env_ipc_recving接受进程是否处于可接受信息状态 env_ipc_dstva接受进程如果接收到发送进程发送的页面，应当将该页面映射到的虚拟地址 注：在接受者这里只负责提供地址，在发送过程中进行地址映射(page_insert) 3.进程创建fork fork只在父进程中被调用一次，父进程和子进程分别返回两个返回值 子进程返回0 父进程返回子进程的envid 首先设置好父进程处理TLB Mod异常的异常处理函数 然后调用syscall_exofork进行新进程的创建 父进程中syscall_exofork返回子进程envid 子进程中返回值保存在trapframe中的返回值寄存器v0 这时子进程的地址空间和异常处理函数等还没被设置好，还不能进行调度，NOT_RUNNABLE 代码难度上最大的一步即为遍历父进程USTACKTOP以下的地址空间并将他们映射到子进程 通过duppage函数实现 这里的思路是找到映射USTACKTOP的页目录项，再去遍历这些页目录项对应的二级页表，这里需要注意检查页表项对应的页面号是否超过范围，因为找页目录项时向上取整 设置子进程的TLB Mod异常处理函数 这时子进程的一切都被设置好，可以进行调度，设置子进程的状态为RUNNABLE 子进程返回到exofork，返回值为0(保存在trapframe中v0寄存器)，退出fork函数，返回值为0 4.COW机制与TLB Mod异常的处理 在fork机制中，我们知道，子进程中的环境几乎与父进程相同，如果我们要将父进程中的数据全部复制到子进程并新分配物理页面，会造成很大的开销，父进程中只读的数据例如代码段，父子进程都只会进行读，不必要进行复制，进一步的，对于可写的页面，我们一开始也不进行复制，等到真对它进行写操作了，我们先把他复制一份到子进程中，再进行写，这就是写时复制(Copy-On-Write)机制，可以极大的减少开销\n为了实现COW机制，我们在TLB中引入一个新的软件中断位COW，对于写时复制机制，我们将他的权限位标记为\n1 PTE_D = 0 \u0026amp;\u0026amp; PTE_COW = 1 这样在对该页进行写操作时，会触发TLB Mod异常，此时再检查PTE_COW是否有效，决定是否进行写时复制(cow_entry)\n我们在UCOW处分配一个物理页空间，并将父进程中触发TLB Mod对应的虚拟地址(cp0-\u0026gt;badvaddr)对应的页复制(memcpy)到该物理页\n然后将该页与子进程进行映射(syscall_mem_map)，父进程解除映射(syscall_mem_unmap)\n实验心得与体会 ​\tlab4的内容是比较庞杂的，其中需要对用户态和内核态有更深刻的理解。我们的MOS操作系统是基于微内核设计的，我们尽可能地将功能放到用户空间进行处理以保证内核的稳定性，例如对于COW写入异常的处理。在这一次实验中，我们完成了系统调用，进程通信的IPC机制，进程创建的fork机制，在代码编写过程中感到较高的理解难度，梳理尤其是fork阶段的父子进程之间的协作，需要仔细理解。\n","permalink":"https://coder0xe.github.io/posts/os-lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","summary":"\u003ch1 id=\"oslab4实验报告\"\u003eOS:lab4实验报告\u003c/h1\u003e\n\u003ch2 id=\"thinking-41\"\u003eThinking 4.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e内核在保存现场的时候是如何避免破坏通用寄存器的？\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e通过执行SAVE_ALL对现场中的所有寄存器进行保存\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e系统陷入内核调用后可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall 留下的信息吗？\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e不可以，a0-a3寄存器中的参数可能会发生改变，在陷入内核时将需要传递的参数保存进了一个Trapframe中，可以从传递的trapframe指针中获取需要的参数\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样 的参数的？\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e用户调用时的参数保存进了一个Trapframe中，在do_syscall函数中从传入的trapframe指针中取出传递的参数再传入对应的系统调用处理函数\u003ccode\u003esys_*\u003c/code\u003e中\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是什么？\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e在处理系统调用过程中改变了trapframe指针中v0寄存器(返回值寄存器)的值，这个返回值可以标志系统调用是否成功，如果失败则返回对应的错误码\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-42\"\u003eThinking 4.2\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e思考 envid2env函数: 为什么 envid2env中需要判断 e-\u0026gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e相关判断代码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (e\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003eenv_status \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e ENV_FREE \u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003e e\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003eenv_id \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e envid) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003eE_BAD_ENV;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e在mkenvid中，envid的生成是通过asid与在envs中的偏移地址得到的，所以可能有envid越界的情况，所以需要判断申请到的env的id是不是等于请求的envid\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-43\"\u003eThinking 4.3\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件 中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释。\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003emkenvid函数不会返回0，故不会有进程的envid为0，而IPC中其他函数有时候需要获取当前进程的PCB，故可以用0作为比较快速的索引\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-44\"\u003eThinking 4.4\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e关于 fork 函数的两个返回值，下面说法正确的是\u003c/strong\u003e：\u003cstrong\u003eC\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA、fork 在父进程中被调用两次，产生两个返回值\u003c/p\u003e\n\u003cp\u003eB、fork 在两个进程中分别被调用一次，产生两个不同的返回值\u003c/p\u003e","title":"OS:lab4实验报告"},{"content":"OS:lab4课下基础 1.系统调用 1.1 系统调用相关概念 ​\t在MIPS中，syscall是用于执行系统调用的自陷指令，它使得进程陷入到内核的异常处理程序中，由内核根据系统调用时的上下文执行相应的内核函数，完成相应的功能，并最终返回到syscall的后一条指令。\n存在只能由内核来完成的操作(读写设备、创建进程、IO等) C标准库中的一些函数的实现依赖于操作系统 通过执行syscall指令，用户进程可以陷入到内核态，请求内核提供的服务 通过系统调用陷入到内核态时，需要在用户态与内核态之间进行数据传递与保护 ​\t系统调用保证了系统的安全性：内核将自己能够提供的服务以系统调用的方式提供给用户空间，用户程序只能将服务相关的参数交予操作系统执行\nAPI : Application Programming Interface，程序之间的接口\n​\t直接使用系统调用较为麻烦，于是产生了一系列用户空间的API定义，他们在系统的调用的基础上，实现了更多更高级的常用功能。用户在编写程序时可以直接调用高层次的API来实现各种功能。\n​\t通过层级划分使得程序具有更好的可移植性，只要程序以来的API不变，无论底层的系统调用如何变化，都不会影响\n1.2 系统调用机制的实现 ​\t异常分发向量组(exception_handlers)中的8号异常，即为操作系统处理系统调用时的异常。\nMOS实验代码中，kern目录下即为内核态代码，user目录下即为用户态代码\n​\t以user/lib/debugf.c中的debugf函数来学习处理系统调用的流程(debugf函数是一个debug信息输出函数，进行了IO方面的系统调用)\n​\tdebugf函数的调用链为(系统调用请求从用户态向内核态传递)\ndebugf调用字符串输出函数debug_output\ndebug_output调用了用户空间的syscall_*函数(这里的*为通配符，代表着用户空间进行系统调用的一组操作，都定义在用户态代码syscall_lab.c中，这里调用的是syscall_print_cons)\nsyscall_*函数调用msyscall函数，系统陷入内核态(msyscall是汇编代码，直接调用syscall)。\n内核态中将异常分发到handle_sys函数，将系统所需信息传递进内核(输出字符串s)\n内核取得信息，执行对应的内核空间的系统调用函数sys_*(kern/syscall_all.c)\n系统调用完成，返回值传递回用户态\n从系统调用函数返回，回到debugf调用处\n通过上述描述，对于系统调用的处理实际上是从用户空间向系统空间进行传递的，用户空间中的syscall_*函数与内核中的sys_*是一一对应的，syscall_*函数是用户空间中最接近内核的函数，他调用msyscall中的汇编代码syscall直接陷入内核态，sys_*函数是内核中系统调用的具体实现。\n​\t直接调用syscall陷入内核的msyscall函数具有六个参数，其中第一个参数是与调用名相似的宏，例如SYS_print_cons，被称为系统调用号(include/syscall.h)，用来区分不同的系统调用，其余还有五个参数，即为系统调用时需要传递给内核的参数。\n回忆MIPS函数调用规范中的参数传递，前四个参数保存在寄存器中\nExercise 4.1 msyscall\n进行系统调用(syscall)，并返回到msyscall的调用者处(jr)，syscall_*\n#include \u0026lt;asm/asm.h\u0026gt; LEAF(msyscall) // Just use \u0026#39;syscall\u0026#39; instruction and return. /* Exercise 4.1: Your code here. */ syscall #陷入内核 jr ra #返回调用者 syscall_* END(msyscall) ​\t通过汇编指令syscall陷入内核态后，处理器将PC寄存器指向一个内核中固定的异常处理入口(见lab3中不同异常处理跳转到的地址)\n​\t在异常向量表中，系统调用这一异常类型的处理入口为handle_sys函数(kern/genex.S)，实际调用do_syscall(kern/syscall_all.c)函数进行系统调用。\n​\t陷入内核态的操作并不是从一个函数跳转到了另一个函数，代码使用的栈指针$sp是内核空间中的栈指针。系统从用户态切换到内核态后，首先需要将原用户进程的运行现场保存到内核空间(SAVE_ALL)，随后的栈指针则指向保存的Trapframe。我们正是借助这个保存的结构体来获取用户态中传递过来的值，例如$a0($4)寄存器保存在内核栈的TF_REG4(sp)处。当内核在handle_开头的函数(处理对应异常的函数)中调用实际进行异常处理的C函数时，将这个栈指针作为参数传递给这个C函数，用来获取用户态中的参数\nExercise 4.2 do_syscall\nHint：用户态的运行现场保存在一个Trapframe中，这个trapframe的指针传递给内核态中处理异常的函数用来获取用户态进行系统调用所传递的参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void do_syscall(struct Trapframe *tf) { int (*func)(u_int, u_int, u_int, u_int, u_int); int sysno = tf-\u0026gt;regs[4]; // 系统调用号 if (sysno \u0026lt; 0 || sysno \u0026gt;= MAX_SYSNO) { tf-\u0026gt;regs[2] = -E_NO_SYS; return; } /* Step 1: Add the EPC in \u0026#39;tf\u0026#39; by a word (size of an instruction). */ /* Exercise 4.2: Your code here. (1/4) */ tf-\u0026gt;cp0_epc += 4; /* Step 2: Use \u0026#39;sysno\u0026#39; to get \u0026#39;func\u0026#39; from \u0026#39;syscall_table\u0026#39;. */ /* Exercise 4.2: Your code here. (2/4) */ func = syscall_table[sysno]; /* Step 3: First 3 args are stored in $a1, $a2, $a3. */ u_int arg1 = tf-\u0026gt;regs[5]; u_int arg2 = tf-\u0026gt;regs[6]; u_int arg3 = tf-\u0026gt;regs[7]; /* Step 4: Last 2 args are stored in stack at [$sp + 16 bytes], [$sp + 20 bytes]. */ u_int arg4, arg5; /* Exercise 4.2: Your code here. (3/4) */ arg4 = *(u_long*)(tf-\u0026gt;regs[29] + 16); arg5 = *(u_long*)(tf-\u0026gt;regs[29] + 20); /* Step 5: Invoke \u0026#39;func\u0026#39; with retrieved arguments and store its return value to $v0 in \u0026#39;tf\u0026#39;. */ /* Exercise 4.2: Your code here. (4/4) */ tf-\u0026gt;regs[2] = func(arg1,arg2,arg3,arg4,arg5); } TIPS\ntf结构体的结构\n1 2 3 4 5 6 7 8 9 10 11 12 struct Trapframe { /* Saved main processor registers. */ unsigned long regs[32]; /* Saved special registers. */ unsigned long cp0_status; unsigned long hi; unsigned long lo; unsigned long cp0_badvaddr; unsigned long cp0_cause; unsigned long cp0_epc; }; 前四个参数保存在a0(4)-a3(7)寄存器中，后两个参数保存在栈帧中\nsp指针保存在29号通用寄存器中\n返回值保存在v0(2)寄存器\n指针转换：\n1 2 arg4 = *(u_long*)(tf-\u0026gt;regs[29] + 16); arg5 = *(u_long*)(tf-\u0026gt;regs[29] + 20); tf-\u0026gt;regs + 16得到一个地址，转换为(u_long*)类型的指针再解引用，取出对应地址的数据 依据系统调用号(保存在a0寄存器中)在系统调用表中找到相应的系统调用处理函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void *syscall_table[MAX_SYSNO] = { [SYS_putchar] = sys_putchar, [SYS_print_cons] = sys_print_cons, [SYS_getenvid] = sys_getenvid, [SYS_yield] = sys_yield, [SYS_env_destroy] = sys_env_destroy, [SYS_set_tlb_mod_entry] = sys_set_tlb_mod_entry, [SYS_mem_alloc] = sys_mem_alloc, [SYS_mem_map] = sys_mem_map, [SYS_mem_unmap] = sys_mem_unmap, [SYS_exofork] = sys_exofork, [SYS_set_env_status] = sys_set_env_status, [SYS_set_trapframe] = sys_set_trapframe, [SYS_panic] = sys_panic, [SYS_ipc_try_send] = sys_ipc_try_send, [SYS_ipc_recv] = sys_ipc_recv, [SYS_cgetc] = sys_cgetc, [SYS_write_dev] = sys_write_dev, [SYS_read_dev] = sys_read_dev, }; 1.3 基础系统调用函数 ​\t在kern/syscall_all.c中定义了一系列基础系统调用，后续的IPC与fork机制以这些系统调用作为支撑\n1.3.1 sys_mem_alloc ​\tsys_mem_alloc的主要功能是分配内存，用户程序可以通过这个系统调用给该程序所允许的虚拟内存空间显式地分配实际的物理内存，或者说我们编写的程序在内存中申请了一片空间。对操作系统来说，是一个进程请求将其运行空间中的某段地址与实际物理内存进行映射，从而可以通过该虚拟页面来对物理内存进行存取访问。\n内核通过传入的进程标识符envid来确定发出请求的进程 Exercise 4.3 envid2env\n通过一个进程的envid获取该进程控制块\nHint：使用宏ENVX()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int envid2env(u_int envid, struct Env **penv, int checkperm) { struct Env *e; /* Step 1: Assign value to \u0026#39;e\u0026#39; using \u0026#39;envid\u0026#39;. */ /* Hint: * If envid is zero, set \u0026#39;penv\u0026#39; to \u0026#39;curenv\u0026#39; and return 0. * You may want to use \u0026#39;ENVX\u0026#39;. */ /* Exercise 4.3: Your code here. (1/2) */ if (envid == 0) { *penv = curenv; return 0; } e = \u0026amp;envs[ENVX(envid)]; if (e-\u0026gt;env_status == ENV_FREE || e-\u0026gt;env_id != envid) { return -E_BAD_ENV; } /* Step 2: Check when \u0026#39;checkperm\u0026#39; is non-zero. */ /* Hints: * Check whether the calling env has sufficient permissions to manipulate the * specified env, * i.e. \u0026#39;e\u0026#39; is either \u0026#39;curenv\u0026#39; or its immediate child. i.e.means in other words * If violated, return \u0026#39;-E_BAD_ENV\u0026#39;. */ /* Exercise 4.3: Your code here. (2/2) */ if (checkperm \u0026amp;\u0026amp; (e-\u0026gt;env_id != curenv-\u0026gt;env_id) \u0026amp;\u0026amp; (e-\u0026gt;env_parent_id != curenv-\u0026gt;env_id)) { return -E_BAD_ENV; } /* Step 3: Assign \u0026#39;e\u0026#39; to \u0026#39;*penv\u0026#39;. */ *penv = e; return 0; } 当envid==0，说明是在fork的情景下调用envid2env，父进程fork的返回值为0，则进程即为当前进程或者说父进程 ENVX是根据进程id获取其在进程数组envs中偏移量的宏 关于checkperm检查权限位 当有效时，检查获取的进程控制块是否为当前进程或是当前进程的子进程(fork)，限制两个进程之间的关系为父子进程时需要检查 Exercise 4.4 sys_mem_alloc\n进程请求将其运行空间中的某段地址与实际物理内存进行映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int sys_mem_alloc(u_int envid, u_int va, u_int perm) { struct Env *env; struct Page *pp; /* Step 1: Check if \u0026#39;va\u0026#39; is a legal user virtual address using \u0026#39;is_illegal_va\u0026#39;. */ /* Exercise 4.4: Your code here. (1/3) */ if (is_illegal_va(va)) { return -E_INVAL; } /* Step 2: Convert the envid to its corresponding \u0026#39;struct Env *\u0026#39; using \u0026#39;envid2env\u0026#39;. */ /* Hint: **Always** validate the permission in syscalls! */ /* Exercise 4.4: Your code here. (2/3) */ try(envid2env(envid,\u0026amp;env,1)); /* Step 3: Allocate a physical page using \u0026#39;page_alloc\u0026#39;. */ /* Exercise 4.4: Your code here. (3/3) */ try(page_alloc(\u0026amp;pp)); /* Step 4: Map the allocated page at \u0026#39;va\u0026#39; with permission \u0026#39;perm\u0026#39; using \u0026#39;page_insert\u0026#39;. */ return page_insert(env-\u0026gt;env_pgdir, env-\u0026gt;env_asid, pp, va, perm); } 检查进程提供的虚拟地址是否合法is_illegal_va 将进程id转换为进程控制块envid2env，这里需要设置checkperm为1，检查取到的进程控制块是否为当前进程的进程控制块 分配物理内存page_alloc 建立虚拟地址与物理地址之间的映射page_insert 1.3.2 sys_mem_map ​\t将源进程地址空间中的相应内存映射到目标进程的相应虚拟内存中去，或者说此时两个进程共享同一页物理内存\nExercise 4.5 sys_mem_map\nHint：srcenv-\u0026gt;dstenv\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm) { struct Env *srcenv; struct Env *dstenv; struct Page *pp; /* Step 1: Check if \u0026#39;srcva\u0026#39; and \u0026#39;dstva\u0026#39; are legal user virtual addresses using * \u0026#39;is_illegal_va\u0026#39;. */ /* Exercise 4.5: Your code here. (1/4) */ if (is_illegal_va(srcva) || is_illegal_va(dstva)) { return -E_INVAL; } /* Step 2: Convert the \u0026#39;srcid\u0026#39; to its corresponding \u0026#39;struct Env *\u0026#39; using \u0026#39;envid2env\u0026#39;. */ /* Exercise 4.5: Your code here. (2/4) */ try(envid2env(srcid,\u0026amp;srcenv,1)); /* Step 3: Convert the \u0026#39;dstid\u0026#39; to its corresponding \u0026#39;struct Env *\u0026#39; using \u0026#39;envid2env\u0026#39;. */ /* Exercise 4.5: Your code here. (3/4) */ try(envid2env(dstid,\u0026amp;dstenv,1)); /* Step 4: Find the physical page mapped at \u0026#39;srcva\u0026#39; in the address space of \u0026#39;srcid\u0026#39;. */ /* Return -E_INVAL if \u0026#39;srcva\u0026#39; is not mapped. */ /* Exercise 4.5: Your code here. (4/4) */ pp = page_lookup(srcenv-\u0026gt;env_pgdir,srcva,NULL); if (!pp) { return -E_INVAL; } /* Step 5: Map the physical page at \u0026#39;dstva\u0026#39; in the address space of \u0026#39;dstid\u0026#39;. */ return page_insert(dstenv-\u0026gt;env_pgdir, dstenv-\u0026gt;env_asid, pp, dstva, perm); } 检查源进程或目标进程的虚拟地址是否合法is_illegal_va 找到源进程和目标进程的进程控制块envid 关于checkperm：需要设置，检查是否为当前进程或当前进程的子进程 找到源进程中虚拟地址对应的物理页面的页控制块page_lookup 将该物理页面建立起与目标进程虚拟地址的映射page_insert 1.3.3 sys_mem_unmap ​\t解除某个进程地址空间虚拟内存和物理内存之间的映射关系\nExercise 4.6 sys_mem_unmap\nHint：page_remove\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int sys_mem_unmap(u_int envid, u_int va) { struct Env *e; /* Step 1: Check if \u0026#39;va\u0026#39; is a legal user virtual address using \u0026#39;is_illegal_va\u0026#39;. */ /* Exercise 4.6: Your code here. (1/2) */ if (is_illegal_va(va)) { return -E_INVAL; } /* Step 2: Convert the envid to its corresponding \u0026#39;struct Env *\u0026#39; using \u0026#39;envid2env\u0026#39;. */ /* Exercise 4.6: Your code here. (2/2) */ try(envid2env(envid,\u0026amp;e,1)); /* Step 3: Unmap the physical page at \u0026#39;va\u0026#39; in the address space of \u0026#39;envid\u0026#39;. */ page_remove(e-\u0026gt;env_pgdir, e-\u0026gt;env_asid, va); return 0; } 1.3.4 sys_yield ​\t用户进程放弃CPU，调度其他进程\nExercise 4.7 sys_yield\nHint：schedule\n1 2 3 4 5 void __attribute__((noreturn)) sys_yield(void) { // Hint: Just use \u0026#39;schedule\u0026#39; with \u0026#39;yield\u0026#39; set. /* Exercise 4.7: Your code here. */ schedule(1); } 1.3.5 总结 ​\t处理系统调用时，并没有切换地址空间，也不需要将进程上下文保存到进程控制块中，只是切换到内核态下执行一些代码，处理系统调用时内核仍然处于当前进程\nsys_mem_alloc：为当前进程中的虚拟地址va分配一块物理内存 sys_mem_map：将源进程地址空间中的地址映射到目标进程地址空间中的地址，或者说两个进程共享同一个物理页 sys_mem_unmap：解除进程中虚拟地址va与物理内存之间的映射关系 sys_yield：当前进程放弃CPU，进行进程调度 2.进程间通信IPC IPC : Inter-Process Communication\n​\tIPC机制的实现使得系统中的进程之间有了相互传递消息的能力。\n​\t所谓通信，最直观的理解就是交换数据，假如我们能够让一个进程有能力将数据传递给另一个进程，那么进程之间自然具有了相互通信的能力。\n​\t由于进程的地址空间之间是相互独立的，要想传递数据，就要想办法把一个地址空间中的东西传给另一个地址空间\n​\t所有的进程都共享同一个内核空间(kseg0)，故要想在不同进程的地址空间之间交换数据，就可以通过内核空间来实现！\n​\t发送方进程可以将数据以系统调用的形式存放在进程控制块中，接收方进程同样以系统调用的方式在进程控制块中找到对应的数据，读取并返回\n1 2 3 4 5 6 7 8 struct Env { // Lab 4 IPC u_int env_ipc_value; // the value sent to us u_int env_ipc_from; // envid of the sender u_int env_ipc_recving; // whether this env is blocked receiving u_int env_ipc_dstva; // va at which the received page should be mapped u_int env_ipc_perm; // perm in which the received page should be mapped }; env_ipc_dstva接受到的页面需要与自身的哪个虚拟页面完成映射 env_ipc_perm传递的页面的权限位设置 Exercise 4.8 sys_ipc_recv\n用于接收消息dst\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int sys_ipc_recv(u_int dstva) { /* Step 1: Check if \u0026#39;dstva\u0026#39; is either zero or a legal address. */ if (dstva != 0 \u0026amp;\u0026amp; is_illegal_va(dstva)) { return -E_INVAL; } /* Step 2: Set \u0026#39;curenv-\u0026gt;env_ipc_recving\u0026#39; to 1. */ /* Exercise 4.8: Your code here. (1/8) */ curenv-\u0026gt;env_ipc_recving = 1; /* Step 3: Set the value of \u0026#39;curenv-\u0026gt;env_ipc_dstva\u0026#39;. */ /* Exercise 4.8: Your code here. (2/8) */ curenv-\u0026gt;env_ipc_dstva = dstva; /* Step 4: Set the status of \u0026#39;curenv\u0026#39; to \u0026#39;ENV_NOT_RUNNABLE\u0026#39; and remove it from * \u0026#39;env_sched_list\u0026#39;. */ /* Exercise 4.8: Your code here. (3/8) */ curenv-\u0026gt;env_status = ENV_NOT_RUNNABLE; TAILQ_REMOVE(\u0026amp;env_sched_list,curenv,env_sched_link); /* Step 5: Give up the CPU and block until a message is received. */ ((struct Trapframe *)KSTACKTOP - 1)-\u0026gt;regs[2] = 0; schedule(1); } env_ipc_recving = 1允许接收消息 env_ipc_dstva = dstva：自己要将接受到的页面与dstva进行映射（映射过程在sys_ipc_send中实现，从srcva映射到dstva，故需要先设置好sys_ipc_recving然后再sys_ipc_send） 当前进程挂起，从调度队列中移除，放弃CPU进行进程调度，等待消息到来 Exercise 4.7 sys_ipc_try_send\n用于发送消息src\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm) { struct Env *e; struct Page *p; /* Step 1: Check if \u0026#39;srcva\u0026#39; is either zero or a legal address. */ /* Exercise 4.8: Your code here. (4/8) */ if (srcva != 0 \u0026amp;\u0026amp; is_illegal_va(srcva)) { return -E_INVAL; } /* Step 2: Convert \u0026#39;envid\u0026#39; to \u0026#39;struct Env *e\u0026#39;. */ /* This is the only syscall where the \u0026#39;envid2env\u0026#39; should be used with \u0026#39;checkperm\u0026#39; UNSET, * because the target env is not restricted to \u0026#39;curenv\u0026#39;\u0026#39;s children. */ /* Exercise 4.8: Your code here. (5/8) */ try(envid2env(envid,\u0026amp;e,0)); /* Step 3: Check if the target is waiting for a message. */ /* Exercise 4.8: Your code here. (6/8) */ if (e-\u0026gt;env_ipc_recving != 1) { return -E_IPC_NOT_RECV; } /* Step 4: Set the target\u0026#39;s ipc fields. */ e-\u0026gt;env_ipc_value = value; e-\u0026gt;env_ipc_from = curenv-\u0026gt;env_id; e-\u0026gt;env_ipc_perm = PTE_V | perm; e-\u0026gt;env_ipc_recving = 0; /* Step 5: Set the target\u0026#39;s status to \u0026#39;ENV_RUNNABLE\u0026#39; again and insert it to the tail of * \u0026#39;env_sched_list\u0026#39;. */ /* Exercise 4.8: Your code here. (7/8) */ e-\u0026gt;env_status = ENV_RUNNABLE; TAILQ_INSERT_TAIL(\u0026amp;env_sched_list,e,env_sched_link); /* Step 6: If \u0026#39;srcva\u0026#39; is not zero, map the page at \u0026#39;srcva\u0026#39; in \u0026#39;curenv\u0026#39; to \u0026#39;e-\u0026gt;env_ipc_dstva\u0026#39; * in \u0026#39;e\u0026#39;. */ /* Return -E_INVAL if \u0026#39;srcva\u0026#39; is not zero and not mapped in \u0026#39;curenv\u0026#39;. */ if (srcva != 0) { /* Exercise 4.8: Your code here. (8/8) */ p = page_lookup(curenv-\u0026gt;env_pgdir,srcva,NULL); if (!p) { return -E_INVAL; } try(page_insert(e-\u0026gt;env_pgdir,e-\u0026gt;env_asid,p,e-\u0026gt;env_ipc_dstva,perm)); } return 0; } 当前进程向envid进程发送消息\n由于发送消息并不一定要给自己的子进程，所以这里是唯一使用envid2env时checkperm=0的情况 检查目标进程是否可以接收消息(env_ipc_recving)\n清除接收进程的接收状态，将相应数据填入进程控制块\n传递物理页面的映射关系\n找到srcva在当前进程中对应的物理页面pp(每一个进程一个页表) 如果srcva在当前进程地址空间中存在映射，则将该页面插入到接受进程对应虚拟地址dstva处 修改接收进程的运行状态为RUNNABLE,插入调度队列重新调度\nsrc为0，只传value，不传物理页面，只有当src不为0，才建立两个进程的页面映射关系，将发送进程srvac处的页面映射到接收进程dstva处\n从图中可以看出IPC机制中的信息发送和接收都是通过系统调用实现，从用户态代码向内核态代码进行传递(syscall_*-\u0026gt;sys_*) 3.进程创建fork lab3中实现了内核通过env_create创建一个进程，实现fork机制可以使一个进程创建一个进程（父进程和子进程）\n3.1 fork机制 ​\t在操作系统中，一个进程调用fork()函数后，将从此分叉成为两个进程运行，其中新产生的进程称为原进程的子进程，原进程称为父进程。\n​\t在子进程中，fork()调用的返回值为0，父进程中，fork()调用的返回值是子进程的envid\n​\t对于操作系统，子进程开始运行时的大部分上下文状态与原进程相同，包括程序和fork前的现场，相比独立的两个进程，父子进程间的通信要方便得多，子进程能够读取原属于父进程的部分数据，父进程可以通过fork返回的子进程id调用其他系统接口控制子进程行为。\nfork之前只有父进程 fork之后父进程和子进程同时开始执行fork之后的代码段 fork在不同进程中的返回值不同 父进程和子进程很多信息相同但进程控制块不同 3.2 写时复制机制COW ​\t在调用了fork后，子进程会继承父进程地址空间中的代码段和数据段等内容，但是子进程和父进程为相互独立的两个进程，两个进程对于其内存的修改应该是互不影响的。\n​\t如果在fork时将父进程地址空间中的内容全部复制到新的物理页，将会消耗大量的物理内存。在这些物理内存中，如代码段部分，父子进程通常不会其进行写入，对于这样的只读页面我们希望避免对其进行复制，节省物理内存。\n​\t引入写时复制机制(Copy-On-Write)，在fork时，将地址空间中所有可写页标记为写时复制页，使得在父进程或子进程对写时复制页面进行写入时，能够产生一种异常，操作系统在处理异常时，为当前试图写入的虚拟地址分配新的物理页面，并复制原页面的内容，最后返回用户程序。\n​\t借助硬件异常来实现写时复制机制，在MIPS中，当程序尝试写入的虚拟页对应的TLB表项没有PTE_D标记时，会触发TLB_Mod异常，陷入内核态。我们可以将写时复制页面的PTE_D位设为0，当进程尝试写这个页面时，会触发TLB Mod异常，此时，就可在异常处理函数中，将虚拟页映射到一个新的物理页，然后将旧的物理页的内容复制到新的物理页，然后再对这个虚拟页进行修改。\n​\t引入TLB中新的的软件标记位PTE_COW(即写时复制页面标记为PTE_D=0 \u0026amp; PTE_COW =1)，当触发TLB Mod时，若PTE_COW为1，则进行复制处理。在进行fork时，需要将所有可以写入的内存页面设置PTE_D = 0 \u0026amp; PTE_COW = 1。\n3.3 fork返回值 fork是一个用户态函数\n​\tfork函数需要若干个原子的系统调用来完成所期望的功能，其中由syscall_exofork实现新进程的创建，在fork的实现中，我们通过判断syscall_exofork的返回值来决定fork返回值以及后续动作。\n在返回用户态时，父子进程经历了相同的恢复运行现场的过程 父进程从系统调用中返回时恢复现场 子进程在进程被调度时恢复现场 在现场恢复后，父子进程都会从内核返回到msyscall 函数中，而它们的现场中存储的返回值（即$v0寄存器的值）是不同的，这一返回值随后返回到syscall_exofork和fork函数，使得fork函数也可以区别两者。 Exercise 4.9 sys_exofork\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int sys_exofork(void) { struct Env *e; /* Step 1: Allocate a new env using \u0026#39;env_alloc\u0026#39;. */ /* Exercise 4.9: Your code here. (1/4) */ try(env_alloc(\u0026amp;e,curenv-\u0026gt;env_id)); /* Step 2: Copy the current Trapframe below \u0026#39;KSTACKTOP\u0026#39; to the new env\u0026#39;s \u0026#39;env_tf\u0026#39;. */ /* Exercise 4.9: Your code here. (2/4) */ e-\u0026gt;env_tf = *((struct Trapframe*)KSTACKTOP - 1); /* Step 3: Set the new env\u0026#39;s \u0026#39;env_tf.regs[2]\u0026#39; to 0 to indicate the return value in child. */ /* Exercise 4.9: Your code here. (3/4) */ e-\u0026gt;env_tf.regs[2] = 0; /* Step 4: Set up the new env\u0026#39;s \u0026#39;env_status\u0026#39; and \u0026#39;env_pri\u0026#39;. */ /* Exercise 4.9: Your code here. (4/4) */ e-\u0026gt;env_status = ENV_NOT_RUNNABLE; e-\u0026gt;env_pri = curenv-\u0026gt;env_pri; return e-\u0026gt;env_id; } 创建一个新进程(分配一个新的进程控制块) 复制一份当前进程的运行现场trapframe到子进程的进程控制块 系统调用在内核态返回的envid只传递给父进程，对于子进程，则需要将其现场中的v0寄存器(返回值寄存器)修改为0作为子进程的返回值 初始化其他字段 3.4 地址空间的准备 ​\t用户程序在运行时入口会将一个用户空间中的指针变量struct Env* env指向当前进程的控制块。对于fork的子进程，它具有与父进程不同的进程控制块，因此在子进程第一次被调度的时候(此时还是在fork函数中)需要对env指针进行更新，使其仍指向当前进程的控制块。\n通过一个系统调用取得自己的envid 根据获得的envid，计算对应的进程控制块下标，将对应进程控制块赋给env ​\t父进程需要将地址空间中与子进程共享的页面映射给子进程，这需要遍历父进程的大部分用户空间页，使用duppage函数完成。\nExercise 4.10 duppage\n将虚拟页号为vpn的虚拟页映射到子进程(可以快速地用0作为id获取当前进程、父进程)\nHint：对于不同权限位的页使用不同方式进行处理，源进程到目标进程复制:syscall_mem_map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static void duppage(u_int envid, u_int vpn) { int r; u_int addr; u_int perm; /* Step 1: Get the permission of the page. */ /* Hint: Use \u0026#39;vpt\u0026#39; to find the page table entry. */ /* Exercise 4.10: Your code here. (1/2) */ perm = vpt[vpn] \u0026amp; 0xfff; //virtual page table[virtual page number] /* Step 2: If the page is writable, and not shared with children, and not marked as COW yet, * then map it as copy-on-write, both in the parent (0) and the child (envid). */ /* Hint: The page should be first mapped to the child before remapped in the parent. (Why?) */ /* Exercise 4.10: Your code here. (2/2) */ addr = vpn * PAGE_SIZE; if (!(perm \u0026amp; PTE_D) || (perm \u0026amp; PTE_LIBRARY)) { //实际上包含了 perm \u0026amp; PTE_COW的情况 因为若该页面为写时复制权限，说明已经被fork过一次，即PTE_D=0 \u0026amp; PTE_COW = 1 syscall_mem_map(0,(void*)addr,envid,(void*)addr,perm);//源进程 源地址 新进程 新地址 } else { perm = (perm \u0026amp; ! PTE_D) | PTE_COW; syscall_mem_map(0,(void*)addr,envid,(void*)addr,perm); // first mapped to the child syscall_mem_map(0,(void*)addr,0,(void*)addr,perm); } } vpn对应的页表项：vpt[vpn]，权限位：低12位 修改权限: \u0026amp; + | 关于内存映射时先映射子进程再映射父进程的原因 如果先给父进程加PTE_COW，然后修改了该页，该页将进行写时复制，父进程指向新的页，而新页没有被加上PTE_COW。此时再map子进程，子进程该页加上PTE_COW位而父进程没有。在随后程序运行中，若父进程进行修改，由于缺失PTE_COW，导致无法进行写时复制，因此子进程的运行出现错误（子进程该页本来不该被改，但却由于父进程被改而一起改了） 3.5 页写入异常 ​\t当用户程序写入在TLB中标记为**不可写入(无TLB_D标记)**的页面时，会发生TLB Mod异常。发生TLB Mod异常后，会跳转到异常向量组中的handle_mod函数，之后跳转到kern/tlbex.c中的do_tlb_mod函数中，这个函数正是处理页写入异常的内核函数，对于COW页面，我们只需要取消其PTE_D标记即可在他们被写入时触发do_tlb_mod中的处理逻辑。\n​\tMOS中对于页写入异常的处理实现在用户空间中。如果需要在用户态下完成页写入异常的处理，是不能直接使用正常情况下的用户栈的(发生异常的也可能是正常栈的页面(映射USTACKTOP以下))，需要使用异常处理栈来运行处理程序。\n​\t另外，内核还需要知道进程自身的处理函数所在地址，地址存在env_user_tlb_mod_entry中，需要由父进程通过系统调用设置。\nExercise 4.11 do_tlb_mod\ndo_tlb_mod函数负责将当前现场保存到异常处理栈中，并设置a0和EPC寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场(trapframe)为参数，跳转到env_user_tlb_mod_entry储存的异常处理函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void do_tlb_mod(struct Trapframe *tf) { struct Trapframe tmp_tf = *tf; if (tf-\u0026gt;regs[29] \u0026lt; USTACKTOP || tf-\u0026gt;regs[29] \u0026gt;= UXSTACKTOP) { // 调整栈指针到异常处理栈 tf-\u0026gt;regs[29] = UXSTACKTOP; } tf-\u0026gt;regs[29] -= sizeof(struct Trapframe); *(struct Trapframe *)tf-\u0026gt;regs[29] = tmp_tf; Pte *pte; page_lookup(cur_pgdir, tf-\u0026gt;cp0_badvaddr, \u0026amp;pte); if (curenv-\u0026gt;env_user_tlb_mod_entry) { tf-\u0026gt;regs[4] = tf-\u0026gt;regs[29]; tf-\u0026gt;regs[29] -= sizeof(tf-\u0026gt;regs[4]); // Hint: Set \u0026#39;cp0_epc\u0026#39; in the context \u0026#39;tf\u0026#39; to \u0026#39;curenv-\u0026gt;env_user_tlb_mod_entry\u0026#39;. /* Exercise 4.11: Your code here. */ tf-\u0026gt;cp0_epc = curenv-\u0026gt;env_user_tlb_mod_entry; } else { panic(\u0026#34;TLB Mod but no user handler registered\u0026#34;); } } 首先检查栈指针的位置，如果不在异常处理栈范围内，就调整到异常处理栈的栈顶（异常重入） 保存当前现场 先向下移动栈指针一个trapframe大小 保存当前现场（指针转换） 把当前的trapframe进行复制，进行保存，而后继续使用当前trapframe Exercise 4.12 sys_set_tlb_mod_entry\n注册进程自身的页写入异常处理函数\n1 2 3 4 5 6 7 8 9 10 11 int sys_set_tlb_mod_entry(u_int envid, u_int func) { struct Env *env; /* Step 1: Convert the envid to its corresponding \u0026#39;struct Env *\u0026#39; using \u0026#39;envid2env\u0026#39;. */ /* Exercise 4.12: Your code here. (1/2) */ try(envid2env(envid,\u0026amp;env,1)); /* Step 2: Set its \u0026#39;env_user_tlb_mod_entry\u0026#39; to \u0026#39;func\u0026#39;. */ /* Exercise 4.12: Your code here. (2/2) */ env-\u0026gt;env_user_tlb_mod_entry = func; return 0; } ​\t页写入异常处理时会返回到用户空间的cow_entry函数\nExercise 4.13 cow_entry\n处理写时复制异常的异常处理函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void __attribute__((noreturn)) cow_entry(struct Trapframe *tf) { u_int va = tf-\u0026gt;cp0_badvaddr; // 发生异常的地址 u_int perm; /* Step 1: Find the \u0026#39;perm\u0026#39; in which the faulting address \u0026#39;va\u0026#39; is mapped. */ /* Hint: Use \u0026#39;vpt\u0026#39; and \u0026#39;VPN\u0026#39; to find the page table entry. If the \u0026#39;perm\u0026#39; doesn\u0026#39;t have * \u0026#39;PTE_COW\u0026#39;, launch a \u0026#39;user_panic\u0026#39;. */ /* Exercise 4.13: Your code here. (1/6) */ perm = vpt[VPN(va)] \u0026amp; 0xfff; if (!(perm \u0026amp; PTE_COW)) { // 检查权限位 ：检查是不是COW页 user_panic(\u0026#34;The permission of the page of va 0x%x doesn\u0026#39;t has PTE_COW!\u0026#34;,va); } /* Step 2: Remove \u0026#39;PTE_COW\u0026#39; from the \u0026#39;perm\u0026#39;, and add \u0026#39;PTE_D\u0026#39; to it. */ /* Exercise 4.13: Your code here. (2/6) */ perm = (perm \u0026amp; !PTE_COW) | PTE_D; /* Step 3: Allocate a new page at \u0026#39;UCOW\u0026#39;. */ /* Exercise 4.13: Your code here. (3/6) */ syscall_mem_alloc(0,(void*)UCOW,PTE_D); /* Step 4: Copy the content of the faulting page at \u0026#39;va\u0026#39; to \u0026#39;UCOW\u0026#39;. */ /* Hint: \u0026#39;va\u0026#39; may not be aligned to a page! */ /* Exercise 4.13: Your code here. (4/6) */ va = ROUNDDOWN(va,PAGE_SIZE); memcpy((void*)UCOW,(const void*)va,PAGE_SIZE); // Step 5: Map the page at \u0026#39;UCOW\u0026#39; to \u0026#39;va\u0026#39; with the new \u0026#39;perm\u0026#39;. /* Exercise 4.13: Your code here. (5/6) */ syscall_mem_map(0,(void*)UCOW,0,(void*)va,perm); // Step 6: Unmap the page at \u0026#39;UCOW\u0026#39;. /* Exercise 4.13: Your code here. (6/6) */ syscall_mem_unmap(0,(void*)UCOW); // Step 7: Return to the faulting routine. int r = syscall_set_trapframe(0, tf); user_panic(\u0026#34;syscall_set_trapframe returned %d\u0026#34;, r); } 从内核态中do_tlb_mod函数返回时，传递的第一个参数（保存在a0(4号)寄存器中）\n1 2 3 4 // do_tlb_mod tf-\u0026gt;regs[29] -= sizeof(struct Trapframe); *(struct Trapframe *)tf-\u0026gt;regs[29] = tmp_tf; tf-\u0026gt;regs[4] = tf-\u0026gt;regs[29]; sp寄存器的位置实际上保存了一个trapframe a0号寄存器中保存了一个trapframe 用户态处理COW异常函数cow_entry接收到第一个参数为这个trapframe 传递的trapframe中badvaddr域即为发生COW异常的虚拟地址，可以通过这个地址得到相应的页面并检查权限位\n在UCOW地址处分配一个新的可写页(PTE_D)，等待复制，注意权限位可写PTE_D ROUNDDOWN(va)实际上是对地址的低12位清0，或者说得到了所在页的首地址\n1 2 va = ROUNDDOWN(va,PAGE_SIZE); memcpy((void*)UCOW,(const void*)va,PAGE_SIZE); 将发生错误的页复制到UCOW新页 将虚拟地址映射到UCOW新页，当前进程解除映射\n1 2 syscall_mem_map(0,(void*)UCOW,0,(void*)va,perm); syscall_mem_unmap(0,(void*)UCOW); 当前进程的trapframe设为tf\n1 int r = syscall_set_trapframe(0, tf); Exercise 4.14 sys_set_env_status\n父进程将子进程的状态设置为status\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int sys_set_env_status(u_int envid, u_int status) { struct Env *env; /* Step 1: Check if \u0026#39;status\u0026#39; is valid. */ /* Exercise 4.14: Your code here. (1/3) */ if (status != ENV_RUNNABLE \u0026amp;\u0026amp; status != ENV_NOT_RUNNABLE) { return -E_INVAL; } /* Step 2: Convert the envid to its corresponding \u0026#39;struct Env *\u0026#39; using \u0026#39;envid2env\u0026#39;. */ /* Exercise 4.14: Your code here. (2/3) */ try(envid2env(envid,\u0026amp;env,1)); /* Step 3: Update \u0026#39;env_sched_list\u0026#39; if the \u0026#39;env_status\u0026#39; of \u0026#39;env\u0026#39; is being changed. */ /* Exercise 4.14: Your code here. (3/3) */ if (env-\u0026gt;env_status != status) { if (status == ENV_RUNNABLE) { //加入调度队列 TAILQ_INSERT_TAIL(\u0026amp;env_sched_list,env,env_sched_link); } else { // 从调度队列取出 TAILQ_REMOVE(\u0026amp;env_sched_list,env,env_sched_link); } } /* Step 4: Set the \u0026#39;env_status\u0026#39; of \u0026#39;env\u0026#39;. */ env-\u0026gt;env_status = status; return 0; } Exercise 4.15 fork : final!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int fork(void) { u_int child; u_int i; /* Step 1: Set our TLB Mod user exception entry to \u0026#39;cow_entry\u0026#39; if not done yet. */ if (env-\u0026gt;env_user_tlb_mod_entry != (u_int)cow_entry) { try(syscall_set_tlb_mod_entry(0, cow_entry)); } /* Step 2: Create a child env that\u0026#39;s not ready to be scheduled. */ // Hint: \u0026#39;env\u0026#39; should always point to the current env itself, so we should fix it to the // correct value. child = syscall_exofork(); if (child == 0) { env = envs + ENVX(syscall_getenvid()); return 0; // 子进程在此返回 } /* Step 3: Map all mapped pages below \u0026#39;USTACKTOP\u0026#39; into the child\u0026#39;s address space. */ // Hint: You should use \u0026#39;duppage\u0026#39;. /* Exercise 4.15: Your code here. (1/2) */ for (i = 0;i \u0026lt; PDX(ROUND(USTACKTOP,PDMAP));i++) { if (vpd[i] \u0026amp; PTE_V) { for (u_int j = 0;j \u0026lt; 1024;j++) { u_int vpn = (i \u0026lt;\u0026lt; 10) | j; if ((vpn \u0026lt; VPN(USTACKTOP) \u0026amp;\u0026amp; (vpt[vpn] \u0026amp; PTE_V))) { duppage(child,vpn); } } } } /* Step 4: Set up the child\u0026#39;s tlb mod handler and set child\u0026#39;s \u0026#39;env_status\u0026#39; to * \u0026#39;ENV_RUNNABLE\u0026#39;. */ /* Hint: * You may use \u0026#39;syscall_set_tlb_mod_entry\u0026#39; and \u0026#39;syscall_set_env_status\u0026#39; * Child\u0026#39;s TLB Mod user exception entry should handle COW, so set it to \u0026#39;cow_entry\u0026#39; */ /* Exercise 4.15: Your code here. (2/2) */ syscall_set_tlb_mod_entry(child,cow_entry); syscall_set_env_status(child,ENV_RUNNABLE); return child; } 首先设置好处理COW异常的异常处理函数\n1 e-env_user_tlb_mod_entry = cow_entry 创建新进程，这里通过syscall_exofork实现\nchild = syscall_exofork(); 即从这一行往后会有两个进程执行以下代码段\n父进程的返回值在syscall_exofork中显示地指出来，为子进程的envid\n子进程由于处于NOT_RUNNABLE状态，他的返回值被保存到trapframe中的返回值寄存器v0(2号)中，等到被调度时（父进程把他设置为RUNNABLE后），返回0，进入下方判断返回\n1 2 3 4 if (child == 0) { env = envs + ENVX(syscall_getenvid()); return 0; // 子进程在此返回 } 最重要的一步就是遍历USTACKTOP以下的页面并从父进程地址空间映射到子进程地址空间，下面进行仔细分析\n1 2 3 4 5 6 7 8 9 10 for (i = 0;i \u0026lt; PDX(ROUND(USTACKTOP,PDMAP));i++) { if (vpd[i] \u0026amp; PTE_V) { for (u_int j = 0;j \u0026lt; 1024;j++) { u_int vpn = (i \u0026lt;\u0026lt; 10) | j; if ((vpn \u0026lt; VPN(USTACKTOP) \u0026amp;\u0026amp; (vpt[vpn] \u0026amp; PTE_V))) { duppage(child,vpn); } } } } 已知只需要对USTACKTOP以下的地址空间进行映射，已经有页映射工具duppage，duppage函数会区分页权限进行操作\n宏PDMAP一个页目录项映射到的地址空间大小(4MB)\n宏ROUND相当于向上取整，\n1 ROUND(USTACKTOP,PDMAP) 即USTACKTOP以下的地址空间至少需要多少个页目录项才能映射完整 宏PDX找到虚拟地址对应的页目录偏移量\n宏vpd是当前进程页目录数组的指针，即为首地址\n然后在每个页目录项对应的二级页表中进行遍历\n1 2 3 4 5 6 for (u_int j = 0;j \u0026lt; 1024;j++) { u_int vpn = (i \u0026lt;\u0026lt; 10) | j; if ((vpn \u0026lt; VPN(USTACKTOP) \u0026amp;\u0026amp; (vpt[vpn] \u0026amp; PTE_V))) { duppage(child,vpn); } } 回顾二级页表地址结构PDX(10bits) + PTX(10bits) + OFFSET(12bits) 这里需要对得到的虚拟页号进行检查，因为我们在取页表项时，为了保证所取到的页表项完整的映射了USTACKTOP以下的地址范围，进行了向上取整，有可能最后一个页目录项(4MB)对应的二级页表中有页表项对应的页面超过了USTACKTOP 对于符合地址范围且有效的页面映射到子进程中 设置子进程的异常处理函数，状态，子进程可以被进行调度\n父进程返回子进程的envid\n","permalink":"https://coder0xe.github.io/posts/os-lab4%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"oslab4课下基础\"\u003eOS:lab4课下基础\u003c/h1\u003e\n\u003ch2 id=\"1系统调用\"\u003e1.系统调用\u003c/h2\u003e\n\u003ch3 id=\"11-系统调用相关概念\"\u003e1.1 系统调用相关概念\u003c/h3\u003e\n\u003cp\u003e​\t在MIPS中，syscall是用于执行系统调用的自陷指令，它使得进程陷入到内核的异常处理程序中，由内核根据系统调用时的上下文执行相应的内核函数，完成相应的功能，并\u003cstrong\u003e最终返回到syscall的后一条指令\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e存在只能由内核来完成的操作(\u003cstrong\u003e读写设备、创建进程、IO\u003c/strong\u003e等)\u003c/li\u003e\n\u003cli\u003eC标准库中的一些函数的实现依赖于操作系统\u003c/li\u003e\n\u003cli\u003e通过执行syscall指令，用户进程可以陷入到内核态，请求内核提供的服务\u003c/li\u003e\n\u003cli\u003e通过系统调用陷入到内核态时，\u003cstrong\u003e需要在用户态与内核态之间进行数据传递与保护\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t\u003cstrong\u003e系统调用保证了系统的安全性\u003c/strong\u003e：内核将自己能够提供的服务以系统调用的方式提供给用户空间，用户程序只能将服务相关的参数交予操作系统执行\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAPI : Application Programming Interface，程序之间的接口\u003c/p\u003e\n\u003cp\u003e​\t直接使用系统调用较为麻烦，于是产生了一系列用户空间的API定义，他们在系统的调用的基础上，实现了更多更高级的常用功能。用户在编写程序时可以直接调用高层次的API来实现各种功能。\u003c/p\u003e\n\u003cp\u003e​\t通过层级划分使得程序具有更好的可移植性，只要程序以来的API不变，无论底层的系统调用如何变化，都不会影响\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240507182619458\" loading=\"lazy\" src=\"/img/image-20240507182619458.png\"\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"12-系统调用机制的实现\"\u003e1.2 系统调用机制的实现\u003c/h3\u003e\n\u003cp\u003e​\t异常分发向量组(\u003ccode\u003eexception_handlers\u003c/code\u003e)中的8号异常，即为操作系统处理系统调用时的异常。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMOS实验代码中，kern目录下即为内核态代码，user目录下即为用户态代码\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e​\t以\u003ccode\u003euser/lib/debugf.c\u003c/code\u003e中的debugf函数来学习处理系统调用的流程(debugf函数是一个debug信息输出函数，进行了\u003cstrong\u003eIO方面的系统调用\u003c/strong\u003e)\u003c/p\u003e\n\u003cp\u003e​\tdebugf函数的调用链为(系统调用请求从用户态向内核态传递)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003edebugf调用字符串输出函数debug_output\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003edebug_output调用了用户空间的\u003ccode\u003esyscall_*\u003c/code\u003e函数(这里的\u003ccode\u003e*\u003c/code\u003e为通配符，代表着用户空间进行系统调用的一组操作，都定义在用户态代码\u003ccode\u003esyscall_lab.c\u003c/code\u003e中，这里调用的是\u003ccode\u003esyscall_print_cons\u003c/code\u003e)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003esyscall_\u003ccode\u003e*\u003c/code\u003e函数调用msyscall函数，系统陷入内核态(msyscall是汇编代码，直接调用syscall)。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内核态中将异常分发到handle_sys函数，将系统所需信息传递进内核(输出字符串s)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内核取得信息，执行对应的内核空间的系统调用函数\u003ccode\u003esys_*\u003c/code\u003e(\u003ccode\u003ekern/syscall_all.c\u003c/code\u003e)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e系统调用完成，返回值传递回用户态\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从系统调用函数返回，回到debugf调用处\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240507184746774\" loading=\"lazy\" src=\"/img/image-20240507184746774.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e通过上述描述，对于系统调用的处理实际上是从用户空间向系统空间进行传递的，用户空间中的\u003ccode\u003esyscall_*\u003c/code\u003e函数与内核中的\u003ccode\u003esys_*\u003c/code\u003e是一一对应的，\u003ccode\u003esyscall_*\u003c/code\u003e函数是用户空间中最接近内核的函数，他调用msyscall中的汇编代码syscall直接陷入内核态，\u003ccode\u003esys_*\u003c/code\u003e函数是内核中系统调用的具体实现。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e​\t直接调用syscall陷入内核的msyscall函数具有六个参数，\u003cstrong\u003e其中第一个参数是与调用名相似的宏，例如SYS_print_cons，被称为系统调用号(include/syscall.h)，用来区分不同的系统调用\u003c/strong\u003e，其余还有五个参数，即为系统调用时需要传递给内核的参数。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e回忆MIPS函数调用规范中的参数传递，前四个参数保存在寄存器中\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240507185903124\" loading=\"lazy\" src=\"/img/image-20240507185903124.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240507185816739\" loading=\"lazy\" src=\"/img/image-20240507185816739.png\"\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eExercise 4.1 msyscall\u003c/p\u003e\n\u003cp\u003e进行系统调用(syscall)，并返回到msyscall的调用者处(jr)，syscall_*\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-assembly\" data-lang=\"assembly\"\u003e#include \u0026lt;asm/asm.h\u0026gt;\n\nLEAF(msyscall)\n\t// Just use \u0026#39;syscall\u0026#39; instruction and return.\n\n\t/* Exercise 4.1: Your code here. */\n\tsyscall #陷入内核\n\tjr ra #返回调用者 syscall_*\nEND(msyscall)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t通过汇编指令syscall陷入内核态后，处理器将PC寄存器指向一个内核中固定的异常处理入口(见lab3中不同异常处理跳转到的地址)\u003c/p\u003e","title":"OS:lab4课下基础"},{"content":"OS:lab3实验报告 Thinking 3.1 请结合 MOS 中的页目录自映射应用解释代码中 e-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V 的含义。\nUVPT是用户地址空间中页表项的起始地址\n结合页目录自映射我们知道，只要给定了二级页表项的起始地址，我们就能通过自映射机制计算出页目录的起始虚拟地址\nUVPT为二级页表基地址 则页目录基地址为$UVPT + (UVPT\u0026raquo;12)*4 = UVPT+UVPT\u0026raquo;10$ 映射到页目录的页表项的地址为$UVPT + ((UVPT+UVPT\u0026raquo;10)\u0026raquo;12)*4 = UVPT + UVPT\u0026raquo;10 + UVPT\u0026raquo;20$ 该项相对于页目录的index：或者说该项相对于页目录的地址偏移为$UVPT\u0026raquo;20$，对应的偏移量为UVPT\u0026raquo;22，即为PDX(UVPT) PDX(UVPT)可以得到二级页表起始虚拟地址UVPT的页目录号\ne-\u0026gt;env_pgdir[PDX(UVPT)]即为指向页目录中指向页目录自身的页目录项\nPADDR(e-\u0026gt;env_pgdir)得到页目录的物理地址并赋予有效位PTE_V\nThinking 3.2 elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？\ndata是传入的进程控制块指针\n作用：在增加虚拟地址到物理地址的映射时提供当前进程地址空间的页目录基地址pg_dir和asid(load_icode_mapper)，所有这个参数是必要的\nThinking 3.3 结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况\nelf_load_seg函数的实现(elfloader.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data) { u_long va = ph-\u0026gt;p_vaddr; size_t bin_size = ph-\u0026gt;p_filesz; size_t sgsize = ph-\u0026gt;p_memsz; u_int perm = PTE_V; if (ph-\u0026gt;p_flags \u0026amp; PF_W) { perm |= PTE_D; } int r; size_t i; u_long offset = va - ROUNDDOWN(va, PAGE_SIZE); if (offset != 0) { if ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, PAGE_SIZE - offset))) != 0) { return r; } } /* Step 1: load all content of bin into memory. */ for (i = offset ? MIN(bin_size, PAGE_SIZE - offset) : 0; i \u0026lt; bin_size; i += PAGE_SIZE) { if ((r = map_page(data, va + i, 0, perm, bin + i, MIN(bin_size - i, PAGE_SIZE))) != 0) { return r; } } /* Step 2: alloc pages to reach `sgsize` when `bin_size` \u0026lt; `sgsize`. */ while (i \u0026lt; sgsize) { if ((r = map_page(data, va + i, 0, perm, NULL, MIN(sgsize - i, PAGE_SIZE))) != 0) { return r; } i += PAGE_SIZE; } return 0; } 首先判断虚拟地址va是否页对齐，如果不对齐就将多余的地址标记为offset，然后将offset所在的BY2PG剩下的那部分大小(PAGE_SIZE-offset)写入对应页的物理地址 然后依次将段内的页映射到物理空间 最后若发现在内存中的大小大于在文件中的大小，需要把多余的空间用0填满 Thinking 3.4 思考上面这一段话，并根据自己在 Lab2 中的理解，回答： 你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址? 存储的是虚拟地址，EPC存储的是宏观PC或者说是发生错误时CPU运行到的指令地址。 对于CPU来说可见的都是虚拟地址，我们编程时使用的也是虚拟地址，经过MMU进行地址转换为物理地址 Thinking 3.5 试找出0、1、2、3号异常处理函数的具体实现位置\n0号对应的异常处理：处理中断handle_int，在genex.S中给出定义\nNESTED(handle_int, TF_SIZE, zero) mfc0 t0, CP0_CAUSE mfc0 t2, CP0_STATUS and t0, t2 andi t1, t0, STATUS_IM7 #第7位为时钟中断，判断是不是时钟 bnez t1, timer_irq timer_irq: li a0, 0 j schedule END(handle_int) 在中断处理程序中需要判断CAUSE寄存器中是由第几号中断位引发的中断（时钟中断为第七位），然后进入对应的中断服务函数 如果t1不等于0跳转到时钟中断处理函数schedule（实际上是进行抢占式调度） 1,2,3号对应的异常处理函数handle_mod以及handle_tlb使用genex.S中定义的宏BUILD_HANDLER实现，下面进行简要分析\nBUILD_HANDLER宏定义\n.macro BUILD_HANDLER exception handler NESTED(handle_\\exception, TF_SIZE + 8, zero) move a0, sp addiu sp, sp, -8 jal \\handler addiu sp, sp, 8 j ret_from_exception END(handle_\\exception) .endm 宏定义中需要传入两个参数\nBUILD_HANDLER tlb do_tlb_refill\n异常名(exception)，用于构建函数名(handle_\\exception)\n异常处理函数(handler)，用于进行对应的异常处理(jal \\handler)，例如经典的do_tlb_refill(同样为汇编代码)\n这里的ret_from_exception即为指导书中给出的\nFEXPORT(ret_from_exception) RESTORE_ALL eret Thinking 3.6 阅读 entry.S、genex.S 和 env_asm.S 这几个文件，并尝试说出时钟中断 在哪些时候开启，在哪些时候关闭 时钟中断是否开启由CP0_STATUS寄存器决定，CP0_STATUS寄存器中关于中断的使能位分为两部分，IE——全局中断使能位，IM0-IM7，硬件以及软件中断使能位，其中IM7对应着时钟中断使能位。当IE和IM7同时开启时，时钟中断开启，否则时钟中断关闭。 Thinking 3.7 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的 首先通过RESET_KCLOCK宏完成对时钟中断计时器Timer的初始化，包括初始化Count寄存器和Compare寄存器，然后调用enable_irq开启中断 在进程运行过程中，若产生时钟中断，则进行异常处理(中断是异步异常)，系统将PC指向0x8000_0180，跳转到.text.exc_grn_entry代码段进行异常分发 中断的处理在异常处理向量exception_handlers中对应的处理函数为handle_int(0号异常) 进一步判断是否为时钟中断，即CAUSE寄存器第七位是否置高 如果是时钟中断，跳转到中断服务函数timer_irq，进一步跳转到schedule进行进程调度 在schedule中采用时间片轮转算法进行进程调度 切换进程：时间片用完，将原来的进程插入到调度队列的尾端，从首端选择一个进程PCB运行(env_run(e)) 实验难点梳理 ​\t我们在lab3中学习了进程管理的相关内容，本实验中完成的功能可以由下图概括\nexception_handlers数组为异常向量组，负责分发异常。我们主要涉及到的是0号异常处理函数(中断处理函数)handle_int，1号异常处理函数handle_mod，2号/3号处理函数handle_tlb。初始化结束后，若有异常产生，则其对应的异常处理函数执行\nenv_create\n分配进程控制块\nenv_alloc从空闲链表中分配一个空闲控制块，并进行相应的初始化工作，初始化过程中调用env_setup_vm函数对虚拟地址空间进行初始化，这里包括复制模版页表base_pgdir。模版页表中包含了虚拟地址空间到物理地址空间pages/envs数组的映射，复制到新页表使得用户进程的地址空间中可以访问pages/envs数组\n调用load_icode函数将程序加载到新创建的地址空间中\nhandle_int\n根据CP0_CAUSE寄存器判断是否为时钟中断(7号中断)，并根据Status寄存器判断7号中断是否开启(全局中断使能\u0026amp;\u0026amp;时钟中断使能IM7)。如果是，则调用schedule函数，schedule函数进行进程调度，调用env_run来运行进程\nenv_run\n将正在执行的进程(curenv)的现场保存在对应的进程控制块中 选择一个可以运行的进程，恢复该进程上次被挂起时候的现场，即恢复env_tf，调用env_pop_tf完成 发生TLB Miss时的异常处理\n​\t硬件在取数据或取指令的时候，CPU发射虚拟地址给MMU进行地址转换。对于用户段虚拟地址的转换通过TLB完成，若TLB在转换的过程中发现TLB中还没有对应于该虚拟地址的映射(key--VPN/ASID)，则会产生TLB Miss异常。\n​\t硬件会打断访存过程并陷入内核态跳转到对应的异常处理程序(tlb_miss_entry : pc : 0x8000_0000)，由操作系统查找页表进行TLB重填(do_tlb_refill)，之后再从异常返回，继续访存.\n从软硬件的角度来看 硬件：在发生TLBMiss 异常的时候，4Kc CPU 会把引发 TLB Miss 的虚拟地址填 入到BadVAddr 寄存器中、虚页号填入到 EntryHi 寄存器的 VPN 域中，将 Cause 寄存 器中的ExcCode 域填写为 TLBL（读请求TLBMiss）或 TLBS（写请求 TLB Miss）。 软件：从BadVAddr 寄存器中获取引发 TLB Miss 的虚拟地址，接着在 cur_pgdir 中查找该虚拟地址对应的物理地址与权限位，然后将物理页面号和权限位填入到EntryLo 寄存器的PFN域和权限位中，再使用tlbwr（TLBWriteentry selected by Random）将 EntryHi 和 EntryLo 寄存器中的 VPN、PFN、ASID、权限位等随机地写入到TLB中，最 后调用ret_from_exception 从异常返回。 实验心得体会 ​\t在lab3中，我们学习了有关进程的内容：OS感知进程的唯一标识：PCB、进程结构体env中相关字段的含义，如何将程序加载到进程内存空间、如何新建一个进程以及如何利用以时钟中断为基础的时间片轮转算法来进行进程调度。将在OS理论课程中我们学习到的知识运用到实践当中来，在一行行编写和理解OS代码中对操作系统的进程管理有了更加深刻的认识。\n","permalink":"https://coder0xe.github.io/posts/os-lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","summary":"\u003ch1 id=\"oslab3实验报告\"\u003eOS:lab3实验报告\u003c/h1\u003e\n\u003ch2 id=\"thinking-31\"\u003eThinking 3.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e请结合 MOS 中的页目录自映射应用解释代码中 e-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V 的含义。\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUVPT是用户地址空间中页表项的起始地址\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240421231419128\" loading=\"lazy\" src=\"/img/image-20240421231419128.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e结合页目录自映射我们知道，只要给定了二级页表项的起始地址，我们就能通过自映射机制计算出页目录的起始虚拟地址\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUVPT为二级页表基地址\u003c/li\u003e\n\u003cli\u003e则页目录基地址为$UVPT + (UVPT\u0026raquo;12)*4 = UVPT+UVPT\u0026raquo;10$\u003c/li\u003e\n\u003cli\u003e映射到页目录的页表项的地址为$UVPT + ((UVPT+UVPT\u0026raquo;10)\u0026raquo;12)*4 = UVPT + UVPT\u0026raquo;10 + UVPT\u0026raquo;20$\u003c/li\u003e\n\u003cli\u003e该项相对于页目录的index：或者说该项相对于页目录的地址偏移为$UVPT\u0026raquo;20$，对应的偏移量为UVPT\u0026raquo;22，即为PDX(UVPT)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePDX(UVPT)\u003c/code\u003e可以得到二级页表起始虚拟地址UVPT的页目录号\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ee-\u0026gt;env_pgdir[PDX(UVPT)]\u003c/code\u003e即为指向页目录中指向页目录自身的页目录项\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePADDR(e-\u0026gt;env_pgdir)\u003c/code\u003e得到页目录的物理地址并赋予有效位\u003ccode\u003ePTE_V\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-32\"\u003eThinking 3.2\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eelf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003edata\u003c/code\u003e是传入的进程控制块指针\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e作用：在增加虚拟地址到物理地址的映射时提供当前进程地址空间的页目录基地址pg_dir和asid(load_icode_mapper)，所有这个参数是必要的\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-33\"\u003eThinking 3.3\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eelf_load_seg\u003c/code\u003e函数的实现(\u003ccode\u003eelfloader.c\u003c/code\u003e)\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e36\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eelf_load_seg\u003c/span\u003e(Elf32_Phdr \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003eph, \u003cspan style=\"color:#ff79c6\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ebin, \u003cspan style=\"color:#8be9fd\"\u003eelf_mapper_t\u003c/span\u003e map_page, \u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003edata) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_long va \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e ph\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003ep_vaddr;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003esize_t\u003c/span\u003e bin_size \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e ph\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003ep_filesz;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003esize_t\u003c/span\u003e sgsize \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e ph\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003ep_memsz;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int perm \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e PTE_V;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (ph\u003cspan style=\"color:#ff79c6\"\u003e-\u0026gt;\u003c/span\u003ep_flags \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e PF_W) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tperm \u003cspan style=\"color:#ff79c6\"\u003e|=\u003c/span\u003e PTE_D;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#8be9fd\"\u003esize_t\u003c/span\u003e i;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_long offset \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e va \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eROUNDDOWN\u003c/span\u003e(va, PAGE_SIZE);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (offset \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003emap_page\u003c/span\u003e(data, va, offset, perm, bin,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t  \u003cspan style=\"color:#50fa7b\"\u003eMIN\u003c/span\u003e(bin_size, PAGE_SIZE \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e offset))) \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e/* Step 1: load all content of bin into memory. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (i \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e offset \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eMIN\u003c/span\u003e(bin_size, PAGE_SIZE \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e offset) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e bin_size; i \u003cspan style=\"color:#ff79c6\"\u003e+=\u003c/span\u003e PAGE_SIZE) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003emap_page\u003c/span\u003e(data, va \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e i, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, perm, bin \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e i, \u003cspan style=\"color:#50fa7b\"\u003eMIN\u003c/span\u003e(bin_size \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e i, PAGE_SIZE))) \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t    \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#6272a4\"\u003e/* Step 2: alloc pages to reach `sgsize` when `bin_size` \u0026lt; `sgsize`. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ewhile\u003c/span\u003e (i \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e sgsize) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003emap_page\u003c/span\u003e(data, va \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e i, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e, perm, \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eNULL\u003c/span\u003e, \u003cspan style=\"color:#50fa7b\"\u003eMIN\u003c/span\u003e(sgsize \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e i, PAGE_SIZE))) \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\ti \u003cspan style=\"color:#ff79c6\"\u003e+=\u003c/span\u003e PAGE_SIZE;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"image-20240422103002915\" loading=\"lazy\" src=\"/img/image-20240422103002915.png\"\u003e\u003c/p\u003e","title":"OS:lab3实验报告"},{"content":"OS理论期中考试复习 一.引论 1. 操作系统定义 操作系统是一组管理计算机硬件资源的软件集合，他向计算机程序提供共性的服务 2. 操作系统发展史 电子管时期：软件：手工修改硬件逻辑单元连接 解决人和CPU的矛盾：软件和硬件分离 2.1 批处理系统 加载在计算机上的一个系统软件，在他的控制下，计算机能够自动地、成批地处理一个或多个用户的作业 用户将一批作业提交给操作系统后就不再干预 2.1.1 联机批处理系统 在主机和输入机之间增加一个存储设备——磁带，在运行于主机的监督程序(OS)的自动控制下，计算机可自动完成：成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行，然后把计算结果向输出机输出。完成了上一批作业后，监督程序又从输入机上输入另一批作业，保存在磁带上，重复处理 优点：监督程序不停地处理各个作业，实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间，克服了人机矛盾。 缺点：CPU与慢速的外设之间的矛盾：在作业输入和结果输出时，主机的高速CPU需要等待慢速的输入输出设备完成工作，主机处于“忙等”状态 2.1.2 脱机批处理系统 增加一台不与初级直接相连而是与输入输出设备打交道的卫星机 优点：主机不直接与慢速的输入输出设备打交道，而是与速度相对较快的磁带机发生关系，主机与卫星机并行工作，发挥主机的高速计算能力 缺点：主机内存中仅存放一道作业，每当该作业运行期间发生输入输出请求后，高速的CPU便处于等待低速的IO完成状态，COU空闲 2.2 多道程序系统 多道程序设计技术，指允许多个程序同时进入内存并运行。即同时把多个程序放入内存中，并允许他们交替在CPU中运行，共享系统中的各种硬软件资源\n当一道程序因为IO请求而暂停运行时，CPU便立即转去运行另一道程序，不同程序间的切换运行 使CPU得到充分利用,同时改善IO设备和内存的利用率，提高整个系统的资源利用率和系统吞吐量 宏观上并行：进入系统的几道程序都处于运行过程中，都开始了各自的运行，但都未运行完毕 微观上串行：各道程序轮流地使用CPU，并交替运行 2.3 单道程序系统 内存中只有一道程序，存在计算时IO设备空闲或进行IO操作时CPU空闲\n2.4 多道批处理系统 多道：系统内可同时容纳多个作业\n成批：在系统运行过程中，不允许用户与其作业发生交互\n优点：系统吞吐量大，资源利用率高\n缺点：平均周转时间长，单个用户不能交互，多用户使用和单独控制的矛盾\n2.5 分时系统 分时技术：把处理机的运行时间分成很短的时间片，按时间片轮流把CPU分配给各联机作业/程序使用，给不同的用户提供程序的使用\n一台计算机同时连接多个用户终端\n特点\n多路性：宏观上看多个用户并行工作，微观上看是各用户轮流使用计算机 交互性：用户可以根据系统对请求的响应结果，进一步向系统提出新的请求(交互式系统) 独立性：用户之间相互独立，互不干扰 及时性：系统对用户的输入及时作出响应 2.6 网络操作系统 传统单机OS上加单独软件层，提供联网功能和资源的远程访问，多机互联 2.7 分布式操作系统 多台机器统一管理形成单一系统 2.8 实时系统 在某个时间限制内及时完成某些及时任务不需要时间片排队 3. 操作系统的基本实现机制 用户态和内核态\n用户态和内核态所在的内存空间不一样\nCPU的运行状态不一样\n指令的执行权限不一样\n从用户态转入内核态\n中断(Interrupt)：来自外部设备的中断请求，当中断请求到来时，CPU自动进入系统态，并从系统空间某个预定地址开始执行指令(中断处理程序)，中断发生在两条指令之间 错误(Fault)：执行指令失败时引起Fault，CPU进入内核态，在系统空间中对错误进行处理，错误发生在执行一条指令的过程中 自陷(Trap)：中断和错误都是CPU被动地进入内核态，自陷是CPU通过自陷指令主动进入内核态，系统调用函数一般是靠自陷指令实现的 二.启动 boot :\n硬件启动依赖软件：通过程序控制使得计算机硬件进入特定工作状态\n软件运行依赖硬件：程序必须运行在设置好工作模式的硬件环境上\n通过软件逐步设置硬件\n加载BIOS(basic input/output system)\n设备启动顺序信息，硬盘信息，硬件自检等 读取MBR(master boot record)\n主引导记录MBR：第0磁头第0磁道第一个扇区，包含bootloader 运行bootloader\n初始化硬件设备，建立内存空间映射图 加载内核\n读取内核镜像，解压缩\n用户层init依据inittab文件设定运行等级\ninit进程执行rc.sysinit\n启动内核模块\n执行不同运行级别的脚本程序\n执行/etc/rc.d/rc.local\n执行/bin/login程序，进入登录状态\n三.内存管理 1. 存储管理的数据结构 1.1 位图表示法 给每个分配单元对应一位，用来记录该分配单元是否闲置 位取值为0表示单元闲置，取值为1表示已被占用 1.2 链表表示法 将分配单元按照是否闲置链接起来（空闲链表） 2. 连续分配存储管理方式 2.1 单一连续分配方式 只用于单用户单任务的OS 内存分为两个区域：系统区、用户区 应用程序装入到用户区，可使用用户区全部空间 缺点：对内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存 2.2 分区式分配 把内存分为一些大小相等或不等的分区，每个应用程序占用一个或几个分区，操作系统占用其中一个分区，支持多个程序并发执行\n2.2.1 固定式分区 当系统初始化时，把存储空间划分成若干个任意大小的固定区域；然后把这些区域分配给每个用户作业 把内存划分为若干个固定大小的连续分区 分区大小相等：只适合于多个相似程序的并发执行 分区大小不等：多个小分区，适量中等分区，少量大分区，根据程序大小分配 缺点： 产生内碎片：分区内部难以利用的空间(这部分空间已经被分配出去只是没被利用) 分区总数固定，并发限制执行的程序数目 数据结构：分区表——记录分区的大小和使用情况 2.2.2 可变式分区 分区的边界可以移动，即分区的大小可变 分区的大小在程序装入时动态确定 缺点： 不会产生内碎片，但产生外碎片(分区之间难以利用的空间，还没被分配) 数据结构：内存分配表 已分配区表 空闲区表 2.2.3 可变式分区的内存分配策略 最佳适应算法(Best Fit)：为一个作业选择分区时，选择大小最接近于作业所要求的存储区域 最坏适应算法(Worst Fit)：为作业选择存储区域时，总是寻找最大的空白区 首次适应算法(First Fit)：每个空白区按其在存储空间中地址递增的顺序连在一起，在为作业分配存储区域时，从这个空白区域链的始端开始查找，选择第一个足以满足请求的空白块 下次适应算法(Next Fit)：存储空间中空白区构成一个循环链，每次为存储请求查找合适的分区时，总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将他划分后分配出去 2.2.4 可变式分区的内存回收 若回收区上下的地址空间是空闲区则进行合并\n回收空闲区域时，空闲表项区数减一的情况：上下都是空闲\n2.2.5 基于索引搜索的分配算法 基于顺序搜索的动态分区分配算法一般只是适合于较小的系统，如果系统的分区很多，空闲链表很长，检索速度会比较慢 2.2.6 快速适应算法 把空闲分区按照容量大小进行分类，经常用到长度的空闲区设立单独的空闲区链表 优点：查找效率高，依据程序的长度，寻找到能容纳他的最小空闲区链表，取下第一块进行分配即可 缺点：分区归还主存时算法复杂 2.2.7 伙伴系统（Linux系统采用，较为重要） 伙伴系统是介于固定分区与可变分区之间的动态分区技术，动态划分和合并2的幂大小的分区 在分配存储块时，将一个大的存储块分裂成两个大小相等的小块，即为伙伴 已分配分区或空闲分区的大小均为2的幂次（向上取整） 内存管理模块保持有多个空闲块链表 回收内存时首先考虑将被释放块与其伙伴合并成一个大的空闲块，然后继续合并下去，直到不能合并为止（不能与除了伙伴之外其他合并） 2.2.8 动态分区管理内存回收——紧凑技术 通过移动作业(一个方向)把多个分散的小分区拼接成一个大分区来消除外部碎片 3. 扩充内存容量 3.1 覆盖技术 一个程序的代码段和数据段按照时间先后占用内存空间 必要的部分占据内存，可选的部分放外存 缺点：增加编程复杂度，必须了解程序模块之间的覆盖关系，调用次序 3.2 交换技术 交换就是把暂时不用的某些程序及其数据的部分或全部从主存移到辅存中去，接着把指定程序或数据从辅存读到相应的主存中 换入换出 4. 重定位 4.1 重定位 确定可执行文件中代码和数据的运行时地址,地址空间的程序和数据经过地址重定位处理后，就变成了可由CPU直接执行的绝对地址程序\n在编译、链接和装载的过程中，对程序指令和数据的修改或映射\n编译时重定位（静态重定位）\n如果在编译时就知道给程序分配的物理地址，直接生成包含物理地址的代码，装入其他地址需要重新编译 装载时重定位（静态重定位）\n装载程序时，将指令和数据的地址转换为物理地址，但降低了装载速度\n执行时重定位（动态重定位）\n在每次访问内存单元前进行地址变换 程序执行时，基址寄存器存放程序的首地址，界限寄存器存放程序的长度 程序执行时，不论是取指令还是数据，硬件自动将逻辑地址加上基址 4.2 pa \u0026amp;\u0026amp; va 逻辑地址空间是一个进程用来访问内存的一组地址，是对内存的抽象，\n不同进程的地址空间相互独立\n程序中使用的地址是逻辑地址空间中的地址，但在访问内存前必须映射为物理地址，这个转换由MMU完成\n5. 代码段 一个程序都是由bss段，data段，text段三个节(section)组成的\n.bss : 保存未初始化的全局变量和静态变量static\n.data : 保存已初始化的全局变量和静态变量\n.text : 保存可执行文件的操作指令\n堆和栈 堆向上生长，栈向下生长\n栈(stack)：存放、交换临时数据的内存区 用户存放程序局部变量的内存区域，但不包括static声明的静态变量 保存/恢复调用现场（函数调用参数压栈） 堆(heap)：存放进程运行中动态分配的内存段 进程调用malloc等函数分配内存时，新分配的内存被动态见加到堆上 利用free等函数释放内存时，被释放的内存从堆中被剔除 总结代码中各数据存储位置（考过） .bss段：未初始化的全局变量或静态变量 .data段：已初始化的全局变量或静态变量 .text段：保存可执行文件的操作指令 栈：局部变量 堆：动态分配内存，如malloc 链接过程的本质 链接过程的本质是合并各个代码中的同类section,并将这些section合并为segment\n6.程序的装入和链接 编译 链接 静态链接：在编译阶段直接把静态库加入到可执行文件中，可执行文件比较大 动态链接：链接阶段只加入描述信息，程序执行时再从系统中把相应动态库加载到内存中 装入 7. 页式内存管理 7.1 基本概念 页：把每个作业的地址空间分为大小相等的片，称之为页\n页框：把主存的存储空间也分成与页面相同大小的片\n页表：逻辑地址空间中的每一页在页表中都对应有一个页表项，\n实现页面到页框的映射\n需要注意页大小与块大小相等！即虚拟页面大小与物理页面大小相等（考过）\n地址结构\n页号/块号 + 块内位移 页表查找\n页表定位（考过）：页表始址+页号*页表项长度 7.2 两级页表 一级页表（页目录）\n二级页表（页表）\n必须调入页目录，动态调入二级页表，节省内存空间\n地址结构\n地址变换\n7.3 TLB 快表 快表是页表的Cache，首先检索TLB，若不命中再查询页表\n设计根本目的是减少一次内存访问时间，换为更快的Cache\n命中率计算访存平均时间问题\nTLB命中t1 TLB缺失t2 TLB命中率 p average = p * t1 + (1-p) * t2 7.4 反置页表 每个页框一个页表项，而不是每个页一个页表项 依据物理页面号来组织，表项内容为逻辑页号P和隶属进程标志符pid 反置页表的大小只与物理内存的大小有关 缺点：不能依据虚拟地址查找，而需遍历整个表来寻找匹配 7.5 哈希页表 用链表法处理计算虚拟页号哈希值的哈希冲突\n对虚拟页号做哈希值，为了处理哈希冲突，哈希页表的每一条目都包含一个链表，链表中的每一个元素有三个域 虚拟页号 所映射的页框号 指向下一个元素的指针 首先计算CPU发射的虚拟地址中虚拟页号的哈希值，定位到哈希表项 遍历链表查找，用虚拟页号与链表中每一个元素的第一个域比较 链表平均长度：物理页框数/哈希表大小 搜索速度加倍：链表平均长度 0.5 8. 段式内存管理(略) 9. 局部性原理 时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内 空间局部性：当前执行指令和临近的几条指令，当前访问的数据和临近的数据常会被集中访问 10.虚拟存储器 指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\n物理内存和外存相结合，提供大范围虚拟地址空间 程序当前需要执行的部分页或段读入到内存 需要执行的指令或数据尚未在内存，将对应的页或段调入到内存后继续执行 将暂时不使用的页或段调出保存在外存上 11.请求分页（段）系统 请求调页功能 页面置换功能\n11.1 缺页中断 要访问的物理页不在页表中(不在主存中)，需要从外存中调入\n11.2 页面调入策略 请求调页：只调入发生缺页时的页面，但是根据局部性原理，很可能会访问缺页附近的页，容易产生较多的缺页中断\n预调页：在发生缺页需要调入某页时，一次调入该页以及相邻的几个页\n11.3 页面置换算法 需要调入页面时，内存中哪个物理页面被置换\n最佳算法(OPT)：选择未来不再使用的或离当前最远位置上出现的页面被置换\n每次需要替换时替换最长时间内不再被访问的页面 (往后边的页面序列读，最后读到哪个已经在分配页框中的页面就替换哪个)\n是一种理想情况，用于性能评价的依据\n最近未使用页面置换算法(NRU:not recently used)：\n使用：读(R)/写(M) 淘汰最近一个时钟周期没有被访问的已修改页面比淘汰一个频繁使用的干净页面要好 硬件记录引用位R和修改位M 时钟每个周期清除R class 0 : R = 0 , M = 0 class 1 : R = 0 , M = 1 class 2 : R = 1, M = 0 class 3 : R = 1, M = 1 从编号最小的类中挑选一个淘汰 注：RM构成的二进制即为编号 先进先出算法(FIFO:first in first out)：总是把最先装入内存的一页调出（循环链表、指向最早页面指针）\n二次机会页面置换算法（改进FIFO）\n对FIFO的改进：检查最老页面的R位，给最老页面一个“二次机会”\n则第一个R位为0页面会被替换\nR=0，最近没用，淘汰 R=1，把R清0后，更新装入时间，放在链表最后（或循环链表） 时钟算法Clock\n检查当前指向节点R位 为1：清0，向前移动 为0：置换出去，新置换页面R位置1，指针移动到新置换页面下一个节点 最近最久不用页面置换算法(LRU:least recently used)：\n选择最近一段时间内最久不用的页面予以淘汰 性能接近最佳算法 页面使用时间先后关系：全局计数器，每个指令自增 每个页面对应页表项保存一个相应的计数器，每当一个页面被访问时，全局硬件计数器赋值相应的计数器，替换计数器值最小的页面 最不常用算法(NFU:not frequently used)：选择到当前时间为止被访问次数最少的页面被置换\n每页设置计数器记录被访问次数，淘汰计数值最小的页面 Aging算法\n计数器每次右移一位，R位(0/1)添加到最左边，即新的访问具有更高的权值 计数器值最小的页面被替换 页面缓冲算法(page buffering)\n对被置换页面的缓冲，有机会找回刚被置换的页面 工作集策略(working set)\n进程在任一个时间t，都存在一个集合，包含最近k次内存访问过的页面，这个集合W(k,t)即称为工作集\n依据工作集，预测使用页面提前调入内存，降低缺失率\n当发生缺页时，淘汰一个不在工作集的页面 12. 页目录自映射 四.进程与线程 1. 进程管理 1.1 并发与并行 并发：程序的并发执行是指若干个程序同时在系统中运行，这些程序的执行在时间上是重叠的\n并行：两个程序在同一时间度量下同时运行在不同的处理机上，则称这两个程序是并行执行的\n数据竞争：多个进程在没有同步保护的情况下访问同一个共享变量，而且至少有一个是写 并行性的确定——Bernstein条件 $R(Si):Si的读子集$​ $W(Si):Si的写子集$ 两个进程S1和S2可并发当且仅当只有两进程的读子集可重合，进程之间读写集，写写集交均为空 1.2 进程 进程是程序在一个数据集合上独立运行的过程，是系统进行资源分配和调度的一个独立单位 动态性：生命周期：产生、执行、消亡 并发性：多个进程同时存在于内存中，能在一段时间内同时运行 独立性：进程是独立运行的基本单位 制约性：进程之间相互制约 结构特征：程序段、数据段、进程控制块PCB 一个进程包括 程序的代码 程序的数据 PC中的值 通用寄存器的值，堆、栈 一组系统资源 1.3 进程控制 由操作系统内核来实现：创建和撤销进程以及实现进程的状态转换 进程创建\n系统初始化 通过已存在的进程创建 用户创建一个作业 提交一个批处理作业 进程撤销\n进程正常结束 给定时限到 出错或失败 进程执行中止服务请求 用户退出登录 原语：由若干条指令所组成的指令序列，来实现某个特定的操作功能\n指令序列是连续的，不可分割 必须在内核态（管态）下执行，且常驻内存 不可中断 执行时关闭中断实现 创建原语fork,exec 撤销原语kill 创建子进程:Fork\nfork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程（调用一次返回两次） 在子进程中,fork函数返回0 在父进程中,fork函数返回新创建子进程的进程ID 出现错误，返回负值 进程运行状态\n就绪状态：进程已获得除处理机外的所需资源，等待分配处理机资源；只要分配CPU就可执行\n执行状态：占用处理机资源\n阻塞状态：正在执行的进程由于发生某种事件而暂时无法执行\n从运行状态到阻塞状态的转换是由进程自身决定的（考过）\n就绪态不会转换到阻塞态，只有运行态才能进入阻塞态\n进程被唤醒：就绪态\n若内存中有N个进程\n运行状态最多1个，最少0个 就绪状态最多N-1个，最少0个 等待状态最多N个，最少N-1个 进程控制块PCB\n进程标识符（进程id/父进程id） 程序和数据地址 当前状态：就绪 运行 阻塞 现场保护区 同步与同步机制 优先级 资源清单（IO设备，打开的文件列表） 2. 线程 多进程场景下通信和共享数据的困难\n进程包含了两个概念：资源拥有者和可执行单元 资源拥有者称为进程 可执行单元称为线程，只包含必不可少的少量资源 与同进程的其他线程共享进程拥有的所有资源 一个进程可以拥有多个线程，一个线程只能属于一个进程 进程是资源分配的基本单位，线程是处理机(CPU)调度的基本单位(考过) 线程除了共享进程的数据，还有自己的堆栈 线程不能单独执行，必须组成进程才能被执行 线程的实现方式 1. 用户级线程 线程在用户空间，通过library模拟实现的thread，不需要或仅需要极少的kernel支持 用户级的线程库 创建和销毁线程 线程之间传递消息和数据 调度线程执行 保存和恢复线程上下文 只需要线程库支持，与内核无关 很多系统调用会引起阻塞，内核会因此阻塞所有相关的线程，即用户级线程可以进行系统调用(考过) 内核只能将处理器分配给进程，即使有多个处理器也无法实现一个进程中多个线程的并行执行 2.内核级线程 kernel有好几个分身，每一个分身可以处理一件事情 kernel对每一个异步时间产生一个线程来处理 内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行 阻塞发生在线程级别 3.混合实现 系统实现内核级线程 用户使用用户级线程 实现从用户空间的线程到内核空间线程的多路 用户级和内核级的比较 在只有用户级线程的系统内，CPU调度还是以进程为单位 在有内核支持线程的系统内，CPU调度以线程为单位 内核级线程是OS内核可感知的，用户级线程是OS内核不可感知的 用户级线程的创建、撤销和调度不需要OS内核的支持，在语言或用户库这一级处理 内核线程的创建、撤销和调度都需要OS内核提供支持 用户级线程执行系统调用指令时将导致所属进程被中断 内核级线程执行系统调用指令只导致该线程被中断 内核线程切换需要进入到内核态，比用户级线程切换效率低(考过) 3. 进程调度 度量指标的定义 吞吐量：作业数/总执行时间 周转时间：完成时间-提交时间 带权周转时间：周转时间/执行时间 平均周转时间：一组作业周转时间之和/作业数 平均带权周转时间：一组作业带权周转时间之和/作业数 1. 批处理系统中常用的调度算法 先来先服务(FCFS:first come first serve)：\n按照作业提交或进程变为就绪状态的先后次序进入就绪队列排队，按队列次序分派CPU 当前作业或进程占用CPU，直到执行完或阻塞才让出CPU(非抢占) 作业或进程被唤醒后放到就绪队列尾部 有利于计算密集作业和长作业，不利于IO密集作业 最短作业优先(SJF:shortest job first)：对预期执行时间短的作业优先分派处理机(非抢占：在每个作业执行完之后选择最短的作业)\n减少平均周转时间，提高吞吐量 对长作业不利 周转时间最优 最短剩余时间优先(SRTN:shortest remaining time next)：\n抢占式：在新作业到来时选择最短的作业：当一个新进程到达时，如果他比当前运行进程具有更短的完成时间，系统抢占当前进程，选择新就绪的进程执行\n长任务长时间不能运行，饥饿现象\n最高响应比优先(HRRN:highest response ratio next)：\n既考虑作业的运行时间又考虑作业的等待时间（非抢占式） 每次进行调度时，计算作业队列中每个作业的优先级，选择优先级最大的运行 优先级 $response-priority: RP = 1 + waittime/needtime $ 2.交互式系统的调度算法 时间片轮转算法(Round Robin)\n将就绪进程按照FCFS原则排成一个队列 每次调度时将CPU分派给队首进程，让其执行一个时间片 在一个时间片结束时，发生时钟中断（抢占式） 时钟中断发生时进程还在运行，就送到就绪队列的末尾 优先级调度(priority scheduling)\n赋予每个进程不同优先级，高优先级先运行 静态优先级 进程创建时指定，运行过程中不再改变 动态优先级 运行过程中动态改变优先级 多级队列算法(MQ)\n分类为多个就绪队列 多级反馈队列算法(FMQ)\n优先级倒置(考过)：优先级抢占式调度算法+临界资源导致\n当高优先级进程Task A 要进入临界区使用临界资 源X时，如果已经有一个低优先级进程Task C 正 在使用该资源\n这种情况是怎么形成的呢，假如有三个完全独立的进程P1,P2,P3。P1的优先级最高依次减小，P3优先级最低。P1和P3两者共用一个临界资源。当P3先执行的时候只是进行了P操作未进行V操作将临界资源释放但是P2这时候把P3的处理机抢占了这时P3无法执行。当P1要执行的时候虽然可以将P2占有的处理机抢占但是无法把P3占用的临界资源进行得到。所以需要等待P2执行结束再P3执行结束释放临界资源这时候P1才可以进行执行。\n高优先级进程(线程)被低优先级进程(线程)延迟或阻塞 临界资源：一次仅允许一个进程访问的资源(考过) 解决方法1：优先级置顶 低优先级进程进入临界区后，所占用的处理机就不允许被抢占 给低优先级进程设置最高优先级 解决方法2：优先级继承 低优先级进程继承高优先级进程的优先级 以便低优先级进程尽快推进 3. 实时系统调度算法 4. 进程同步 多个相关进程在执行次序上的协调，保证这种关系的机制为同步机制\n数据竞争：多个进程对共享变量的无保护的同时访问，至少有一个是写 原子性违反：原子性：一组操作要么都做，要么都不做 死锁 4.1 临界区 临界资源：一次只允许一个进程使用的资源称为临界资源 临界区：对临界资源进行访问的程序片段 两个进程不同时处于临界区：互斥 4.2 基于忙等待的互斥方法 忙等待 ： 一个进程进入临界区之后，其他进程因无法满足竞争条件而循环探测竞争条件，浪费CPU，轮询\n严格轮换法\n设立一个公用整型变量turn\n进入临界区循环检查是否允许进入\nturn为0时，进程0可进入，退出时改turn为1 turn为1时，进程1可进入，退出时改turn为0 忙等：反复测试变量，浪费CPU\n严格要求两个进程交替运行，不必要\nPeterson算法\n4.3 信号量Semaphore S\u0026gt;=0表示当前可用的资源的数目\n对信号量操作原语：原子操作不会被打断\nP(S):down/wait 获取资源 V(S):up/signal 释放资源 信号量必须置一次且只能置一次初值（代表资源的个数）\nS的初值\nS = 1实现互斥：二元信号量（等于mutex） S \u0026gt; 1实现同步：通用信号量 P操作分配资源：检查信号量初值是否大于0，如果大于0，减一，继续执行；如果等于0，进程被直接阻塞，将当前进程从运行队列移动到信号量的队列，减1的操作暂时不做。进程P被阻塞到某个信号量，进程不在运行态，所以在唤醒前都不会占用CPU资源\nV操作释放资源：首先将信号量S增加1(原子操作)，如果有一个或多个进程在信号量的队列睡眠，就会随机唤醒一个进程(将进程从信号量的队列移动到就绪队列)，并使得其运行后能完成P操作的减1操作，所有S还是0\n信号量机制数据结构：一个整数(S)+一个队列(信号量等待队列)\n信号量的取值能小于0吗？和不同的系统实现有关\n信号量用于互斥\nP(S) 临界区 V(S) 初值 S=1，等价于锁 使用信号量实现会和\n使用信号量实现多路复用\nn个线程同时运行在临界区——限流阀\n信号量初值设为n 多进程同步原语：屏障Barriers\n计数器记录到达汇合点的线程数\n互斥：多个进程操作同一个临界资源就是互斥\n同步：多个进程要按一定的顺序执行就是同步\n信号量集\n同时需要多种资源、每种占用的数目不同且可分配的资源还存在一个临界值\nP.V操作可以解决任何同步互斥问题\n4.4 互斥量 Mutex 用于实现对共享资源和代码的互斥访问 0解锁，1加锁 mutex已经加锁，调用mutex_lock会阻塞 信号量值设为1就是互斥量 mutex_lock / mutex_unlock 4.5 条件变量 当某个条件未被满足，阻塞当前线程 4.6 管程 Monitor 把分散的临界区集中起来，为每个可共享资源设计一个专门机构来统一管理各进程对该资源的访问，这个专门机构为管程 对于共享资源，管程需要提供互斥和同步 管程的机制保证只有一个进程在管程内执行 一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据 4.7 进程间通信 低级通信：只能传递状态和整数值 信号量机制 管程机制 高级通信：能够传送任意数量的数据 管道 共享内存 消息系统 管道 管道是用于连接读进程和写进程以实现两个进程通信的共享文件\ncat file1 | grep sth_to_search 无名管道\n管道是半双工的，数据只能向一个方向流动，需要双方通信时修妖建立起两个管道\n只能用于父子进程或兄弟进程\n单独构成一种独立的文件系统，管道对于两端的进程而言就是一个文件，但不属于某种文件系统，它单独构成一种文件系统，只存在在内存中\n写入内容在管道缓冲区末尾，从缓冲区头部读出数据\n有名管道(FIFO)\n无名管道只能在具有亲缘关系的进程间通信，有名管道克服了这一限制\nFIFO提供一个路径名与之关联，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能彼此通过FIFO相互通信 消息传递 两个通信原语\nsend(destination,\u0026amp;message) receive(source,\u0026amp;message) 调用方式：阻塞/非阻塞\n共享内存 最有用的进程间通信方式，最快的IPC形式，避免了其他形式的IPC必须执行的缓冲复制 进程直接读写共享内存，效率高 两个不同进程A,B共享内存的意义是，同一块物理内存被映射到A,B各自的进程地址空间 ","permalink":"https://coder0xe.github.io/posts/os%E6%9C%9F%E4%B8%AD%E7%90%86%E8%AE%BA%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/","summary":"\u003ch1 id=\"os理论期中考试复习\"\u003eOS理论期中考试复习\u003c/h1\u003e\n\u003ch2 id=\"一引论\"\u003e一.引论\u003c/h2\u003e\n\u003ch3 id=\"1-操作系统定义\"\u003e1. 操作系统定义\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e操作系统是一组\u003cstrong\u003e管理计算机硬件资源的软件集合\u003c/strong\u003e，他向计算机程序提供共性的服务\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-操作系统发展史\"\u003e2. 操作系统发展史\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e电子管时期：软件：手工修改硬件逻辑单元连接\u003c/li\u003e\n\u003cli\u003e解决人和CPU的矛盾：软件和硬件分离\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"21-批处理系统\"\u003e2.1 批处理系统\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e加载在计算机上的一个系统软件，在他的控制下，计算机能够自动地、成批地处理一个或多个用户的作业\u003c/li\u003e\n\u003cli\u003e用户将一批作业提交给操作系统后就不再干预\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"211-联机批处理系统\"\u003e2.1.1 联机批处理系统\u003c/h5\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240416232900166\" loading=\"lazy\" src=\"/img/image-20240416232900166.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在主机和输入机之间增加一个存储设备——磁带，在运行于主机的\u003cstrong\u003e监督程序(OS)的自动控制\u003c/strong\u003e下，计算机可自动完成：成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行，然后把计算结果向输出机输出。完成了上一批作业后，监督程序又从输入机上输入另一批作业，保存在磁带上，重复处理\u003c/li\u003e\n\u003cli\u003e优点：监督程序不停地处理各个作业，实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间，克服了人机矛盾。\u003c/li\u003e\n\u003cli\u003e缺点：\u003cstrong\u003eCPU与慢速的外设之间的矛盾：在作业输入和结果输出时，主机的高速CPU需要等待慢速的输入输出设备完成工作，主机处于“忙等”状态\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"212-脱机批处理系统\"\u003e2.1.2 脱机批处理系统\u003c/h5\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240416234006322\" loading=\"lazy\" src=\"/img/image-20240416234006322.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e增加一台不与初级直接相连而是与输入输出设备打交道的卫星机\u003c/li\u003e\n\u003cli\u003e优点：主机不直接与慢速的输入输出设备打交道，而是与速度相对较快的磁带机发生关系，\u003cstrong\u003e主机与卫星机并行工作\u003c/strong\u003e，发挥主机的高速计算能力\u003c/li\u003e\n\u003cli\u003e缺点：主机内存中仅存放一道作业，每当该作业运行期间发生输入输出请求后，高速的CPU便处于等待低速的IO完成状态，COU空闲\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"22-多道程序系统\"\u003e2.2 多道程序系统\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e多道程序设计技术，\u003cstrong\u003e指允许多个程序同时进入内存并运行\u003c/strong\u003e。即同时把多个程序放入内存中，并允许他们交替在CPU中运行，共享系统中的各种硬软件资源\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e当一道程序因为IO请求而暂停运行时，CPU便立即转去运行另一道程序，不同程序间的切换运行\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使CPU得到充分利用,同时改善IO设备和内存的利用率，提高整个系统的资源利用率和系统吞吐量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240416235652994\" loading=\"lazy\" src=\"/img/image-20240416235652994.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e宏观上并行\u003c/strong\u003e：进入系统的几道程序都处于运行过程中，都开始了各自的运行，但都未运行完毕\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e微观上串行\u003c/strong\u003e：各道程序轮流地使用CPU，并交替运行\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"23-单道程序系统\"\u003e2.3 单道程序系统\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e内存中只有一道程序，存在计算时IO设备空闲或进行IO操作时CPU空闲\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240416235510405\" loading=\"lazy\" src=\"/img/image-20240416235510405.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"24-多道批处理系统\"\u003e2.4 多道批处理系统\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e多道：系统内可同时容纳多个作业\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e成批：在系统运行过程中，不允许用户与其作业发生交互\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e优点：系统吞吐量大，资源利用率高\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e缺点：平均周转时间长，\u003cstrong\u003e单个用户不能交互，多用户使用和单独控制的矛盾\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"25-分时系统\"\u003e2.5 分时系统\u003c/h4\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240417000609671\" loading=\"lazy\" src=\"/img/image-20240417000609671.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e分时技术：把处理机的运行时间分成很短的时间片，按时间片轮流把CPU分配给各联机作业/程序使用，\u003cstrong\u003e给不同的用户提供程序的使用\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e一台计算机同时连接多个用户终端\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e特点\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e多路性：宏观上看多个用户并行工作，微观上看是各用户轮流使用计算机\u003c/li\u003e\n\u003cli\u003e交互性：用户可以根据系统对请求的响应结果，进一步向系统提出新的请求(交互式系统)\u003c/li\u003e\n\u003cli\u003e独立性：用户之间相互独立，互不干扰\u003c/li\u003e\n\u003cli\u003e及时性：系统对用户的输入及时作出响应\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"26-网络操作系统\"\u003e2.6 网络操作系统\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e传统单机OS上加单独软件层，提供联网功能和资源的远程访问，多机互联\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"27-分布式操作系统\"\u003e2.7 分布式操作系统\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e多台机器统一管理形成单一系统\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"28-实时系统\"\u003e2.8 实时系统\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在某个时间限制内及时完成某些及时任务不需要时间片排队\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-操作系统的基本实现机制\"\u003e3. 操作系统的基本实现机制\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e用户态和内核态\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240417002636183\" loading=\"lazy\" src=\"/img/image-20240417002636183.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e用户态和内核态所在的\u003cstrong\u003e内存空间\u003c/strong\u003e不一样\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCPU的\u003cstrong\u003e运行状态\u003c/strong\u003e不一样\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e指令的\u003cstrong\u003e执行权限\u003c/strong\u003e不一样\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e从用户态转入内核态\u003c/strong\u003e\u003c/p\u003e","title":"OS理论期中考试复习"},{"content":"OS第三次理论作业 一.第一题 (1) 答 32位虚拟地址空间，故整个的地址空间大小为4GB；页内偏移量为12位，故一页有4096字节 (2) 答 考察了二级页表的自映射机制，第一级页表所在的逻辑地址即为第一级页表中第一个页表项的逻辑地址，第一个页表项映射到第一个二级页表，第一个二级页表对应的虚拟页号为$0x80000000 \u0026raquo; 12 = 0x00080000$，故该页表项为第$0x0008000$个页表项，相对于页表项起始地址的偏移量为$0x00080000 * 4$，故对应的逻辑地址为$PT_{base} + (PT_{base} \u0026laquo;12) *4 = 0x80200000$ (3) 答 逻辑地址0x0：访问逻辑地址0x0时，对应的页目录偏移量为0，对应的有效位为0，引发了缺页中断，需要进行重填\n逻辑地址0x00803004：访问逻辑地址0x00803004时，对应的页目录偏移量为2，有效位为1，对应的物理地址为0x5000，逻辑地址对应的二级页表偏移量为3，对应的页表项有效位为1，对应的物理地址为0x20000，页内偏移量为4字节，\n若系统为小端存储(数据的低字节放在低地址空间，大小端的顺序是以字节为单位的，而不是bit)，则数据排布为0000_9000,0032_6001,则访问到的数据为0x1 若系统为大端存储(数据的高字节放在低地址空间)，则数据排布为0090_0000,0160_3200,则访问到的数据为0x0 逻辑地址0x00402001：访问逻辑地址0x00402001时，对应的页目录偏移量为1，有效位为1，对应的物理地址为0x1000，逻辑地址对应的二级页表偏移量为2，对应的页表项有效位为1，对应的物理地址为0x5000，页内偏移量为1字节，访问到的数据为0x0\n(4) 答 ​\t要想访问物理地址0x326028，先看他的物理页号，物理页号为$0x326028 \u0026raquo; 12 = 0x326000$则对应起始物理地址为0x20000页表中偏移量为1的项，对应页目录中偏移量为3的页表项的映射，页内偏移量为$0x28$，故逻辑地址为$0x00c01028$\n二.第二题 前提：LOAD STORE操作的均为虚拟地址 大尾端为将数据的高位存在低地址端\n0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000\n0000440: b484 6c4e 004e ed00 0000 0000 0100 0000\n在大端模式下，前32位应该这样读: e6 84 6c 4e\n在小端模式下，前32位应该这样读: 4e 6c 84 e6\n指令 结果 寻址过程 Load[0x0000_1022] $0x20$ 逻辑地址对应的页目录偏移量为0，对应的页目录项$0x00100007$，有效位有效，对应页表的物理基地址为$0x00100000$，逻辑地址对应的页表偏移量为1，对应的页表项为$0x00004067$，有效位有效（对于读操作不需要考虑读写位），并且可以读写，对应物理地址加上页内偏移量为$0x00004022$，读取的数据为$0x20$ Store[0x00c0_7222] Error 逻辑地址对应的页目录偏移量为3，对应的页目录项为$0x00103007$，有效位有效，对应页表的物理基地址为$0x00103000$，逻辑地址对应的页表偏移量为7，对应的页表项为$0xEEFF0001$,有效位为1，但是读写位为0，即只可读，不可写，故无法进行Store Store[0x00c0_05bf] OK 逻辑地址对应的页目录偏移量为3，对应的页目录项为$0x00103007$，有效位有效，对应页表的物理基地址为$0x00103000$，逻辑地址对应的页表偏移量为0，对应的页表项为$0x11220067$，对应的有效位为1，读写位为1，可以进行写操作 Load[0x0000_3013] $0x19$ 逻辑地址对应的页目录偏移量为0，对应的页目录项$0x00100007$，有效位有效，对应页表的物理基地址为$0x00100000$，逻辑地址对应的页表偏移量为3，对应的页表项为$0x00004007$，对应的有效位为1，并且可以读写，对应物理地址加上页内偏移量为$0x00004013$，读取的数据为$0x19$ Load[0xff80_078f] Error 逻辑地址对应的页目录偏移量为$0x3FE$，它对应的物理地址为$PD_{base} + PDX(x) \u0026laquo;2=0x00200FF8$,对应的页目录项为$0x001FE007$，对应的有效位和读写位均为1，对应页表的物理基地址为$0x001FE000$，逻辑地址对应的页表偏移量为3，对应的页表项为$0xD0E1F203$，有效位有效且可读可写，对应页表物理基地址为$0xD0E1F000$，不存在相应的物理地址 Load[0xffff_f005] $0x66$ 逻辑地址对应的页目录偏移量为$0x3FF$，它对应的物理地址为$PD_{base} + PDX(va) \u0026laquo; 2 = 0x00200FFC$对用的页目录项为$001FF007$，对应的有效位和读写位均为1，对应页表的基地址为$0x001FF000$，逻辑地址对应的页表偏移量为$0x3FF$，对应页表项的物理基地址为$0x001FFFFC$，对应的页表项为$0x00103067$，有效位和读写位均为1，对应物理地址加上页内偏移量为$0x00103005$，读取的数据为$0x66$ 经过李国庆先生的指正，这里需要注意的是，从虚拟地址va中得到了对应的页目录偏移量(PDX(va))以及页表偏移量(PTX(va))，这里并不能直接访问到对应的项，需要先计算出它所在的物理地址再访问对应的页表项内容，\n页目录项的物理地址(一项为4字节，左移2位)\npa = PDbase + PDX(va) \u0026lt;\u0026lt; 2 页表项的物理地址(题目中第一个页目录项即为第一个页表项，相当于第一个二级页表就是页目录，即PTbase=PDbase)\npa = PDbase + PTX(va) \u0026lt;\u0026lt; 2 ","permalink":"https://coder0xe.github.io/posts/os%E7%AC%AC%E4%B8%89%E6%AC%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/","summary":"\u003ch1 id=\"os第三次理论作业\"\u003eOS第三次理论作业\u003c/h1\u003e\n\u003ch2 id=\"一第一题\"\u003e一.第一题\u003c/h2\u003e\n\u003ch3 id=\"1-答\"\u003e(1) 答\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e32位虚拟地址空间，故整个的地址空间大小为4GB；页内偏移量为12位，故一页有4096字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-答\"\u003e(2) 答\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e考察了二级页表的自映射机制，第一级页表所在的逻辑地址即为第一级页表中第一个页表项的逻辑地址，第一个页表项映射到第一个二级页表，第一个二级页表对应的虚拟页号为$0x80000000 \u0026raquo; 12 = 0x00080000$，故该页表项为第$0x0008000$个页表项，相对于页表项起始地址的偏移量为$0x00080000 * 4$，故对应的逻辑地址为$PT_{base} + (PT_{base} \u0026laquo;12) *4 = 0x80200000$\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-答\"\u003e(3) 答\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e逻辑地址0x0\u003c/strong\u003e：访问逻辑地址0x0时，对应的页目录偏移量为0，对应的有效位为0，引发了缺页中断，需要进行重填\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240415102931840\" loading=\"lazy\" src=\"/img/image-20240415102931840.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e逻辑地址0x00803004\u003c/strong\u003e：访问逻辑地址0x00803004时，对应的页目录偏移量为2，有效位为1，对应的物理地址为0x5000，逻辑地址对应的二级页表偏移量为3，对应的页表项有效位为1，对应的物理地址为0x20000，页内偏移量为4字节，\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240415104253218\" loading=\"lazy\" src=\"/img/image-20240415104253218.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240415104120733\" loading=\"lazy\" src=\"/img/image-20240415104120733.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240415104609564\" loading=\"lazy\" src=\"/img/image-20240415104609564.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若系统为小端存储(数据的低\u003cstrong\u003e字节\u003c/strong\u003e放在低地址空间，\u003cstrong\u003e大小端的顺序是以字节为单位的，而不是bit\u003c/strong\u003e)，则数据排布为0000_9000,0032_6001,则访问到的数据为0x1\u003c/li\u003e\n\u003cli\u003e若系统为大端存储(数据的高\u003cstrong\u003e字节\u003c/strong\u003e放在低地址空间)，则数据排布为0090_0000,0160_3200,则访问到的数据为0x0\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e逻辑地址0x00402001\u003c/strong\u003e：访问逻辑地址0x00402001时，对应的页目录偏移量为1，有效位为1，对应的物理地址为0x1000，逻辑地址对应的二级页表偏移量为2，对应的页表项有效位为1，对应的物理地址为0x5000，页内偏移量为1字节，访问到的数据为0x0\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240415104100600\" loading=\"lazy\" src=\"/img/image-20240415104100600.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240415104501294\" loading=\"lazy\" src=\"/img/image-20240415104501294.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240415104523831\" loading=\"lazy\" src=\"/img/image-20240415104523831.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4-答\"\u003e(4) 答\u003c/h3\u003e\n\u003cp\u003e​\t要想访问物理地址0x326028，先看他的物理页号，物理页号为$0x326028 \u0026raquo; 12 = 0x326000$则对应起始物理地址为0x20000页表中偏移量为1的项，对应页目录中偏移量为3的页表项的映射，页内偏移量为$0x28$，故逻辑地址为$0x00c01028$\u003c/p\u003e\n\u003ch2 id=\"二第二题\"\u003e二.第二题\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e前提：LOAD STORE操作的均为虚拟地址 大尾端为将数据的高位存在低地址端\u003c/p\u003e\n\u003cp\u003e0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000\u003c/p\u003e\n\u003cp\u003e0000440: b484 6c4e 004e ed00 0000 0000 0100 0000\u003c/p\u003e\n\u003cp\u003e在大端模式下，前32位应该这样读: e6 84 6c 4e\u003c/p\u003e\n\u003cp\u003e在小端模式下，前32位应该这样读: 4e 6c 84 e6\u003c/p\u003e","title":"OS第三次理论作业"},{"content":"OO第二单元第三次作业 [toc]\n0.本次作业新增需求 新增一种RESET请求，可以将单部电梯重置为双轿电梯 [时间戳]RESET_ACCEPT-电梯ID-换乘楼层-每个轿厢的满载人数-每个轿厢移动一层的时间(单位s) 重置电梯两个轿厢的参数相同（满载人数、移动一层的时间） 重置完成后轿厢A默认在换乘楼层的下一层，轿厢B默认在换乘楼层的上一层 轿厢A只能在换乘楼层及以下运行，轿厢B只能在换乘楼层及以上运行 两个轿厢不能同时处于换乘楼层 特别地，双轿厢电梯可以不受RECEIVE约束地从换乘楼层移动一层以离开换乘楼层 保证双轿厢电梯不会接收到第一类重置请求和第二类重置请求。 换乘楼层在3层和9层之间 双轿厢电梯耗电量为$\\frac 1 4$ 1.处理流程分析 ​\t本次作业中主要的任务即为处理新增的RESET请求，对于上次作业已有的调度策略没有进行改变，目标比较明确。下面是时序图\n1.1 UML时序图 1.2 新增RESET请求的处理 1.2.1 Elevator ​\t本次作业中对于双轿厢RESET请求的类协作与第二次作业中普通重置请求相同。这里我对于RESET请求的处理方式是接收到双轿厢RESET请求时新建一个线程，将原来的线程作为A轿厢，新建的电梯线程作为B轿厢。这里首先给出电梯新增的几个属性\n1 2 3 4 5 6 7 //Elevator private char elevatorType = \u0026#39;C\u0026#39;; // 轿厢类型 A B private int transferFloor = -1; private int lowerLimit = 1; private int upperLimit = 11; private Flag busyFlag = null; // 一组电梯共享一个flag进行通信 private AtomicInteger personSatisfied; elevatorType：电梯的类型，初始时电梯的类型为C类型，双轿厢重置后修改为A/B类型 lowerlimit/upperlimit：电梯的运行楼层限制，用于Dispatcher中对于符合运行范围电梯的筛选 transferFloor：换乘楼层(似乎没用，不是lowerlimit就是upperlimit) busyFlag：用于控制双轿厢电梯在换乘楼层互斥的需求，这里借鉴了讨论区中实现线程安全类的思路 personSatisfied：计数器，所有电梯线程和输入线程的共享变量，当一个乘客需求被满足(送到指定楼层)，该原子类型+1 ​\t参考NormalReset在第二次作业中的实现方式，DoubleCarReset我选择相同的实现方法，当电梯拿到DoubleCarReset请求之后立即进行重置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Elevator private void doubleCarReset() { if (curNum != 0) { removePeopleInElevator(); } OutputHandler.printResetBegin(elevatorId); try { Thread.sleep(1200); } catch (InterruptedException e) { e.printStackTrace(); } OutputHandler.printResetEnd(elevatorId); // 创建新电梯线程 //... newelevator.start(); // 加入与Dispatcher共享变量中 this.elevatorList.get(elevatorId - 1).add(newelevator); this.elevatorRequestTableList.get(elevatorId - 1).add(newRequestTable); // reset后全部扔回，防止在reset期间分配到不符合reset后电梯运行范围的乘客请求 this.requestTable.receiveResetRequest(buffer); this.mainRequestTable.receiveResetRequest(this.requestTable.getRequestList()); doubleCarResetRequest.set(null); } 注意输出，启动新电梯线程，扔回乘客请求，set(null)的顺序，这里不再赘述。 这里建立新线程之后将新线程的Elevator和RequestTable加入到与Dispatcher共享的电梯表和电梯请求表中，便于获取电梯状态计算得分以及分配乘客请求。 需要注意的是在电梯重置过程中调度器还在进行分配，可能会出现分配的乘客不满足RESET后电梯运行范围的问题，在我的实现中，将原电梯的等待队列变为A轿厢的等待队列，这样如果分配了位于transferFloor之上的请求就会出现错误，所以我的实现是在第二类RESET之后将给他分配的所有请求扔回去重新调度(更加精确的做法似乎是判断一下范围，将不符合范围的请求扔回去，但是感觉不如直接扔回去简洁且没有bug) ​\t在电梯移动过程中，需要注意利用busyFlag占领和释放换乘楼层，或者说，当移动到换乘楼层时进行占领(occupy)，离开换乘楼层时进行释放(release)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private void move() { try { Thread.sleep((long) (1000 * speed)); } catch (InterruptedException e) { e.printStackTrace(); } int pace = (direction) ? 1 : -1; curFloor += pace; if (elevatorType != \u0026#39;C\u0026#39; \u0026amp;\u0026amp; curFloor == transferFloor) { busyFlag.setOccupied(); } OutputHandler.printArrive(elevatorType,curFloor,elevatorId); if (elevatorType != \u0026#39;C\u0026#39; \u0026amp; curFloor - pace == transferFloor) { busyFlag.setRelease(); } } ​\t需要修改电梯中出乘客的out方法，我们可以将需要出电梯的乘客分为两类\n到达目的地 还没到达目的地但已经到达换乘楼层：扔回总请求队列重新调度 1 2 3 4 5 6 7 8 9 10 private void out() { // 到达目的地的人出电梯 if (!destMap.get(curFloor).isEmpty()) { arriveDestOut(); } // 需要换乘的人出电梯 if (elevatorType != \u0026#39;C\u0026#39; \u0026amp;\u0026amp; curFloor == transferFloor) { transferOut(); } } 1.2.2 Flag ​\t这里借鉴了讨论区同学的思路(膜拜),我的理解是，实际上是相当于对换乘楼层上了锁，一个轿厢到达换乘楼层时上锁，若锁被另一个轿厢占用则等待不输出，直到另一个轿厢释放锁，该轿厢占有锁，输出ARRIVE，这样在保证正确性的同时又保证了性能(再次膜拜)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Flag { enum State { BUSY, IDLE } private State state; public Flag() { this.state = State.IDLE; } public synchronized void setOccupied() { waitRelease(); // 两个轿厢共享一个flag 相当于对这=换乘楼层的访问进行了上锁 一个走另一个才能访问 this.state = State.BUSY; notifyAll(); } private synchronized void waitRelease() { notifyAll(); while (this.state == State.BUSY) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void setRelease() { this.state = State.IDLE; notifyAll(); } } 1.2.3 Strategy 在策略类中需要新增一种建议TRANSFER，当一个轿厢要在换乘楼层WAIT或OVER时先进行TRANSER，即转向离开换乘楼层，防止另一个轿厢不能到达换乘楼层导致死锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (buffer.isEmpty()) { // 当前的缓冲队列为空 if (requestTable.isOver() \u0026amp;\u0026amp; requestTable.isEmpty()) { if (curFloor == transferFloor) { return Advice.TRANSFER; } else { return Advice.OVER; } } else { if (curFloor == transferFloor) { return Advice.TRANSFER; } else { return Advice.WAIT; } } } 1.2.4 Dispatcher ​\t在调度器中，并没有对调参算法进行改进，只需要对电梯进行筛选，不能分配给运行范围不符合乘客需求的电梯。筛选的标准即为电梯能接到乘客：\n若乘客上行，则电梯的lowerlimit应当小于等于乘客起始楼层fromFloor，电梯的upperlimit应当大于fromFloor 若乘客下行，则电梯的upperlimit应当大于等于乘客起始楼层fromFloor，电梯的lowerlimit应该小于fromFloor 1 2 3 4 5 6 7 8 9 10 11 for (Elevator elevator : doubleElevator) { if (direction \u0026amp;\u0026amp; elevator.getLowerLimit() \u0026gt; fromFloor || direction \u0026amp;\u0026amp; elevator.getUpperLimit() \u0026lt;= fromFloor) { continue; } else if (!direction \u0026amp;\u0026amp; elevator.getUpperLimit() \u0026lt; fromFloor || !direction \u0026amp;\u0026amp; elevator.getLowerLimit() \u0026gt;= fromFloor) { continue; } double score = calculateScore(elevator,person); //... } 1.2.5 OutputHandler ​\t由于本次作业中输出时需要判断电梯的类型，如果在每次输出时进行判断，则显得过于臃肿，故考虑到构建一个输出类，利用类中的静态输出方法区分电梯类别输出，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void printOpen(char elevatorType,int curFloor,int elevatorId) { switch (elevatorType) { case \u0026#39;A\u0026#39;: TimableOutput.println(String.format(\u0026#34;OPEN-%d-%d-A\u0026#34;,curFloor,elevatorId)); break; case \u0026#39;B\u0026#39;: TimableOutput.println(String.format(\u0026#34;OPEN-%d-%d-B\u0026#34;,curFloor,elevatorId)); break; case \u0026#39;C\u0026#39;: TimableOutput.println(String.format(\u0026#34;OPEN-%d-%d\u0026#34;,curFloor,elevatorId)); break; default: break; } } 1.3 电梯线程结束的条件 ​\t在这次作业中，由于换乘乘客也需要扔回去重新调度，加上两种RESET请求，设置结束的条件更加复杂。最初我写了各种“旁敲侧击”的条件，例如各种队列是否为空，但是效果并不好，总是出现电梯线程提前结束的情况。其实关于电梯线程结束最直接的条件就是一定要满足人民对于美好生活的需求，即判断是不是所有的乘客都已经到达了目的地，是不是所有的两类reset请求都已经完成。\n是不是所有乘客都已经到达了目的地 设置一个全局共享计数器，personSatisfied，每当一个乘客到达目的地，+1 在输入线程中设置一个乘客计数器，personCnt，每拿到一个乘客请求，+1 是不是两类reset请求都已经完成 遍历两个数组中是不是每个元素都是空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //InputThread public void run() { try { ElevatorInput elevatorInput = new ElevatorInput(System.in); int personCnt = 0; // 计算乘客数量 while (true) { Request request = elevatorInput.nextRequest(); if (request == null \u0026amp;\u0026amp; (personCnt == personSatisfied.get()) \u0026amp;\u0026amp; (dispatcher.ResetOver())) { mainRequestTable.setOver(); break; } else if (request == null) { mainRequestTable.waitRequest(); } else if (request instanceof PersonRequest) { //... personCnt++; } else if (request instanceof NormalResetRequest) { this.dispatcher.normalResetElevator((NormalResetRequest) request); } else if (request instanceof DoubleCarResetRequest) { this.dispatcher.doubleCarResetElevator((DoubleCarResetRequest) request); } } elevatorInput.close(); } catch (IOException e) { e.printStackTrace(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //Dispatcher public boolean ResetOver() { for (AtomicReference\u0026lt;DoubleCarResetRequest\u0026gt; doubleCarResetRequest : this.doubleCarElevatorResets) { if (doubleCarResetRequest.get() != null) { return false; } } for (AtomicReference\u0026lt;NormalResetRequest\u0026gt; normalResetRequest : this.normalCarElevatorResets) { if (normalResetRequest.get() != null) { return false; } } return true; } 2. UML图以及代码复杂度分析 2.1 UML图 2.2 代码复杂度分析 Dispatcher.calculateScore(Elevator, Person) 0.0 1.0 1.0 1.0 Dispatcher.Dispatcher(RequestTable, ArrayList\u0026gt;, ArrayList\u0026gt;, ArrayList\u0026gt;, ArrayList\u0026gt;) 0.0 1.0 1.0 1.0 Dispatcher.dispatchRequest(Person) 23.0 5.0 14.0 15.0 Dispatcher.doubleCarResetElevator(DoubleCarResetRequest) 0.0 1.0 1.0 1.0 Dispatcher.doubleCarResetOver() 3.0 3.0 2.0 3.0 Dispatcher.getDistance(int, int, int, boolean) 13.0 1.0 3.0 6.0 Dispatcher.getScore(int, double, double) 0.0 1.0 1.0 1.0 Dispatcher.getState(int, int, int) 0.0 1.0 1.0 1.0 Dispatcher.normalResetElevator(NormalResetRequest) 0.0 1.0 1.0 1.0 Dispatcher.run() 13.0 4.0 7.0 7.0 Elevator.arriveDestOut() 1.0 1.0 2.0 2.0 Elevator.destMapinit() 1.0 1.0 2.0 2.0 Elevator.doubleCarReset() 2.0 1.0 3.0 3.0 Elevator.Elevator(int, RequestTable, RequestTable, AtomicReference, AtomicReference, ArrayList\u0026gt;, ArrayList\u0026gt;, \u0026hellip;) 0.0 1.0 1.0 1.0 Elevator.elevatorAinit(int, Flag, double, int) 0.0 1.0 1.0 1.0 Elevator.elevatorBinit(int, Flag, double, int) 0.0 1.0 1.0 1.0 Elevator.getCapacity() 0.0 1.0 1.0 1.0 Elevator.getCurFloor() 0.0 1.0 1.0 1.0 Elevator.getCurNum() 0.0 1.0 1.0 1.0 Elevator.getDirection() 0.0 1.0 1.0 1.0 Elevator.getElevatorType() 0.0 1.0 1.0 1.0 Elevator.getLowerLimit() 0.0 1.0 1.0 1.0 Elevator.getSpeed() 0.0 1.0 1.0 1.0 Elevator.getUpperLimit() 0.0 1.0 1.0 1.0 Elevator.getWaitNum() 0.0 1.0 1.0 1.0 Elevator.in() 12.0 4.0 4.0 9.0 Elevator.move() 5.0 1.0 4.0 6.0 Elevator.moveRequestToBuffer() 3.0 3.0 2.0 3.0 Elevator.normalReset() 2.0 1.0 3.0 3.0 Elevator.openAndClose() 1.0 1.0 2.0 2.0 Elevator.out() 3.0 1.0 3.0 4.0 Elevator.removePeopleInElevator() 8.0 1.0 5.0 5.0 Elevator.run() 12.0 5.0 10.0 10.0 Elevator.transfer() 4.0 1.0 1.0 5.0 Elevator.transferOut() 12.0 1.0 6.0 6.0 Flag.Flag() 0.0 1.0 1.0 1.0 Flag.setOccupied() 0.0 1.0 1.0 1.0 Flag.setRelease() 0.0 1.0 1.0 1.0 Flag.waitRelease() 3.0 1.0 3.0 3.0 InputThread.InputThread(RequestTable, Dispatcher, AtomicInteger) 0.0 1.0 1.0 1.0 InputThread.run() 9.0 3.0 10.0 10.0 Main.main(String[]) 1.0 1.0 2.0 2.0 OutputHandler.printArrive(char, int, int) 1.0 1.0 1.0 4.0 OutputHandler.printClose(char, int, int) 1.0 1.0 1.0 4.0 OutputHandler.printIn(char, int, int, int) 1.0 1.0 1.0 4.0 OutputHandler.printOpen(char, int, int) 1.0 1.0 1.0 4.0 OutputHandler.printOut(char, int, int, int) 1.0 1.0 1.0 4.0 OutputHandler.printReceive(char, int, int) 1.0 1.0 1.0 4.0 OutputHandler.printResetBegin(int) 0.0 1.0 1.0 1.0 OutputHandler.printResetEnd(int) 0.0 1.0 1.0 1.0 Person.getFromFloor() 0.0 1.0 1.0 1.0 Person.getId() 0.0 1.0 1.0 1.0 Person.getToFloor() 0.0 1.0 1.0 1.0 Person.Person(Integer, Integer, Integer) 0.0 1.0 1.0 1.0 RequestTable.addRequest(Person) 0.0 1.0 1.0 1.0 RequestTable.delRequest(Person) 0.0 1.0 1.0 1.0 RequestTable.getOneRequestAndRemove() 1.0 2.0 1.0 2.0 RequestTable.getRequestList() 0.0 1.0 1.0 1.0 RequestTable.isEmpty() 0.0 1.0 1.0 1.0 RequestTable.isOver() 0.0 1.0 1.0 1.0 RequestTable.receiveResetRequest(ArrayList) 0.0 1.0 1.0 1.0 RequestTable.RequestTable() 0.0 1.0 1.0 1.0 RequestTable.setOver() 0.0 1.0 1.0 1.0 RequestTable.waitRequest() 1.0 1.0 2.0 2.0 Strategy.canOpenForIn(int, int, boolean, int) 14.0 5.0 3.0 8.0 Strategy.canOpenForout(int, int, char, HashMap\u0026gt;) 19.0 9.0 7.0 9.0 Strategy.getAdvice(int, int, char, int, boolean, int, HashMap\u0026gt;) 26.0 8.0 5.0 10.0 Strategy.hasReqInOriginDirection(int, boolean) 6.0 3.0 2.0 6.0 Strategy.Strategy(RequestTable, ArrayList) 0.0 1.0 1.0 1.0 代码复杂度主要集中在调参算法分配策略、电梯的动作、策略类中 3.Bug修复与策略 本次作业中强测和互测均未出现bug 房友出现RTLE问题 ","permalink":"https://coder0xe.github.io/posts/oo-unit2-hw7/","summary":"\u003ch1 id=\"oo第二单元第三次作业\"\u003eOO第二单元第三次作业\u003c/h1\u003e\n\u003cp\u003e[toc]\u003c/p\u003e\n\u003ch2 id=\"0本次作业新增需求\"\u003e0.本次作业新增需求\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e新增一种\u003ccode\u003eRESET\u003c/code\u003e请求，可以将单部电梯重置为双轿电梯\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e[时间戳]RESET_ACCEPT-电梯ID-换乘楼层-每个轿厢的满载人数-每个轿厢移动一层的时间(单位s)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e重置电梯两个轿厢的参数相同（满载人数、移动一层的时间）\u003c/li\u003e\n\u003cli\u003e重置完成后轿厢A默认在换乘楼层的下一层，轿厢B默认在换乘楼层的上一层\u003c/li\u003e\n\u003cli\u003e轿厢A只能在换乘楼层及以下运行，轿厢B只能在换乘楼层及以上运行\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e两个轿厢不能同时处于换乘楼层\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e特别地，双轿厢电梯可以不受RECEIVE约束地从换乘楼层移动一层以离开换乘楼层\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e保证双轿厢电梯不会接收到第一类重置请求和第二类重置请求\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e换乘楼层在3层和9层之间\u003c/li\u003e\n\u003cli\u003e双轿厢电梯耗电量为$\\frac 1 4$\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"1处理流程分析\"\u003e1.处理流程分析\u003c/h2\u003e\n\u003cp\u003e​\t本次作业中主要的任务即为处理新增的RESET请求，对于上次作业已有的调度策略没有进行改变，目标比较明确。下面是时序图\u003c/p\u003e\n\u003ch3 id=\"11-uml时序图\"\u003e1.1 UML时序图\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240420143756451\" loading=\"lazy\" src=\"/img/image-20240420143756451.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"12-新增reset请求的处理\"\u003e1.2 新增RESET请求的处理\u003c/h3\u003e\n\u003ch4 id=\"121-elevator\"\u003e1.2.1 Elevator\u003c/h4\u003e\n\u003cp\u003e​\t本次作业中对于双轿厢RESET请求的类协作与第二次作业中普通重置请求相同。这里我对于RESET请求的处理方式是接收到双轿厢RESET请求时新建一个线程，将原来的线程作为A轿厢，新建的电梯线程作为B轿厢。这里首先给出电梯新增的几个属性\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//Elevator\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003echar\u003c/span\u003e elevatorType \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e; \u003cspan style=\"color:#6272a4\"\u003e// 轿厢类型 A B\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e transferFloor \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e lowerLimit \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e 1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e upperLimit \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e 11;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e Flag busyFlag \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enull\u003c/span\u003e; \u003cspan style=\"color:#6272a4\"\u003e// 一组电梯共享一个flag进行通信\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e AtomicInteger personSatisfied;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eelevatorType\u003c/code\u003e：电梯的类型，初始时电梯的类型为C类型，双轿厢重置后修改为A/B类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elowerlimit/upperlimit\u003c/code\u003e：电梯的运行楼层限制，用于Dispatcher中对于符合运行范围电梯的筛选\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etransferFloor\u003c/code\u003e：换乘楼层(似乎没用，不是lowerlimit就是upperlimit)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebusyFlag\u003c/code\u003e：用于控制双轿厢电梯在换乘楼层互斥的需求，这里借鉴了讨论区中实现线程安全类的思路\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epersonSatisfied\u003c/code\u003e：计数器，所有电梯线程和输入线程的共享变量，当一个乘客需求被满足(送到指定楼层)，该原子类型+1\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t参考NormalReset在第二次作业中的实现方式，DoubleCarReset我选择相同的实现方法，当电梯拿到DoubleCarReset请求之后立即进行重置\u003c/p\u003e","title":"OO-Unit2-HW7"},{"content":"OO第二单元第二次作业 [toc]\n0.题目新增需求 乘客不再固定电梯接送，设计电梯调度策略 增加RECEIVE输出，避免自由竞争策略 增加RESET请求，时长1.2s，在RESET期间电梯处于静默状态(不可以开关门、移动、RECEIVE等)，重置电梯 1.处理流程分析 1.1 电梯调度策略 ​\t在本次作业中，需要设计将乘客分配给合适的电梯的调度器(补第五次作业偷的懒)，我的设计中选择将调度器作为一个线程实现，输入线程与调度器线程交互，调度器线程与六个电梯线程交互。对于单个电梯运行的策略我保留了第五次作业的LOOK算法，对于多部电梯的分配策略，我选择了性价比较高的调参方法，性价比体现在代码量较少的同时能够拿到比较好的性能分数。UML时序图如下\n1.1.1 UML时序图 1.1.2 调参算法 ​\t所谓调参算法其实就是选取几个有关电梯的指标，给这些指标赋予合适的参数，为每部电梯计算出得分，选择得分最高的电梯进行分配。我选取的指标有电梯接到该乘客需要走的距离，电梯中人数，电梯等待队列中人数，电梯容量，电梯速度。\n距离：这里距离的计算是不准确的，没有找出电梯运行的上确界或下确界，即没有找出电梯运行到哪里就可以转向，而是同一按照1/11处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private int getDistance(int fromFloor,int toFloor,int curFloor,boolean direction) { int distance = 0; int flow = (direction) ? 1 : -1; if ((toFloor - fromFloor) * flow \u0026gt; 0) { // 乘客移动方向与电梯当前移动方向相同 if ((fromFloor - curFloor) * flow \u0026gt;= 0) { // 电梯沿当前方向能接到乘客 distance = abs(fromFloor - curFloor); } else { if (flow == 1) { distance = 20 - curFloor + fromFloor; } else { distance = 20 + curFloor - fromFloor; } } } else { if (flow == 1) { distance = 22 - curFloor - fromFloor; } else { distance = curFloor + fromFloor - 2; } } return distance; } 电梯状态：电梯状态这个参数实际上是电梯容量、电梯中人数、电梯等待队列中人数三个量经过调参得来的，可以适当增加电梯等待队列中人数的权重，避免给一部性能好的电梯分配太多乘客，这样的性能可能还不如大家都运行\n1 2 3 private double getState(int capacity,int curNum,int waitNum) { return 1.3 * capacity - 1.1 * curNum - 1.0 * waitNum; } 计算得分：这里借鉴了肖灿学长的博客中的公式(千万别用线性公式)\n1 2 3 private double getScore(int distance,double state,double speed) { return (25 - distance + state - 5 * speed) / sqrt(speed); } ​\t关于后续被卡RTLE的处理：在电梯同时reset时，这样各部电梯得分都是相同的，我的实现中会把乘客都分给第一部电梯(擂台法记录最高得分的方式)，只需要在计算得分相同时，再次判断两个电梯中哪一部的等待队列中人数少并加入其中就可以解决这个问题，或者说多部电梯同时reset且得分相同的情况约等于模6实现。\n1 2 3 4 5 6 7 8 9 10 11 12 double score = calculateScore(elevator,person); if (score \u0026gt; bestScore) { bestScore = score; bestElevatorId = i; bestWaitNum = elevator.getWaitNum(); } else if (score == bestScore) { if (elevator.getWaitNum() \u0026lt; bestWaitNum) { bestScore = score; bestElevatorId = i; bestWaitNum = elevator.getWaitNum(); } } 1.2 RESET请求的实现方式 1.2.1 RESET实现 ​\t对于RESET请求的实现方式我最初使用了调度器线程和电梯线程直接交互的方式，这样的实现涉及到两个线程的交互。后来从Kai_Ker大佬那里学习到一种在电梯内部让电梯自行实现RESET的方式，并在重构中实现(膜拜)。\n原子类型类 AtomicReference\u0026lt;\u0026gt;\n​\t使用原子类型类AtomicReference\u0026lt;ResetRequest\u0026gt;，可以保证对于该类访问的线程安全性。这里设计ResetRequest为调度器线程和电梯线程的共享对象，在调度器中以数组形式管理六部电梯的六个ResetRequest变量。下面梳理一下处理流程：\n​\t在输入线程InputThread中，构建乘客总请求表mainRequestTable，负责保管所有的乘客请求，如果拿到重置请求直接调用调度器进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 while (true) { Request request = elevatorInput.nextRequest(); if (request == null \u0026amp;\u0026amp; dispatcher.resetOver()) { mainRequestTable.setOver(); break; } else if (request == null) { mainRequestTable.waitRequest(); } else if (request instanceof PersonRequest) { // 构建乘客实例 mainRequestTable.addRequest(person); } else if (request instanceof ResetRequest) { this.dispatcher.resetElevator((ResetRequest) request); } } ​\t在调度器线程Dispatcher中，有管理六部电梯的Reset请求的数组ArrayList\u0026lt;AtomicReference\u0026lt;ResetRequest\u0026gt;\u0026gt; elevatorResets，当调度器拿到重置请求，就把重置请求放进数组中对应的位置，并且要唤醒对应的电梯线程，因为电梯线程此时可能处于WAIT。而电梯线程中保管着一个ResetRequest(对应着调度器线程数组中的一个元素)，电梯每次运行时检查一下自己的ResetRequest是否不为空，即调度器线程是否在数组对应位置放了充值请求，如果有就先处理重置请求。\n调度器线程\n1 2 3 4 5 6 public void resetElevator(ResetRequest request) { this.elevatorResets.get(elevatorId - 1).set((ResetRequest)request); synchronized (this.elevatorRequestTableList.get(elevatorId - 1)) { this.elevatorRequestTableList.get(elevatorId - 1).notify(); } } 电梯线程\n1 2 3 4 5 6 7 8 9 public void run() { while (true) { if (this.resetRequest.get() != null) { this.reset(); continue; } //获得建议并运行... } } ​\t在电梯拿到reset请求后，重置自己的速度和容量属性。题目中要求在输出RESET-ACCEPT之后移动楼层不超过两层(不输出超过两次ARRIVE)，似乎这里还有优化空间，例如让电梯尽力走两层多送些人，但是我并没有针对这一点作出设计，而是拿到RESET请求就执行。当拿到RESET请求后，先判断电梯中此时是否有人(curNum)，如果有人就要把人清空，和等待队列中的人一起扔回总请求表重新调度(这里扔回总请求表重新调度的性能应当优于放回电梯自身的等待队列，因为重置之后该电梯不一定就是得分最高，同时应当注意扔回去的请求要改变起始楼层fromFloor)。这里唯一算作优化的一点是，在重置时，可以判断一下电梯中是否有人在重置时的楼层下电梯，避免已经完成了运送又重新调度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private void reset() { speed = resetRequest.get().getSpeed(); capacity = resetRequest.get().getCapacity(); // 如果电梯中有人 if (curNum != 0) { // OPEN-CLOSE 如果目的地不是当前楼层扔回buffer } TimableOutput.println(String.format(\u0026#34;RESET_BEGIN-%d\u0026#34;,elevatorId)); try { Thread.sleep(1200); } catch (InterruptedException e) { e.printStackTrace(); } TimableOutput.println(String.format(\u0026#34;RESET_END-%d\u0026#34;,elevatorId)); // 需要注意的是在输出之后扔回 避免提前receive requestTable.receiveResetRequest(buffer); mainRequestTable.receiveResetRequest(requestTable.getRequestList()); // 需要注意的是最后才能set null 防止主请求表提前结束 resetRequest.set(null); } 这里同样需要注意的一点是，输出RESET，扔回总表，set(null)的顺序 关于buffer的设计后面介绍 ​\t**在receiveResetRequest方法中，要注意唤醒对应的线程。**我们知道，当输入线程拿到的请求为空但但电梯线程不能结束时输入线程和调度器线程会陷入WAIT状态，当电梯等待队列中没有请求且没有被设置结束时陷入WAIT状态。当我们扔回请求时，破坏了等待条件中的没有请求，需要唤醒线程再次进行确认\n1 2 3 4 5 public synchronized void receiveResetRequest(ArrayList\u0026lt;Person\u0026gt; resetRequest) { this.requestList.addAll(resetRequest); resetRequest.clear(); // 每次扔回之后需要清空 this.notify(); } 1.2.2 buffer设计 ​\t题目中要求，在RESET过程中，电梯处于静默状态，不能输出RECEIVE等。一种比较简单的想法是，在分配乘客时，如果电梯处于RESET中，就不给他分配乘客。但是一种典型的情况是，六部电梯同时RESET，并在RESET期间输入大量乘客请求，以上做法很容易发生分配策略不佳导致超时RTLE或不断查询电梯状态的CTLE问题。一种较好的的解决办法是：即使电梯处于reset过程中，照样给电梯分配请求，具体的实现需要为电梯中请求队列之外新增一个缓冲队列buffer，调度器将乘客分配到电梯的请求队列中，每次电梯运行时，再从请求队列中将请求移动到缓冲队列中，这时统一输出RECEIVE\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Elevator.java public void run() { while (true) { if (this.resetRequest.get() != null) { this.reset(); continue; } // 将调度器与电梯的共享队列中的请求移动到buffer中并输出 每一次调用后requestTable一定为空 moveRequestToBuffer(); // 获得建议并运行 } } public void moveRequestToBuffer() { while (!requestTable.isEmpty()) { Person person = requestTable.getOneRequestAndRemove(); buffer.add(person); TimableOutput.println(String.format(\u0026#34;RECEIVE-%d-%d\u0026#34;, person.getId(),elevatorId)); } } 1.3 电梯线程结束条件 ​\t这次的作业中，设置线程的结束实际上是一个链式的过程，可如下图描述\n​\t所以重要的是考虑好起爆点的设计，即在输入线程中主请求表mainRequestTable的结束会导致调度线程和电梯线程的结束。我们知道，电梯的RESET请求会将乘客请求扔回mainRequestTable，即电梯相当于mainRequestTable的生产者，故mainRequestTable结束条件为拿到的请求为空并且所有的RESET请求都处理完(reset数组中每个元素都为空)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // InputThread public void run() { try { ElevatorInput elevatorInput = new ElevatorInput(System.in); while (true) { Request request = elevatorInput.nextRequest(); if (request == null \u0026amp;\u0026amp; dispatcher.resetOver()) { mainRequestTable.setOver(); break; } else if (request == null) { mainRequestTable.waitRequest(); } else if (request instanceof PersonRequest) { //... } else if (request instanceof ResetRequest) { this.dispatcher.resetElevator((ResetRequest) request); } } elevatorInput.close(); } catch (IOException e) { e.printStackTrace(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //Dispatcher public void run() { while (true) { if (mainRequestTable.isEmpty() \u0026amp;\u0026amp; mainRequestTable.isOver()) { for (RequestTable requestTable : this.elevatorRequestTableList) { requestTable.setOver(); } break; } Person person = mainRequestTable.getOneRequestAndRemove(); if (person == null) { mainRequestTable.waitRequest(); //需要wait 不然会CTLE } // 分配... } } public boolean resetOver() { for (AtomicReference\u0026lt;ResetRequest\u0026gt; resetRequest : this.elevatorResets) { if (resetRequest.get() != null) { return false; } } return true; } 这里mainRequestTable.isEmpty() \u0026amp;\u0026amp; mainRequestTable.isOver()即为电梯处理RESET中先扔回请求再对ResetRequest置空的原因，防止置空之后请求还没扔回来的时候就错判结束了电梯线程 2. UML类图及代码复杂度分析 2.1 UML类图 2.2 代码复杂度分析 代码复杂度主要聚集在策略类中判断策略的部分和电梯的动作in以及reset等，和上次作业一样 3. Bug修复与策略 强测中未出现bug，互测中被卡了RTLE，通过小规模重构改正，重构后架构如前文所述 关于CTLE：代码中出现轮询的问题大概是线程的run方法中while循环的问题，可以通过打印输出发现，只需要设置适当的条件使得线程阻塞而非始终循环 ","permalink":"https://coder0xe.github.io/posts/oo-unit2-hw6/","summary":"\u003ch1 id=\"oo第二单元第二次作业\"\u003eOO第二单元第二次作业\u003c/h1\u003e\n\u003cp\u003e[toc]\u003c/p\u003e\n\u003ch2 id=\"0题目新增需求\"\u003e0.题目新增需求\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e乘客不再固定电梯接送，设计电梯调度策略\u003c/li\u003e\n\u003cli\u003e增加RECEIVE输出，避免自由竞争策略\u003c/li\u003e\n\u003cli\u003e增加RESET请求，时长1.2s，在RESET期间电梯处于静默状态(不可以开关门、移动、RECEIVE等)，重置电梯\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"1处理流程分析\"\u003e1.处理流程分析\u003c/h2\u003e\n\u003ch3 id=\"11-电梯调度策略\"\u003e1.1 电梯调度策略\u003c/h3\u003e\n\u003cp\u003e​\t在本次作业中，需要设计将乘客分配给合适的电梯的调度器(\u003cdel\u003e补第五次作业偷的懒\u003c/del\u003e)，我的设计中选择将调度器作为一个线程实现，输入线程与调度器线程交互，调度器线程与六个电梯线程交互。对于单个电梯运行的策略我保留了第五次作业的LOOK算法，对于多部电梯的分配策略，我选择了\u003cstrong\u003e性价比较高\u003c/strong\u003e的调参方法，性价比体现在代码量较少的同时能够拿到比较好的性能分数。UML时序图如下\u003c/p\u003e\n\u003ch4 id=\"111-uml时序图\"\u003e1.1.1 UML时序图\u003c/h4\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240420141737494\" loading=\"lazy\" src=\"/img/image-20240420141737494.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"112-调参算法\"\u003e1.1.2 调参算法\u003c/h4\u003e\n\u003cp\u003e​\t所谓调参算法其实就是选取几个有关电梯的指标，给这些指标赋予合适的参数，为每部电梯计算出得分，选择得分最高的电梯进行分配。我选取的指标有\u003cstrong\u003e电梯接到该乘客需要走的距离，电梯中人数，电梯等待队列中人数，电梯容量，电梯速度\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e距离：这里距离的计算是不准确的，没有找出电梯运行的\u003cstrong\u003e上确界或下确界\u003c/strong\u003e，即没有找出电梯运行到哪里就可以转向，而是同一按照1/11处理\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003egetDistance\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e fromFloor,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e toFloor,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e curFloor,\u003cspan style=\"color:#8be9fd\"\u003eboolean\u003c/span\u003e direction) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e distance \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e 0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e flow \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (direction) \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e 1 : \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((toFloor \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e fromFloor) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e flow \u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e 0) { \u003cspan style=\"color:#6272a4\"\u003e// 乘客移动方向与电梯当前移动方向相同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e ((fromFloor \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e curFloor) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e flow \u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;=\u003c/span\u003e 0) { \u003cspan style=\"color:#6272a4\"\u003e// 电梯沿当前方向能接到乘客\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                distance \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e abs(fromFloor \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e curFloor);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            } \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (flow \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e 1) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    distance \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e 20 \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e curFloor \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e fromFloor;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                } \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    distance \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e 20 \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e curFloor \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e fromFloor;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        } \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (flow \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e 1) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                distance \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e 22 \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e curFloor \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e fromFloor;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            } \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                distance \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e curFloor \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e fromFloor \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e 2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e distance;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e电梯状态：电梯状态这个参数实际上是\u003cstrong\u003e电梯容量、电梯中人数、电梯等待队列中人数\u003c/strong\u003e三个量经过调参得来的，可以\u003cstrong\u003e适当增加电梯等待队列中人数的权重\u003c/strong\u003e，避免给一部性能好的电梯分配太多乘客，这样的性能可能还不如大家都运行\u003c/p\u003e","title":"OO-Unit2-HW6"},{"content":"OS:lab3课下基础 1.进程 由于没有实现线程，本实验中进程既是基本的分配单元，也是基本的执行单元\n1.1 进程控制块 ​\t进程控制块(Process Control Block)是用来管理进程的数据结构，可以记录进程的变化过程，记录进程的外部特征。PCB是系统感知进程存在的唯一标志，进程与PCB是一一对应的。在MOS中，PCB定义为一个Env结构体\n1 2 3 4 5 6 7 8 9 10 11 struct Env { struct Trapframe env_tf;\t// saved context (registers) before switching LIST_ENTRY(Env) env_link;\t// intrusive entry in \u0026#39;env_free_list\u0026#39; u_int env_id;\t// unique environment identifier u_int env_asid;\t// ASID of this env u_int env_parent_id;\t// env_id of this env\u0026#39;s parent u_int env_status;\t// status of this env Pde *env_pgdir;\t// page directory TAILQ_ENTRY(Env) env_sched_link; // intrusive entry in \u0026#39;env_sched_list\u0026#39; u_int env_pri;\t// schedule priority }; env_tf : 在发生进程调度，或当陷入内核时，会将当时的进程上下文环境保存在env_tf变量中\ntrap.h中对于Trapframe结构体的定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 struct Trapframe { /* Saved main processor registers. */ unsigned long regs[32]; /* Saved special registers. */ unsigned long cp0_status; unsigned long hi; unsigned long lo; unsigned long cp0_badvaddr; unsigned long cp0_cause; unsigned long cp0_epc; }; 可以知道，当发生进程调度时，对于上下文的保存主要是保存了32个通用寄存器以及协处理器寄存器中的内容，值得注意的是，cp0_epc相当于记录了当前执行到的指令位置\nenv_link：用来构建空闲进程链表env_free_list的链接域\nenv_id：每个进程的id都不一样，是进程独一无二的标识符\nenv_parent_id：本进程的父进程id\nenv_status：该进程的状态，只有如下列举三种情况\nENV_FREE：表示该进程控制块没有被任何进程使用，即该进程控制块处于空闲链表中 ENV_NOT_RUNNABLE：表示该进程处于阻塞状态 ENV_RUNNABLE：表示该进程处于执行状态或就绪状态 env_pgdir：保存了该进程页目录的内核虚拟地址\nenv_sched_link：用来构造调度队列env_sched_list的链接域\nenv_pri：进程的优先级\n1.2 系统启动 env_init ​\t在实验中，存放进程控制块的物理内存在系统启动后就已经分配好，就是envs数组。一开始所有的进程控制块都是空闲的，因此要把他们都串联到env_free_list上。\n进程控制块空闲队列env_free_list使用了LIST结构 进程控制块调度队列env_sched_list使用了TAILQ结构，实现了双端队列，可以在头部或尾部插入和取出 Exercise 3.1 env_init\n将所有进程控制块逆序插入空闲链表，编号更小的进程控制块优先被分配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void env_init(void) { int i; /* Step 1: Initialize \u0026#39;env_free_list\u0026#39; with \u0026#39;LIST_INIT\u0026#39; and \u0026#39;env_sched_list\u0026#39; with * \u0026#39;TAILQ_INIT\u0026#39;. */ /* Exercise 3.1: Your code here. (1/2) */ LIST_INIT(\u0026amp;env_free_list); TAILQ_INIT(\u0026amp;env_sched_list); /* Step 2: Traverse the elements of \u0026#39;envs\u0026#39; array, set their status to \u0026#39;ENV_FREE\u0026#39; and insert * them into the \u0026#39;env_free_list\u0026#39;. Make sure, after the insertion, the order of envs in the * list should be the same as they are in the \u0026#39;envs\u0026#39; array. */ /* Exercise 3.1: Your code here. (2/2) */ for (i = NENV - 1; i \u0026gt;= 0;i--) { envs[i].env_status = ENV_FREE; LIST_INSERT_HEAD(\u0026amp;env_free_list,\u0026amp;envs[i],env_link); } /* * We want to map \u0026#39;UPAGES\u0026#39; and \u0026#39;UENVS\u0026#39; to *every* user space with PTE_G permission (without * PTE_D), then user programs can read (but cannot write) kernel data structures \u0026#39;pages\u0026#39; and * \u0026#39;envs\u0026#39;. * * Here we first map them into the *template* page directory \u0026#39;base_pgdir\u0026#39;. * Later in \u0026#39;env_setup_vm\u0026#39;, we will copy them into each \u0026#39;env_pgdir\u0026#39;. */ struct Page *p; panic_on(page_alloc(\u0026amp;p)); p-\u0026gt;pp_ref++; base_pgdir = (Pde *)page2kva(p); map_segment(base_pgdir, 0, PADDR(pages), UPAGES, ROUND(npage * sizeof(struct Page), PAGE_SIZE), PTE_G); map_segment(base_pgdir, 0, PADDR(envs), UENVS, ROUND(NENV * sizeof(struct Env), PAGE_SIZE), PTE_G); } 1.3 段地址映射 map_segment ​\tbase_pgdir为模版页表，所谓模版页表就是相当于为之后创建的进程的页表写了个板子，创建页表时先将这个模版复制过去。在env_init函数的最后，使用page_alloc函数为模版页表base_pgdir分配了一页物理内存，将其转换为内核虚拟地址后，使用map_segment函数将内核数组pages和envs映射到用户空间的UPAGES和UENVS处，以供用户程序读取\n关于map_segment：在一级页表基地址pgdir对应的两级页表结构中按页做段地址映射，将虚拟地址段va~va+size映射到物理地址段pa~pa+size\nExercise 3.2 map_segment\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static void map_segment(Pde *pgdir, u_int asid, u_long pa, u_long va, u_int size, u_int perm) { assert(pa % PAGE_SIZE == 0); assert(va % PAGE_SIZE == 0); assert(size % PAGE_SIZE == 0); /* Step 1: Map virtual address space to physical address space. */ for (int i = 0; i \u0026lt; size; i += PAGE_SIZE) { /* * Hint: * Map the virtual page \u0026#39;va + i\u0026#39; to the physical page \u0026#39;pa + i\u0026#39; using \u0026#39;page_insert\u0026#39;. * Use \u0026#39;pa2page\u0026#39; to get the \u0026#39;struct Page *\u0026#39; of the physical address. */ /* Exercise 3.2: Your code here. */ page_insert(pgdir,asid,pa2page(pa + i),va + i,perm | PTE_V); } } 1.4 进程的标识ASID ​\t实验中对于不同进程的识别是通过进程标识符env_id实现的，每个进程的id是独一无二的，在进程创建时就被赋予。\n创建新env_id是通过mkenvid实现的\n1 2 3 4 u_int mkenvid(struct Env *e) { static u_int i = 0; return ((++i) \u0026lt;\u0026lt; (1 + LOG2NENV)) | (e - envs); } ​\tenv_id已经可以唯一表示进程，包括进程虚拟地址空间，为什么还需要额外的域来作为虚拟地址空间的标识？\n​\t系统中并发执行多个拥有不同虚拟地址空间的进程，具有不同的页表。CPU的MMU使用TLB缓存虚拟地址映射关系，不同页表拥有不同虚拟地址映射。当CPU切换页表，TLB中仍可能缓存有之前页表的虚拟地址映射关系，这些映射关系可能与当前页表所描述的不一致，即为无效映射关系。\n​\t为了避免TLB缓存的无效映射关系在页表切换后导致错误的地址翻译发生，早期操作系统实现在CPU每次切换页表时无效化所有TLB项，但效率较低，会造成很多TLB Miss\n​\t现代的CPU及操作系统，采用ASID解决上述问题。ASID用于标识虚拟地址空间，同时并发执行的多个进程具有不同ASID以便TLB标识其虚拟地址空间\n​\t在lab2中提到，TLB实质上构建了一个映射 $$ \u0026lt;VPN,ASID\u0026gt;-\u0026gt;\u0026lt;PFN,N,D,V,G\u0026gt; $$ ​\tTLB存储进程的ASID，作为key的一部分，用于区别不同地址空间中的映射，相当于每个进程都有自己虚拟地址空间（使用ASID标识）下的一套TLB缓存，每次切换页表不必再清空所有TLB表项。\n经过以上分析，我们知道对于在TLB中进行虚拟地址转换需要进行两步\n首先寻找虚拟地址对应的虚页号(\u0026raquo;12) 如果有再检查ASID域，检查是不是一个进程，是否能使用相应的映射关系 ​\t同样ASID也具有唯一标识性，直到进程被销毁或TLB清空时，其ASID才可以被分配给其他进程，MIPS-4Kc中的ASID只有8个bit，即实验中可用的ASID只有256个，我们使用asid_alloc为进程分配ASID码，如果ASID已经耗尽还需要创建进程，内核会发生崩溃(panic)\n1 2 3 4 5 6 7 8 9 10 11 12 static int asid_alloc(u_int *asid) { for (u_int i = 0; i \u0026lt; NASID; ++i) { int index = i \u0026gt;\u0026gt; 5; int inner = i \u0026amp; 31; if ((asid_bitmap[index] \u0026amp; (1 \u0026lt;\u0026lt; inner)) == 0) { asid_bitmap[index] |= 1 \u0026lt;\u0026lt; inner; *asid = i; return 0; } } return -E_NO_FREE_ENV; } 1.5 设置进程控制块 创建进程的流程如下\n申请一个空闲的PCB：从env_free_list中索取一个空闲PCB块 手工初始化进程控制块 为新进程初始化页目录(env_setup_vm) 将PCB从共享页表摘除 ​\t首先介绍初始化新进程地址空间的函数env_setup_vm\nExercise 3.3 env_setup_vm\n首先为新进程分配一页物理页\n将模版页表base_pgdir的内容(pages/envs数组)复制到新进程对应的地址空间\n复制到对应的地址空间memcpy，这里在虚拟地址空间中pages和envs存储位置在mmu.h中定义，如下图所示\n故只需要从UTOP复制到UVPT\nULIM是kseg0和kuseg的分界线，是系统给用户进程分配的最高地址，kseg0和kseg1的访问不经过TLB，这部分内存由内核管理，所有进程共享，MOS操作系统特意将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问\n这里我们要暴露的是UTOP往上到UVPT之间所有进程共享的只读空间\nUVPT往上到ULIM之间是进程自己的页表\n将UVPT处的页表项设置为只读权限，故用户进程可以通过UVPT读自己的页表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static int env_setup_vm(struct Env *e) { /* Step 1: * Allocate a page for the page directory with \u0026#39;page_alloc\u0026#39;. * Increase its \u0026#39;pp_ref\u0026#39; and assign its kernel address to \u0026#39;e-\u0026gt;env_pgdir\u0026#39;. * * Hint: * You can get the kernel address of a specified physical page using \u0026#39;page2kva\u0026#39;. */ struct Page *p; try(page_alloc(\u0026amp;p)); /* Exercise 3.3: Your code here. */ p-\u0026gt;pp_ref++; e-\u0026gt;env_pgdir = (Pde*)page2kva(p); /* Step 2: Copy the template page directory \u0026#39;base_pgdir\u0026#39; to \u0026#39;e-\u0026gt;env_pgdir\u0026#39;. */ /* Hint: * As a result, the address space of all envs is identical in [UTOP, UVPT). * See include/mmu.h for layout. */ memcpy(e-\u0026gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP), sizeof(Pde) * (PDX(UVPT) - PDX(UTOP))); /* Step 3: Map its own page table at \u0026#39;UVPT\u0026#39; with readonly permission. * As a result, user programs can read its page table through \u0026#39;UVPT\u0026#39; */ e-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V; return 0; } Exercise 3.4 env_alloc\n拿到一个空闲的进程控制块PCB 为新进程初始化地址空间 初始化env_id/parent_id/分配env_asid 初始化env_tp中的栈指针寄存器sp(通用寄存器第29个)和cp0_status寄存器，对于cp0寄存器中的设置后续说明 从空闲链表中移除PCB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int env_alloc(struct Env **new, u_int parent_id) { int r; struct Env *e; /* Step 1: Get a free Env from \u0026#39;env_free_list\u0026#39; */ /* Exercise 3.4: Your code here. (1/4) */ if (LIST_EMPTY(\u0026amp;env_free_list)) { return -E_NO_FREE_ENV; } e = LIST_FIRST(\u0026amp;env_free_list); /* Step 2: Call a \u0026#39;env_setup_vm\u0026#39; to initialize the user address space for this new Env. */ /* Exercise 3.4: Your code here. (2/4) */ try(env_setup_vm(e)); /* Step 3: Initialize these fields for the new Env with appropriate values: * \u0026#39;env_user_tlb_mod_entry\u0026#39; (lab4), \u0026#39;env_runs\u0026#39; (lab6), \u0026#39;env_id\u0026#39; (lab3), \u0026#39;env_asid\u0026#39; (lab3), * \u0026#39;env_parent_id\u0026#39; (lab3) * * Hint: * Use \u0026#39;asid_alloc\u0026#39; to allocate a free asid. * Use \u0026#39;mkenvid\u0026#39; to allocate a free envid. */ e-\u0026gt;env_user_tlb_mod_entry = 0; // for lab4 e-\u0026gt;env_runs = 0;\t// for lab6 /* Exercise 3.4: Your code here. (3/4) */ r = asid_alloc(\u0026amp;(e-\u0026gt;env_asid)); if (r != 0) { return r; } e-\u0026gt;env_id = mkenvid(e); e-\u0026gt;env_parent_id = parent_id; /* Step 4: Initialize the sp and \u0026#39;cp0_status\u0026#39; in \u0026#39;e-\u0026gt;env_tf\u0026#39;. * Set the EXL bit to ensure that the processor remains in kernel mode during context * recovery. Additionally, set UM to 1 so that when ERET unsets EXL, the processor * transitions to user mode. */ e-\u0026gt;env_tf.cp0_status = STATUS_IM7 | STATUS_IE | STATUS_EXL | STATUS_UM; // Reserve space for \u0026#39;argc\u0026#39; and \u0026#39;argv\u0026#39;. e-\u0026gt;env_tf.regs[29] = USTACKTOP - sizeof(int) - sizeof(char **); /* Step 5: Remove the new Env from env_free_list. */ /* Exercise 3.4: Your code here. (4/4) */ LIST_REMOVE(e,env_link); *new = e; return 0; } ​\t关于寄存器的设置：\ncp0_status：\nIE位表示中断是否开启\nIM7位表示是否响应时钟中断\nEXL以及UM位表示处理器当前的运行状态(当且仅当EXL=0且UM=1是为用户模式，其余均为内核模式)，每当异常发生，EXL被置1，执行eret时EXL被置0。我们知道，每个进程在每一次被调度时，都会执行\nRESTORE_ALL(registers) eret 首先要恢复env_tf中保存的所有寄存器的值，如果不设置EXL位，那么恢复完status寄存器的值后(此时EXL=0,UM=1)即进入用户模式，此时再访问内核地址段（例如恢复其他寄存器的值），执行特权指令，处理器就会立刻陷入异常。如果我们设置了EXL=1，则恢复完status寄存器的值后(EXL=1,UM=1)仍然处于内核态，不会发生错误。而在运行进程前，运行到eret时，就会将EXL设置为0，此时UM=IE=1表示在用户模式下且开启中断，之后进程成功以用户模式运行且操作系统正常响应中断。（实际上设置EXL位的目的就是避免在没有恢复完进程现场前就进入用户模式发生错误，控制住在eret时再回到用户模式）\nsp：设置栈指针，对应第29个通用寄存器，为argc和argv分配空间\n1.6 加载二进制镜像 ​\tELF文件的类型有三种，可重定位文件、可执行文件和可被共享的对象文件。本节中需要将程序(可执行文件)加载到新进程的地址空间中。\n​\t要想正确加载一个ELF文件到内存，只需将ELF文件中所有需要加载的程序段加载到对应的虚拟地址上。\nlab3中还没实现文件系统，无法直接操作磁盘中的ELF文件，这里将ELF文件内容转化为C数组形式，通过编译到内核中完成加载\nload_icode函数负责加载可执行文件binary到进程e的内存中 elf_from函数完成了解析ELF文件头的部分 elf_load_seg函数负责将ELF文件的一个segment加载到内存，它的最后两个参数用于接受一个自定义的回调函数map_page以及以及需要转递给回调函数的额外参数data，并由回调函数(这里为load_icode_mapper)完成单个页面的加载过程。 ​\tload_icode函数会从ELF文件中解析出每个segment的段头ph，以及其在内存中的起始位置bin，再由elf_load_seg函数将参数指定的程序段加载到进程的地址空间中。\nExercise 3.5 load_icode_mapper 回调函数将一页加载到用户内存空间中\n分配一个物理页面p 如果src非空，加载len字节到分配的物理页面p偏移量offset位置 将物理页面p插入到页表中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int load_icode_mapper(void *data, u_long va, size_t offset, u_int perm, const void *src, size_t len) { struct Env *env = (struct Env *)data; struct Page *p; int r; /* Step 1: Allocate a page with \u0026#39;page_alloc\u0026#39;. */ /* Exercise 3.5: Your code here. (1/2) */ r = page_alloc(\u0026amp;p); if (r != 0) { return r; } /* Step 2: If \u0026#39;src\u0026#39; is not NULL, copy the \u0026#39;len\u0026#39; bytes started at \u0026#39;src\u0026#39; into \u0026#39;offset\u0026#39; at this * page. */ // Hint: You may want to use \u0026#39;memcpy\u0026#39;. if (src != NULL) { /* Exercise 3.5: Your code here. (2/2) */ memcpy(page2kva(p) + offset,src,len); } /* Step 3: Insert \u0026#39;p\u0026#39; into \u0026#39;env-\u0026gt;env_pgdir\u0026#39; at \u0026#39;va\u0026#39; with \u0026#39;perm\u0026#39;. */ return page_insert(env-\u0026gt;env_pgdir, env-\u0026gt;env_asid, p, va, perm); } Exercise 3.6 load_icode 加载ELF到进程\n首先使用elf_form将binary转换为ELF头的形式用于解析 将ELF中的每一段(loadable)加载到内存中，调用elf_load_seg env_tf.cp0_epc字段指示了进程恢复运行时PC应当恢复到的位置，程序入口为e_entry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static void load_icode(struct Env *e, const void *binary, size_t size) { /* Step 1: Use \u0026#39;elf_from\u0026#39; to parse an ELF header from \u0026#39;binary\u0026#39;. */ const Elf32_Ehdr *ehdr = elf_from(binary, size); if (!ehdr) { panic(\u0026#34;bad elf at %x\u0026#34;, binary); } /* Step 2: Load the segments using \u0026#39;ELF_FOREACH_PHDR_OFF\u0026#39; and \u0026#39;elf_load_seg\u0026#39;. * As a loader, we just care about loadable segments, so parse only program headers here. */ size_t ph_off; ELF_FOREACH_PHDR_OFF (ph_off, ehdr) { Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off); if (ph-\u0026gt;p_type == PT_LOAD) { // \u0026#39;elf_load_seg\u0026#39; is defined in lib/elfloader.c // \u0026#39;load_icode_mapper\u0026#39; defines the way in which a page in this segment // should be mapped. panic_on(elf_load_seg(ph, binary + ph-\u0026gt;p_offset, load_icode_mapper, e)); } } /* Step 3: Set \u0026#39;e-\u0026gt;env_tf.cp0_epc\u0026#39; to \u0026#39;ehdr-\u0026gt;e_entry\u0026#39;. */ /* Exercise 3.6: Your code here. */ e-\u0026gt;env_tf.cp0_epc = ehdr-\u0026gt;e_entry; } 1.7 创建进程 这里的创建进程指在操作系统内核初始化时直接创建进程，例如在init.c中\n1 2 3 // lab3: ENV_CREATE_PRIORITY(user_bare_loop, 1); ENV_CREATE_PRIORITY(user_bare_loop, 2); ​\t创建新进程由env_create完成\nExercise 3.7 env_create\n分配一个新的Env结构体 设置进程控制块 并将程序载入到该进程的地址空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Env *env_create(const void *binary, size_t size, int priority) { struct Env *e; /* Step 1: Use \u0026#39;env_alloc\u0026#39; to alloc a new env, with 0 as \u0026#39;parent_id\u0026#39;. */ /* Exercise 3.7: Your code here. (1/3) */ env_alloc(\u0026amp;e,0); /* Step 2: Assign the \u0026#39;priority\u0026#39; to \u0026#39;e\u0026#39; and mark its \u0026#39;env_status\u0026#39; as runnable. */ /* Exercise 3.7: Your code here. (2/3) */ e-\u0026gt;env_pri = priority; e-\u0026gt;env_status = ENV_RUNNABLE; /* Step 3: Use \u0026#39;load_icode\u0026#39; to load the image from \u0026#39;binary\u0026#39;, and insert \u0026#39;e\u0026#39; into * \u0026#39;env_sched_list\u0026#39; using \u0026#39;TAILQ_INSERT_HEAD\u0026#39;. */ /* Exercise 3.7: Your code here. (3/3) */ load_icode(e,binary,size); TAILQ_INSERT_HEAD(\u0026amp;env_sched_list,e,env_sched_link); return e; } 1.8 进程运行与切换 ​\tenv_run是进程运行使用的基本函数，它包括两个功能\n保存当前进程上下文（若当前没有运行进程则跳过） 恢复要启动的进程的上下文，然后运行该进程 这里的上下文指寄存器 ​\t我们要运行一个新进程往往意味着进程切换，进程切换需要对上下文（各种寄存器）进行保存，本实验中寄存器状态保存的地方是KSTACKTOP以下的一个sizeof(TrapFrame)的小的区域中\nExercise 3.8 env_run\n保存当前进程的上下文信息 切换curenv为即将运行的进程 设置全局变量cur_pgdir为当前进程页目录地址 调用env_pop)tf ：恢复现场，异常返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void env_run(struct Env *e) { assert(e-\u0026gt;env_status == ENV_RUNNABLE); // WARNING BEGIN: DO NOT MODIFY FOLLOWING LINES! #ifdef MOS_PRE_ENV_RUN MOS_PRE_ENV_RUN_STMT #endif // WARNING END /* Step 1: * If \u0026#39;curenv\u0026#39; is NULL, this is the first time through. * If not, we may be switching from a previous env, so save its context into * \u0026#39;curenv-\u0026gt;env_tf\u0026#39; first. */ if (curenv) { curenv-\u0026gt;env_tf = *((struct Trapframe *)KSTACKTOP - 1); } /* Step 2: Change \u0026#39;curenv\u0026#39; to \u0026#39;e\u0026#39;. */ curenv = e; curenv-\u0026gt;env_runs++; // lab6 /* Step 3: Change \u0026#39;cur_pgdir\u0026#39; to \u0026#39;curenv-\u0026gt;env_pgdir\u0026#39;, switching to its address space. */ /* Exercise 3.8: Your code here. (1/2) */ cur_pgdir = curenv-\u0026gt;env_pgdir; /* Step 4: Use \u0026#39;env_pop_tf\u0026#39; to restore the curenv\u0026#39;s saved context (registers) and return/go * to user mode. * * Hint: * - You should use \u0026#39;curenv-\u0026gt;env_asid\u0026#39; here. * - \u0026#39;env_pop_tf\u0026#39; is a \u0026#39;noreturn\u0026#39; function: it restores PC from \u0026#39;cp0_epc\u0026#39; thus not * returning to the kernel caller, making \u0026#39;env_run\u0026#39; a \u0026#39;noreturn\u0026#39; function as well. */ /* Exercise 3.8: Your code here. (2/2) */ env_pop_tf(\u0026amp;(curenv-\u0026gt;env_tf),curenv-\u0026gt;env_asid); } 2.中断与异常 回想上学期计组P7内容\n2.1 异常的分发 ​\t当发生异常时，处理器会进入一个用于分发异常的程序，这个程序的作用是检测发生了哪种异常并调用相应的异常处理程序。\nExercise 3.9 补全异常分发代码 entry.S\n异常分发的步骤如下：\n使用SAVE_ALL将上下文保存到内核的异常栈中 消除Status寄存器中的UM,EXL,IE位，保持内核态，关闭中断，允许嵌套异常（读、改、存） 取得Cause寄存器中2-6位，即对应的异常码部分，用来区别不同的异常 用取得的异常码作为索引在exception_handlers数组中找到对应的中断处理函数，跳转到对应的中断处理函数，这就是分发！ .section .text.exc_gen_entry exc_gen_entry: SAVE_ALL /* * Note: When EXL is set or UM is unset, the processor is in kernel mode. * When EXL is set, the value of EPC is not updated when a new exception occurs. * To keep the processor in kernel mode and enable exception reentrancy, * we unset UM and EXL, and unset IE to globally disable interrupts. */ mfc0 t0, CP0_STATUS and t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE) mtc0 t0, CP0_STATUS /* Exercise 3.9: Your code here. */ mfc0\tt0, CP0_CAUSE andi\tt0, 0x7c /*2-6位异常码*/ lw\tt0, exception_handlers(t0) jr\tt0 ​\tSAVE_ALL是用于将当前CPU上下文保存到内核的异常栈的宏，简单分析一下（和他相似定义的还有RESTORE_ALL，都定义在stackframe.h中）\n.macro SAVE_ALL .set noat .set noreorder mfc0 k0, CP0_STATUS andi k0, STATUS_UM beqz k0, 1f move k0, sp /* * If STATUS_UM is not set, the exception was triggered in kernel mode. * $sp is already a kernel stack pointer, we don\u0026#39;t need to set it again. */ li sp, KSTACKTOP 1: subu sp, sp, TF_SIZE sw k0, TF_REG29(sp) mfc0 k0, CP0_STATUS sw k0, TF_STATUS(sp) mfc0 k0, CP0_CAUSE sw k0, TF_CAUSE(sp) mfc0 k0, CP0_EPC sw k0, TF_EPC(sp) mfc0 k0, CP0_BADVADDR sw k0, TF_BADVADDR(sp) mfhi k0 sw k0, TF_HI(sp) mflo k0 sw k0, TF_LO(sp) sw $0, TF_REG0(sp) sw $1, TF_REG1(sp) sw $2, TF_REG2(sp) sw $3, TF_REG3(sp) sw $4, TF_REG4(sp) sw $5, TF_REG5(sp) sw $6, TF_REG6(sp) sw $7, TF_REG7(sp) sw $8, TF_REG8(sp) sw $9, TF_REG9(sp) sw $10, TF_REG10(sp) sw $11, TF_REG11(sp) sw $12, TF_REG12(sp) sw $13, TF_REG13(sp) sw $14, TF_REG14(sp) sw $15, TF_REG15(sp) sw $16, TF_REG16(sp) sw $17, TF_REG17(sp) sw $18, TF_REG18(sp) sw $19, TF_REG19(sp) sw $20, TF_REG20(sp) sw $21, TF_REG21(sp) sw $22, TF_REG22(sp) sw $23, TF_REG23(sp) sw $24, TF_REG24(sp) sw $25, TF_REG25(sp) sw $26, TF_REG26(sp) sw $27, TF_REG27(sp) sw $28, TF_REG28(sp) sw $30, TF_REG30(sp) sw $31, TF_REG31(sp) .set at .set reorder .endm 首先检查我们需要处理的异常是否是在内核态被触发的（或者说是否是异常重入，异常重入正如它的字面意思：是不是在处理异常过程中(内核态)又发生了异常需要处理）\n我们通过检查Status寄存器的UM位实现检查是不是异常重入\n如果为0，说明该异常是在内核态被触发的，是异常重入 如果为1，说明该异常是在用户态被触发的，不是异常重入 如果是异常重入，则栈指针sp已经指向内核异常栈\n如果不是异常重入，则需要先将sp指向内核异常栈(借助MIPS中的延迟槽保存原来的sp值)\nbeqz k0, 1f move k0, sp /*保存原来的sp*/ li sp, KSTACKTOP /*指向异常处理栈*/ ​\t在我们的系统中，CPU发生异常后就会自动跳转到地址0x80000180处，发生用户态地址的TLB Miss异常时，会自动跳转到地址0x80000000，故我们需要将处理异常的代码.text.exc_gen_entry放到0x80000180处，将.text.tlb_miss_entry放到0x80000000处。这可以通过链接器实现，在kernel.lds中指定两个代码段的加载位置\nExercise 3.10 kernel.lds 指定两个异常处理代码的存放位置，用于CPU处理异常时跳转到对应位置，这里就相当于完成了包含两种异常的异常分发\n1 2 3 4 5 6 7 8 9 10 /* Exercise 3.10: Your code here. */ . = 0x80000000; .tlb_miss_entry : { *(.text.tlb_miss_entry) } . = 0x80000180; .exc_gen_entry : { *(.text.exc_gen_entry) } 2.2 异常向量组 ​\t异常分发程序通过exception_handlers数组定位中断处理程序(Cause)，而exception_handlers就称作异常向量组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 extern void handle_int(void); extern void handle_tlb(void); extern void handle_sys(void); extern void handle_mod(void); extern void handle_reserved(void); void (*exception_handlers[32])(void) = { [0 ... 31] = handle_reserved, [0] = handle_int, [2 ... 3] = handle_tlb, #if !defined(LAB) || LAB \u0026gt;= 4 [1] = handle_mod, [8] = handle_sys, #endif }; GNU扩展语法：[first...last] = value对数组某个区间上的元素赋成同一个值 0号异常处理函数为handle_int：表示中断，由时钟中断、控制台中断等中断造成 1号异常处理函数为handle_mod：表示存储异常，进行存储操作时该页被标记为已读 2号异常处理函数为handle_tlb：表示TLB load异常 3号异常处理函数为handle_tlb：表示TLB store异常 8号异常处理函数为handle_sys：表示系统调用，syscall指令陷入内核 ​\t有异常产生，则其对应的处理函数就会执行，在lab3中主要使用0号对应的时钟异常，我们需要产生并处理时钟中断，并利用时钟中断进行抢占式进程调度（解析见实验报告）\n2.3 时钟中断 ​\tMOS系统中使用时间片轮转调度算法进行进程调度，每个进程运行一个时间片。MOS通过硬件计时器产生的时钟中断知晓一个进程的时间片结束，比如设定某个进程的时间片长度为200倍的时钟中断间隔(TIMER_INTERVAL)，那么当MOS记录发生了200次时钟中断后就知道该进程的时间片结束了，当前运行的进程被挂起(如果还没结束)，在调度队列中选取一个合适的进程运行。\n​\tMIPS-4Kc中的CP0内置了可产生中断的Timer，利用Timer产生时钟中断。CP0中存在两个用于控制Timer的寄存器，Count寄存器和Compare寄存器，Count寄存器按照与处理器频率相关的频率不断自增，Compare寄存器维持不变。当Count寄存器的值与Compare寄存器的值相等且非0时，时钟中断会被立即触发。\n​\t在include/kclock.h中实现了对Timer的初始化：\nCount寄存器清0 Compare寄存器配置为我们所期望的寄存器周期数 ​\t时钟中断的处理流程：\n系统将PC指向0x8000_0180，跳转到.text.exc_gen_entry代码段执行 通过.text_gen_entry对异常进行分发(我们实现的中断为异步异常)，最终调用中断处理handle_int函数进行中断处理 handle_int函数根据CAUSE寄存器的值判断是否为Timer对应的7号中断位引发的时钟中断，如果是，跳转到中断服务函数timer_irq，跳转到sechdule中执行 Exercise 3.11 RESET_KCLOCK宏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 .macro RESET_KCLOCK li t0, TIMER_INTERVAL /* * Hint: * Use \u0026#39;mtc0\u0026#39; to write an appropriate value into the CP0_COUNT and CP0_COMPARE registers. * Writing to the CP0_COMPARE register will clear the timer interrupt. * The CP0_COUNT register increments at a fixed frequency. When the values of CP0_COUNT and * CP0_COMPARE registers are equal, the timer interrupt will be triggered. * */ /* Exercise 3.11: Your code here. */ mtc0\tzero, CP0_COUNT mtc0\tt0, CP0_COMPARE .endm 2.4 进程调度 ​\t我们使用的进程调度算法即为时间片轮转算法。时间片轮转算法中，时间片长度被量化为$time = N*TimerInterval$，这里的N为进程的优先级。\n​\t使用调度链表存储所有就绪的进程，即一个进程在调度链表中当且仅当它的状态为RUNNABLE。内核创建新进程时，将其插入调度链表的头部，当期阻塞或退出时，从调度链表中移除。\n​\t调度函数schedule被调用时，当前运行的进程被存储在全局变量curenv中，其剩余的时间片长度被存储在静态变量count中，需要进行进程切换的情况包括\n尚未调度过任何进程(curenv==NULL) 当前进程用完了时间片(count==0) 当前进程不再就绪(status!=RUNNABLE) yield参数指定必须发生切换 ​\t当无需进行切换时，我们只需要将剩余时间片count-1，然后调用env_run函数继续运行当前进程curenv。\n​\t在发生进程切换时，还需要判断当前进程是否仍然就绪(RUNNABLE)，如果是则将其移动到调度链表的尾部。之后我们选择调度链表首部的进程来调度运行，将剩余时间片长度设置为它的优先级。\nExercise 3.12 schedule 切换进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void schedule(int yield) { static int count = 0; // remaining time slices of current env struct Env *e = curenv; /* We always decrease the \u0026#39;count\u0026#39; by 1. * * If \u0026#39;yield\u0026#39; is set, or \u0026#39;count\u0026#39; has been decreased to 0, or \u0026#39;e\u0026#39; (previous \u0026#39;curenv\u0026#39;) is * \u0026#39;NULL\u0026#39;, or \u0026#39;e\u0026#39; is not runnable, then we pick up a new env from \u0026#39;env_sched_list\u0026#39; (list of * all runnable envs), set \u0026#39;count\u0026#39; to its priority, and schedule it with \u0026#39;env_run\u0026#39;. **Panic * if that list is empty**. * * (Note that if \u0026#39;e\u0026#39; is still a runnable env, we should move it to the tail of * \u0026#39;env_sched_list\u0026#39; before picking up another env from its head, or we will schedule the * head env repeatedly.) * * Otherwise, we simply schedule \u0026#39;e\u0026#39; again. * * You may want to use macros below: * \u0026#39;TAILQ_FIRST\u0026#39;, \u0026#39;TAILQ_REMOVE\u0026#39;, \u0026#39;TAILQ_INSERT_TAIL\u0026#39; */ /* Exercise 3.12: Your code here. */ if (yield|| count == 0 || e == NULL || e-\u0026gt;env_status != ENV_RUNNABLE) { if (e \u0026amp;\u0026amp; e-\u0026gt;env_status == ENV_RUNNABLE) { TAILQ_REMOVE(\u0026amp;env_sched_list,e,env_sched_link); TAILQ_INSERT_TAIL(\u0026amp;env_sched_list,e,env_sched_link); } if (TAILQ_EMPTY(\u0026amp;env_sched_list)) { panic(\u0026#34;no runnable envs\u0026#34;); } e = TAILQ_FIRST(\u0026amp;env_sched_list); count = e-\u0026gt;env_pri; } count--; env_run(e); } 3. 总结 ​\t我们在lab3中学习了进程管理的相关内容，本实验中完成的功能可以由下图概括\nexception_handlers数组为异常向量组，负责分发异常。我们主要涉及到的是0号异常处理函数(中断处理函数)handle_int，1号异常处理函数handle_mod，2号/3号处理函数handle_tlb。初始化结束后，若有异常产生，则其对应的异常处理函数执行\nenv_create\n分配进程控制块\nenv_alloc从空闲链表中分配一个空闲控制块，并进行相应的初始化工作，初始化过程中调用env_setup_vm函数对虚拟地址空间进行初始化，这里包括复制模版页表base_pgdir。模版页表中包含了虚拟地址空间到物理地址空间pages/envs数组的映射，复制到新页表使得用户进程的地址空间中可以访问pages/envs数组\n调用load_icode函数将程序加载到新创建的地址空间中\nhandle_int\n根据CP0_CAUSE寄存器判断是否为时钟中断(7号中断)，并根据Status寄存器判断7号中断是否开启(全局中断使能\u0026amp;\u0026amp;时钟中断使能IM7)。如果是，则调用schedule函数，schedule函数进行进程调度，调用env_run来运行进程\nenv_run\n将正在执行的进程(curenv)的现场保存在对应的进程控制块中 选择一个可以运行的进程，恢复该进程上次被挂起时候的现场，即恢复env_tf，调用env_pop_tf完成 发生TLB Miss时的异常处理\n​\t硬件在取数据或取指令的时候，CPU发射虚拟地址给MMU进行地址转换。对于用户段虚拟地址的转换通过TLB完成，若TLB在转换的过程中发现TLB中还没有对应于该虚拟地址的映射(key--VPN/ASID)，则会产生TLB Miss异常。\n​\t硬件会打断访存过程并陷入内核态跳转到对应的异常处理程序(tlb_miss_entry : pc : 0x8000_0000)，由操作系统查找页表进行TLB重填(do_tlb_refill)，之后再从异常返回，继续访存.\n从软硬件的角度来看 硬件：在发生TLBMiss 异常的时候，4Kc CPU 会把引发 TLB Miss 的虚拟地址填 入到BadVAddr 寄存器中、虚页号填入到 EntryHi 寄存器的 VPN 域中，将 Cause 寄存 器中的ExcCode 域填写为 TLBL（读请求TLBMiss）或 TLBS（写请求 TLB Miss）。 软件：从BadVAddr 寄存器中获取引发 TLB Miss 的虚拟地址，接着在 cur_pgdir 中查找该虚拟地址对应的物理地址与权限位，然后将物理页面号和权限位填入到EntryLo 寄存器的PFN域和权限位中，再使用tlbwr（TLBWriteentry selected by Random）将 EntryHi 和 EntryLo 寄存器中的 VPN、PFN、ASID、权限位等随机地写入到TLB中，最 后调用ret_from_exception 从异常返回。 ​\n","permalink":"https://coder0xe.github.io/posts/os-lab3%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"oslab3课下基础\"\u003eOS:lab3课下基础\u003c/h1\u003e\n\u003ch2 id=\"1进程\"\u003e1.进程\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e由于没有实现线程，本实验中进程既是基本的分配单元，也是基本的执行单元\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"11-进程控制块\"\u003e1.1 进程控制块\u003c/h3\u003e\n\u003cp\u003e​\t进程控制块(\u003ccode\u003eProcess Control Block\u003c/code\u003e)是用来管理进程的数据结构，可以记录进程的变化过程，记录进程的外部特征。\u003cstrong\u003ePCB是系统感知进程存在的唯一标志，进程与PCB是一一对应的\u003c/strong\u003e。在MOS中，PCB定义为一个Env结构体\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e Env {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003estruct\u003c/span\u003e Trapframe env_tf;\t \u003cspan style=\"color:#6272a4\"\u003e// saved context (registers) before switching\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#50fa7b\"\u003eLIST_ENTRY\u003c/span\u003e(Env) env_link;\t \u003cspan style=\"color:#6272a4\"\u003e// intrusive entry in \u0026#39;env_free_list\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int env_id;\t\t\t \u003cspan style=\"color:#6272a4\"\u003e// unique environment identifier\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int env_asid;\t\t\t \u003cspan style=\"color:#6272a4\"\u003e// ASID of this env\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int env_parent_id;\t\t \u003cspan style=\"color:#6272a4\"\u003e// env_id of this env\u0026#39;s parent\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int env_status;\t\t \u003cspan style=\"color:#6272a4\"\u003e// status of this env\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tPde \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003eenv_pgdir;\t\t\t \u003cspan style=\"color:#6272a4\"\u003e// page directory\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#50fa7b\"\u003eTAILQ_ENTRY\u003c/span\u003e(Env) env_sched_link; \u003cspan style=\"color:#6272a4\"\u003e// intrusive entry in \u0026#39;env_sched_list\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tu_int env_pri;\t\t\t \u003cspan style=\"color:#6272a4\"\u003e// schedule priority\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eenv_tf \u003c/code\u003e: 在发生进程调度，或当陷入内核时，会将当时的进程上下文环境保存在env_tf变量中\u003c/p\u003e","title":"OS:lab3课下基础"},{"content":"OS:lab2实验报告 Thinking 2.1 **在编写的C程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS汇编程序中lw和sw指令使用的地址被视为虚拟 地址，还是物理地址？ ** 在编写的C程序中，指针变量中存储的地址为虚拟地址 汇编程序中lw，sw发送的也是虚拟地址 Thinking 2.2 请从可重用性的角度，阐述用宏来实现链表的好处 使用宏定义对链表操作进行封装，可以实现代码的复用，即减少了工作量，也提高了程序的可读性 请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异 对于单向链表，由于它只能获得每一项的后面一项，因此在删除时需要遍历整个链表；同样，如果是在某一项的前面插入，也需要从head开始遍历这个链表。但是如果是“在某一项之后插入”，单项链表可以直接进行该操作。 对于循环链表，因为它仍然是单向的，所以在“删除”、“某一项之前插入”、“某一项之后插入”三个操作的性能和单项链表相同。但是，由于循环链表首尾相连，同时维护了一个指向尾项的指针，因此它可以直接在尾部插入。 对于双向链表，因为它可以直接获得某一项的前后两项，所以无论是“删除”还是“在某一项前或后插入”都可以以O(1)的开销实现。但是，双向链表没有维护指向尾部的指针，因此无法直接将某一项插入链表尾部，如要实现该操作还需要遍历整个链表。 Thinking 2.3 选择Page_list正确的展开结构\nC\nstruct Page_list{ struct { struct { struct Page *le_next; struct Page **le_prev; } pp_link; u_short pp_ref; }* lh_first; } Thinking 2.4 请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID的必要性。 操作系统会给每一个进程分配一个页表，每个页表都有自己的虚拟地址空间，而同一虚拟地址在不同地址空间中通常映射到不同的物理地址。如果没有ASID来区分当前虚拟地址是在哪个进程中使用，则可能会将该虚拟地址映射到错误的物理地址。(每一个进程都有自己的虚拟地址空间4G，ASID可以区分不同进程同一虚拟地址转换成物理地址的方法) 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc中可容纳不同的地址空间的最大数量 ASID有8位，即最多可以有$2^8$个地址空间（进程数量） Thinking 2.5 tlb_invalidate 和 tlb_out 的调用关系是怎样的？\ntlb_invalidate中调用了tlb_out 请用一句话概括 tlb_invalidate 的作用\n删除特定虚拟地址在 TLB 中的旧表项 逐行解释 tlb_out 中的汇编代码\nLEAF(tlb_out) .set noreorder mfc0 t0, CP0_ENTRYHI #维护EntryHi寄存器 将EntryHi寄存器中原本的值存入t0 mtc0 a0, CP0_ENTRYHI #将需要寻找的Key(VPN,ASID)存入EntryHi nop /* Step 1: Use \u0026#39;tlbp\u0026#39; to probe TLB entry */ /* Exercise 2.8: Your code here. (1/2) */ tlbp\t#寻找EntryHi中Key在TLB中对应的表项，并将索引号存入Index寄存器，若不存在则Index最高位置1(index为负数) nop /* Step 2: Fetch the probe result from CP0.Index */ mfc0 t1, CP0_INDEX #将Index寄存器中的值存入t1寄存器 .set reorder bltz t1, NO_SUCH_ENTRY #判断index值大小，若小于0则说明没找到 .set noreorder mtc0 zero, CP0_ENTRYHI #将EntryHi清0 mtc0 zero, CP0_ENTRYLO0 #将EntryLo0清0 mtc0 zero, CP0_ENTRYLO1 #将EntryLo1清0 nop /* Step 3: Use \u0026#39;tlbwi\u0026#39; to write CP0.EntryHi/Lo into TLB at CP0.Index */ /* Exercise 2.8: Your code here. (2/2) */ tlbwi\t#向找到的index表项中写入Key,Data(全为0) .set reorder NO_SUCH_ENTRY: mtc0 t0, CP0_ENTRYHI #恢复调用前EntryHi的值 j ra #跳转回调用者 END(tlb_out) Thinking 2.6 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别 首先是内存管理机制，MIPS主要采用的是页式管理系统，X86主要采用的是段页式 在对TLB不命中的处理上，MIPS会触发TLB Refill异常，内核的tlb_refill_handler会以pgd_current为当前进程的PGD基址，索引获得转换失败的虚址对应的PTE，并将其填入TLB，然后CPU再用刚刚转换失败的虚拟地址重新访问TLB；X86在TLB不命中时，由硬件MMU以CR3为当前进程的PGD基址，索引获得PFN后直接输出PA，同时MMU会填充TLB以加快下次转换的速度 转换失败的虚址，MIPS使用BadVAddr寄存器存放，X86使用CR2存放 Thinking A.1 **在现代的 64 位系统中，提供了 64 位的字长，但实际上不是64位页式存 储系统。假设在64位系统中采用三级页表机制，页面大小4KB。由于64位系统中字长为 8B，且页目录也占用一页，因此页目录中有512 个页目录项，因此每级页表都需要9位。因此在64位系统下，总共需要3×9+12=39位就可以实现三级页表机制,并不需要64 位。现考虑上述39位的三级页式存储系统，虚拟地址空间为512GB，若三级页表的基地址为PTbase，请计算： **\n三级页表页目录的基地址。 $PT_{base} + PT_{base} \u0026laquo; 9 + PT_{base} \u0026laquo; 18$\n映射到页目录自身的页目录项（自映射）。\n$PT_{base} + PT_{base} \u0026laquo; 9 + PT_{base} \u0026laquo; 18 + PT_{base} \u0026laquo; 27$​\n对于Thinking A.1 的解释 1. MOS中的页目录自映射 ​\t在lab2中我们实现了虚拟内存管理机制——两级页表。提出问题：如何在虚拟地址空间中维护页表和页目录？我们知道，在MOS操作系统中，操作系统会为每一个进程分配4GB的虚拟地址空间。在两级页表机制中，将4GB虚拟地址空间映射到物理内存，则需要1024个页表(页目录有1024项)，每个页表中1024项\n虚拟地址格式\n|PDX(page dictionary offset : 10 bits)|PTX(page table offset : 10 bits) | page_offset : 12 bits 共有1M个页表项\n​\t我们知道页表和页目录实际上也保存在虚拟地址空间中，而对于4GB的虚拟地址空间只需要1024个页表就可以管理（每个页表管理4MB大小的空间），1024个页表的占用空间大小为4MB，且页表在虚拟内存中连续对齐排布，就一定有一个页表所对应的4MB地址空间为这1024个页表的4MB空间，这个页表就是就是页目录，故4MB就可以容纳下页表和页目录。总的来说，这1024个页表中有一个特殊的页表为页目录，在MOS中，将页表和页目录映射到了虚拟地址空间中的0x7fc0_0000-0x8000_0000(4MB)。\n从上图中可以清晰的看出，1024个页表中有一个特殊的页表为页目录，页目录中的1024个表项又指向包括他自己在内的1024个页表\n​\t在连续排布的1M个页表项中，每一个页表项对应着虚拟内存中从低到高的4KB大小的虚拟地址空间，例如第一个页表项(地址为PTbase)对应着虚拟内存中第一个虚拟页面\n​\t这样以此类推，在内存中第n个页表项管理着第n个虚拟页面\n2.对问题的计算解答 2.1 首先以二级页表为例 页表基地址为PTbase\n页目录项所在地址：基地址PTbase+偏移量(4*page_number)\n​\t页表的基地址或者说就是第一个页表项的地址，他所在的页面页号为$PT_{base} \u0026raquo; 12$，而该页是由第$PT_{base} \u0026raquo; 12$个页表项映射到。这个页表项也就是页目录中的第一个页表项。即页目录中第一个页表项的虚拟地址为$PT_{base} + 4*(PT_{base} \u0026laquo; 12)$,即页目录的基地址为$PT_{base} + PT_{base} \u0026laquo; 10$，页目录项所在的页面号：$(PT_{base} + PT_{base} \u0026laquo; 10) \u0026laquo; 12 $，故该页目录项的地址为$PT_{base} + PT_{base} \u0026laquo; 10 + PT_{base} \u0026laquo; 20$\n2.2 三级页表计算 页表基地址为PTbase\n三级页表基地址即为PTbase，所在页面号为$PT_{base} \u0026laquo; 12$ 二级页表基地址即为二级页表第一项的地址$PT_{baze} + PT_{base} \u0026laquo; 9$，所在页面号为$PT_{base} \u0026laquo; 12 + PT_{base} \u0026laquo;21$​ 页目录（一级页表）的基地址即为一级页表第一项的地址$PT_{base} + PT_{base} \u0026laquo; 9 + PT_{base} \u0026laquo; 18$​ 2.3 思路总结 页表项地址 -\u0026gt; 在哪一页？第n页虚拟页面由第n个页表项控制 -\u0026gt; 该页表项地址？起始地址+偏移量 -\u0026gt;递推\n多级页表的映射是按照顺序进行的，即内存中划分的第一个页块由上一级页表的第一个页表项映射，而这个页表项所在的页面是由上一级页表的第一个页表项映射，依次类推。\n实验难点 1. 总结建立物理内存管理的过程 void mips_init(u_int argc, char **argv, char **penv, u_int ram_low_size) { printk(\u0026#34;init.c:\\tmips_init() is called\\n\u0026#34;); // lab2: mips_detect_memory(ram_low_size); mips_vm_init(); page_init(); } ​\t在跳转到mips_init函数后\nmips_detect_memory：检查可用的物理内存大小，初始化物理页面数量npage\nmips_vm_init：初始化页面控制块数组pages管理所有物理页面的页面控制块（通过alloc为pages分配内存）\npage_init：将初始化过程中已经使用的物理页面ref标记为1（这里freemem以下的空间为已经使用的空间），其余的空闲页面的页面控制块加入空闲链表page_free_list（空闲链表的插入和删除都是从头部进行）。\n总体来说实现了指导书中图左半部分\n2.总结实验中建立虚拟内存管理的过程 ​\t我们从用户进程的视角来分析虚拟内存管理，我们实现的实际上是发生TLB Miss时进行的异常处理，即对TLB表项进行重填。\n当发生TLB Miss，调用do_tlb_refill进行重填 do_tlb_refill会首先在页表中查找该虚拟地址对应的二级页表项(page_lookup) 如果有则进行重填 如果没有则进行分配(passive_alloc) 首先分配物理页面(page_alloc) 然后建立起va和刚分配的物理页面之间的映射(page_insert) 对原表项进行无效化(page_invalidate) 实验体会 ​\tlab2主要实现了MOS操作系统中的内存管理机制，实验内容主要分为三部分：物理内存管理(链表法)，虚拟内存管理(二级页表)，TLB重填机制。通过对lab2中代码的编写，对于C语言中宏定义函数，二级指针等更深层次的内容有了一定认识。同时建立物理内存管理和虚拟内存管理的过程也让我体会到理论课中的知识在实践中的应用。\n","permalink":"https://coder0xe.github.io/posts/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","summary":"\u003ch1 id=\"oslab2实验报告\"\u003eOS:lab2实验报告\u003c/h1\u003e\n\u003ch2 id=\"thinking-21\"\u003eThinking 2.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e**在编写的C程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS汇编程序中lw和sw指令使用的地址被视为虚拟 地址，还是物理地址？ **\n\u003cul\u003e\n\u003cli\u003e在编写的C程序中，指针变量中存储的地址为虚拟地址\u003c/li\u003e\n\u003cli\u003e汇编程序中\u003ccode\u003elw\u003c/code\u003e，\u003ccode\u003esw\u003c/code\u003e发送的也是虚拟地址\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-22\"\u003eThinking 2.2\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e请从可重用性的角度，阐述用宏来实现链表的好处\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e使用宏定义对链表操作进行封装，可以实现代码的复用，即减少了工作量，也提高了程序的可读性\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e对于单向链表\u003c/strong\u003e，由于它只能获得每一项的后面一项，因此在删除时需要遍历整个链表；同样，如果是在某一项的前面插入，也需要从\u003ccode\u003ehead\u003c/code\u003e开始遍历这个链表。但是如果是“在某一项之后插入”，单项链表可以直接进行该操作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e对于循环链表\u003c/strong\u003e，因为它仍然是单向的，所以在“删除”、“某一项之前插入”、“某一项之后插入”三个操作的性能和单项链表相同。但是，由于循环链表首尾相连，同时维护了一个指向尾项的指针，因此它可以直接在尾部插入。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e对于双向链表\u003c/strong\u003e，因为它可以直接获得某一项的前后两项，所以无论是“删除”还是“在某一项前或后插入”都可以以O(1)的开销实现。但是，双向链表没有维护指向尾部的指针，因此无法直接将某一项插入链表尾部，如要实现该操作还需要遍历整个链表。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-23\"\u003eThinking 2.3\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e选择\u003ccode\u003ePage_list\u003c/code\u003e正确的展开结构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003estruct Page_list{\n\tstruct {\n\t\tstruct {\n\t\t\tstruct Page *le_next;\n\t\t\tstruct Page **le_prev;\n\t\t} pp_link;\n\t\tu_short pp_ref;\n\t}* lh_first;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-24\"\u003eThinking 2.4\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID的必要性。\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e操作系统会给每一个进程分配一个页表，每个页表都有自己的虚拟地址空间，而同一虚拟地址在不同地址空间中通常映射到不同的物理地址。如果没有\u003ccode\u003eASID\u003c/code\u003e来区分\u003cstrong\u003e当前虚拟地址是在哪个进程中使用\u003c/strong\u003e，则可能会将该虚拟地址映射到错误的物理地址。(\u003cstrong\u003e每一个进程都有自己的虚拟地址空间4G，ASID可以区分不同进程同一虚拟地址转换成物理地址的方法\u003c/strong\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc中可容纳不同的地址空间的最大数量\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eASID\u003c/code\u003e有8位，即最多可以有$2^8$个地址空间（进程数量）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-25\"\u003eThinking 2.5\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003etlb_invalidate\u003c/code\u003e 和 \u003ccode\u003etlb_out\u003c/code\u003e 的调用关系是怎样的？\u003c/strong\u003e\u003c/p\u003e","title":"OS:lab2实验报告"},{"content":"OS:lab2课下基础 一.物理内存管理 1.虚拟地址映射到物理地址 在MIPS-4Kc上，软件访存虚拟地址会先被MMU(Memory Management Unit) 映射到物理地址，随后使用物理地址来访问内存或其他外设\n​\t虚拟地址空间中的四个部分\nkseg0：存放内核代码与数据 将虚拟地址的最高位清0得到物理地址 通过Cache访存 0x8000_0000 - 0x9fff_ffff kseg1：访问外设 将虚拟地址的最高三位清0得到物理地址 不通过Cache访存 0xa000_0000 - 0xbfff_ffff kuseg：用户程序代码与数据 通过TLB转换成物理地址 通过Cache访存 0x0000_0000 - 0x7fff_ffff 2.内核程序启动 lab1中内核启动后跳转到mips_init函数，lab2中在mips_init中增加三个函数\n在建立内核管理机制时，实验中都通过kseg0访问内存\n2.1 mips_detect_memory 探测硬件可用内存，并对一些和内存管理相关的变量进行初始化\nvoid mips_detect_memory(u_int _memsize) { /* Step 1: Initialize memsize. */ memsize = _memsize; /* Step 2: Calculate the corresponding \u0026#39;npage\u0026#39; value. */ /* Exercise 2.1: Your code here. */ npage = memsize / PAGE_SIZE; printk(\u0026#34;Memory size: %lu KiB, number of pages: %lu\\n\u0026#34;, memsize / 1024, npage); } memsize对应总物理内存对应的字节数 npage对应总物理页数 PAGE_SIZE是mmu.h中定义的宏，大小是4096，即每个物理页面的大小为4096字节 2.2 mips_vm_init alloc 在建立起页式内存管理机制之前，使用alloc进行内存空间的分配\n这段代码的作用是分配n字节的空间并返回初始的虚拟地址，同时将地址按 align字节对齐（保证align 可以整除初始虚拟地址），若clear为真，则将对应内存空间的值清零，否则不清零 void *alloc(u_int n, u_int align, int clear) { extern char end[]; u_long alloced_mem; /* Initialize `freemem` if this is the first time. The first virtual address that the * linker did *not* assign to any kernel code or global variables. */ if (freemem == 0) { freemem = (u_long)end; // end } /* Step 1: Round up `freemem` up to be aligned properly */ freemem = ROUND(freemem, align); /* Step 2: Save current value of `freemem` as allocated chunk. */ alloced_mem = freemem; /* Step 3: Increase `freemem` to record allocation. */ freemem = freemem + n; // Panic if we\u0026#39;re out of memory. panic_on(PADDR(freemem) \u0026gt;= memsize); /* Step 4: Clear allocated chunk if parameter `clear` is set. */ if (clear) { memset((void *)alloced_mem, 0, n); } /* Step 5: return allocated chunk. */ return (void *)alloced_mem; } 这里freemem是一个全局变量，初始值为0，我们将它初始化为end(0x8040_0000)，这个变量代表地址小于freemem的空间都被分配完了\n**地址关于align对齐：**使用ROUND()函数实现，其计算如下 $$ ROUND(freemem,align) = \\lceil \\frac {freemem} {align} \\rceil *align $$ 向上取整即找到了freemem之上最小的，按align对齐的地址，中间未用到的地址空间全部舍弃\n分配内存空间\nalloced_mem = freemem; freemem = freemem + n; 分配的空闲内存空间即为[alloced_mem,freemem]这n个字节大小的空间，这里注意freemem进行了更新，仍然保持着freemem地址空间之下都被分配完的性质。\nPADDR:Physical ADDRess\nkva : kernel virtual address\n建立内存管理机制时都是通过kseg0的地址转换方式进行转换，即对最高位清0(ULIM=0x8000_0000) #define PADDR(kva) \\ ({ \\ u_long _a = (u_long)(kva); \\ if (_a \u0026lt; ULIM) \\ panic(\u0026#34;PADDR called with invalid kva %08lx\u0026#34;, _a); \\ _a - ULIM; /*高位清0*/ \\ }) 这里将虚拟地址转化为物理地址，检查是否超出物理地址范围 C语言标准中，多行宏定义要用\\隔开，在预处理时会将这些行拼接为一行 关于int转换到void*\n可以注意到(void*)alloced_mem，alloced_mem是一个无符号整型，涉及到整型向void*类型的转换，效果为指针指向的地址值为int值，例如这个例子代表指向地址alloced_mem(作为地址值)。\nmips_vm_init void mips_vm_init() { /* Allocate proper size of physical memory for global array `pages`, * for physical memory management. Then, map virtual address `UPAGES` to * physical address `pages` allocated before. For consideration of alignment, * you should round up the memory size before map. */ pages = (struct Page *)alloc(npage * sizeof(struct Page), PAGE_SIZE, 1); printk(\u0026#34;to memory %x for struct Pages.\\n\u0026#34;, freemem); printk(\u0026#34;pmap.c:\\t mips vm init success\\n\u0026#34;); } pages是一个结构体类型的全局数组，里边的每一个元素都是结构体Page类型\n每一个Page结构体是对应的物理页面的页面控制块，其中包含一个指针域(pp_link)(主要用于空闲链表page_free_list)，以及一个数据域(pp_ref)，记录了有多少虚拟页面映射到该物理页面(pp_ref==0即为空闲页面)\nPage结构体展开为\nstruct Page{ struct { struct Page* le_next; struct Page** le_prev; } pp_link; u_short pp_ref; } 2.3 page_init void page_init(void) { /* Step 1: Initialize page_free_list. */ /* Hint: Use macro `LIST_INIT` defined in include/queue.h. */ LIST_INIT(\u0026amp;page_free_list); /* Step 2: Align `freemem` up to multiple of PAGE_SIZE. */ freemem = ROUND(freemem,PAGE_SIZE); /* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */ u_long used_page_num = PPN(PADDR(freemem)); u_long i; /*注：pages是Page结构体数组头指针 *(pages+i)与pages[i]等同于访问pages中第i个page*/ for (i = 0;i \u0026lt; used_page_num;i++) { pages[i].pp_ref = 1; } /* Step 4: Mark the other memory as free. */ for (i = used_page_num;i \u0026lt; npage;i++) { pages[i].pp_ref = 0; LIST_INSERT_HEAD(\u0026amp;page_free_list,\u0026amp;pages[i],pp_link); } } page_init主要的功能是将已经使用的物理页面引用次数标记为1，并将空闲的物理页面的页面控制块(Page结构体)加入空闲链表中，这里注意加入空闲链表的位置为头部 freemem虚拟地址，freemem以下的地址空间全都被使用了，比如我们刚才为pages数组分配空间，将freemem以struct Page大小进行对齐，划分物理页面时以PAGE_SIZE将freemem对齐，当前物理页面编号PPN(PADDR(freemem))。 关于空闲链表：当一个进程需要分配内存时，就需要将空闲链表头部的页控制块对应的那一页物理内存分配出去，同时将该页控制块从空闲链表中删去。 当一页物理内存被使用完毕（准确来说，引用次数为0）时，将其对应的页控制块重新插入到空闲链表的头部。 2.4 链表宏 LIST_INSERT_AFTER 在节点之后进行插入\n#define LIST_INSERT_AFTER(listelm, elm, field) \\ /* Exercise 2.2: Your code here. */ \\ do {\t\\ LIST_NEXT((elm), field) = LIST_NEXT((listelm), field); \\ if (LIST_NEXT((listelm), field) != NULL) \\ LIST_NEXT((listelm), field)-\u0026gt;field.le_prev = \u0026amp;LIST_NEXT((elm), field); \\ LIST_NEXT((listelm), field) = (elm); \\ (elm)-\u0026gt;field.le_prev = \u0026amp;LIST_NEXT((listelm), field); \\ } while (0) 实验中使用链表宏主要是对空闲页面的页面控制块（Page结构体）进行管理，每一个页面控制块可以分为链接域(pp_link)和数据域(pp_ref)(即代码中的field为pp_link)。链接域pp_link是一个结构体，其中包含两个指针，struct Page *le_next，struct Page **le_prev。\nstruct Page* le_next是指向下一个节点的指针\nstruct Page **le_prev是指向前一个元素的le_next指针的二级指针，主要用途是改变前一个元素le_next的指向，例如在listelm之前插入节点elm，*(listelm)-\u0026gt;field.le_prev = (elm)\n2.5 page_alloc 将空闲链表头部页控制块对应的物理页面分配出去，并将其从空闲链表中删除\nint page_alloc(struct Page **new) { /* Step 1: Get a page from free memory. If fails, return the error code.*/ struct Page *pp; if (LIST_EMPTY(\u0026amp;page_free_list)) { return -E_NO_MEM; } pp = LIST_FIRST(\u0026amp;page_free_list); LIST_REMOVE(pp, pp_link); /* Step 2: Initialize this page with zero. memset((void*)page2kva(pp),0,PAGE_SIZE); *new = pp; return 0; } 如果空闲链表为空，返回error code，其中错误码都定义在头文件error.h中，其中关于内存分配的错误码为E_NO_MEM\npage2kva：将页面控制块地址转换为对应的内核虚拟地址，这里memset实际上是对物理地址空间的写行为，我们在代码中读写虚拟地址时，虚拟地址经过CPU发送给MMU，转换为相应的物理地址，再对物理地址空间进行读写，实际上确实是对物理页面进行了清空\n2.6 page_free page_free与page_decref配合使用，page_decref的功能是将页面控制块的使用次数pp_ref-1，当pp_ref=0时调用page_free，将页面控制块重新插入空闲链表头部\nvoid page_free(struct Page *pp) { assert(pp-\u0026gt;pp_ref == 0); /* Just insert it into \u0026#39;page_free_list\u0026#39;. */ LIST_INSERT_HEAD(\u0026amp;page_free_list,pp,pp_link); } 3.总结建立物理内存管理的过程 void mips_init(u_int argc, char **argv, char **penv, u_int ram_low_size) { printk(\u0026#34;init.c:\\tmips_init() is called\\n\u0026#34;); // lab2: mips_detect_memory(ram_low_size); mips_vm_init(); page_init(); } ​\t在跳转到mips_init函数后\nmips_detect_memory：检查可用的物理内存大小，初始化物理页面数量npage\nmips_vm_init：初始化页面控制块数组pages管理所有物理页面的页面控制块（通过alloc为pages分配内存）\npage_init：将初始化过程中已经使用的物理页面ref标记为1（这里freemem以下的空间为已经使用的空间），其余的空闲页面的页面控制块加入空闲链表page_free_list（空闲链表的插入和删除都是从头部进行）。\n总体来说实现了指导书中图左半部分\n二.虚拟内存管理 位于kuseg的虚拟地址，需要使用两级页表结构对其进行地址转换，即用户编写的代码和数据需要使用两级页表来访问相应的物理地址空间\n1.两级页表结构 两级页表解决了一级页表当页数过多时占用内存空间过大的问题，解决方法是将一级页表再分页，建立起页目录，每次只将原页表中的一部分拿到内存中\n一级页表:Page Dictionary\n一级页表表项定义为Pde(u_long)类型，实际上是一个32位整型 二级页表:Page Table\n二级页表表项定义为Pte(u_long)类型，实际上是一个32位整型 或者认为一级页表项是个中间量，二级页表项对应的物理地址才是我们需求的物理地址\n每个页表项由32位组成，包括20位物理页号和12位标志位，12位标志位包含高6位硬件标志位和低6位软件标志位\n对于一个32位的虚拟地址，31-22位代表一级页表表项的偏移量(1024项)，21-12位代表二级页表表项的偏移量(1024项)，11-0位代表页内偏移(PAGE_SIZE=4096)，与物理页面大小相同\n宏函数PDX(va)：一级页表表项偏移量(先移位再用与运算高位清0)\n宏函数PTX(va)：二级页表表项偏移量\n通过TLB访存过程如下图\n2.页表相关函数 2.1 二级页表检索函数 pgdir_walk 将一级页表基地址pgdir对应的两级页表结构中va虚拟地址所在的二级页表项的指针存储在ppte指向的空间上，如果对应的二级页表不存在且creat=1则使用page_alloc函数分配一页物理内存存放二级页表\n关于page_alloc：在一般操作系统中，当物理页全部被映射（所有内存空间均被占用），此时还需要申请新的物理页，那么就需要将一些在内存中的物理页置换到硬盘中，选择哪个物理页的算法就称为页面置换算法，例如FIFO算法和LRU算法。 然而在MOS中，这一过程的实现被简化，一旦物理页全部被分配(page_free_list isEmpty)，进行新的物理页分配时并不会进行任何的页面置换，而是直接返回错误，即在对应page_alloc函数中返回-E_NO_MEM。\n代码\nstatic int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte) { Pde *pgdir_entryp; struct Page *pp; /* Step 1: Get the corresponding page directory entry. */ pgdir_entryp = pgdir + PDX(va); /* Step 2: If the corresponding page table is not existent (valid) then: * * If parameter `create` is set, create one. Set the permission bits \u0026#39;PTE_C_CACHEABLE | * PTE_V\u0026#39; for this new page in the page directory. If failed to allocate a new page (out * of memory), return the error. * * Otherwise, assign NULL to \u0026#39;*ppte\u0026#39; and return 0. */ if (!(*pgdir_entryp \u0026amp; PTE_V)) { // 该页目录项中的有效位为0 if (create) { int ret = page_alloc(\u0026amp;pp); // 创建新物理页，即该一级页表表项对应的二级页表页面 if (ret != 0) { // 观察创建返回值 return ret; // -E_NO_MEM 分配失败返回错误码 } else { pp-\u0026gt;pp_ref = 1; // 为0时为空闲页面 // pp是分配出的空闲物理页的页控制块，是原来空闲页面链表(page_free_list)的第一个元素 *pgdir_entryp = page2pa(pp) | PTE_V | PTE_C_CACHEABLE; } } else { *ppte = NULL; return 0; } } /* Step 3: Assign the kernel virtual address of the page table entry to \u0026#39;*ppte\u0026#39;. */ // ppte对应的为虚拟地址，这里做了二级页表基地址物理地址到虚拟地址的映射 *ppte = (Pte*)(KADDR(PTE_ADDR(*pgdir_entryp))) + PTX(va); // 页表偏移量 PTX return 0; } page2pa：将物理页号左移12位得到物理地址，符合页表项的结构20位物理页号+12位权限位 PTE_ADDR：将一级页表项pgdir_entryp的低12位权限位清0，即得到原本的物理地址，即他所对应的二级页表的物理地址 注：我们使用的都是虚拟地址，例如一级页表的基地址，二级页表的基地址等 思路梳理\n先根据一级页表基地址和偏移量找到一级页表的表项，再根据一级页表中物理页号部分得到二级页表的物理基地址，转换为虚拟地址(TLB映射过程中处于内核态，使用kseg0的地址映射策略KADDR)，再根据二级页表偏移量找到对应的二级页表项 代码的前半段功能为给无效的一级页表项分配二级页表，并更新一级页表项中的物理页号部分（物理页号左移12位就是物理地址），最后补充权限位(或运算) 2.2 增加地址映射函数 page_insert 将一级页表地址pgdir对应的两级页表结构中虚拟地址va映射到页控制块pp对应的物理页面，并设置页表项权限\nnt page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm) { Pte *pte; /* Step 1: Get corresponding page table entry. */ //要将pp映射到va，首先检查va是否已经存在了映射 pgdir_walk(pgdir, va, 0, \u0026amp;pte); if (pte \u0026amp;\u0026amp; (*pte \u0026amp; PTE_V)) { // 如果存在映射且有效 if (pa2page(*pte) != pp) { //如果当前的映射不是映射到pp，先移除当前映射，后续再映射到pp page_remove(pgdir, asid, va); } else { // 如果当前已经映射到pp，则只需要更新权限位 //这里对虚存对应的页表项进行更新，要对TLB中对应表项无效化，下次访问触发重填异常 tlb_invalidate(asid, va); *pte = page2pa(pp) | perm | PTE_C_CACHEABLE | PTE_V; return 0; } } /* Step 2: Flush TLB with \u0026#39;tlb_invalidate\u0026#39;. */ tlb_invalidate(asid,va); /* Step 3: Re-get or create the page table entry. */ /* If failed to create, return the error. */ int ret = pgdir_walk(pgdir,va,1,\u0026amp;pte); if (ret != 0) { return -E_NO_MEM; } /* Step 4: Insert the page to the page table entry with \u0026#39;perm | PTE_C_CACHEABLE | PTE_V\u0026#39; * and increase its \u0026#39;pp_ref\u0026#39;. */ pp-\u0026gt;pp_ref++; *pte = page2pa(pp) | perm | PTE_C_CACHEABLE | PTE_V; return 0; } **思路梳理：**要把虚拟地址映射到物理页面上，首先要检查该虚拟地址是否已经存在有效的映射 存在有效的映射且没有映射到我们目标的物理页面：取消已有的映射 已经映射到我们目标的物理页面：更新权限位 不存在已有的有效的映射：则找到虚拟地址va对应的二级页表项(这里设置creat=1，如果不存在就创建，创建不成功返回错误码)，修改二级页表项中的内容（物理地址）以及更新权限位 所谓增加地址映射实际上就是要更新二级页表项的值，将其中的值更新为需要映射到的物理页面的页号 2.3 寻找映射的物理地址函数 page_lookup 找到二级页表结构中虚拟地址所对应的二级页表项所对应的物理页面\nstruct Page *page_lookup(Pde *pgdir, u_long va, Pte **ppte) { struct Page *pp; Pte *pte; /* Step 1: Get the page table entry. */ pgdir_walk(pgdir, va, 0, \u0026amp;pte); /* Hint: Check if the page table entry doesn\u0026#39;t exist or is not valid. */ if (pte == NULL || (*pte \u0026amp; PTE_V) == 0) { return NULL; } /* Step 2: Get the corresponding Page struct. */ /* Hint: Use function `pa2page`, defined in include/pmap.h . */ pp = pa2page(*pte); if (ppte) { *ppte = pte; } return pp; } **思路梳理：**先找到对应的二级页表项，二级页表项中保存的是物理地址的高20位（或者说物理页号）以及低12位的权限位，这里可以将*pte作为物理地址使用，函数pa2page的执行流程为先将物理地址右移12位（*pte丢弃权限位）得到物理页号PPN，再通过PPN找到物理页面的页控制块指针\u0026amp;pages[PPN] 2.4 取消地址映射函数 page_remove void page_remove(Pde *pgdir, u_int asid, u_long va) { Pte *pte; /* Step 1: Get the page table entry, and check if the page table entry is valid. */ struct Page *pp = page_lookup(pgdir, va, \u0026amp;pte); if (pp == NULL) { return; } /* Step 2: Decrease reference count on \u0026#39;pp\u0026#39;. */ page_decref(pp); /* Step 3: Flush TLB. */ *pte = 0; tlb_invalidate(asid, va); return; } 思路梳理：首先找到二级页表项映射到的物理地址的页控制块。page_decref函数会将该页面控制块中使用次数pp_ref-1并在pp_ref==0时进行page_free，同时需要刷新TLB，将va对应的表项删除。 三.TLB重填 1. MIPS-4Kc中的奇偶页TLB设计 ​\t在MIPS-4Kc中，每一个TLB表项都包含一组Key以及两组Data，其中，一组Key由EntryHi保存，两组Data分别由EntryLo0，EntryLo1保存。回想起上学期计组课程，我们的TLB表项中似乎只是一组Key对应一组Data?为什么在MIPS-4Kc中会存在一组Key对应两组Data呢？观察他们的存储方式\n​\t我们知道，VPN有20位，然而在Key中只有高19位，这样自然对应着两个物理页，在EntryLo0中保存偶数页的页号，在EntryLo1中保存奇数页的页号，并根据VPN最低位判断奇偶页。（CPU发送虚拟地址时，先访问TLB，一下拿到两个数据）\n内存管理寄存器\nKey:EntryHi\nVPN：Virtual Page Number，当TLB缺失时，VPN自动由硬件填充为对应虚拟地址的虚页号 ASID：用于区分不同进程的地址空间应当映射到不同的物理地址。我们知道，系统会为每一个进程分配一个单独的虚拟地址空间，在进行虚实地址转换来访问物理内存时，不同进程相同虚拟地址不会映射到同一物理地址，这就需要ASID来进行区分 Data:EntryLo\nPFN：Physical Frame Number,软件填写PFN，接着使用TLB的写指令，才可以将Key和Data写入TLB表项 C：Cache访问属性 **D：**可写位 V：有效位 G：全局位，该位如果为1，则CPU发出的虚拟地址只需要与VPN匹配，忽略ASID 2.TLB指令 tlbr：以 Index 寄存器中的值为索引，读出TLB中对应的表项到EntryHi与EntryLo0、 EntryLo1 tlbwi：以 Index 寄存器中的值为索引，将此时EntryHi与EntryLo0、EntryLo1 的值写 到索引指定的TLB表项中。 tlbwr：将 EntryHi 与 EntryLo0、EntryLo1 的数据随机写到一个 TLB 表项中（此处使 用Random 寄存器来“随机”指定表项，Random寄存器本质上是一个不停运行的循环计数 器）。 tlbp：根据EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项，并将 表项的索引存入Index 寄存器（若未找到匹配项，则Index最高位被置1(为负数)） ​\t则软件操作TLB的流程为：填写CP0中寄存器+TLB指令\n3.TLB维护流程 ​\t在用户地址空间访存时，虚拟地址到物理地址的转换均通过TLB进行。访问需要转换的虚拟内存地址时\n首先要使用虚拟页号（VPN）和当前进程的ASID在TLB中查询该地址对应的物理页号 若VPN和ASID组成的Key在TLB中有对应的表项，则可取得物理地址 若不能查询到则产生TLB Miss异常，系统跳转到异常处理程序，在两级页表结构中找到对应的物理地址对TLB进行重填 若对虚拟地址对应的页表项进行更新，要对TLB中对应的表项进行无效化(invalidate)，下次再访问该虚拟地址时，硬件触发TLB重填异常，对TLB进行重填 3.1 TLB无效化 通过tlb_invalidate函数删除特定虚拟地址在TLB中的旧表项，具体是通过调用tlb_out函数完成\ntlb_out\n思路梳理： 先将要查找的虚拟地址存入EntryHi寄存器，然后调用tlbp指令在TLB中查找（此时Index寄存器中保存了找到的对应表项的索引）。如果没有找到（索引小于0），则直接跳到最后；如果找到了，将索引对应的tlb项清空（需要将EntryHi和EntryLo寄存器清零后使用tlbwi指令）。注意在函数最后需要将调用该函数前EntryHi寄存器中的值恢复\nLEAF(tlb_out) .set noreorder mfc0 t0, CP0_ENTRYHI #维护EntryHi寄存器 将EntryHi寄存器中原本的值存入t0 mtc0 a0, CP0_ENTRYHI #将需要寻找的Key(VPN,ASID)存入EntryHi nop /* Step 1: Use \u0026#39;tlbp\u0026#39; to probe TLB entry */ /* Exercise 2.8: Your code here. (1/2) */ tlbp\t#寻找EntryHi中Key在TLB中对应的表项，并将索引号存入Index寄存器，若不存在则Index最高位置1(index为负数) nop /* Step 2: Fetch the probe result from CP0.Index */ mfc0 t1, CP0_INDEX #将Index寄存器中的值存入t1寄存器 .set reorder bltz t1, NO_SUCH_ENTRY #判断index值大小，若小于0则说明没找到 .set noreorder mtc0 zero, CP0_ENTRYHI #将EntryHi清0 mtc0 zero, CP0_ENTRYLO0 #将EntryLo0清0 mtc0 zero, CP0_ENTRYLO1 #将EntryLo1清0 nop /* Step 3: Use \u0026#39;tlbwi\u0026#39; to write CP0.EntryHi/Lo into TLB at CP0.Index */ /* Exercise 2.8: Your code here. (2/2) */ tlbwi\t#向找到的index表项中写入Key,Data(全为0) .set reorder NO_SUCH_ENTRY: mtc0 t0, CP0_ENTRYHI #恢复调用前EntryHi的值 j ra #跳转回调用者 END(tlb_out) 3.2 TLB重填 ​\tTLB重填过程由kern/tlb_asm.S中的do_tlb_refill函数完成。在发生TLB Miss异常时，对应的虚拟地址被存放在BadVAddr中，同时在EntryHi寄存器中保存该页面的Key。调用_do_tlb_refill进行TLB重填后将奇偶页表项存入EntryLo，再随机写入到TLB的一个表项中(tlbwr)\ndo_tlb_refill\nNESTED(do_tlb_refill, 24, zero) mfc0 a1, CP0_BADVADDR mfc0 a2, CP0_ENTRYHI andi a2, a2, 0xff /* ASID is stored in the lower 8 bits of CP0_ENTRYHI */ .globl do_tlb_refill_call; do_tlb_refill_call: addi sp, sp, -24 /* Allocate stack for arguments(3), return value(2), and return address(1) */ sw ra, 20(sp) /* [sp + 20] - [sp + 23] store the return address */ addi a0, sp, 12 /* [sp + 12] - [sp + 19] store the return value */ jal _do_tlb_refill /* (Pte *, u_int, u_int) [sp + 0] - [sp + 11] reserved for 3 args */ lw a0, 12(sp) /* Return value 0 - Even page table entry */ lw a1, 16(sp) /* Return value 1 - Odd page table entry */ lw ra, 20(sp) /* Return address */ addi sp, sp, 24 /* Deallocate stack */ mtc0 a0, CP0_ENTRYLO0 /* Even page table entry */ mtc0 a1, CP0_ENTRYLO1 /* Odd page table entry */ nop /* Hint: use \u0026#39;tlbwr\u0026#39; to write CP0.EntryHi/Lo into a random tlb entry. */ /* Exercise 2.10: Your code here. */ tlbwr jr ra END(do_tlb_refill) _do_tlb_refill\nvoid _do_tlb_refill(u_long *pentrylo, u_int va, u_int asid) { tlb_invalidate(asid, va); Pte *ppte; /* Hints: * Invoke \u0026#39;page_lookup\u0026#39; repeatedly in a loop to find the page table entry \u0026#39;*ppte\u0026#39; * associated with the virtual address \u0026#39;va\u0026#39; in the current address space \u0026#39;cur_pgdir\u0026#39;. * * **While** \u0026#39;page_lookup\u0026#39; returns \u0026#39;NULL\u0026#39;, indicating that the \u0026#39;*ppte\u0026#39; could not be found, * allocate a new page using \u0026#39;passive_alloc\u0026#39; until \u0026#39;page_lookup\u0026#39; succeeds. */ /* Exercise 2.9: Your code here. */ while(page_lookup(cur_pgdir,va,\u0026amp;ppte) == NULL) { passive_alloc(va,cur_pgdir,asid); } ppte = (Pte *)((u_long)ppte \u0026amp; ~0x7); pentrylo[0] = ppte[0] \u0026gt;\u0026gt; 6; pentrylo[1] = ppte[1] \u0026gt;\u0026gt; 6; } **思路梳理：**不断寻找va对应的二级页表项，如果一直为空则不断尝试为该二级页表项分配物理页面，直到不为空为止 passive_alloc\nstatic void passive_alloc(u_int va, Pde *pgdir, u_int asid) { struct Page *p = NULL; if (va \u0026lt; UTEMP) { panic(\u0026#34;address too low\u0026#34;); } if (va \u0026gt;= USTACKTOP \u0026amp;\u0026amp; va \u0026lt; USTACKTOP + PAGE_SIZE) { panic(\u0026#34;invalid memory\u0026#34;); } if (va \u0026gt;= UENVS \u0026amp;\u0026amp; va \u0026lt; UPAGES) { panic(\u0026#34;envs zone\u0026#34;); } if (va \u0026gt;= UPAGES \u0026amp;\u0026amp; va \u0026lt; UVPT) { panic(\u0026#34;pages zone\u0026#34;); } if (va \u0026gt;= ULIM) { panic(\u0026#34;kernel address\u0026#34;); } panic_on(page_alloc(\u0026amp;p)); panic_on(page_insert(pgdir, asid, p, PTE_ADDR(va), (va \u0026gt;= UVPT \u0026amp;\u0026amp; va \u0026lt; ULIM) ? 0 : PTE_D)); } **思路梳理：**先分配出一个物理页面，再将虚拟地址va对应的二级页表项映射到物理页面上 4.总结虚拟内存管理的过程 我们从用户进程的视角来分析虚拟内存管理，我们实现的实际上是发生TLB Miss时进行的异常处理，即对TLB表项进行重填。\n当发生TLB Miss，调用do_tlb_refill进行重填 do_tlb_refill会首先在页表中查找该虚拟地址对应的二级页表项(page_lookup) 如果有则进行重填 如果没有则进行分配(passive_alloc) 首先分配物理页面(page_alloc) 然后建立起va和刚分配的物理页面之间的映射(page_insert) 对原表项进行无效化(page_invalidate) 四.上机前复习 1.已知二级页表基地址pgdir，两级页表均有1024项，遍历虚拟地址空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //已知Pde* pgdir for (u_long i = 0; i \u0026lt; 1024; i++) { //遍历页目录的1024项 Pde *pde = pgdir + i; //第i个页目录项对应的虚拟地址 if ((*pde) \u0026amp; PTE_v) { //第i个页表有效 for (u_long j = 0; j \u0026lt; 1024; j++) {//遍历第i个页表的1024项 Pte *pte = (Pte*)KADDR(PTE_ADDR(*pde)) + j; if ((*pte) \u0026amp; PTE_V) { //第j个页有效 //some code /*例如*/ //1.将(*pte)页表项映射到某物理地址，且保留后边的所有12位offset (*pte) = PTE_ADDR(物理地址) | ((*pte) \u0026amp; 0xfff); //或(*pte) = (((某物理地址)/PAGESIZE) \u0026lt;\u0026lt; 12) | ((*pte) \u0026amp; 0xfff); //2.定向设置(*pte)页表项的权限位 (*pte) = ((*pte) | PTE_SWP) \u0026amp; (~PTE_V); //3.改变TLB中的(*pte)页表项(实际上是使他无效) //tlb_invalidate(asid,va); tlb_invalidate(asid,(i \u0026lt;\u0026lt; 22) | (j \u0026lt;\u0026lt; 12)); } } } } 2.几个量 1 2 3 4 5 6 7 8 9 10 11 12 13 // 已知Pde *pgdir Pde *pde = pgdir + i; 1.pde : 第i个页目录项对应的虚拟地址 2.(*pde) : 第i个页目录项的内容 3.PTE_ADDR(*pde) : 第i个页目录项内容中的物理地址 = 第i个页表的物理基地址 4.KADDR(PTE_ADDR(*pde)) : 第i个页表的虚拟基地址 Pte *pte = (*Pte)KADDR(PTE_ADDR(*pde)) + j; 1.pte : 第j个页表项对应的虚拟地址 2.(*pte) : 第j个页表项内容 //虚拟地址 va u_long i = PDX(va); u_long j = PTX(va); u_long va = (i \u0026lt;\u0026lt; 22) | (j \u0026lt;\u0026lt; 12) | offset; 3.2021级上机题目 3.1exam 统计二级页表中满足以下条件的页表项\n页表项有效\n1 if ((*pte) \u0026amp; PTE_V) 页表项映射的物理地址为给定的Page *pp物理地址\n1 PTE_ADDR(*pte) == page2pa(pp) 页表项的权限包含给定的权限perm_mask(赋予该权限之后和原页表项内容相同)\n1 (*pte) == ((*pte) | perm_mask) 思路：遍历二级页表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 for (u_long i = 0;i \u0026lt; 1024;i++) { int cnt = 0; Pde *pde = pgdir + i; if (!(*pde \u0026amp; PTE_V)) { continue; } for (u_long j = 0;j \u0026lt; 1024;j++) { Pte *pte = (Pte*)KADDR(PTE_ADDR(*pde)) + j; if (!(*pte \u0026amp; PTE_V)) { continue; } if (((*pte) == ((*pte | perm_mask))) \u0026amp;\u0026amp; (PTE_ADDR(*pte) == page2pa(pp))){ cnt++; } } return cnt; } 3.2 extra 实现一个简单的交换机制 4. 2022级上级题目 4.1 exam 挺简单的，遍历指定范围的虚拟地址空间，找到引用次数大于阈值的物理页面数量，主要是寻找到虚拟页面对应的物理页面的页控制块，题目中提示了要使用page_lookup函数，这里需要判断如果返回的页面控制块为空(无映射或无效)就跳过 4.2 extra 总体实现难度也不高，题意为实现一个简化版的伙伴交换系统，完成分配和回收函数，题目中给出了很多限制，例如只能申请4KB,8KB的空闲块，分配机制按照题目提示就能完成，这里需要注意8KB对应的页面控制块是他的低4KB的页面控制块，要想拿到高4KB的页面控制块只需要对地址增加之后转换(pa2page(page2pa(pp) + PAGE_SIZE))\n回收函数中我认为有一个思考点是如何将4KB的空间和他的空闲的伙伴地址空间一同回收(这里题目中限制了只有4KB才会出现伙伴，因为最多分配8KB)\n第一点是如何确定谁是他的伙伴，或者说怎样找到他的伙伴的页面控制块，再进一步的说，如何找到他的伙伴空间的地址。我们在把8KB的地址空间拆分为伙伴时(初始时将全部4MB地址空间划分为8KB插入空闲链表)，可以理解为一个4KB在低地址，一个4KB在高地址。这样我们只需要判断出我们拿到的这个4KB位于高地址还是低地址位置，在加或减页面大小就能得到他的伙伴的物理地址。如何判断呢？我们可以清楚地知道，如果将全部8KB都划分为4KB序列，**对这些4KB块编号(从0开始)，那么处于低地址的编号为偶数，处于高地址的编号为奇数。这样只需要计算出相对的页面编号就行了。**假设我们拿到的页面控制块为struct Page *pp，这样可以由他对应的物理地址相对于首地址的偏移量再除以页面大小得到编号。\n伪代码表示\noffset = page2pa(pp) - start; number = offset / PAGE_SIZE; if (number % 2 == 0) { // 低地址 伙伴位于高地址 struct Page*higher_buddy = pa2page(page2pa(pp) + PAGE_SIZE); } else { struct Page*lower_buddy = pa2page(page2pa(pp) - PAGE_SIZE); } 接下来一点是判断这个伙伴是否空闲，即是否在4KB的空闲链表中，只需要遍历4KB的空闲链表看看能不能找到即可，这里使用宏LIST_FOREACH可以完成for遍历头书写\n4.3总结 ​\t从lab2以后对于操作系统的理解难度变得更高，更加印证了陈奕帅学长的话：“学好OS就要理解好OS的代码”，诚哉斯言！\n","permalink":"https://coder0xe.github.io/posts/os-lab2%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"oslab2课下基础\"\u003eOS:lab2课下基础\u003c/h1\u003e\n\u003ch2 id=\"一物理内存管理\"\u003e一.物理内存管理\u003c/h2\u003e\n\u003ch3 id=\"1虚拟地址映射到物理地址\"\u003e1.虚拟地址映射到物理地址\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在MIPS-4Kc上，软件访存虚拟地址会先被MMU(Memory Management Unit) 映射到物理地址，随后使用物理地址来访问内存或其他外设\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e​\t虚拟地址空间中的四个部分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ekseg0\u003c/code\u003e：\u003cstrong\u003e存放内核代码与数据\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e将虚拟地址的最高位清0得到物理地址\u003c/li\u003e\n\u003cli\u003e通过Cache访存\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e0x8000_0000 - 0x9fff_ffff\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekseg1\u003c/code\u003e：\u003cstrong\u003e访问外设\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e将虚拟地址的最高三位清0得到物理地址\u003c/li\u003e\n\u003cli\u003e不通过Cache访存\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e0xa000_0000 - 0xbfff_ffff\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekuseg\u003c/code\u003e：\u003cstrong\u003e用户程序代码与数据\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e通过TLB转换成物理地址\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e通过Cache访存\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e0x0000_0000 - 0x7fff_ffff\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240331202331322\" loading=\"lazy\" src=\"/img/image-20240331202331322.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"2内核程序启动\"\u003e2.内核程序启动\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003elab1中内核启动后跳转到mips_init函数，lab2中在mips_init中增加三个函数\u003c/p\u003e\n\u003cp\u003e在建立内核管理机制时，实验中都通过kseg0访问内存\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"21-mips_detect_memory\"\u003e2.1 mips_detect_memory\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e探测硬件可用内存，并对一些和内存管理相关的变量进行初始化\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evoid mips_detect_memory(u_int _memsize) {\n\t/* Step 1: Initialize memsize. */\n\tmemsize = _memsize;\n\t/* Step 2: Calculate the corresponding \u0026#39;npage\u0026#39; value. */\n\t/* Exercise 2.1: Your code here. */\n\tnpage = memsize / PAGE_SIZE;\n\tprintk(\u0026#34;Memory size: %lu KiB, number of pages: %lu\\n\u0026#34;, memsize / 1024, npage);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ememsize\u003c/code\u003e对应总物理内存对应的字节数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enpage\u003c/code\u003e对应总物理页数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePAGE_SIZE\u003c/code\u003e是\u003ccode\u003emmu.h\u003c/code\u003e中定义的宏，大小是4096，即每个物理页面的大小为4096字节\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"22-mips_vm_init\"\u003e2.2 mips_vm_init\u003c/h4\u003e\n\u003ch5 id=\"alloc\"\u003ealloc\u003c/h5\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在建立起页式内存管理机制之前，使用alloc进行内存空间的分配\u003c/p\u003e","title":"OS:lab2课下基础"},{"content":"OO第二单元第一次作业 [toc]\n0. 前置知识 0.1 进程与线程 计算机中，我们把一个任务称作一个进程(Process)\n在一个进程中，还包含一个至多个子任务，称为线程(Thread)\n进程与线程是包含关系，一个进程中可以包含多个线程\n线程内执行顺序确定，线程间执行顺序由操作系统调度，无法确定\ntips:此单元作业中不要使用调试，会影响线程，转为使用打印调试法\n0.1.1 创建新线程 Java语言中内置了多线程支持，当Java程序启动的时候，实际上是启动了一个JVM进程，然后JVM启动主线程来执行main方法，在main方法中我们可以启动其他线程\n继承Thread类\n从Thread类派生一个自定义类，覆写run方法\npublic class myThread extends Thread { @Override public void run() { // ... } } 实现Runnable接口\n实现Runnable接口，重写run方法\npublic class myRunnable implements Runnable { @Override public void run() { //... } } 创建一个新线程\nThread t = new myThread(); Thread t = new Thread(new myRunnable) 启动新线程\nt.start() 注：start()方法会在内部自动调用实例的run方法，直接调用run()方法不会创建新线程 线程入口run()方法的模版\npublic void run(){ try{ while(true){ if(has new task) { //... } else { break; } } //do something to finish } catch(InterruptedException e){ //该线程被调用interrupt //... } //do something to finish } 0.1.2 线程的状态 在Java程序中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法，一旦run()方法执行结束，线程就结束了\nNew:新创建的线程，尚未执行\nRunnable：需要注意的是Runnable对应着两种状态\nReady：准备被调度（尚未运行） Running：正运行 Blocked：运行中的线程，因为某些操作被阻塞而挂起\nWaiting：运行中的线程，不定长时间的等待状态\nTimed Waiting：运行中的线程，定长时间的等待状态（Thread.sleep(),其中sleep传入的参数为毫秒） Terminated：线程终止：run()执行结束或stop()被调用\njoin 当线程对象调用.join方法时，主线程(main)会等待该线程执行结束后才继续往下执行自身线程 0.1.3 中断线程 中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，自身线程立刻结束运行\nt.interrupt() interrupt()为发送中断请求，不一定能够及时响应\n代码模版如下\nclass myThread extends Thread { public void run() { while (!isInterrupted()) { try { //... } catch (InterruptedException e) { break; } } } } 或者通过设置running标志位来标识线程是否应该继续运行\nclass myThread extends Thread { public volatile boolean running = true; public void run() { while (running) { //... } } } 外部中断线程运行\nt.running = false volatile用于修饰线程间共享的变量，确保每个线程都能读到更新后的变量\n在JAVA虚拟机中，变量的值保存在主内存中，当线程访问变量时，会先获取一个副本，并保存在自己的工作内存中，若线程修改了变量的值，虚拟机会在某个时刻将修改后的值写回到主内存，但是时间不确定！\n这导致了某个线程更新了变量，另一个线程读取的值可能还是更新前的\nvolatile:\n每次访问线程间共享的变量时，总是获取主存内的最新值 每次修改变量后，立即写回到主存 0.1.4 线程同步 多进程之间的共享数据在多进程同时进行读写时，会出现数据不一致的问题\n在多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其余线程必须等待\n通过加锁和解锁的操作，就能保证这些指令总是在一个线程执行期间，不会有其他线程进入此指令区间，即使在执行期间线程被操作系统中断，其他线程也会因为无法获得锁导致无法进入指令区间。\n加锁和解锁之间的代码块称为临界区，任何时候临界区最多只有一个线程可以执行\n加锁关键字synchronized\n对某一个对象加锁\nsynchronized(obj) { ... } 对某一个方法加锁\nsynchronized method (...) { ... } 对于静态方法: monitor实际是***.class one thread per class 对于动态方法:monitor实际上是this one thread per object/instance 完成工作后就会交出锁，下一个线程拿到锁继续工作\nJava中的synchronized锁是可重入锁\npublic class Counter { private int count = 0; public synchronized void add(int n) { dec(-n); } public synchronized void dec(int n) { count += n; } } java允许线程反复获取同一个锁，例如上例中add和dec方法都需要获取当前实例的this锁，add方法中已经获取了this锁，可以再次获取this锁调用dec\n关于可重入锁：获取锁的时候，不但要判断是否为第一次获取，还要记录这是第几次获取，获取一次锁，记录+1，退出synchronized块，记录-1，减到0的时候会释放锁\n死锁：多个线程各自持有不同的锁，然后各自试图获取对方手中的锁，双方无限等待下去，造成死锁\n解决方法是线程之间获取锁的顺序要一致 0.1.5 wait \u0026amp;\u0026amp; notify 在synchronized内部可以调用wait()使线程进入等待状态\n必须在已获得的锁对象上调用wait()方法，例如\nthis.wait() 线程进入等待状态后会释放锁，交给其他进程\n在synchronized内部可以调用notify()或notifyAll()唤醒其他等待进程\n通常使用notifyAll更加安全，确保所有访问者的公平性 必须在已获得的锁对象上调用notify()方法\nthis.notify() 被唤醒的线程还需要重新获得锁后才能继续执行\nwait-notify实际上是生产者-消费者模型\n0.2 生产者-消费者模型 生产者向托盘对象中存入生产的货物(synchronized method) 消费者从托盘中取走相应的货物(synchronizedd method) 货物放置控制 货物提取控制 托盘既可以是单一对象，也可以是容器对象 0.3 电梯调度算法 选用LOOK算法，后续详细介绍 1.题目需求分析 完成乘客请求：\n电梯上下行 开关门动作 控制乘客进出电梯 电梯运行基本约束\n可到达楼层1-11 初始位置1层 数量6部(编号为1-6) 移动一层花费的的时间:0.4s 开/关门花费的时间:0.2s 乘客进出电梯不花费时间 限乘人数:6人 乘客只能进入和离开输入时指定的电梯，不可以进入其他电梯(后续作业有变动)\n时间戳]乘客ID-FROM-起点层-TO-终点层-BY-电梯ID 关于性能：\n运行时间尽量短 尽量不让请求等待过长时间 减少系统的无效运行 2.处理流程分析 2.1 多线程协作分析 ​\t在第五次作业中，提供的乘客请求均已指定了接收的电梯，所以我在这一次作业中并没有设计调度器(偷懒)，这导致在第六次作业中需要小小地重构一下构建调度器。第一次接触多线程编程，正所谓谋定而后动，第一重要的是梳理好各个线程之间的协作关系。在第五次作业中，主要涉及到的线程为输入线程和六个电梯线程，为每个电梯设计一个等待队列，每部电梯的等待队列即为该电梯线程与输入线程的共享变量，输入线程将拿到的请求放到队列中，电梯线程从队列中拿出请求，即输入线程为生产者，电梯线程为消费者，这里选择将等待队列类实现为一个线程安全类，即为外部提供好对等待队列的操作接口，外部调用时不必考虑线程安全问题，在类内部保证线程安全问题。这里对线程之间协作的分析如下图：\nUML协作图 主类负责启动各个线程，线程之间的共享变量写到构造方法中\n电梯类向策略类询问接乘客的策略\n这里需要注意的一点是：什么时候设置电梯线程结束？\n当读入的请求为空时，就能说明已经没有后续请求\n在请求队列中设置了标记位endFlag，当读入空请求时将每个电梯中请求队列的标记位置true\n策略类返回OVER建议结束电梯线程：当前电梯中没有人并且请求队列标记位为true\n2.2 电梯调度算法 2.2.1 LOOK算法 这里采用了hyggge学长博客中推荐的LOOK算法，该算法可表述如下(转载)\n首先为电梯规定一个初始方向，然后电梯开始沿着该方向运动。\n到达某楼层时，\n首先判断是否需要开门\n如果发现电梯里有人可以出电梯（到达目的地），则开门让乘客出去； 如果发现该楼层中有人想上电梯，并且目的地方向和电梯方向相同，则开门让这个乘客进入。 接下来，进一步判断电梯里是否有人\n。如果电梯里还有人，则沿着当前方向移动到下一层。否则，检查请求队列中是否还有请求（目前其他楼层是否有乘客想要进电梯）\n如果请求队列不为空，且某请求的发出地是电梯\u0026quot;前方\u0026quot;的某楼层，则电梯继续沿着原来的方向运动。\n如果请求队列不为空，且所有请求的发出地都在电梯\u0026quot;后方\u0026quot;的楼层上，或者是在该楼层有请求但是这个请求的目的地在电梯后方（因为电梯不会开门接反方向的请求），则电梯掉头并进入\u0026quot;判断是否需要开门\u0026quot;的步骤（循环实现）。\n如果请求队列为空，且输入线程没有结束（即没有输入文件结束符），则电梯停在该楼层等待请求输入（wait）。\n注意：电梯等待时运行方向不变。在我的设计中，运行方向是电梯的一个状态量而不是过程量，用来表示下一次move时的方向。当有新请求进入请求队列时，电梯被唤醒，此时电梯的运行方向仍然是电梯wait前的方向。\n如果请求队列为空，且输入线程已经结束，则电梯线程结束。\n2.2.2 电梯类以及策略类的设置 2.2.2.1 Elevator extends Thread 记录电梯运行的基本信息，内聚属于每一部电梯的strategy\n1 2 3 4 5 6 7 private final int elevatorId; // 电梯序号 1-6 private int curNum = 0; // 乘客人数 \u0026lt;=6 private int curFloor = 1; //当前楼层 1-11 private boolean direction = true; // 当前运行方向 private HashMap\u0026lt;Integer, HashSet\u0026lt;Person\u0026gt;\u0026gt; destMap; private RequestTable requestTable; private Strategy strategy; // 每部电梯的策略 关于deskmap：是\u0026lt;到达楼层(目的地),乘客\u0026gt;的哈希表，在进入乘客时，从请求队列requestTable中删除乘客并加入destmap，出电梯时从destmap中判断(或者说destmap中的人数等于curNum)，这里为了避免后续加入乘客时调用destMap.get(toFloor)可能为空的情况，可以考虑对这个比较复杂的数据结构进行初始化，私有方法destMapInit\n1 2 3 4 5 6 public void destMapinit() { this.destMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 1;i \u0026lt;= 11;i++) { this.destMap.put(i,new HashSet\u0026lt;\u0026gt;()); } } 电梯在每次运行时询问策略类建议，依据对应的策略运行\n@Override public void run() { while (true) { Advice advice = strategy.getAdvice(this.elevatorId,this.curFloor, this.curNum,this.direction,this.destMap); if (advice == Advice.OVER) { break; } else if (advice == Advice.MOVE) { move(); } else if (advice == Advice.REVERSE) { this.direction = !this.direction; } else if (advice == Advice.WAIT) { requestTable.waitRequest(); } else if (advice == Advice.OPEN) { openAndClose(); } } } 返回OVER建议时break，跳出while循环，结束进程 关于电梯等待\n当电梯中请求队列为空且并没有结束请求时等待 当电梯等待列表中新增乘客或设置结束位时通知电梯，不用再等了(由于这里只有两个线程共享requestTable变量，或者说线程池中等待的只有一个线程，调用notify()或notifyAll()效果是相同的) 其他电梯运行方法：运行时间通过Thread.sleep(time)进行模拟实现\n移动\n1 2 3 4 5 6 7 8 9 private void move() { // 移动一层时间为0.4s try { Thread.sleep(400); } catch (InterruptedException e) { e.printStackTrace(); } this.curFloor += this.direction ? 1 : -1; TimableOutput.println(String.format(\u0026#34;ARRIVE-%d-%d\u0026#34;,this.curFloor,this.elevatorId)); } 进入乘客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void in() { if (this.curNum == 6) { return; } ArrayList\u0026lt;Person\u0026gt; people = this.requestTable.getRequestMap().get(this.curFloor); for (int i = 0; i \u0026lt; people.size();i++) { Person person = people.get(i); int toFloor = person.getToFloor(); if (this.curNum == 6) { break; } if ((toFloor \u0026gt; this.curFloor \u0026amp;\u0026amp; this.direction) || (toFloor \u0026lt; this.curFloor \u0026amp;\u0026amp; !this.direction)) { //乘客从requestTable中转移到destMap } } } 进入乘客时要每一次都判断是否超载 对于等待队列中ArrayList遍历删除的细节：如果采用正序遍历，则每次删除需要将i回退一位，否则可能有遗漏，更优雅的方式是逆序删除 出乘客\n1 2 3 4 private void out() { HashSet\u0026lt;Person\u0026gt; people = this.destMap.get(this.curFloor); // 用迭代器在目的地在当前楼层的乘客进行遍历删除 } 2.2.2.2 Strategy 对于策略类的实现只需要描述出LOOK算法的内容即可\n对于策略类中返回的建议使用枚举类Advice封装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public Advice getAdvice(int elevatorId,int curFloor, int curNum, boolean direction, HashMap\u0026lt;Integer, HashSet\u0026lt;Person\u0026gt;\u0026gt; destMap) { if (canOpenForout(curFloor, destMap) || canOpenForIn(curFloor, curNum, direction)) { return Advice.OPEN; } if (curNum != 0) { return Advice.MOVE; } else { if (requestTable.isEmpty()) { // 队列为空 if (requestTable.isOver()) { // 输入结束 return Advice.OVER; } else { return Advice.WAIT; } } else { if (hasReqInOriginDirection(curFloor, direction)) { return Advice.MOVE; } else { return Advice.REVERSE; } } } } hasReqInOriginDirection：在电梯当前运行同方向上还有乘客请求 2.2.2.3 RequestTable线程安全类的实现 类中主要共享变量\n// \u0026lt;楼层序号,每个楼层发出请求的人\u0026gt; private HashMap\u0026lt;Integer, ArrayList\u0026lt;Person\u0026gt;\u0026gt; requestMap; // 请求数量 private int requestNum; // 请求结束标记 private boolean endFlag; 对以上变量的读写要保证线程安全，这里我的实现是对以上变量的读写均设置为synchronized方法，值得一提的是增加请求方法和设置结束标志方法，这两个方法需要对睡着的电梯线程进行唤醒，电梯等待的原因是此时没有请求且没有结束，这两个方法会对电梯等待的条件判断造成破坏（增加请求/已经结束），这样似乎更好理解需要唤醒电梯的原因\naddRequest()\n1 2 3 4 5 6 public synchronized void addRequest(Person person) { int fromFloor = person.getFromFloor(); requestMap.get(fromFloor).add(person); requestNum++; this.notify(); } setOver()\n1 2 3 4 public synchronized void setOver() { this.notify(); this.endFlag = true; } 其他方法：判断电梯是否为空，是否结束，电梯等待，删除请求等，不一一赘述了\n3. UML类图以及代码复杂度分析 3.1 UML类图 3.2 代码复杂度分析 主要复杂度集中在电梯类中进入乘客和策略类中判断策略的部分，可以理解 4. Bug修复与策略 主要的调试方法：输出 在此次作业中强测和互测均无bug 互测中房友的bug：本摆烂人交了一发样例刀中了人，没有细究原因(摆烂摊手) ","permalink":"https://coder0xe.github.io/posts/oo-unit2-hw5/","summary":"\u003ch1 id=\"oo第二单元第一次作业\"\u003eOO第二单元第一次作业\u003c/h1\u003e\n\u003cp\u003e[toc]\u003c/p\u003e\n\u003ch2 id=\"0-前置知识\"\u003e0. 前置知识\u003c/h2\u003e\n\u003ch3 id=\"01-进程与线程\"\u003e0.1 进程与线程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e计算机中，我们把一个任务称作一个进程(Process)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在一个进程中，还包含一个至多个子任务，称为线程(Thread)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e进程与线程是包含关系，一个进程中可以包含多个线程\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e线程内执行顺序确定，线程间执行顺序由操作系统调度，无法确定\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003etips:此单元作业中不要使用调试，会影响线程，转为使用打印调试法\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240326000818799\" loading=\"lazy\" src=\"/img/image-20240326000818799.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"011-创建新线程\"\u003e0.1.1 创建新线程\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eJava语言中内置了多线程支持，当Java程序启动的时候，实际上是启动了一个\u003cstrong\u003eJVM进程\u003c/strong\u003e，然后JVM启动\u003cstrong\u003e主线程\u003c/strong\u003e来执行\u003ccode\u003emain\u003c/code\u003e方法，在\u003ccode\u003emain\u003c/code\u003e方法中我们可以\u003cstrong\u003e启动其他线程\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e继承Thread类\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e从Thread类派生一个自定义类，覆写run方法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epublic class myThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\t// ...\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e实现Runnable接口\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e实现Runnable接口，重写run方法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epublic class myRunnable implements Runnable {\n\t@Override \n\tpublic void run() {\n\t\t//...\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e创建一个新线程\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eThread t = new myThread();\nThread t = new Thread(new myRunnable)\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e启动新线程\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003et.start()\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e注：start()方法会在内部自动调用实例的run方法，直接调用run()方法不会创建新线程\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e线程入口\u003ccode\u003erun()\u003c/code\u003e方法的模版\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epublic void run(){\n\ttry{\n\t\twhile(true){\n\t\t\tif(has new task) {\n\t\t\t\t//...\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//do something to finish\n\t}\n\tcatch(InterruptedException e){  //该线程被调用interrupt\n\t\t//...\n\t}\n\t//do something to finish\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"012-线程的状态\"\u003e0.1.2 线程的状态\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在Java程序中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法，一旦run()方法执行结束，线程就结束了\u003c/p\u003e","title":"OO-Unit2-HW1"},{"content":"OS第二次理论作业 1.多道程序的存储管理 空间的分配：分区式分配，将内存分为一些大小相等或不等的分区，每个应用程序占用一个或几个分区，操作系统占用其中一个分区 1.1 固定（静态）式分区分配 当系统初始化时，把存储空间划分为若干个任意大小的区域，然后将这些区域分配给每个用户作业\n将内存划分为若干个固定大小的连续分区 分区大小相等：多个相同程序的并发执行 分区大小不等：多个小分区，适量的中等分区，少量的大分区 优点：易于实现，开销小 缺点：内碎片造成浪费，分区总数固定，限制了并发执行的程序数目 采用的数据结构：分区表——记录分区的大小和使用情况 1.1.1 单一队列分配方式 ​\t需要加载程序时，选择一个当前闲置且容量足够大的分区进行加载，即多个用户程序排在一个共同的队列中等待分区\n1.1.2 多队列分配方式 ​\t防止单一队列造成的小程序占用大分区的情况，采用多个队列，每个分区一个队列，程序按照大小排在相应的队列中，即小分区排队的都是小程序，大分区排队的都是大程序\n1.2 可变（动态）式分区分配 可变式分区：分区的边界可以移动，即分区的大小可变\n优点：没有内碎片 缺点：有外碎片 1.2.0 内碎片与外碎片 内碎片：分配给作业的存储空间中未被利用的部分，如固定分区中存在的碎片 内碎片其实已经被分配出去了，只是没有被利用，在作业完成后会得到释放 外碎片：系统中无法利用的小的空闲分区，如分区与分区之间存在的碎片，动态分区管理会产生外部碎片 消除外部碎片的方法：紧凑技术 1.2.1 位图表示法 给每个分配单元赋予一个字位，用来记录该分配单元是否闲置。字位取值为0表示单元闲置，取值为1表示已被占用 空间成本固定，不依赖于程序中的程序数量 时间成本低，操作简单，直接修改位图值 没有容错能力：无法确定是为1还是因错误变为1 1.2.2 链表表示法 将分配单元按照是否闲置链接起来 空间成本取决于程序的数量 例如空闲链表，将内存中空闲的区域以链表的形式穿起来 时间成本：链表扫描速度较慢，还要进行链表项的插入删除和修改 有一定容错能力，链表有被占空间和闲置空间的表项，可相互验证 1.3 基于顺序搜索的分配算法 First Fit：每个空白区按其在存储空间中地址递增的顺序连载一起，在为作业分配存储区域时，从这个空白区域链的始端开始查找，选择第一个足以满足请求（够大）的空白块 Next Fit：把存储空间中的空白区构成一个循环链，每次为存储请求查找合适的分区时，总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将他划分后分配出去 Best Fit：为一个作业选择分区时，总是寻找其大小最接近于作业所要求的存储区域 Worst Fit：为作业选择存储区域时，总是寻找最大的空白区 2.页式内存管理 从方便管理物理内存的角度考虑\n2.1 程序、进程和作业 程序：程序是静止的，是存放在磁盘上的可执行文件 进程：进程是动态的，进程包括程序的程序处理对象（数据），是系统分配资源的基本单位，分为系统进程和用户进程，进程有生命周期 作业：作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合，一个作业可以有多个进程 2.2 分页式存储管理 把一个逻辑地址连续的程序分散存放到若干不连续的内存区域内，充分利用内存空间，逻辑上相邻的页，物理上不一定相邻\n页：在页式存储管理系统中，把每个作业的地址空间分成一些大小相等的片，称之为页\n存储块（页框）：把主存的存储空间也分成与页面大小相同的片，这些片称为存储块或页框\n地址结构：页号+页内位移\n给定逻辑地址空间中的地址为A，页面的大小为L，则\n页号P=int(A/L) 页内地址偏移D=A mod L 2.3 一级页表 2.4 两级页表 一级页表的问题：若逻辑地址空间很大，则划分的页比较多，页表很大，占用的存储空间很大且要求连续，较难实现\n将页表再进行分页，离散地将各个页表页面存放在不同的物理块中，同时再建立一张外部页表用以记录页表页面对应的物理块号\n在运行过程中，必须把外部页表（页表的页表）调入内存，而动态调入内部页表，只将当前所需的一些内部页表装入内存，其余部分根据需要再陆续调入\n地址：页表页面号+页号+页内地址 2.5 多级页表 多级页表结构中，指令所给出的地址除偏移地址之外的 各部分全是各级页表的页表号或页号，而各级页表中记录的全是物理页号，指向下级页表或真正的被访问页 2.6 TLB ​\tTLB是页表的Cache，用于减少访问内存的次数，缩短时间\n2.7 MMU ​\tCPU中用于进行虚拟地址与物理地址转换的单元，MMU中有TLB，得到VA后首先在TLB中进行查找，找不到再去页表中查找\n3.段式内存管理 从方便用户编程的角度考虑\n一个段可以定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的，每段都有自己的名字，且都是一段连续的地址空间（长度不定）\n地址结构：段号S+位移量W\n关于地址维数\n对于页式管理，一个程序的各页是根据程序空间连续编址的，程序地址空间只有一维 对于段式管理，一个程序依据信息特性拆分为多段，各段之间独立编址，故地址空间有两维 可以更好地满足程序内存动态增长的情况\n4.段页式内存管理 先将用户程序 分成若干个段（段式），并为每一个段赋一个段名，再把 每个段分成若干个页（页式） 5.虚拟存储管理 5.1 交换 附.第二次理论作业 1.动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB 的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均 为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16 位下一节点域信息。这两种方法分别需要多少字节的存储空间？那种方法更好？\n使用位图：为每个单元分配1bit，128MB内存被划分为$\\frac {2^{27}} n$个单元，需要使用$\\frac {2^{27}} n$个bit，即$\\frac {2^{24}} n$个字节\n使用空闲链表：每个节点$32+16+16=64bits=8bytes$，内存中有$\\frac {2^{27}} {2^{17}} = 2^{10}$个空闲分区，故空闲链表需要$2^{13}$个字节\n进行比较：当$n\u0026gt;2048$时，使用位图所占用的内存空间更小，位图法更好，当$n\u0026lt;=2048$时使用空闲链表的方法更好\n**2.在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、 9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、 WorstFit和NextFit将找出哪些空闲区？ **\n空闲区号 1 2 3 4 5 6 7 8 空闲区大小 10KB 4KB 20KB 18KB 7KB 9KB 12KB 15KB 使用First Fit：\n12KB会使用编号为3的大小为20KB的空闲分区 10KB会使用编号为1的大小为10KB的空闲分区 9KB会使用编号为4的大小为18KB的空闲分区 使用Best Fit:\n12KB会使用编号为7的大小为12KB的空闲分区 10KB会使用编号为1的大小为10KB的空闲分区 9KB会使用编号为6的大小为9KB的空闲分区 使用Worst Fit:\n12KB会使用编号为3的大小为20KB的空闲分区 10KB会使用编号为4的大小为18KB的空闲分区 9KB会使用编号为8的大小为15KB的空闲分区 使用Next Fit:\n12KB会使用编号为3的大小为20KB的空闲分区 10KB会使用编号为4的大小为18KB的空闲分区 9KB会使用编号为6的大小为9KB的空闲分区 3.解释逻辑地址、物理地址、地址映射，并举例说明。\n逻辑地址是操作系统的用户编写应用程序时所用的地址，物理地址是内存中实际的地址，地址映射是指逻辑地址向物理地址转换的过程 举例来说，对32位的MIPS体系结构而言，每一个进程都拥有独立的4GB逻辑地址空间，每一个区域的地址空间有其特定的用途，kuseg、kseg0、kseg1和kseg2都有各自的地址映射方式。MIPS体系结构广泛应用于不同硬件条件的嵌入式系统，具体机器的物理内存和物理地址不尽相同，但逻辑地址到物理地址的映射按区域基本确定，有通过MMU转换的区域，也有直接高位清零转换的区域。 4.解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地 址转换过程。\n页式存储管理的目的是高效利用内存，减少内存碎片的产生，并实现大逻辑空间映射小物理空间。使用页式内存管理就需要存储一张页表，用于记录逻辑页向物理页的映射。由于查询页表会增加一次访问内存，影响性能，于是设计了快表(TLB)，即页表的高速缓存(cache)，在查找页面映射时先查找快表，若命中则无需查询页表，若未命中则需要查页表，并将对应的页表项替换到快表中。\n将逻辑地址划分为页号和页内偏移两个部分，只需要找到对应的物理页号再加上页内偏移即可找到物理地址。首先在TLB中查找页号，若命中则将它对应的物理页号加上页内偏移得到物理地址，若TLB未命中，则在内存中查页表，将对应的页表项替换进TLB，再得到物理内存进行访存\n5.叙述缺页中断的处理流程。\n缺页中断：软件试图访问已经映射在虚拟地址空间中，但是还未被加载在内存中的一个分页时发生中断，需要从外存中将该页调入内存\n​\t若此时内存中还有空闲块，则直接将缺页从外存中调入内存，若内存已满，则需要采用页面置换算法淘汰某页再进行调入。\n**6.假设一个机器有38位的虚拟地址和32位的物理地址。 (1) 与一级页表相比，多级页表的主要优点是什么？ (2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中 的第一级和第二级页表域各分配多少位？ **\n多级页表为页表再设置页表，实行动态页表调入，只需要将当前使用的页表项所在的页调入内存，减少了内存中存储页表的空间\n页内偏移地址为14位，则全部页表项所占空间：$2^{24}*4=2^{26}bytes$，将一级页表再划分，可分为$2^{12}$页，则二级页表的页表域为12位，一级页表的页表域为12位。\n7.假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例 如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考： (1) LRU、FIFO和Clock算法的效果如何？ (2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？\n访问的页面符合局部性原理，三种算法产生的缺页中断相同 尽量把工作集装入内存，将0-498页面映射到固定的页框，每次只置换第499个页面 8.一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而 且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见， 假设第0个字是碎片的一部分而最高位的字包含了有效的数据。\n​\t每个字节的读写时间为2.5ns,$128MB=2^{27}B$，对每个字节既要读又要写，需要$22.52^{27}=671ms$\n","permalink":"https://coder0xe.github.io/posts/os%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/","summary":"\u003ch1 id=\"os第二次理论作业\"\u003eOS第二次理论作业\u003c/h1\u003e\n\u003ch2 id=\"1多道程序的存储管理\"\u003e1.多道程序的存储管理\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e空间的分配：分区式分配，将内存分为一些大小相等或不等的分区，每个应用程序占用一个或几个分区，操作系统占用其中一个分区\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"11-固定静态式分区分配\"\u003e1.1 固定（静态）式分区分配\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当系统初始化时，把存储空间划分为若干个任意大小的区域，然后将这些区域分配给每个用户作业\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e将内存划分为若干个固定大小的连续分区\n\u003cul\u003e\n\u003cli\u003e分区大小相等：多个相同程序的并发执行\u003c/li\u003e\n\u003cli\u003e分区大小不等：多个小分区，适量的中等分区，少量的大分区\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e优点：易于实现，开销小\u003c/li\u003e\n\u003cli\u003e缺点：内碎片造成浪费，分区总数固定，限制了并发执行的程序数目\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e采用的数据结构：分区表——记录分区的大小和使用情况\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"111-单一队列分配方式\"\u003e1.1.1 单一队列分配方式\u003c/h4\u003e\n\u003cp\u003e​\t需要加载程序时，选择一个当前闲置且容量足够大的分区进行加载，即多个用户程序排在一个共同的队列中等待分区\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240325162408174\" loading=\"lazy\" src=\"/img/image-20240325162408174.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"112-多队列分配方式\"\u003e1.1.2 多队列分配方式\u003c/h4\u003e\n\u003cp\u003e​\t防止单一队列造成的小程序占用大分区的情况，采用多个队列，每个分区一个队列，程序按照大小排在相应的队列中，即小分区排队的都是小程序，大分区排队的都是大程序\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240325162557585\" loading=\"lazy\" src=\"/img/image-20240325162557585.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"12-可变动态式分区分配\"\u003e1.2 可变（动态）式分区分配\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可变式分区：分区的边界可以移动，即分区的大小可变\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e优点：没有内碎片\u003c/li\u003e\n\u003cli\u003e缺点：有外碎片\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"120-内碎片与外碎片\"\u003e1.2.0 内碎片与外碎片\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e内碎片：分配给作业的存储空间中未被利用的部分，如固定分区中存在的碎片\n\u003cul\u003e\n\u003cli\u003e内碎片其实已经被分配出去了，只是没有被利用，在作业完成后会得到释放\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e外碎片：系统中无法利用的小的空闲分区，如分区与分区之间存在的碎片，动态分区管理会产生外部碎片\n\u003cul\u003e\n\u003cli\u003e消除外部碎片的方法：紧凑技术\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"121-位图表示法\"\u003e1.2.1 位图表示法\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e给每个分配单元赋予一个字位，用来记录该分配单元是否闲置。字位取值为0表示单元闲置，取值为1表示已被占用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240325163550979\" loading=\"lazy\" src=\"/img/image-20240325163550979.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e空间成本固定，不依赖于程序中的程序数量\u003c/li\u003e\n\u003cli\u003e时间成本低，操作简单，直接修改位图值\u003c/li\u003e\n\u003cli\u003e没有容错能力：无法确定是为1还是因错误变为1\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"122-链表表示法\"\u003e1.2.2 链表表示法\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e将分配单元按照是否闲置链接起来\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240325163726416\" loading=\"lazy\" src=\"/img/image-20240325163726416.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e空间成本取决于程序的数量\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e例如空闲链表，将内存中空闲的区域以链表的形式穿起来\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e时间成本：链表扫描速度较慢，还要进行链表项的插入删除和修改\u003c/li\u003e\n\u003cli\u003e有一定容错能力，链表有被占空间和闲置空间的表项，可相互验证\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"13-基于顺序搜索的分配算法\"\u003e1.3 基于顺序搜索的分配算法\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFirst Fit\u003c/strong\u003e：每个空白区按其在存储空间中地址递增的顺序连载一起，\u003cstrong\u003e在为作业分配存储区域时，从这个空白区域链的始端开始查找，选择第一个足以满足请求（够大）的空白块\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNext Fit\u003c/strong\u003e：把存储空间中的空白区构成一个\u003cstrong\u003e循环链\u003c/strong\u003e，每次为存储请求查找合适的分区时，\u003cstrong\u003e总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将他划分后分配出去\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBest Fit\u003c/strong\u003e：为一个作业选择分区时，\u003cstrong\u003e总是寻找其大小最接近于作业所要求的存储区域\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWorst Fit\u003c/strong\u003e：为作业选择存储区域时，\u003cstrong\u003e总是寻找最大的空白区\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2页式内存管理\"\u003e2.页式内存管理\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e从方便管理物理内存的角度考虑\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"21-程序进程和作业\"\u003e2.1 程序、进程和作业\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e程序\u003c/strong\u003e：程序是\u003cstrong\u003e静止\u003c/strong\u003e的，是存放在磁盘上的可执行文件\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e进程\u003c/strong\u003e：进程是动态的，进程包括程序的程序处理对象（数据），是系统分配资源的基本单位，分为系统进程和用户进程，\u003cstrong\u003e进程有生命周期\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e作业\u003c/strong\u003e：作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合，\u003cstrong\u003e一个作业可以有多个进程\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"22-分页式存储管理\"\u003e2.2 分页式存储管理\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e把一个逻辑地址连续的程序分散存放到若干不连续的内存区域内，充分利用内存空间，逻辑上相邻的页，物理上不一定相邻\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e页\u003c/strong\u003e：在页式存储管理系统中，\u003cstrong\u003e把每个作业的地址空间分成一些大小相等的片\u003c/strong\u003e，称之为页\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e存储块（页框）\u003c/strong\u003e：\u003cstrong\u003e把主存的存储空间也分成与页面大小相同的片，这些片称为存储块或页框\u003c/strong\u003e\u003c/p\u003e","title":"OS第二次理论作业"},{"content":"OS : lab1 实验报告 Thinking 1.1 **尝试分别使用实验环境中的原生x86工具链(gcc、ld、readelf、objdump 等)和 MIPS 交叉编译工具链（带有 mips-linux-gnu 前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数 的含义。 **\nobjdump传入参数的含义\n参数 含义 -d 将代码段反汇编 反汇编那些应该还有指令机器码的section -D 与 -d 类似，但反汇编所有section -S 将代码段反汇编的同时，将反汇编代码和源代码交替显示，源码编译时需要加-g参数，即需要调试信息 -C 将C++符号名逆向解析 -l 反汇编代码中插入源代码的文件名和行号 -j section: 仅反编译所指定的section，可以有多个-j参数来选择多个section objdump-DS 要反汇编的目标文件名 \u0026gt; 导出文本文件名\n-DS表示反汇编并将反汇编代码和源代码交替显示\n使用原生x86工具链进行编译并查看反汇编\ngit@22373362:~/compile $ gcc -c hello.c -o hello.o git@22373362:~/compile $ objdump -DS hello.o \u0026gt; x86_log 如下图（部分）\n使用MIPS交叉编译工具链进行编译\ngit@22373362:~/compile $ mips-linux-gnu-gcc -c hello.c -o mips_hello.o git@22373362:~/compile $ mips-linux-gnu-objdump -DS mips_hello.o \u0026gt; mips_log Thinking1.2 **尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。 **\n解析结果如下图\n也许你会发现我们编写的readelf程序是不能解析readelf文件本身的，而我们刚才介绍的系统工具readelf则可以解析，这是为什么呢？(提示：尝试使用readelf-h，并阅读tools/readelf目录下的Makefile，观察readelf与hello的不同）\nhello\nreadelf\n通过观察两个可执行文件的ELF头可以发现，hello可执行文件为ELF32类型，而readelf为ELF64类型，而我们编写的readelf.c文件只支持解析ELF32格式的文件，只使用了ELF32类型的结构体\nMakefile\n%.o: %.c $(CC) -c $\u0026lt; .PHONY: clean readelf: main.o readelf.o $(CC) $^ -o $@ hello: hello.c $(CC) $^ -o $@ -m32 -static -g clean: rm -f *.o readelf hello 可以观察到hello在编译过程中传入了-m32参数，编译出32位的可执行文件 readelf默认编译为64位的可执行文件 Thinking 1.3 在理论课上我们了解到，MIPS体系结构上电时，启动入口地址为0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照 内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行）。\n因为我们在kernel.lds中设置好了各个节被加载的位置，即最终的segment地址，同时使用了ENTRY(_start)指定了程序入口（即内核入口），最终保证了内核入口能够被正确跳转\n实验难点分析 ​\t本次实验的主要难点在于实现readelf.c来解析ELF文件中的段信息以及printk函数的实现\nreadelf ​\tExercise1.1中，要求我们完成一个解析ELF文件的C代码文件readelf.c，更准确的说是要求我们完成对节头表的遍历，思路上不困难，即先根据首地址和节头表的偏移量计算出节头表中第一项的位置，之后遍历后边表项即可，真正让人头疼的是一些C语言指针问题，先给出源代码。\nint readelf(const void *binary, size_t size) { Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary; if (!is_elf_format(binary, size)) { fputs(\u0026#34;not an elf file\\n\u0026#34;, stderr); return -1; } const void *sh_table; Elf32_Half sh_entry_count; Elf32_Half sh_entry_size; sh_table = (const void*)ehdr + ehdr-\u0026gt;e_shoff; sh_entry_count = ehdr-\u0026gt;e_shnum; sh_entry_size = ehdr-\u0026gt;e_shentsize; for (int i = 0; i \u0026lt; sh_entry_count; i++) { const Elf32_Shdr *shdr; unsigned int addr; /* Exercise 1.1: Your code here. (2/2) */ shdr = (const Elf32_Shdr*)sh_table + i; addr = shdr-\u0026gt;sh_addr; printf(\u0026#34;%d:0x%x\\n\u0026#34;, i, addr); } return 0; } 关于结构体指针：结构体指针引用其中变量使用箭头表示\nsh_entry_count = ehdr-\u0026gt;e_shnum 关于指针的加减运算：指针加减运算移动的字节数为指针所指向的元素类型的字节数乘上偏移量，即 $$ Type * p\\space + \\space off \\space : \\space sizeof(Type)*off \\space bytes $$\n关于指针的类型转换，在此题中出现的是有类型和无类型之间的转换，都用到了强制类型转换\nsh_table = (const void*)ehdr + ehdr-\u0026gt;e_shoff; shdr = (const Elf32_Shdr*)sh_table + i; 我们注意到这两处都涉及到指针的运算，若不对指针类型进行转换则移动字节会以原来类型进行移动\n关于GNU中对于void*元素类型的规定，我们注意到\nsh_table = (const void*)ehdr + ehdr-\u0026gt;e_shoff; 那么void*所指代的元素类型占多大字节？在GNU中规定占一个字节\nprintk printk是内核用于输出调试信息的接口，这些调试信息可以帮助我们获取系统或程序中的一些关键信息，在系统出现问题后也能第一时间将错误信息记录下来，以帮助开发人员定位问题原因。例如我们的MOS系统中init.c文件中输出\nprintk(\u0026#34;init.c:\\tmips_init() is called\\n\u0026#34;); ​\t用来表示内核初始化已经启动。\n​\t在kern/printk.c中，我们可以看到printk.c的定义为\nvoid printk(const char *fmt, ...) { va_list ap; va_start(ap, fmt); vprintfmt(outputk, NULL, fmt, ap); va_end(ap); } ​\t注意到在参数列表中用省略号省略掉一些参数，这就是不定长参数。（注：可以参考printf的理解，前面是格式化字符串，后面跟随变量，当然后边变量的种类以及个数是根据格式化字符串确定的，后面的参数列表也就是不定长参数）我们首先介绍不定长参数。\n不定长参数 ​\t对于不定长参数，我们使用不定长参数表存储。在stdarg.h中，定义了一组宏和变量如下\nva_list：变长参数表的变量类型\nva_start(va_list ap, lastarg) ：用于初始化变长参数表的宏，其中lastarg代表最后一个形参\nva_arg(va_list ap, 类型)：用于取变长参数表下一个参数的宏，例如我们要获取边长参数表下一个int类型的参数\nva_list ap; int num = va_arg(ap,int); va_end(va_list ap) : 结束使用变长参数表的宏\n​\t总的来说我们对于变长参数表的处理是：可以把他看做一个不限制元素类型的数组，其中存放着各个参数，当我们需要使用时，就不断从中拿出来\nvprintfmt 函数定义分析 ​\tvprintfmt是练习中要求我们主要完成的代码部分，它实现了格式化输出字符串，我们在printk.c中实际上是通过vprintfmt实现了打印功能。观察printk.c中传递给vprintfmt的参数\nvprintfmt(outputk, NULL, fmt, ap); 对应vprintfmt的定义参数\nvoid vprintfmt(fmt_callback_t out, void *data, const char *fmt, va_list ap) 其中第一个参数outputk是一个函数指针，它对应着printk.c中的函数outputk\nvoid outputk(void *data, const char *buf, size_t len) { for (int i = 0; i \u0026lt; len; i++) { printcharc(buf[i]); } } ​\toutputk即为一个字符串输出函数，虽然参数列表中有三个形参，但是我们实际上只用到了两个（第三个多余的void *data我们目前对他传递了NULL，是一个预留的形参），即指向字符串首地址的指针const char *buf以及字符串的长度size_t len。我们在vprintfmt中对该函数进行调用，故传入它的函数指针。\n解析思路分析 ​\tvprintfmt中主要是实现了对于格式化输出，思路就是对于格式化字符串进行解析，再从边长参数列表中一个个拿出对应的实参进行格式化输出，更进一步的，就是对%后面的格式控制符进行解析并对应格式输出，对于其他部分调用out函数指针原样输出\n实验体会与感想 ​\tLab1主要让我们学习操作系统启动的基本流程、掌握ELF文件的结构和功能，以及最终完成一个printk函数的书写。在完成实验的过程中，我逐步学习到有关操作系统的启动和ELF文件的有关知识，其中在printk函数的编写过程中我复习了C语言中有关指针的知识，并知道了在GNU标准中void*所指向的元素类型所占大小为一个字节。在完成实验之后，通过对make run中不断输出的现象进探究，我了解到在QEMU环境中，在bootloader阶段会由QEMU辅助进行$ra等寄存器的赋初值行为，同时学习到简单的gdb调试汇编代码方法。\n","permalink":"https://coder0xe.github.io/posts/os-lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","summary":"\u003ch1 id=\"os--lab1-实验报告\"\u003eOS : lab1 实验报告\u003c/h1\u003e\n\u003ch2 id=\"thinking-11\"\u003eThinking 1.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e**尝试分别使用实验环境中的原生x86工具链(gcc、ld、readelf、objdump 等)和 MIPS 交叉编译工具链（带有 mips-linux-gnu 前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数 的含义。 **\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eobjdump传入参数的含义\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e参数\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e含义\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-d\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e将代码段反汇编 反汇编那些应该还有指令机器码的section\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-D\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e与 -d 类似，但反汇编所有section\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-S\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e将代码段反汇编的同时，将反汇编代码和源代码交替显示，源码编译时需要加-g参数，即需要调试信息\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-C\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e将C++符号名逆向解析\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-l\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e反汇编代码中插入源代码的文件名和行号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e-j\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003esection: 仅反编译所指定的section，可以有多个-j参数来选择多个section\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eobjdump-DS 要反汇编的目标文件名 \u0026gt; 导出文本文件名\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e-DS表示反汇编并将反汇编代码和源代码交替显示\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用原生x86工具链进行编译并查看反汇编\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egit@22373362:~/compile $ gcc -c hello.c -o hello.o\ngit@22373362:~/compile $ objdump -DS hello.o \u0026gt; x86_log\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如下图（部分）\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240325205255571\" loading=\"lazy\" src=\"/img/image-20240325205255571.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e使用MIPS交叉编译工具链进行编译\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egit@22373362:~/compile $ mips-linux-gnu-gcc -c hello.c -o mips_hello.o\ngit@22373362:~/compile $ mips-linux-gnu-objdump -DS mips_hello.o \u0026gt; mips_log\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"image-20240325205459358\" loading=\"lazy\" src=\"/img/image-20240325205459358.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking12\"\u003eThinking1.2\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e**尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。 **\u003c/p\u003e","title":"OS:lab1实验报告"},{"content":"OS ：lab1课下基础 1. 操作系统的启动 : boot 1.1 概述 ​\t将硬件初始化的相关工作称为bootloader程序，将bootloader程序放在非易失存储器中(ROM/FLASH)，将操作系统内核放在磁盘中。\n将硬件初始化相关工作从操作系统中抽离出来放在bootloader中实现。实现了硬件启动和软件启动的分离。即由bootloader实现硬件启动，操作系统内核实现软件启动，这样负责硬件启动的指令不多，需要的存储空间不大，可以存在容量较小的ROM或FLASH中 bootloader在硬件初始化之后，需要为软件启动（操作系统内核的功能）做准备，将内核镜像从存放他的存储器（例如磁盘）中读到RAM中。bootloader需要将内核镜像加载到内存中，就可以选择用哪一个内核镜像进行加载，实现多重开机的功能，在一个硬件上选择运行不同的操作系统。 bootloader划分了硬件启动和软件启动的边界，bootloader主要负责硬件启动相关工作，操作系统内核专注于软件启动以及对用户提供服务的工作。简化操作系统的开发和移植。 1.2 bootloader ​\tbootloader需要正确地找到内核并加载执行。bootloader的实现依赖于CPU的体系结构，分为stage1，stage2两个部分。\n1.3 QEMU中操作系统的启动 ​\tQEMU已经提供了bootloader的引导功能，支持加载ELF格式的内核。启动流程被简化为加载内核到内存，之后跳转到内核的入口。\n2. ELF 2.1 编译链接 ​\t我们知道源代码文件需要经过编译链接两个阶段才能变成可执行文件来运行。\n编译-c：源代码被翻译为二进制指令，得到目标文件\n链接：将多个目标文件链接为可执行文件\n将编译好的目标文件反汇编：objdump指令\nobjdump -DS \u0026lt;要反汇编的目标文件名\u0026gt; \u0026gt; \u0026lt;导出文本文件名\u0026gt; ​\t以简单的代码为示例\n#include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello,world!\\n\u0026#34;); return 0; } ​\t这里我们知道，头文件中只包含函数的声明，而不包括函数的定义，因此在预处理阶段（替换头文件、宏定义过程）只会将printf替换为他的声明。最后在链接阶段才会替换为printf的实现。即在编译的最后，链接器将所有的目标文件链接在一起，将 之前未填写的地址等信息填上，形成最终的可执行文件，这就是链接的过程\n2.2 ELF ​\tELF是一种文件格式，即Executable and Linkable Format。ELF是Unix系统中一种常见的文件格式，包括可重定位文件(relocatable)，可执行文件(executable)，共享对象文件(shared object)。其中可重定位文件即为我们熟悉的.o文件，后两种文件都需要对.o文件进行链接才能产生。\n2.2.1 段和节 段：segment 节：section ELF 官方文档中对于section segment的解释\n所谓section与segment是同一数据的两种视图\n左侧是链接视图：使用section进行链接\n右侧是执行视图：使用segment运行\n每个segment中包含一个或多个section\n节头表(Section header table)：包含程序中各个节(section)的信息，在程序编译链接时使用\n段头表(Program header table)：包含程序中各个段(segment)的信息，在运行时使用\n编译-\u0026gt;链接-\u0026gt;运行\n编译：源代码-\u0026gt;可执行代码（机器码，目标文件或可执行文件中就是机器码）\n链接：链接器将性质相同的sections归类合并为一个segment，例如.text,.data,.bss等都是典型的需要加载的section，就会被安排到LOAD segment\n.text是指可执行代码，也就是机器码，编译时确定（C、汇编等等语言经过编译都转化为机器码） .data存放在编译时就能确定的数据（而非运行时），如已初始化的全局变量和静态变量 .bss保存未初始化的全局变量和静态变量 运行：使用各个segement进行运行\n​\t从编译-\u0026gt;链接-\u0026gt;运行的角度看section和segment，以简单的hello world程序为例\n使用-c选项进行编译\n通过readelf -S \u0026lt;filename\u0026gt;对产生的可重定向文件(.o)进行查看，可以发现程序经过编译之后已经被划分为了不同的段，其中有我们熟知的.text，.data等，这就是编译产生的不同类别的section。.text中的内容为可执行代码，即机器码。.data中的内容为在编译阶段中就可以确定的变量值，例如全局变量等。\n通过上面的实验已经知道，对源代码文件的编译会将源代码划分为不同的section，那么在链接的过程中就会对不同源代码编译后产生的相同类别的section进行合并，例如将不同代码中的text段合并为一个text段。\nsegment中有几种分区，分别存放不同种类的section。常见的有NOTE segment和LOAD segment。NOTE segment中存放了调试的一些信息，例如dwarf或者gnu_version、gnu_hash等，我们常见的.data,.text会被存放在LOAD segment中。下面是对前程序进行链接后的结果，同样使用readelf查看section信息(其中.note前缀等即为NOTE segment区域)\nps:后续在课件中找到的图\n2.2.1 ELF结构 主要结构有ELF头，段头表，节头表等，我们可以结合课程组给出的elf.h来理解各个部分的主要结构。\nELF header(Ehdr) ：ELF文件头\ntypedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type;\t/* Object file type */ Elf32_Half e_machine;\t/* Architecture */ Elf32_Word e_version;\t/* Object file version */ Elf32_Addr e_entry;\t/* Entry point virtual address */ Elf32_Off e_phoff;\t/* Program header table file offset */ Elf32_Off e_shoff;\t/* Section header table file offset */ Elf32_Word e_flags;\t/* Processor-specific flags */ Elf32_Half e_ehsize;\t/* ELF header size in bytes */ Elf32_Half e_phentsize;\t/* Program header table entry size */ Elf32_Half e_phnum;\t/* Program header table entry count */ Elf32_Half e_shentsize;\t/* Section header table entry size */ Elf32_Half e_shnum;\t/* Section header table entry count */ Elf32_Half e_shstrndx;\t/* Section header string table index */ } Elf32_Ehdr; 对于ELF文件头的定义是一个结构体，名为Elf32_Ehdr。我们只关注结构体中比较重要的几个变量\nElf32_Off e_phoff ：段头表相对文件的偏移量 Elf32_Off e_shoff : 节头表相对文件的偏移量 我们依据以上两个变量可以找到段头表或节头表第一项的位置，再向下遍历即可得到表中的每一项 Elf32_Half e_phentsize : entry size 即段头表中每一项（每一个段头program header : phdr，描述相应段的信息）的大小 Elf32_Half e_phnum : 段头表中表项的个数 Elf32_Half e_shentsize : 节头表中每一项（每一个节头 section header : shdr，描述相应节的信息）的大小 Elf32_Half e_shnum : 节头表中表项的个数 program header (phdr) : 段头\ntypedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; 每一个段头是段头表中的一项(entry)，他描述了一段的信息\nsection header (shdr) : 节头\ntypedef struct { Elf32_Word sh_name;\t/* Section name */ Elf32_Word sh_type;\t/* Section type */ Elf32_Word sh_flags;\t/* Section flags */ Elf32_Addr sh_addr;\t/* Section addr */ Elf32_Off sh_offset;\t/* Section offset */ Elf32_Word sh_size;\t/* Section size */ Elf32_Word sh_link;\t/* Section link */ Elf32_Word sh_info;\t/* Section extra info */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize;\t/* Section entry size */ } Elf32_Shdr; 每一个节头是节头表中的一项，他描述了一节的信息\n2.2.3 Exercise 1.1 中的一些问题 ​\tExercise1.1中，要求我们完成一个解析ELF文件的C代码文件readelf.c，更准确的说是要求我们完成对节头表的遍历，思路上不困难，即先根据首地址和节头表的偏移量计算出节头表中第一项的位置，之后遍历后边表项即可，真正让人头疼的是一些C语言指针问题，先给出源代码。\nint readelf(const void *binary, size_t size) { Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary; if (!is_elf_format(binary, size)) { fputs(\u0026#34;not an elf file\\n\u0026#34;, stderr); return -1; } const void *sh_table; Elf32_Half sh_entry_count; Elf32_Half sh_entry_size; sh_table = (const void*)ehdr + ehdr-\u0026gt;e_shoff; sh_entry_count = ehdr-\u0026gt;e_shnum; sh_entry_size = ehdr-\u0026gt;e_shentsize; for (int i = 0; i \u0026lt; sh_entry_count; i++) { const Elf32_Shdr *shdr; unsigned int addr; /* Exercise 1.1: Your code here. (2/2) */ shdr = (const Elf32_Shdr*)sh_table + i; addr = shdr-\u0026gt;sh_addr; printf(\u0026#34;%d:0x%x\\n\u0026#34;, i, addr); } return 0; } 关于结构体指针：结构体指针引用其中变量使用箭头表示\nsh_entry_count = ehdr-\u0026gt;e_shnum 关于指针的加减运算：指针加减运算移动的字节数为指针所指向的元素类型的字节数乘上偏移量，即 $$ Type * p\\space + \\space off \\space : \\space sizeof(Type)*off \\space bytes $$\n关于指针的类型转换，在此题中出现的是有类型和无类型之间的转换，都用到了强制类型转换\nsh_table = (const void*)ehdr + ehdr-\u0026gt;e_shoff; shdr = (const Elf32_Shdr*)sh_table + i; 我们注意到这两处都涉及到指针的运算，若不对指针类型进行转换则移动字节会以原来类型进行移动\n关于GNU中对于void*元素类型的规定，我们注意到\nsh_table = (const void*)ehdr + ehdr-\u0026gt;e_shoff; 那么void*所指代的元素类型占多大字节？在GNU中规定占一个字节\n可以使用系统自带的readelf命令进行验证\nreadelf -S \u0026lt;file\u0026gt; 查看节信息\nreadelf -l \u0026lt;file\u0026gt; 查看段信息\nOffset代表该段数据相对于ELF文件的偏移 VirtAddr代表该段数据最终被加载到内存的位置 FileSiz代表该段数据在文件中所占的大小 MemSiz代表该段数据在内存中所占的大小 注：MemSiz \u0026gt;= FileSiz C语言中未初始化的全局变量，我们需要为其分配内存，但它 又不需要被初始化成特定数据。因此，在可执行文件中也只记录它需要占用内存(MemSiz)， 但在文件中却没有相应的数据（因为它并不需要初始化成特定数据）。故而在这种情况下， MemSiz会大于FileSiz。这也解释了，为什么C语言中全局变量会有默认值0。这是因为 操作系统在加载时将所有未初始化的全局变量所占的内存统一填了0\n3. MIPS内存布局 3.1 MIPS-32内存 程序中使用的地址被称为虚拟地址、程序地址或逻辑地址，处理器发往总线的地址为物理地址，需要通过CPU中的MMU单元进行转换(Memory Management Unit)，全部虚拟地址构成了虚拟地址空间，本实验中32位MIPS操作系统的虚拟地址空间大小为4GB\nMIPS体系结构中，4GB虚拟地址空间被划分为四个部分\nkuseg：用户态下唯一可用的地址空间（内核态下也可使用这段地址空间）。需要通过 MMU中的 TLB 进行虚拟地址到物理地址的变换。对这段 地址的==存取都会通过cache==。\nkseg0：内核态下可用的地址，MMU将地址的最高位清零（\u0026amp;7fffffff）就得到物理地址用于访存，这段虚拟地址被连续的映射到物理地址的低512MB，对这段地址的==存取都会通过cache==，我们将操作系统内核放在kseg0区域，例如.text,.data,.bss段。\n注：该段地址范围为0x80000000-0x9fffffff,有一个疑问是如果只对最高位清0，剩下31位地址空间比512MB大，但是我们观察最高三位数据，100 \u0026amp; 011 ~ 100 \u0026amp; 011 实际上经过运算已经保证了这段地址范围内高三位都是0。\nkseg1：内核态下可用的地址，MMU将地址的高三位清零（\u0026amp;1fffffff）就得到物理地址用于访存，这段虚拟地址被连续的映射到物理地址的低512MB，但是对这段地址的==存取不通过 cache==，往往在这段地址上使用MMIO（Memory-Mapped I/O）技术来访问外设。\nkseg2：：这段地址只能在内核态下使用并且需要 MMU 中 TLB 将虚拟地址转换为物理地址。对这段地址的==存取都会通过cache==。\n3.2 Linker Script ​\t在链接阶段引入Linker Script，Linker Script中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置，这样就可以把我们的内核代码加载到正确的位置上。\n​\t上图即为操作系统实验中定义的kseg0内存划分，lab1练习题中只需简单的将.text段放在Kernel Text区域，将.data和.bss段放在.text后面即可。\n/* * Set the architecture to mips. */ OUTPUT_ARCH(mips) /* * Set the ENTRY point of the program to _start. */ ENTRY(_start) SECTIONS { . = 0x80020000; //kernel text起始地址 .text : {*(.text)} .data : {*(.data)} bss_start = .; .bss : {*(.bss)} bss_end = .; . = 0x80400000; //KSTACKTOP end = . ; } 解释：\n.为定位计数器，根据输出节的大小增长，SECTIONS命令开始时值为0，通过设置.的值即可设置接下来节的起始地址，例如上例中为.text段设置起始地址为Kernel Text的起始地址。\n.text : {*(.text)}表示将输入文件中所有.text节放到输出的.text节（这就是链接过程中section的合并）\n这样我们就可以大概理解内核的装载过程，Linker Script设置了各个section在内存(kseg0)中的内存位置，并将各个源代码编译后产生的可执行文件中的同类section合并为一个section后放进内存\n4.构建MOS内核 4.1 顶层Makefile ​\t展示部分代码\ninclude include.mk ... modules := lib init kern all: $(targets) $(target_dir): mkdir -p $@ tools: CC=\u0026#34;$(HOST_CC)\u0026#34; CFLAGS=\u0026#34;$(HOST_CFLAGS)\u0026#34; $(MAKE) --directory=$@ $(modules): tools $(MAKE) --directory=$@ $(mos_elf): $(modules) $(target_dir) $(LD) $(LDFLAGS) -o $(mos_elf) -N -T $(link_script) $(objects) 可以看到构建MOS系统的最后一步为链接指令\n$(LD) $(LDFLAGS) -o $(mos_elf) -N -T $(link_script) $(objects) **其中-T选项表示读取Linker Script脚本，**即为我们在上一节中完成的脚本。\n$@展开为当前目标名称，进入目标目录并调用make\n$(modules): tools $(MAKE) --directory=$@ 4.2 _start函数 ​\t_start是内核的入口\n#include \u0026lt;asm/asm.h\u0026gt; #include \u0026lt;mmu.h\u0026gt; .text EXPORT(_start) .set at .set reorder /* Lab 1 Key Code \u0026#34;enter-kernel\u0026#34; */ /* clear .bss segment */ la v0, bss_start la v1, bss_end clear_bss_loop: beq v0, v1, clear_bss_done sb zero, 0(v0) addiu v0, v0, 1 j clear_bss_loop /* End of Key Code \u0026#34;enter-kernel\u0026#34; */ clear_bss_done: /* disable interrupts */ mtc0 zero, CP0_STATUS /* set up the kernel stack */ li\tsp, 0x80400000 /* jump to mips_init */ j\tmips_init 注：栈空间为向下生长，需要将sp指针设置在内核栈空间的栈顶 mips_init函数在init.c文件中，在汇编程序中通过j/jal实现跳转到函数符号对应的地址，在链接时链接器会对代码中的符号进行重定位，实现跨文件的函数调用 4.3 printk ​\tprintk是内核用于输出调试信息的接口，这些调试信息可以帮助我们获取系统或程序中的一些关键信息，在系统出现问题后也能第一时间将错误信息记录下来，以帮助开发人员定位问题原因。例如我们的MOS系统中init.c文件中输出\nprintk(\u0026#34;init.c:\\tmips_init() is called\\n\u0026#34;); ​\t用来表示内核初始化已经启动。\n​\t在kern/printk.c中，我们可以看到printk.c的定义为\nvoid printk(const char *fmt, ...) { va_list ap; va_start(ap, fmt); vprintfmt(outputk, NULL, fmt, ap); va_end(ap); } ​\t注意到在参数列表中用省略号省略掉一些参数，这就是不定长参数。（注：可以参考printf的理解，前面是格式化字符串，后面跟随变量，当然后边变量的种类以及个数是根据格式化字符串确定的，后面的参数列表也就是不定长参数）我们首先介绍不定长参数。\n4.3.1 不定长参数 ​\t对于不定长参数，我们使用不定长参数表存储。在stdarg.h中，定义了一组宏和变量如下\nva_list：变长参数表的变量类型\nva_start(va_list ap, lastarg) ：用于初始化变长参数表的宏，其中lastarg代表最后一个形参\nva_arg(va_list ap, 类型)：用于取变长参数表下一个参数的宏，例如我们要获取边长参数表下一个int类型的参数\nva_list ap; int num = va_arg(ap,int); va_end(va_list ap) : 结束使用变长参数表的宏\n​\t总的来说我们对于变长参数表的处理是：可以把他看做一个不限制元素类型的数组，其中存放着各个参数，当我们需要使用时，就不断从中拿出来\n4.3.2 vprintfmt 4.3.2.1 函数定义分析 ​\tvprintfmt是练习中要求我们主要完成的代码部分，它实现了格式化输出字符串，我们在printk.c中实际上是通过vprintfmt实现了打印功能。观察printk.c中传递给vprintfmt的参数\nvprintfmt(outputk, NULL, fmt, ap); 对应vprintfmt的定义参数\nvoid vprintfmt(fmt_callback_t out, void *data, const char *fmt, va_list ap) 其中第一个参数outputk是一个函数指针，它对应着printk.c中的函数outputk\nvoid outputk(void *data, const char *buf, size_t len) { for (int i = 0; i \u0026lt; len; i++) { printcharc(buf[i]); } } ​\toutputk即为一个字符串输出函数，虽然参数列表中有三个形参，但是我们实际上只用到了两个（第三个多余的void *data我们目前对他传递了NULL，是一个预留的形参），即指向字符串首地址的指针const char *buf以及字符串的长度size_t len。我们在vprintfmt中对该函数进行调用，故传入它的函数指针。\n4.3.3.3 解析思路分析 ​\tvprintfmt中主要是实现了对于格式化输出，思路就是对于格式化字符串进行解析，再从边长参数列表中一个个拿出对应的实参进行格式化输出，更进一步的，就是对%后面的格式控制符进行解析并对应格式输出，对于其他部分调用out函数指针原样输出\n​\t对于fmt的字符串格式\n​\t对格式字符串中各项进行解释\nflag\nwidth\nlength\nspecifier\n​\t当我们读到%后对后面字符串进行解析即可\nvoid vprintfmt(fmt_callback_t out, void *data, const char *fmt, va_list ap) { char c; const char *s; long num; int width; int long_flag; // output is long (rather than int) int neg_flag; // output is negative int ladjust; // output is left-aligned char padc; // padding char for (;;) { /* scan for the next \u0026#39;%\u0026#39; */ /* Exercise 1.4: Your code here. (1/8) */ s = fmt; while(*s != \u0026#39;%\u0026#39; \u0026amp;\u0026amp; *s != \u0026#39;\\0\u0026#39;) { s++; } /* flush the string found so far 输出%之前的字符串*/ /* Exercise 1.4: Your code here. (2/8) */ out(data,fmt,s-fmt); fmt = s; /* check \u0026#34;are we hitting the end?\u0026#34; */ /* Exercise 1.4: Your code here. (3/8) */ if (*fmt == \u0026#39;\\0\u0026#39;) { break; } /* we found a \u0026#39;%\u0026#39; */ /* Exercise 1.4: Your code here. (4/8) */ fmt++; /* check format flag 左对齐 右对齐 、填充字符*/ /* Exercise 1.4: Your code here. (5/8) */ if (*fmt == \u0026#39;-\u0026#39;) { ladjust = 1; fmt++; } else { ladjust = 0; } if (*fmt == \u0026#39;0\u0026#39;) { padc = \u0026#39;0\u0026#39;; fmt++; } else { padc = \u0026#39; \u0026#39;; } /* get width 输出宽度*/ /* Exercise 1.4: Your code here. (6/8) */ width = 0; while (*fmt \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; *fmt \u0026lt;= \u0026#39;9\u0026#39;) { width = width * 10 + (*fmt - \u0026#39;0\u0026#39;); fmt++; } /* check for long 这里标记长整数只有l*/ /* Exercise 1.4: Your code here. (7/8) */ if (*fmt == \u0026#39;l\u0026#39;) { long_flag = 1; fmt++; } else { long_flag = 0; } neg_flag = 0; switch (*fmt) { case \u0026#39;b\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 2, 0, width, ladjust, padc, 0); break; case \u0026#39;d\u0026#39;: case \u0026#39;D\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } /* * Refer to other parts (case \u0026#39;b\u0026#39;, case \u0026#39;o\u0026#39;, etc.) and func \u0026#39;print_num\u0026#39; to * complete this part. Think the differences between case \u0026#39;d\u0026#39; and the * others. (hint: \u0026#39;neg_flag\u0026#39;). */ /* Exercise 1.4: Your code here. (8/8) */ if (num \u0026lt; 0) { neg_flag = 1; num = -num; } else { neg_flag = 0; } print_num(out, data, num, 10, neg_flag,width, ladjust, padc, 0); break; case \u0026#39;o\u0026#39;: case \u0026#39;O\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 8, 0, width, ladjust, padc, 0); break; case \u0026#39;u\u0026#39;: case \u0026#39;U\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 10, 0, width, ladjust, padc, 0); break; case \u0026#39;x\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 16, 0, width, ladjust, padc, 0); break; case \u0026#39;X\u0026#39;: if (long_flag) { num = va_arg(ap, long int); } else { num = va_arg(ap, int); } print_num(out, data, num, 16, 0, width, ladjust, padc, 1); break; case \u0026#39;c\u0026#39;: c = (char)va_arg(ap, int); print_char(out, data, c, width, ladjust); break; case \u0026#39;s\u0026#39;: s = (char *)va_arg(ap, char *); print_str(out, data, s, width, ladjust); break; case \u0026#39;\\0\u0026#39;: fmt--; break; default: /* output this char as it is */ out(data, fmt, 1); } fmt++; } } ps:关于bootloader以及QEMU的一些思考 0.问题发现 在完成lab1课下代码后，我尝试进行make run，发现不断输出init.c: mips_init() is called，如下图 ​ 我认为是代码出现了问题，果断求助助教。在助教的帮助下，我逐渐理解了这个问题。\n1.分析代码 通过阅读代码，我们知道，输出这个字符串是start.S调用init.c中函数mips_init得到，由于不方便展示源码，这里只指出我是通过j指令完成了跳转，强调这一点是有必要的，如果使用jal进行跳转就不会出现这种状况，jal指令会改变$ra寄存器的值，与后边的论述矛盾。 通过对我们make的内核mos进行gdb调试，发现在程序执行完mips_init()之后总是跳回到start.S的第一行代码，如下图。 ​ 通过上学期的计组知识，我们知道，从被调用者跳回到调用者是通过指令jr $ra实现的，这一点我们可以在gdb中展示汇编代码得到验证(gdb模式下直接输入disassemble)，如下图。 ​ 这样问题就转化为$ra的值是什么？通过指令i registers可以查看各个寄存器的值。我们得到$ra寄存器的值如下图 ​ 同时我们可以发现，start.S中第一条代码的地址即为此地址。 ​ 但是在我们的代码中并没有存在对$ra赋值的操作，也就是说问题转化为$ra初值是如何得到的？\n2.bootloader 通过以上的分析，我们知道在内核相关代码中，我们并没有对$ra的值有写操作，此时将目光放在启动内核之前的硬件初始化阶段，即bootloader。直接make dbg进入调试，我们会发现输出如下 ​ 这里的0xbfc00000即为bootloader的地址，gdb并不支持显示调试信息，此时我们可以使用汇编级调试，通过运行\nset disassemble-nextline-on 进入汇编调试模式，之后ni单步调试，我们发现在bootloader中进行了对寄存器的赋初值操作，这里只展示我们关心的对于$ra寄存器的赋值操作，如下图 ​ 以上两条指令即为对$ra寄存器的赋值操作，更加值得注意的是下面两条汇编代码 ​ 我们发现在完成硬件相关初始化之后，跳转到了内核入口，在实践中印证了指导书中的内容 ​ 现在我们已经知道了$ra寄存器是在bootloader中进行赋初值，但是，bootloader是如何知道内核入口(kernel_entry)在哪里呢，即bootloader是如何知道要给$ra赋这个地址的?这与我们的实验环境QEMU有关。\n3.QEMU 我们知道，实验中我们使用了QEMU自带的bootloader，实际上，qemu也处理了一部分软件流程，对bootloader进行了简化，这在init.c的注释部分给出了提示。 ​ 直接去盒一下github上的源码！ ​ 在源码中我们找到了对$ra赋值操作，进一步的，查找kernel_entry是如何得来的？进一步查阅源码，可以发现 ​ 同时源码中给出了关于load_kernel()函数的定义，这里不再关心，我们可以得到结论：对$ra寄存器的赋值是在bootloader阶段由QEMU辅助完成的！\n4. 总结 此篇讨论帖讨论了关于$ra寄存器初值的问题以及bootloader和QEMU的一些思考，如有错误敬请指正，这里特别感谢助教的指引和帮助！\n","permalink":"https://coder0xe.github.io/posts/os-lab1%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"os-lab1课下基础\"\u003eOS ：lab1课下基础\u003c/h1\u003e\n\u003ch2 id=\"1-操作系统的启动--boot\"\u003e1. 操作系统的启动 : boot\u003c/h2\u003e\n\u003ch3 id=\"11-概述\"\u003e1.1 概述\u003c/h3\u003e\n\u003cp\u003e​\t\u003cstrong\u003e将硬件初始化的相关工作称为bootloader程序\u003c/strong\u003e，将\u003ccode\u003ebootloader\u003c/code\u003e程序放在非易失存储器中(ROM/FLASH)，将操作系统内核放在磁盘中。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将硬件初始化相关工作从操作系统中抽离出来放在bootloader中实现。实现了硬件启动和软件启动的分离。\u003cstrong\u003e即由bootloader实现硬件启动，操作系统内核实现软件启动\u003c/strong\u003e，这样负责硬件启动的指令不多，需要的存储空间不大，可以存在容量较小的ROM或FLASH中\u003c/li\u003e\n\u003cli\u003ebootloader在硬件初始化之后，需要为软件启动（操作系统内核的功能）做准备，将内核镜像从存放他的存储器（例如磁盘）中读到RAM中。\u003cstrong\u003ebootloader需要将内核镜像加载到内存中，就可以选择用哪一个内核镜像进行加载，实现多重开机的功能，在一个硬件上选择运行不同的操作系统。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ebootloader划分了硬件启动和软件启动的边界\u003c/strong\u003e，bootloader主要负责硬件启动相关工作，操作系统内核专注于软件启动以及对用户提供服务的工作。简化操作系统的开发和移植。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"12-bootloader\"\u003e1.2 bootloader\u003c/h3\u003e\n\u003cp\u003e​\tbootloader需要正确地找到内核并加载执行。bootloader的实现依赖于CPU的体系结构，分为stage1，stage2两个部分。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240318110032974\" loading=\"lazy\" src=\"/img/image-20240318110032974.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"13-qemu中操作系统的启动\"\u003e1.3 QEMU中操作系统的启动\u003c/h3\u003e\n\u003cp\u003e​\tQEMU已经提供了bootloader的引导功能，支持加载ELF格式的内核。启动流程被简化为加载内核到内存，之后跳转到内核的入口。\u003c/p\u003e\n\u003ch2 id=\"2-elf\"\u003e2. ELF\u003c/h2\u003e\n\u003ch3 id=\"21-编译链接\"\u003e2.1 编译链接\u003c/h3\u003e\n\u003cp\u003e​\t我们知道源代码文件需要经过编译链接两个阶段才能变成可执行文件来运行。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e编译\u003ccode\u003e-c\u003c/code\u003e：源代码被翻译为二进制指令，得到目标文件\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e链接：将多个目标文件链接为可执行文件\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e将编译好的目标文件反汇编：objdump指令\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eobjdump -DS \u0026lt;要反汇编的目标文件名\u0026gt; \u0026gt; \u0026lt;导出文本文件名\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240320221446864\" loading=\"lazy\" src=\"/img/image-20240320221446864.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t以简单的代码为示例\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#include\u0026lt;stdio.h\u0026gt;\nint main()\n{\n\tprintf(\u0026#34;hello,world!\\n\u0026#34;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t这里我们知道，\u003cstrong\u003e头文件中只包含函数的声明，而不包括函数的定义\u003c/strong\u003e，因此在预处理阶段（替换头文件、宏定义过程）只会将printf替换为他的声明。最后在链接阶段才会替换为printf的实现。\u003cstrong\u003e即在编译的最后，链接器将所有的目标文件链接在一起，将 之前未填写的地址等信息填上，形成最终的可执行文件，这就是链接的过程\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"22-elf\"\u003e2.2 ELF\u003c/h3\u003e\n\u003cp\u003e​\tELF是一种文件格式，即\u003ccode\u003eExecutable and Linkable Format\u003c/code\u003e。ELF是Unix系统中一种常见的文件格式，包括可重定位文件(relocatable)，可执行文件(executable)，共享对象文件(shared object)。其中可重定位文件即为我们熟悉的.o文件，后两种文件都需要对.o文件进行链接才能产生。\u003c/p\u003e\n\u003ch4 id=\"221-段和节\"\u003e2.2.1 段和节\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e段：segment\u003c/li\u003e\n\u003cli\u003e节：section\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eELF 官方文档中对于section segment的解释\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240320224950997\" loading=\"lazy\" src=\"/img/image-20240320224950997.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e所谓section与segment是同一数据的两种视图\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e左侧是链接视图：使用section进行链接\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e右侧是执行视图：使用segment运行\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e每个segment中包含一个或多个section\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e节头表(Section header table)：包含程序中各个节(section)的信息，在程序编译链接时使用\u003c/p\u003e","title":"OS-lab1课下基础"},{"content":"OS-lab0 实验报告 Thinking 0.1 执行命令cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。 ​\t不一样。第一次执行add命令之前的status是未跟踪文件。第二次执行cat命令的status为尚未暂存以备提交的变更，并提示修改：README.txt。原因是第一次时，文件未被add过，即为未跟踪文件(Untracked file)，第二次查看status时，README.txt已经被add过，即已经放入暂存区，故只提示修改。\nThinking 0.2 思考一下箭头中的add thefile、stage thefile和 commit分别对应的是Git里的哪些命令呢？ **add the file : git add \u0026amp;\u0026amp; git commit ** **stage the file : git add ** **commit : git commit ** Thinking 0.3 代码文件print.c 被错误删除时，应当使用什么命令将其恢复？\n可以使用git checkout -- print.c\n关于git checkout -- \u0026lt;file\u0026gt;:在工作区中对多个文件进行多次修改后，若还未执行git add，可以使用本命令将工作区恢复成原样 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复\ngit reset HEAD print.c\ngit checkout -- print.c\n关于git reset HEAD \u0026lt;file\u0026gt;:在工作区中对多个文件进行多次修改并执行过git add后，则需要先使用本命令，再git checkout\n无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？\ngit rm --cached hello.txt Thinking 0.4 git reset \u0026ndash;hard\n​\tgit reset可以进行版本的回退或者切换到任何一个版本，--hard选项会强制覆盖工作区中的文件。回退到前n个版本，可以使用\ngit reset --hard HEAD~n 或者记录下每次提交的hash值。使用hash值进行任意版本之间的切换。\ngit reset --hard \u0026lt;hash-value\u0026gt; Thinking 0.5 echo first echo second \u0026gt; output.txt echo third \u0026gt; output.txt echo fourth \u0026raquo; output.txt ​\t输出如下图\n​\t可以发现的区别为：关于重定向 \u0026gt; 将标准输出重定向到文件，但会覆盖文件原来的内容，\u0026raquo; 为将标准输出追加到文件之后\nThinking 0.6 command文件内容如下：主要利用输出重定向以及追加(\u0026raquo;)将命令输出到test文件中\nresult文件内容如下：将test脚本运行产生结果输出到result文件中\n分析\n使用单引号将字符串括起来会使单引号内字符串字节作为字符串输出，不解释其中的变量或命令\n使用双引号将字符串括起来会解析变量以及特殊字符等\n使用反引号：反引号用来包含一个命令字符串，其中的命令先执行，得到的结果返回到层命令再执行\n例如例子\necho echo Shell Start echo `echo Shell Start` echo echo $c\u0026gt;file1 echo `echo $c\u0026gt;file1` 注：当echo命令向文件中写入参数值时，若参数已有一个确定值，则将该值写入，否则会写入空值或不写入 难点分析 ​\t在lab0实验中，我们学习了linux系统的基本指令以及Makefile，shell脚本的编写等。其中对于指令的掌握是有难度的，对于指令的不同选项和用法的记忆是需要循序渐进的，尤其是文本处理三剑客grep,sed,awk，这三个命令在处理文本时带来极高的效率。\n实验体会 ​\tlab0实验是linux系统的入门实验，是MOS操作系统开发的第一个台阶。在实验构成上内容比较基础，以训练掌握linux的基本工具为主。对于较为灵活的grep,sed,awk指令还需要进一步在学习中训练。对于Makefile，shell脚本的编写让我感受到命令行的便捷性。\n","permalink":"https://coder0xe.github.io/posts/os-lab0-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","summary":"\u003ch1 id=\"os-lab0-实验报告\"\u003eOS-lab0 实验报告\u003c/h1\u003e\n\u003ch2 id=\"thinking-01\"\u003eThinking 0.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e执行命令cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t不一样。第一次执行add命令之前的status是未跟踪文件。第二次执行\u003ccode\u003ecat\u003c/code\u003e命令的status为尚未暂存以备提交的变更，并提示修改：README.txt。原因是第一次时，文件未被\u003ccode\u003eadd\u003c/code\u003e过，即为未跟踪文件(\u003ccode\u003eUntracked file\u003c/code\u003e)，第二次查看status时，README.txt已经被add过，即已经放入暂存区，故只提示修改。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240313232853804\" loading=\"lazy\" src=\"/img/image-20240313232853804.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240313232939134\" loading=\"lazy\" src=\"/img/image-20240313232939134.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"thinking-02\"\u003eThinking 0.2\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e思考一下箭头中的add thefile、stage thefile和 commit分别对应的是Git里的哪些命令呢？\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240313233546782\" loading=\"lazy\" src=\"/img/image-20240313233546782.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e**add the file : git add \u0026amp;\u0026amp; git commit **\u003c/li\u003e\n\u003cli\u003e**stage the file : git add **\u003c/li\u003e\n\u003cli\u003e**commit : git commit **\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"thinking-03\"\u003eThinking 0.3\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e代码文件print.c 被错误删除时，应当使用什么命令将其恢复？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e可以使用\u003ccode\u003egit checkout -- print.c\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e关于\u003ccode\u003egit checkout -- \u0026lt;file\u0026gt;\u003c/code\u003e\u003c/strong\u003e:在工作区中对多个文件进行多次修改后，\u003cstrong\u003e若还未执行git add，可以使用本命令将工作区恢复成原样\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003egit reset HEAD print.c\u003c/code\u003e\u003c/p\u003e","title":"OS-lab0-实验报告"},{"content":"OO第一单元第三次作业 0. 题目需求 ​\t本次作业在上次作业的基础上主要增加了求导因子，同时自定义函数表达式中允许调用已经定义过的表达式。\n求导因子(归结在因子中)，求导因子形式为dx(表达式)，含义为对表达式中的x求导，其中可以出现多次求导的情况，但是自定义函数表达式中不会出现求导算子\n==关于求导的形式化表述==\n求导算子 -\u0026gt; \u0026lsquo;dx\u0026rsquo;\n求导因子 -\u0026gt; 求导算子 空白项 ‘(\u0026rsquo; 空白项 求导因子 空白项 \u0026lsquo;)\u0026rsquo; | 求导算子 空白项 \u0026lsquo;(\u0026rsquo; 空白项 表达式 空白项 \u0026lsquo;)\u0026rsquo;\n注意：求导算子内部可能有表达式，应该调用parseExpr 注：形式化表述中允许了多层求导的情况，例如，\ndx(dx(x)) ==可能用到的求导公式== $$ I.f(x)\\space =\\space c\\space ,f\u0026rsquo;(x)\\space = \\space 0 $$\n$$ II.f(x)\\space = \\space x^n,f\u0026rsquo;(x) = nx^{n-1} $$\n$$ III. f(x)\\space = \\space exp(x),f\u0026rsquo;(x) \\space = \\space exp(x) $$\n$$ IV.[f(g(x))]\u0026rsquo;\\space = \\space f\u0026rsquo;(g(x))g\u0026rsquo;(x) $$\n$$ V.[f(x)g(x)]\u0026rsquo; \\space = \\space f\u0026rsquo;(x)g(x) + f(x)g\u0026rsquo;(x) $$\n==因子-\u0026gt;变量因子|常数因子|表达式因子|求导因子==\n自定义函数定义，自定义函数中允许调用出现已经定义的函数，但不允许出现求导因子。需要注意的是调用，即实参一定是因子\n必要的括号\nexp()调用时的一层括号 exp(\u0026lt;factor\u0026gt;)内的因子为不带指数的表达式因子，两侧必要一层括号 这意味着求导是需要进行计算展开的\u0026hellip; 1. 思路分析 1.1 函数定义式解析 ​\t在上一次的作业中我们使用了字符串替换的方法用来解析函数定义式和调用，这种架构在这一次作业中自动满足了函数中可以调用先前已经定义函数的要求。\n1.2 求导因子解析 ​\t对于求导因子的处理是新建一个求导因子类，其中设置属性保存需要求导的多项式。求导的过程在建立多项式过程中进行，即在表达式转化为poly的过程中调用derive进行求导，递归地转化为对每一个unit求导，只需要对unit写一个求导方法即可。或者说求导因子类的toPoly返回的poly是求导之后的poly，toString方法返回的是求导之后的多项式字符串(两边一定记得加括号)\n2. 代码分析 2.1 UML图 2.2 代码分析 ​\t这次作业的代码在上次代码的基础上实际上只增加了求导环节，代码复杂度上变化不是很大，主要是输入预处理以及输出化简环节复杂度较高。\n3. bug修复 这次的bug是在求导因子类中toString方法中忘记对求导返回的表达式字符串两侧加括号 ps: 建立src test目录的方式 ​\t经过第二次作业的bug洗礼，突然回想起上学期JUnit的好，这就需要建立起src和test文件夹。最简单的方式是克隆上一次作业代码时在目录下再新建一层src，直接克隆进src，之后设置它为Resources Root，再建立test文件夹，设置为Test Resources Root。\n​\t之后使用Go to新建Test（JUnit4标准）即可\n在test文件代码前输入 import org.junit.Test 保证每一个注解的内容是@Test ","permalink":"https://coder0xe.github.io/posts/oo-unit1-hw3/","summary":"\u003ch1 id=\"oo第一单元第三次作业\"\u003eOO第一单元第三次作业\u003c/h1\u003e\n\u003ch2 id=\"0-题目需求\"\u003e0. 题目需求\u003c/h2\u003e\n\u003cp\u003e​\t本次作业在上次作业的基础上主要增加了求导因子，同时自定义函数表达式中允许\u003cstrong\u003e调用\u003c/strong\u003e已经定义过的表达式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e求导因子(归结在因子中)\u003c/strong\u003e，求导因子形式为\u003ccode\u003edx(表达式)\u003c/code\u003e，含义为对表达式中的x求导，\u003cstrong\u003e其中可以出现多次求导的情况，但是自定义函数表达式中不会出现求导算子\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e==关于求导的形式化表述==\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e求导算子\u003c/strong\u003e -\u0026gt; \u003cstrong\u003e\u0026lsquo;dx\u0026rsquo;\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e求导因子\u003c/strong\u003e -\u0026gt; 求导算子 空白项 ‘(\u0026rsquo; 空白项 求导因子 空白项 \u0026lsquo;)\u0026rsquo; | 求导算子 空白项 \u0026lsquo;(\u0026rsquo; 空白项 表达式 空白项 \u0026lsquo;)\u0026rsquo;\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e注意：求导算子内部可能有表达式，应该调用\u003ccode\u003eparseExpr\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e注：形式化表述中允许了多层求导的情况，例如，\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edx(dx(x))\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e==可能用到的求导公式==\n$$\nI.f(x)\\space =\\space c\\space ,f\u0026rsquo;(x)\\space = \\space 0\n$$\u003c/p\u003e\n\u003cp\u003e$$\nII.f(x)\\space = \\space x^n,f\u0026rsquo;(x) = nx^{n-1}\n$$\u003c/p\u003e\n\u003cp\u003e$$\nIII. f(x)\\space = \\space exp(x),f\u0026rsquo;(x) \\space = \\space exp(x)\n$$\u003c/p\u003e\n\u003cp\u003e$$\nIV.[f(g(x))]\u0026rsquo;\\space = \\space f\u0026rsquo;(g(x))g\u0026rsquo;(x)\n$$\u003c/p\u003e\n\u003cp\u003e$$\nV.[f(x)g(x)]\u0026rsquo; \\space = \\space f\u0026rsquo;(x)g(x) + f(x)g\u0026rsquo;(x)\n$$\u003c/p\u003e","title":"OO-Unit1-HW3"},{"content":"OS : lab0课下基础 1. Linux Command cat命令用于拼接文件并输出到标准输出，也可以用于查看单个文件内容。\n拼接文件并输出到标准输出，cat file1 file2将文件2的内容拼接到文件1的后边输出到标准输出\n查看单个文件内容，cat file\n常用：使用cat命令拼接文件重定向输出到文件中\ncat file1 file2 \u0026gt; newfile head查看文件的首部内容\nhead -n \u0026lt;n\u0026gt;显示文件的前n行内容 tail查看文件的尾部内容\ntail -n \u0026lt;n\u0026gt;显示文件的后n行内容 tail -f \u0026lt;n\u0026gt;文件增长时，输出后续添加的数据 ps命令用于显示当前进程状态（process status）\nps -e显示所有进程 ps -f 显示全部信息 kill用于向进程发送信号，不止于终止进程\nkill -9强制杀死进程 sudo超级用户权限执行命令\nsudo command mkdir递归建立目录：-p参数\nmkdir -p dir/inner 2.有关文本处理 1. vim /\u0026lt;word\u0026gt;文件下寻找名为\u0026lt;word\u0026gt;的字符串\n:%s/\u0026lt;word1\u0026gt;/\u0026lt;word2\u0026gt;/g，全文中寻找\u0026lt;word1\u0026gt;字符串，并将该字符串取代为\u0026lt;word2\u0026gt;\n[n] yy，复制游标所在的一行或n行，用p/P可以粘贴\n[n] dd，删除游标所在的一行或n行，用p/P可以粘贴（类似于剪切）\np粘贴在光标下一行，P粘贴在光标上一行\nu:undo\nctrl + Q块选，通过移动光标可以选中块，实现更加便捷的操作，例如删去段首的注释，为段首增加空格等。\nd剪切选中文本 y复制选中文本 p粘贴选中文本 u复原 }选中光标下一个段落 {选中光标上一个段落 2. grep grep(global regular expression)命令用于查找文件中符合条件的字符串或正则表达式。主要用于查找\ngrep [options] pattern [files] pattern表示要查找的字符串或正则表达式\nfiles要查找的一个或多个文件或目录，若省略该参数则表示从标准输入中读取\noptions\n-i，忽略大小写进行匹配\n-v，反向查找，只打印不匹配的行\n-n，显示匹配行的行号\n需要注意的是 -n选项输出形式为 “行号:内容“ 而不只是行号\n-r，递归查找子目录中的文件\n-l，只打印匹配的文件名\n-c，只打印匹配的行数\n-a，不忽略二进制数据进行查找\n3. sed sed可以通过命令编辑和输出文本，通常用于整行的处理\nsed [选项] \u0026#39;命令\u0026#39; 输入文本 选项\n-n：安静模式，只显示经过sed处理的内容，否则显示输入文本的全部内容 -i：直接修改读取的文件内容，而不是输出到屏幕 命令（用单引号括起来）\n关于命令中指定行数进行操作\n指定某一行，例如 '3p' 指定范围内的行，例如'3,6p' 指定某几行，例如'8p;32p;256p;1024p'，用分号分隔 最后一行用$表示 不指定行则默认为所有行执行操作 \u0026lt;行号\u0026gt;a\u0026lt;内容\u0026gt; ： 在相应行下一行新增内容\n\u0026lt;行号\u0026gt;i\u0026lt;内容\u0026gt;：在相应行上一行新增内容\n\u0026lt;行号\u0026gt;c\u0026lt;内容\u0026gt; ：取代，用内容取代相应行的文本\n\u0026lt;行号\u0026gt;d：删除相应行\n\u0026lt;行号\u0026gt;p：输出相应行\n\u0026lt;行号\u0026gt;s/\u0026lt;原字符串\u0026gt;/\u0026lt;替换字符串\u0026gt;/g：若有g则表示将对应行中所有原字符串替换，否则将只替换第一个原字符串，通常使用\nsed -i \u0026#39;s/str1/str2/g\u0026#39; text 对文本进行全局替换\n4. awk awk主要用于格式化处理文本，倾向于将一行分为多个字段进行处理\nawk [options] \u0026#39;模式或条件 {操作}\u0026#39; files awk -f 脚本文件 files awk常用的内置变量\n**FS(field separator)：列分隔符，**指定每行文本的字段分隔符，默认为空格或制表位，与-F作用相同 OFS:输出分隔符，指定输出字段间的分隔符 RS(record separator)：行分隔符，awk处理文本时，每一行称为一个record，RS即为每行之间的分隔符 NF：当前处理行的字段个数/被分割成的段数 NR(number of record)：当前处理行的行号 FNR(file number of record)：awk当前读取的记录数，其变量值小于等于NR，当读取第二个文件时，FNR从0开始重新计数，NR不会。故可以通过FNR==NR判断是不是在读取第一个文件 FILENAME：被处理的文件名 $0：当前处理行的整行内容 $n：当前处理行的第n个字段 ​\t(本图和下图来自B站Ternurafl)\n选项：\n-F：指定输入文件分隔符，-F fs\nfs : field seperater 指每一行(每一个record)的分隔符\n例如课下作业中将grep查找的内容利用管道输入到awk,再利用awk将内容以:分隔开，\ngrep -n \u0026#34;all\u0026#34; text | awk -F: \u0026#39;print {$1}\u0026#39; \u0026gt; line.txt 默认以空格或\u0026lt;tab\u0026gt;作为分隔符。文本中的每一行我们称作一个record，会对每个record用分隔符进行分割，例如文本示例如下\nwelcome to BUAA cs 以默认空格进行划分，会产生四个参数，分别记作$1...$4，最后一个参数使用 $NF表示，倒数第二个参数 $(NF-1) ，$0表示没有进行分割的整行的数据。\n-v对内置变量进行赋值，常见的是对FS,OFS等赋值\nawk -v FS=\u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39; awk -v OFS=\u0026#39;#\u0026#39; \u0026#39;{print $1,$3}\u0026#39; 脚本\n脚本的格式 ：‘{ action }’\n例如lab0课下中 \u0026lsquo;{print $1}\u0026rsquo; 打印第一个参数，使用print会换行，使用printf进行打印需要有格式符，类似于C语言，支持指定格式输出例如以上例子\n\u0026#39;{printf \u0026#34;%-7s %-2s %-4s %-2s\\n\u0026#34;,$1,$2,$3,$4}\u0026#39; 注：数字代表占最小宽，-代表左对齐 对于\u0026rsquo;{action}\u0026lsquo;的形式只适用于一些比较简单的脚本操作，如果涉及到比较复杂的操作可以编写好脚本文件再使用-f参数读入。\nawk -f shell.sh files 常用的awk命令示例\n输出所有内容\nawk \u0026#39;{print $0}\u0026#39; a.txt ## print 命令默认换行 输出范围指定行号的内容 例如输出第一行到第三行的内容 通过逻辑与 \u0026amp;\u0026amp; 实现 这同样可以通过sed实现\nawk \u0026#39;NR==1,NR==3{print $0}\u0026#39; file awk \u0026#39;(NR\u0026gt;=1)\u0026amp;\u0026amp;(NR\u0026lt;=3){print $0}\u0026#39; file sed -n \u0026#39;1,3p\u0026#39; file 这里使用了内置变量NR(number of record) awk命令中支持简单的逻辑操作和数学运算 逻辑操作 ：\u0026amp;\u0026amp;, ||, ！ 算术操作 ：+ - * / % ^ 输出离散行号的内容 通过逻辑或||实现 同样可以通过sed实现\nawk \u0026#39;NR==1||NR==3{print $0}\u0026#39; file sed -n \u0026#39;1p;3p\u0026#39; file 输出奇偶行内容\nawk \u0026#39;NR%2==1{print $0}\u0026#39; file awk \u0026#39;NR%2==0{print $0}\u0026#39; file 输出匹配行的内容 字符串、以什么开头结尾、正则表达式等 用 /\u0026hellip;/形式\n^表示以什么开头 例如 ^e表示以e开头 $表示以什么结尾 例如 r$表示以r结尾 awk \u0026#39;/^d/{print $0}\u0026#39; file ##输出以d开头 awk \u0026#39;/r$/{print $0}\u0026#39; file ##输出以r结尾 awk \u0026#39;/dqr/{print $0}\u0026#39; file ## 输出匹配字符串dqr的行 awk \u0026#39;/pattern/{print $0}\u0026#39; file ## 输出正则表达式匹配的行 指定fs进行分割\nawk -F : \u0026#39;{print $1}\u0026#39; file ## 输出以冒号作为field separator分割的第一项 指定分隔符进行输出 只要在输出项之间加上分隔符输出\nawk \u0026#39;{print $1\u0026#34; is not equal to \u0026#34;$3}\u0026#39; awk \u0026#39;{print $1\u0026#34;==\u0026#34;$3}\u0026#39; 指定分隔符输出还可以通过对OFS变量进行赋值\n可以在\u0026rsquo;{actioin}\u0026lsquo;外边通过-v参数对变量进行赋值 或在\u0026rsquo;{action}\u0026lsquo;内指定变量值 awk -v OFS=\u0026#34; is not equal to \u0026#34; \u0026#39;{print $1,$2}\u0026#39; file awk \u0026#39;OFS=\u0026#34; is not equal to \u0026#34;{print $1,$2}\u0026#39; file 但是此时我们如果尝试输出使用新OFS的整行内容，例如\nawk -v OFS=\u0026#34; is not equal to\u0026#34; \u0026#39;{print $0}\u0026#39; file 会发现并没有对内容进行更新，此时通常使用$1=$1来激活$0的重新赋值，这种情况只会在输出$0时出现\nawk -v OFS=\u0026#34; is not equal to\u0026#34; \u0026#39;$1=$1,{print $0}\u0026#39; 输出匹配字段的内容\nawk \u0026#39;$1\u0026gt;50{print $1}\u0026#39; file awk \u0026#39;$1~\u0026#34;d\u0026#34;{print $1}\u0026#39; file #输出第一字段中包含\u0026#34;d\u0026#34;的行内容 使用三元运算符进行赋值\nawk \u0026#39;max=($2\u0026gt;$3)?$2:$3;{print max}\u0026#39; file 使用 if else 语句\nawk \u0026#39;{if(condition){do} else {do}}\u0026#39; file 关于内置函数\nindex($n,str)：返回某个字段中该字符串的位置 length($n)：返回某个字段的长度 awk \u0026#39;/dqr/{print length($1)}\u0026#39; ##输出匹配dqr的第一个字段的长度 awk \u0026#39;/dqr/{print index($1,d)}\u0026#39; ##输出匹配dqr的第一个字段中d的位置 BEGIN END\nBEGIN语句块在awk读取数据之前进行，END语句块在awk读取数据结束之后进行，且均只会进行一次\nawk \u0026#39;BEGIN{print \u0026#34;表头\u0026#34;} NR==1{print $0} END{print \u0026#34;finish\u0026#34;}\u0026#39; file 关于 -f 参数\n-f参数表示读取awk脚本进行操作 awk脚本中可以采用 BEGIN{} {} END{}的形式，如下例\nawk -f awk.sh file 其中awk.sh内容如下\nBEGIN{ print \u0026#34;输出开始\u0026#34; } { print $0 } END{ print \u0026#34;输出结束\u0026#34; } 3. Makefile 3.1 课下题目分析 \u0026lt;target\u0026gt;: dependencies command 1 command 2 注意：command前tab\n关于C语言文件如何产生可执行文件，当有一个工程中有多个C语言文件时，我们需要采用先编译后链接的方法（需要注意的是，.h头文件并不参与编译过程，在预处理阶段就会被替换为相应的代码）\n指定C文件先只进行编译不进行链接，模版为\ngcc -c file.c -o file.o 这里-o参数为命名产生文件的名字，使用格式为源文件明 -o 产生文件名\n这里-c参数用来指定只进行编译，-o参数用来指定编译后产生的文件名\n关于编译需要注意：如果对应的.h头文件并不在.c文件相同的目录下，例如lab0课下中的题目，\n这样需要注意在编译时需要使用-I参数指定头文件所在的目录或具体的头文件，在这个例子中，main.c中使用了fibo.h中定义的函数，该函数的实现在fibo.c中，这样我们在编译时就要指定头文件的目录../include.(参数-I和头文件路径之间可有空格也可没有)\ngcc -c -I ../include fibo.c -o fibo.o 具体的，应该如下编写Makefile\n第一种\ncompile : fibo.o main.o gcc main.o fibo.o -o ../fibo fibo.o : fibo.c gcc -c -I../include fibo.c -o fibo.o main.o : main.c gcc -c -I../include main.c -o main.o .PHONY : clean clean : rm -rf *.o 注：这里指定了生成文件目录../fibo 第二种\n​\t引入变量编写Makefile\nTARGET = compile OBJS = fibo.o main.o GXX = gcc $(TARGET) : $(OBJS) $(GXX) $^ -o ../fibo %.o : %.c : $(GXX) -c $\u0026lt; -o $@ .PHONY clean clean: rm -rf *.o 对多个编译后的文件进行链接，模版为\ngcc [*.o *.so *.a ...] -o result.o 这里是对多个.o文件进行链接，不需要指定参数，后面的-o参数为指定生成文件名\n课下题目中涉及到在父目录中编译子目录中的内容，我们使用make -c ./subdir \u0026lt;target\u0026gt;完成，这里实际上就是父目录的Makefile通过调用子目录的Makefile对子目录中的文件进行编译（其实Makefile也是一系列指令的集合）。我们使用make -c ./subdir \u0026lt;target\u0026gt;完成，这个指令其实相当于两个指令的集合cd ./subdir \u0026amp;\u0026amp; make \u0026lt;target\u0026gt;(这个\u0026lt;target\u0026gt;是子目录Makefile中定义的)\n关于.PHONY\n我们经常用到make clean指令，例如定义出\n.PHONY clean clean: rm -rf *.o .PHONY是一个伪目标，可以防止执行命令的target与当前目录下文件名称重复\n3.2 编写规范的Makefile ​\t当我们的项目中有多个C文件时，我们需要对他们进行联合编译，例如我们需要对hello.c，calculate.c，main.c进行联合编译，我们可以通过一条指令完成\nall : hello.c calculate.c main.c gcc hello.c calculate.c main.c -o main ​\t这样的写法看似简洁，但是实际上，如果我们对其中的某个文件进行了更改，需要对文件进行重新编译，我们如果采用上面这种写法，执行编译实际上需要把所有的文件全部重新编译一遍，这样的效率是很低的，因此我们采用先编译，后链接的方法，这样即使某个文件发生改变，我们也只需要对这个文件重新编译，在对整体重新链接，因此我们可以写为如下\nall : hello.o calculate.o main.o gcc hello.o calculate.o main.o -o main hello.o : hello.c gcc -c hello.c -o hello.o ... ​\t以上的这种写法在编译效率上大大提升，但实际上仍然存在问题，当我们的C文件非常多时，以上写法代码量很大，因此我们考虑引入变量来减少代码量，先对下面出现的符号进行介绍\n$^：代表全部的依赖项 $\u0026lt;：代表第一个依赖项 $@：代表构建目标 ​\t给出较为规范的Makefile模版\nGXX = gcc TARGET = all OBJS = hello.o calculate.o main.o .PHONY clean $(TARGET):$(OBJS) $(GXX) $^ -o $@ %.o : %.c $(GXX) -c $\u0026lt; -o $@ clean: rm -rf *.o ​\t另外还有一种更加简洁的模版\nGXX = gcc SRC = $(wildcard *.c) OBJS = $(patsubst %.c,%.o,$(SRC)) compile : $(OBJS) $(GXX) $^ -o ../fibo $(OBJS) : %.o : %.c $(CXX) -c -I ../include $\u0026lt; -o $@ .PHONY : clean clean : rm -rf *.o\twildcard函数：获取Makefile目录下所有符合pattern的文件列表\n$(wildcard \u0026lt;pattern\u0026gt;) patsubst函数：text中字符串若满足pattern则替换为replacement，用于文件名的替换\n$(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,\u0026lt;text\u0026gt;) 4. Shell编程 Shell 是一个命令行解释器 用于直接向OS发送请求 Shell脚本由各个linux命令组成，是命令的组合\n4.1 Shell脚本的创建与运行 Shell脚本一定要以#!/bin/bash开头，#!/bin/bash称为Shebang，是命令行的解释器（实际上是一个路径）\n创建的Shell脚本一定要赋予执行权限\nchmod +x script.sh 执行脚本\n直接输入脚本的绝对路径或相对路径即可\n./script.sh 或\nbash script.sh 4.2 Shell变量 ​\tShell中变量分为系统变量和自定义变量，系统变量有$HOME,$PWD,$USER,$SHELL等，主要介绍自定义变量。\n定义变量：变量名称=值（等号两边不允许有空格） 撤销变量：unset 变量名称 定义静态变量（无法撤销） readonly 变量名=值 获取变量值：$变量 例如\n#!/bin/bash A=100 echo A=$A readonly B=3 echo B=$B 注：echo为常用的输出到标准输出语句，并附带自动换行，可以使用-n参数取消换行\n4.3 位置参数变量 ​\t当执行一个shell脚本时，如果需要获取命令行中的参数信息，就需要用到位置参数变量\n$n：$0表示命令本身，$1-9表示第1到第9个参数，10以上的编号需要用大括号包含${10} $*：代表命令行中所有参数，将所有参数看成一个整体字符串 $#：表示命令行中所有的参数个数（以空格为区分） 需要注意的是，如果在echo输出字符串中有参数，则只能使用双引号，不能使用单引号，若使用单引号只会原样输出，不会带入参数值 ​\t例如脚本\n#!/bin/bash echo \u0026#39;0=$0\u0026#39; echo \u0026#34;1=$1\u0026#34; echo \u0026#34;2=$2\u0026#34; echo \u0026#34;number of paras is $#\u0026#34; echo \u0026#34;all in one is $*\u0026#34; ​\t观察运行结果\n4.4 运算符 运算符格式为 $((运算式)) $[运算式] expr\n例如\nA=$(($1+$2)) B=$[$1+$2] C=\u0026#39;expr $1+$2\u0026#39; 4.5 条件判断语句 ​\t条件语句的模版为(fi表示if语句块结束)\nif condition1 then command11 command12 ...... elif condition2 then command21 command22 ...... else command31 command32 ...... fi 对于判断条件 我们使用 if [condition] 的写法\n需要注意的是空格的问题 if\u0026lt;空格\u0026gt;[\u0026lt;空格\u0026gt;condition\u0026lt;空格\u0026gt;]\u0026lt;空格\u0026gt;\n常用的判断语句有(这里就需要注意命令行中的参数类型) 判断两个字符串相等if [ $1 = $2 ] = 判断两个整数 if [ $1 -gt $2 ] -lt less than -le less or equal -gt greater than -ge greater or equal -eq equal -ne not equal 4.6 循环语句 4.6.1 for循环 ​\t第一种for循环的写法是列举出全部的变量\nfor 变量 in 值1 值2 值3 ... do ... done ​\t这样的写法适用于循环值可列举的情况，我们可以用这种形式验证$*和$@的区别\n#!/bin/bash #使用$* for i in \u0026#34;$*\u0026#34; do echo \u0026#34;num is $i\u0026#34; done #使用$@ for i in \u0026#34;$@\u0026#34; do echo \u0026#34;num is $i\u0026#34; done ($*将参数看为一个整体，$@将参数分开看待，但是如果不加双引号都是分开看看待)\n​\t第二种for循环的写法更加常用\nfor((初始值;循环控制条件;变量变化)) do ... done 例如\n#!/bin/bash for((j=0;j\u0026lt;100;j++)) do echo \u0026#34;j=$j\u0026#34; done 4.6.2 while循环 while [ condition ] do ... done 关于while循环中变量的自增，有两个写法\nlet i=i+1 i=$[$i+1] i=$(($i+1)) 例如\n#!/bin/bash i=100 zero=0 while [ $i -ge $zero ] do echo \u0026#34;i=$i\u0026#34; let i=i-1 done 5.函数 函数模版\nfunction fun_name() { body... return int_value; } 返回值是[0-255]之间的值,可也以无返回值，函数调用后用$?来获取返回值。\n函数调用，第n个参数在函数体内用${n}来获取\nfun_name param1 param2 ... paramN 例如\n#!/bin/bash function func1() { zero=0 para1=$1 while [ $para1 -gt $zero ] do echo \u0026#34;para1=$para1\u0026#34; let para1=para1-1 done return $para1 } func1 10 echo \u0026#34;return value is $?\u0026#34; 这里需要注意的是，在函数中并不能直接修改传入参数的值，只能间接修改，即新创建一个变量存储参数值\npara1=$1 ","permalink":"https://coder0xe.github.io/posts/os-lab0/","summary":"\u003ch1 id=\"os--lab0课下基础\"\u003e\u003ccenter\u003eOS : lab0课下基础\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"1-linux-command\"\u003e1. Linux Command\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ecat\u003c/code\u003e命令用于拼接文件并输出到标准输出，也可以用于查看单个文件内容。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e拼接文件并输出到标准输出，\u003ccode\u003ecat file1 file2\u003c/code\u003e将文件2的内容拼接到文件1的后边输出到标准输出\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e查看单个文件内容，\u003ccode\u003ecat file\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e常用：使用cat命令拼接文件重定向输出到文件中\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecat file1 file2 \u0026gt; newfile\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ehead\u003c/code\u003e查看文件的首部内容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehead -n \u0026lt;n\u0026gt;\u003c/code\u003e显示文件的前\u003ccode\u003en\u003c/code\u003e行内容\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003etail\u003c/code\u003e查看文件的尾部内容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etail -n \u0026lt;n\u0026gt;\u003c/code\u003e显示文件的后\u003ccode\u003en\u003c/code\u003e行内容\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etail -f \u0026lt;n\u0026gt;\u003c/code\u003e文件增长时，输出后续添加的数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eps\u003c/code\u003e命令用于显示当前进程状态（process status）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eps -e\u003c/code\u003e显示所有进程\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eps -f \u003c/code\u003e显示全部信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ekill\u003c/code\u003e用于向进程发送信号，不止于终止进程\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ekill -9\u003c/code\u003e强制杀死进程\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esudo\u003c/code\u003e超级用户权限执行命令\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esudo command\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emkdir\u003c/code\u003e递归建立目录：\u003ccode\u003e-p\u003c/code\u003e参数\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emkdir -p dir/inner\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2有关文本处理\"\u003e2.有关文本处理\u003c/h2\u003e\n\u003ch3 id=\"1-vim\"\u003e1. vim\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/\u0026lt;word\u0026gt;\u003c/code\u003e文件下寻找名为\u003ccode\u003e\u0026lt;word\u0026gt;\u003c/code\u003e的字符串\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e:%s/\u0026lt;word1\u0026gt;/\u0026lt;word2\u0026gt;/g\u003c/code\u003e，全文中寻找\u003ccode\u003e\u0026lt;word1\u0026gt;\u003c/code\u003e字符串，并将该字符串取代为\u003ccode\u003e\u0026lt;word2\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e[n] yy\u003c/code\u003e，复制游标所在的一行或n行，用p/P可以粘贴\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e[n] dd\u003c/code\u003e，删除游标所在的一行或n行，用p/P可以粘贴（类似于剪切）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ep粘贴在光标下一行，P粘贴在光标上一行\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eu:undo\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ectrl + Q\u003c/code\u003e块选，通过移动光标可以选中块，实现更加便捷的操作，例如删去段首的注释，为段首增加空格等。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ed\u003c/code\u003e剪切选中文本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ey\u003c/code\u003e复制选中文本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e粘贴选中文本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eu\u003c/code\u003e复原\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e}\u003c/code\u003e选中光标下一个段落\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e{\u003c/code\u003e选中光标上一个段落\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-grep\"\u003e2. grep\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003egrep(global regular expression)命令用于查找文件中符合条件的字符串或正则表达式。\u003cstrong\u003e主要用于查找\u003c/strong\u003e\u003c/p\u003e","title":"OS-lab0"},{"content":"OO第一单元第二次作业 0.题目需求分析 0.1 概念分析 本次作业在第一次作业的基础上添加了指数函数和自定义函数，其中\n需要支持嵌套多层括号 新增指数因子，指数函数括号内部包含任意因子 新增自定义函数因子，自定义函数的表达式会给出且其中不会调用其他自定义函数 本次迭代表达式架构上的改变\n支持前导0的十进制带符号整数\n因子\n变量因子，x\n幂函数\n一般形式：x^非负整数 省略形式：指数为1，x 指数函数：特指以e为底数的指数函数，表示为exp(\u0026lt;因子\u0026gt;)等\n一般形式：exp(\u0026lt;因子\u0026gt;)^指数，注：该指数为exp()整体的指数 exp()的指数为非负整数 **省略形式：**指数为1时，写为exp(\u0026lt;因子\u0026gt;) 自定义函数\n自定义函数中不会调用其他自定义函数，定义类似于\nf(x,y,z) = 表达式（可能不全部包含x,y,z这三个变量）\nf,g,h是函数的函数名，本次作业中的自定义函数名只包括f,g,h即最多只有三个自定义函数\nx,y,z是函数的形参，形参个数为1~3个，且同一函数定义中不会出现重复使用的形参\n函数表达式为关于形参的表达式\n函数调用的形式为f(因子，因子，因子)，例如f(x^2),g(exp(x^2),exp(x)),h(1,0,-0)，因子为函数调用中的实参，包含任意一种因子\n注意：函数定义中不允许出现自定义函数，但是函数调用中的实参可以是自定义函数\n常数因子\n表达式因子\n项\n表达式\n​\t关于去括号要求中的**“必要的括号”**\n指数函数调用时必要的一层括号exp()\n指数函数对应的嵌套因子为不带指数的表达式因子时，该因子两侧必要的一层括号，例如\nexp((x+1)^2)中(x+1)中的括号是不合法的，需要展开为不带指数的形式exp((x^2+2*x+1))\n0.2 表达式架构图 大致保留之前的架构，新增指数函数因子类和自定义函数因子类 1.处理流程分析 1.1 字符串预处理 由于自定义函数的引入，可以新增去除,后不必要的+ 1.2 语义分析 1.2.1 Lexer ​\t本次作业中，新增了EXP,F,G,H,COMMA(逗号)等token，需要增加识别功能。\n1.2.2 Parser 1.2.2.1 parseExp ​\t在Parser类中新建一个方法parseExp，当我们读到的token为EXP时调用该方法进行解析。首先对括号内的因子进行解析，再对括号外的指数进行解析。 $$ exp()^n \\space | \\space exp() $$\npublic Factor parseExp() { // exp(\u0026lt;factor\u0026gt;)^\u0026lt;num\u0026gt; | exp(\u0026lt;factor\u0026gt;) // lexer : exp -\u0026gt; pos = pos + 4 already into the ( // 读到RP时接着往后读看有没有指数 int pow = 1;//默认指数为1 Factor innerFactor = parseFactor(); if (lexer.getCurTokenType() == TokenType.POW) { // 后面有指数 } return new Exp(innerFactor, pow); } 1.2.2.2 parseFunc 1.2.2.2.1 Definer ​\t为了成功地解析自定义函数，我们首先定义出Definer类，他的主要作用是处理自定义函数的定义以及调用。（相当于parseFunc的slave）其中定义出两个HashMap\nprivate static HashMap\u0026lt;String, String\u0026gt; funcMap = new HashMap\u0026lt;\u0026gt;(); private static HashMap\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; paraMap = new HashMap\u0026lt;\u0026gt;(); funcMap构建了以函数名[f|g|h]为key，函数定义式为value的HashMap\nparaMap构建了以函数名[f|g|h]为key，函数形参formalParas为value的HashMap\n注意：这里由于存在定义式中形参x与指数符号exp重复的问题，可以考虑在addFunc过程中对x,y,z替换为w,q,r，但是这里处理也同样需要注意不要替换掉exp中的x，在callFunc中直接对w,q,r进行替换，在周三早上的研讨课听到，感觉比较优雅，原来的实现是在callFunc时判断逻辑不要让exp中x被替换。复杂度上相同，但更倾向换参版本。\n​\t其中定义出两个方法，一个是addFunc用于处理输入，在输入时将字符串传入addFunc方法，构建函数的定义式到funcMap和paraMap中，另一个是callFunc用于输入解析parser，将函数名和实参列表传入，依据之前构建好的funcMap和paraMap得到用实参替换形参之后的表达式字符串。\npublic static void addFunc(String input){ // 输入的函数定义式 //首先进行形参替换 //主要调用 String.split(\u0026#34;...\u0026#34;)方法对函数的定义式进行分割，并分别put到funcMap,paraMap } public static String callFunc(String funcName, ArrayList\u0026lt;Factor\u0026gt; actualParas) { // 自定义函数解析时使用 获得替换后的函数表达式 // 获得这个函数名对应的定义式以及形参列表 for (//遍历形参列表) { //将函数定义式中的形参用实参替换 替换时一定要注意在两边加括号！！！！！ } return funcDef; } 注：这里传入的是Factor，可以调用toString方法进行转化，在接口中定义方法toString，在各个implement class中Override，在这里我们实现的确确实实就是把形参替换成实参，只需要考虑字符串层面的操作,怎么把这一项用字符串描述出来.\nnumber：直接将数字转化为字符串\nreturn number.toString(); pow：较为简单的拼接字符串\nreturn \u0026#34;x^\u0026#34; + pow; Func类：自然而然的返回属性newFunc.\nreturn this.newFunc Exp类：由于指数exp(\u0026lt;factor\u0026gt;)^n的形式，递归调用Factor.toString方法。\npublic String toString() { // exp(factor)^n toString if (pow == 1) { return \u0026#34;exp(\u0026#34; + factor.toString() + \u0026#34;)\u0026#34;; } else { return \u0026#34;exp(\u0026#34; + factor.toString() + \u0026#34;)^\u0026#34; + pow; } } Expr类：表达式类转换为字符串，递归调用Term.toString，记得后面判断加上指数，而且左右一定要有括号\npublic String toString() { StringBuilder sb = new StringBuilder(); for (Term term : terms) { //递归 Term.toString } //加上指数 return sb.toString(); } Term类：需要注意的是项可能有符号\npublic String toString() { StringBuilder sb = new StringBuilder(); if (this.sign == -1) { sb.append(\u0026#39;-\u0026#39;); } for (Factor factor : factors) { //递归调用 factor.toString } return sb.toString(); } 需要注意的是，这个类中的属性和方法都被定义为了static属性，即这些属性和方法都是类所有的，而不是对象所有的，对于方法而言可以直接通过类进行调用。\n1.2.2.2.2 parseFunc ​\t接下来使用Definer帮助解析parseFunc.其中函数调用的形式为 $$ f(,,) $$ ​\t解析逻辑为先解析函数名，然后解析所有的实参。\n关于Func类\n在Func类中设置两个属性\nprivate String newFunc; //实参带入形参之后的结果 private Expr expr; //newFunc解析成表达式后的结果 在Func类的构造方法中，我们传入函数名[f|g|h]和实参列表actualParams，通过调用Definer类中的静态方法callFunc得到替换为实参之后的表达式，然后对表达式进行解析。\npublic Func(String name, ArrayList\u0026lt;Factor\u0026gt; actualParams) { this.newFunc = Definer.callFunc(name,actualParams); //形参替换为实参-\u0026gt;字符串 this.expr = this.setExpr(); // 解析成表达式 } private Expr setExpr() { //newFunc字符串预处理 //new lexer //new parser return parser.parseExpr(); //字符串解析为表达式 } 关于parseFunc\n负责对自定义函数中的实参部分进行解析，和函数名一同传给Func再newFunc-\u0026gt;setExpr得到解析好的表达式。\npublic Factor parseFunc(String name) { //函数调用的形式为 f(\u0026lt;factor\u0026gt;,\u0026lt;factor\u0026gt;,\u0026lt;factor\u0026gt;) 进来时正读到f //读f-LP //跳过f-LP ArrayList\u0026lt;Factor\u0026gt; actualParams = new ArrayList\u0026lt;\u0026gt;(); //将第一个实参parseFactor并加入list while (//后边还有因子) { //继续加入 } //跳过f-RP return new Func(name, actualParams); } 1.3 表达式计算输出 1.3.1 更改HashMap类型 ​\t继续沿用第一次作业中Unit和Poly的思路，这次化简结束之后的表达式形式应当为 $$ Expr \\space = \\space \\Sigma (ax^n * \\Pi exp(\u0026lt;factor_i\u0026gt;)^{n_i}) $$\n​\t即每一个Unit中的内容应当为 $$ Unit \\space = \\space ax^n * \\Pi exp(\u0026lt;factor_i\u0026gt;)^{n_i} $$ ​\t考虑到exp的形式可以进行化简，但我们先不化简，在Unit类中新增一个用于表示指数函数的HashMap。\nHashMap\u0026lt;Poly,Integer\u0026gt; expMap; key为factor的多项式 value为exp的指数 (expMap这里不同键值对之间实际上表示的是乘法关系，这样两个Unit相乘时，只需要将两个expMap合并在一起就模拟了相乘的效果）\n​\t在Poly类中新增一个存储Unit的HashMap\nHashMap\u0026lt;Unit,BigInteger\u0026gt; unitMap ​\t这里需要注意的是因为key为自定义类，需要对hashCode(),equals()方法进行重写\nequals()\nequals方法用来比较两个引用对象是否为同一个对象，在超类Objects类中的定义为比较两个引用指向的对象是否相等。\npublic boolean equals(Object obj) { return (this == obj); } 而在我们的自定义类中，我们定义出来很多属性，在我们的作业内容中，以Poly中定义的单项式哈希表为例，\nHashMap\u0026lt;Unit,BigInteger\u0026gt; unitMap ​\tUnit的属性有coe,pow,expMap。那么两个Unit之间着三个属性相同，我们就认为他们符合equals方法，判断得到应当为相同对象。因此我们应当在Unit类中覆写equals方法，加入判断这几个属性如果都相等就是相同对象的判断。为了避免空指针，使用Objects.equals进行判断。\npublic boolean equals(Object obj) { if (obj instanceof Unit) { Unit unit = (Unit) obj; return Objects.equals(coe,unit.coe) \u0026amp;\u0026amp; Objects.equals(pow,unit.pow) \u0026amp;\u0026amp; Objects.equals(expMap,unit.expMap); } else { return false; } } hashCode()\n正如方法的名称，hashCode()返回值为对象的哈希编码，即在table中的索引，用来确定对象的存储地址。在自定义类的超类\tObjects宏对于hashCode()的描述主要可以概括为以下几点\n同一对象多次调用hashCode()，要求返回值相等 如果两个对象相同，即适用于equals方法，两个对象的hashCode相同 对于我们的自定义类，我们可以通过类中的属性来计算hashCode，这样可以达到满足equals即返回相同hashCode的效果。（对于equals判断中使用的属性，计算hashCode时一定要用到，没使用的属性计算时一定不要用）。为了避免空指针，我们常调用Objects.hash(para1,para2,...)的方法进行计算。\npublic int hashCode() { return Objects.hash(coe,pow,expMap); } 1.3.2 关于去除不必要的括号 ​\t题目要求中对于必要的括号定义如下\nexp调用的括号exp() 指数函数对应的嵌套因子为不带指数的表达式因子时，该表达式因子两侧必要的一层括号 ​\t当前我的实现中，判断是否加括号的逻辑在exp(\u0026lt;poly\u0026gt;)中对poly调用toString方法时进行。此时构建的多项式结构为\n​\texp()内一定为因子，不需要加括号的因子有常数因子，幂函数，指数函数，需要加括号的因子为表达式因子。我写了返回boolean类型的addPar方法，分别对exp内的poly分情况进行判断，这里加不加括号与Unit中toString方法的优化有关，也就是说若这个Unit是常数时，返回的字符串一定是常数，而不是3*x^0之类，只要我们对每个Unit的化简足够可靠(最简)，就可以保证这里的逻辑只需要对coe,pow,expMap中有效项个数等量进行简单判断。这里主要给出判断伪代码。\npublic static boolean addPar(Poly poly) { if (//若多项式中有两项及以上) { return true; } else if (//若多项式中只有一项) { if (//系数为0) { return false; } else { if (//是数字) { return false; } else if (//是幂函数) { return false; } else if (//是指数函数) { return false; } } } return true; } 注：Simplify为定义出的用于化简的静态类，其中getValidExp用于查找exp哈希表中“有效项”，存储时形式为HashMap\u0026lt;Poly,Biginteger\u0026gt;,所谓有效项就是指数大于0\n1.3.3 对于底层项进行优化输出 ​\t对于优化输出，我的思路是在构建字符串时进行化简，而不是对字符串进行化简，在这次作业中我进行的优化有\nexp(0)=1 合并同类项 对exp()中的多项式提取公因数 以及上一次作业中的对于指数为0/1，系数为0/1/-1的情况进行判断输出 ​\t一定要慎重优化，避免出现bug!\n​\t对于优化，我单独建立了Simplify类，其中定义出多个静态方法用于表达式化简，这里一定要与addPar中的逻辑对应，即相应的数字，幂函数，指数函数都要化简为最简的形式。\n1.4 序列化深克隆方法 ​\t在进行优化输出的过程中，涉及到对Unit，Poly等类的深克隆，为了避免对这些类中的对象进行递归克隆，我采用了序列化克隆的方法（有模版比较省事），只需要把Unit以及Poly接到Serializable接口上并重写cloneSerializable方法即可。给出克隆模版\npublic Unit cloneSerializable() { Unit unit = null; try { //序列化对象 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); //反序列化对象 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); unit = (Unit) ois.readObject(); } catch (Exception e) { e.printStackTrace(); } return unit; } ​\t我认为这个方法是极为方便的，唯一的缺点就是会导入一堆java.io包，IDEA可能会自动帮你合并为java.io.*，但这是不符合代码规范的，需要手动调整。\n2. 代码分析 2.1 UML类图分析 2.2 代码复杂度分析 ​\t爆复杂度部分和上次作业一样集中在输入预处理以及输出化简部分。\n3. bug分析 第二次作业中出现了优化bug，提出exp中gcd时忘记不能提出负数，导致强测和互测被刀 数据范围问题 Integer.parseInteger()被爆范围 ","permalink":"https://coder0xe.github.io/posts/oo-unit1-hw2/","summary":"\u003ch1 id=\"oo第一单元第二次作业\"\u003e\u003ccenter\u003eOO第一单元第二次作业\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"0题目需求分析\"\u003e0.题目需求分析\u003c/h2\u003e\n\u003ch3 id=\"01-概念分析\"\u003e0.1 概念分析\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本次作业在第一次作业的基础上添加了指数函数和自定义函数，其中\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e需要支持嵌套多层括号\u003c/li\u003e\n\u003cli\u003e新增指数因子，指数函数括号内部包含任意因子\u003c/li\u003e\n\u003cli\u003e新增自定义函数因子，自定义函数的表达式会给出且其中不会调用其他自定义函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e本次迭代表达式架构上的改变\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e支持前导0的十进制带符号整数\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e因子\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e变量因子\u003c/strong\u003e，\u003ccode\u003ex\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e幂函数\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e一般形式\u003c/strong\u003e：\u003ccode\u003ex^非负整数\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e省略形式\u003c/strong\u003e：指数为1，\u003ccode\u003ex\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e指数函数：特指以e为底数的指数函数，表示为exp(\u0026lt;因子\u0026gt;)等\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e一般形式：\u003c/strong\u003e\u003ccode\u003eexp(\u0026lt;因子\u0026gt;)^指数\u003c/code\u003e，注：该指数为\u003ccode\u003eexp()\u003c/code\u003e整体的指数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexp()\u003c/code\u003e的指数为非负整数\u003c/li\u003e\n\u003cli\u003e**省略形式：**指数为1时，写为\u003ccode\u003eexp(\u0026lt;因子\u0026gt;)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e自定义函数\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e自定义函数中不会调用其他自定义函数，定义类似于\u003c/p\u003e\n\u003cp\u003ef(x,y,z) = 表达式（可能不全部包含x,y,z这三个变量）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ef\u003c/code\u003e,\u003ccode\u003eg\u003c/code\u003e,\u003ccode\u003eh\u003c/code\u003e是函数的函数名，本次作业中的自定义函数名只包括\u003ccode\u003ef\u003c/code\u003e,\u003ccode\u003eg\u003c/code\u003e,\u003ccode\u003eh\u003c/code\u003e即最多只有三个自定义函数\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ex\u003c/code\u003e,\u003ccode\u003ey\u003c/code\u003e,\u003ccode\u003ez\u003c/code\u003e是函数的形参，形参个数为1~3个，且同一函数定义中不会出现重复使用的形参\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e函数表达式为关于形参的表达式\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e函数调用的形式为f(因子，因子，因子)，例如f(x^2),g(exp(x^2),exp(x)),h(1,0,-0)，因子为函数调用中的实参，包含任意一种因子\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e注意：函数定义中不允许出现自定义函数，但是函数调用中的实参可以是自定义函数\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e常数因子\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e表达式因子\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e项\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e表达式\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t关于去括号要求中的**“必要的括号”**\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e指数函数调用时必要的一层括号\u003ccode\u003eexp()\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e指数函数对应的嵌套因子为\u003cstrong\u003e不带指数的表达式因子\u003c/strong\u003e时，该因子两侧必要的一层括号，例如\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eexp((x+1)^2)\u003c/code\u003e中\u003ccode\u003e(x+1)\u003c/code\u003e中的括号是不合法的，需要展开为不带指数的形式\u003ccode\u003eexp((x^2+2*x+1))\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"02-表达式架构图\"\u003e0.2 表达式架构图\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e大致保留之前的架构，新增指数函数因子类和自定义函数因子类\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240306101304740\" loading=\"lazy\" src=\"/img/image-20240306101304740.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"1处理流程分析\"\u003e1.处理流程分析\u003c/h2\u003e\n\u003ch3 id=\"11-字符串预处理\"\u003e1.1 字符串预处理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e由于自定义函数的引入，可以新增去除\u003ccode\u003e,\u003c/code\u003e后不必要的\u003ccode\u003e+\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"12-语义分析\"\u003e1.2 语义分析\u003c/h3\u003e\n\u003ch4 id=\"121-lexer\"\u003e1.2.1 Lexer\u003c/h4\u003e\n\u003cp\u003e​\t本次作业中，新增了\u003ccode\u003eEXP\u003c/code\u003e,\u003ccode\u003eF\u003c/code\u003e,\u003ccode\u003eG\u003c/code\u003e,\u003ccode\u003eH\u003c/code\u003e,\u003ccode\u003eCOMMA\u003c/code\u003e(逗号)等token，需要增加识别功能。\u003c/p\u003e\n\u003ch4 id=\"122-parser\"\u003e1.2.2 Parser\u003c/h4\u003e\n\u003ch5 id=\"1221-parseexp\"\u003e1.2.2.1 parseExp\u003c/h5\u003e\n\u003cp\u003e​\t在\u003ccode\u003eParser\u003c/code\u003e类中新建一个方法\u003ccode\u003eparseExp\u003c/code\u003e，当我们读到的\u003ccode\u003etoken\u003c/code\u003e为\u003ccode\u003eEXP\u003c/code\u003e时调用该方法进行解析。\u003cstrong\u003e首先对括号内的因子进行解析，再对括号外的指数进行解析。\u003c/strong\u003e\n$$\nexp(\u003cfactor\u003e)^n \\space | \\space exp(\u003cfactor\u003e)\n$$\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e    public Factor parseExp() { // exp(\u0026lt;factor\u0026gt;)^\u0026lt;num\u0026gt; | exp(\u0026lt;factor\u0026gt;)\n        // lexer : exp -\u0026gt; pos = pos + 4 already into the (\n        // 读到RP时接着往后读看有没有指数\n        int pow = 1;//默认指数为1\n        Factor innerFactor = parseFactor();\n        if (lexer.getCurTokenType() == TokenType.POW) {\n            // 后面有指数\n        }\n        return new Exp(innerFactor, pow);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003ch5 id=\"1222-parsefunc\"\u003e1.2.2.2 parseFunc\u003c/h5\u003e\n\u003ch6 id=\"12221-definer\"\u003e1.2.2.2.1 Definer\u003c/h6\u003e\n\u003cp\u003e​\t为了成功地解析自定义函数，我们首先定义出\u003ccode\u003eDefiner\u003c/code\u003e类，\u003cstrong\u003e他的主要作用是处理自定义函数的定义以及调用\u003c/strong\u003e。（相当于\u003ccode\u003eparseFunc\u003c/code\u003e的\u003ccode\u003eslave\u003c/code\u003e）其中定义出两个\u003ccode\u003eHashMap\u003c/code\u003e\u003c/p\u003e","title":"OO-Unit1-hw2"},{"content":"OS预习题三：MIPS 一.思路分析 ​\t刚开始拿到课程组给出的源文件感觉有点发蒙，我们要补全的代码为start.S，文件结构如下\n​\t和题目有关联的主要文件为需要补全的汇编代码start.S，start.S中调用hello.c以及output.c中的函数。这里我们回忆一下编译的过程，如下图\n​\t这时我刚刚回想起汇编文件是.c文件通过编译得到（这里助教推荐汇编文件的后缀名写为.S而不是.s）。题目的要求是补全汇编代码，具体来说就是为函数分配栈帧。\n问题1分析\n首先分析为print_str创建栈帧，该函数只传递一个参数。\nvoid print_str(const char *buf) { for (int i = 0; buf[i]; i++) { printcharc(buf[i]); } } ​\t我在做题目时的疑问是：用不用为函数的返回地址$ra创建栈空间呢？这个问题实际上就是要分析$ra寄存器的值在函数调用过程中会不会被覆写掉(jr $ra返回)。我们现在分析这个代码的调用过程，有了上学期的MIPS汇编编写经验，相信会比较轻松.print_str内部调用printcharc，这个调用会改变$ra的值，但是我们并不需要考虑维护，因为这个维护是由编译器进行的，**不要忘记该段代码为C语言，还在汇编语言的上层，我们如果想要建立起“平等”的视角，需要把该段代码转换为汇编代码，这就是编译器的工作。**故我们经过分析可以知道，在printstr每次调用子进程时，编译器都为我们做好了各个寄存器的维护，即最后返回时$ra即为初始值，故该段代码我们只需要为其参数分配空间，结束调用后再返还空间（也可以试着脑补把C代码翻译为MIPS，这样就会发现其实翻译过程中会涉及到对$ra等寄存器的维护，这其实就是模拟了编译器为其分配栈帧的过程，可能这样会理解的更深入一些？）\naddiu sp,sp,-4 问题二分析\n问题二实际上就是考察了如果传递六个参数应当怎样分配栈空间，\n前四个参数由寄存器a0-a3传递，栈帧中只需要为其分配栈空间，不需要进行存值 后两个参数需要在分配的空间中保存值 这样六个参数需要24字节\naddiu sp,sp,-24 lw $\u0026lt;\u0026gt;, 16(sp) lw $\u0026lt;\u0026gt;, 20(sp) 注：栈是向下生长的，分配栈空间需要将栈指针sp向下移动，填充参数不断向上移动sp\n二.补全后代码 #include \u0026lt;asm/asm.h\u0026gt; .data str: .asciiz \u0026#34;Hello World\\n\u0026#34; # Null-terminated string \u0026#34;Hello World\u0026#34; stored at label \u0026#39;str\u0026#39; .align 2 # align to 4-byte boundary (2^2) var: .byte 3 # correctly aligned byte: 3 /* \u0026#39;\u0026lt;x\u0026gt;\u0026#39; in the comments is the part to be replaced. */ /* use \u0026#39;.align \u0026lt;x\u0026gt;\u0026#39; to align the following words to 1-byte boundary (disabling word-alignment) */ /* so that the byte 3 and word 7 is \u0026#34;connected\u0026#34; */ /* Your code here. (1/6) */ .align 0 .word 7, 8, 9 .text /* We define \u0026#39;_start_mips\u0026#39; here as the entry of our program. */ EXPORT(_start_mips) .set at .set reorder mtc0 zero, CP0_STATUS li sp, 0x84000000 /* Load the address of the string \u0026#39;str\u0026#39; into the first parameter register. */ la a0, str /* use \u0026#39;addiu sp, sp, \u0026lt;x\u0026gt;\u0026#39; to push a proper-sized frame onto the stack for Nonleaf function \u0026#39;print_str\u0026#39;. */ /* Your code here. (2/6) */ addiu sp, sp,-4 jal print_str /* use \u0026#39;addiu sp, sp, \u0026lt;x\u0026gt;\u0026#39; to restore stack pointer. */ /* Your code here. (3/6) */ addiu sp, sp,4 /* Set the first four parameters. */ li a0, 0 li a1, 1 li a2, 2 li a3, 3 /* use \u0026#39;addiu sp, sp, \u0026lt;x\u0026gt;\u0026#39; to push a proper-sized frame onto the stack for Nonleaf function \u0026#39;hello\u0026#39;. */ /* Your code here. (4/6) */ addiu sp, sp, -24 lw t1, var\tli t2, 5 /* use \u0026#39;sw t1, \u0026lt;x\u0026gt;(sp)\u0026#39; to store t1 at the proper place of the stack */ /* so that t1 is 5th argument of function hello. */ /* Your code here. (5/6) */ sw t1, 16(sp) /* use \u0026#39;sw t2, \u0026lt;x\u0026gt;(sp)\u0026#39; to store t2 at the proper place of the stack */ /* so that t2 is 6th argument of function hello. */ /* Your code here. (6/6) */ sw t2, 20(sp) /* use \u0026#39;j\u0026#39; to call the function \u0026#39;hello\u0026#39;, we use \u0026#39;j\u0026#39; instead of \u0026#39;jal\u0026#39; because \u0026#39;hello\u0026#39; is \u0026#39;noreturn\u0026#39; */ j hello ","permalink":"https://coder0xe.github.io/posts/ospre-mips/","summary":"\u003ch1 id=\"os预习题三mips\"\u003e\u003ccenter\u003eOS预习题三：MIPS\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"一思路分析\"\u003e一.思路分析\u003c/h2\u003e\n\u003cp\u003e​\t刚开始拿到课程组给出的源文件感觉有点发蒙，我们要补全的代码为\u003ccode\u003estart.S\u003c/code\u003e，文件结构如下\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240302194456589\" loading=\"lazy\" src=\"/img/image-20240302194456589.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t和题目有关联的主要文件为需要补全的汇编代码\u003ccode\u003estart.S\u003c/code\u003e，\u003ccode\u003estart.S\u003c/code\u003e中调用\u003ccode\u003ehello.c\u003c/code\u003e以及\u003ccode\u003eoutput.c\u003c/code\u003e中的函数。这里我们回忆一下编译的过程，如下图\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240303175249973\" loading=\"lazy\" src=\"/img/image-20240303175249973.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t这时我刚刚回想起汇编文件是\u003ccode\u003e.c\u003c/code\u003e文件通过编译得到（这里助教推荐汇编文件的后缀名写为\u003ccode\u003e.S\u003c/code\u003e而不是\u003ccode\u003e.s\u003c/code\u003e）。题目的要求是补全汇编代码，具体来说就是为函数分配栈帧。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e问题1分析\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e首先分析为\u003ccode\u003eprint_str\u003c/code\u003e创建栈帧，该函数只传递一个参数。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e void print_str(const char *buf) {\n      for (int i = 0; buf[i]; i++) {\n          printcharc(buf[i]);\n      }\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t我在做题目时的疑问是：用不用为函数的返回地址\u003ccode\u003e$ra\u003c/code\u003e创建栈空间呢？这个问题实际上就是要分析\u003ccode\u003e$ra\u003c/code\u003e寄存器的值在函数调用过程中会不会被覆写掉(\u003ccode\u003ejr $ra\u003c/code\u003e返回)。我们现在分析这个代码的调用过程，\u003cdel\u003e有了上学期的MIPS汇编编写经验，相信会比较轻松\u003c/del\u003e.\u003ccode\u003eprint_str\u003c/code\u003e内部调用\u003ccode\u003eprintcharc\u003c/code\u003e，这个调用会改变\u003ccode\u003e$ra\u003c/code\u003e的值，但是我们并不需要考虑维护，\u003cstrong\u003e因为这个维护是由编译器进行的\u003c/strong\u003e，**不要忘记该段代码为C语言，还在汇编语言的上层，我们如果想要建立起“平等”的视角，需要把该段代码转换为汇编代码，这就是编译器的工作。**故我们经过分析可以知道，在\u003ccode\u003eprintstr\u003c/code\u003e每次调用子进程时，编译器都为我们做好了各个寄存器的维护，即最后返回时\u003ccode\u003e$ra\u003c/code\u003e即为初始值，故该段代码我们只需要为其参数分配空间，结束调用后再返还空间（也可以试着脑补把C代码翻译为MIPS，这样就会发现其实翻译过程中会涉及到对\u003ccode\u003e$ra\u003c/code\u003e等寄存器的维护，这其实就是模拟了编译器为其分配栈帧的过程，可能这样会理解的更深入一些？）\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eaddiu sp,sp,-4\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e问题二分析\u003c/p\u003e\n\u003cp\u003e问题二实际上就是考察了如果传递六个参数应当怎样分配栈空间，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e前四个参数由寄存器\u003ccode\u003ea0-a3\u003c/code\u003e传递，栈帧中只需要为其分配栈空间，不需要进行存值\u003c/li\u003e\n\u003cli\u003e后两个参数需要在分配的空间中保存值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样六个参数需要24字节\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eaddiu sp,sp,-24\nlw $\u0026lt;\u0026gt;, 16(sp)\nlw $\u0026lt;\u0026gt;, 20(sp)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e注：栈是向下生长的，分配栈空间需要将栈指针sp向下移动，填充参数不断向上移动sp\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"二补全后代码\"\u003e二.补全后代码\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#include \u0026lt;asm/asm.h\u0026gt;\n.data\nstr:\n.asciiz \u0026#34;Hello World\\n\u0026#34;  # Null-terminated string \u0026#34;Hello World\u0026#34; stored at label \u0026#39;str\u0026#39;\n.align 2 # align to 4-byte boundary (2^2)\nvar:\n.byte 3 # correctly aligned byte: 3\n/* \u0026#39;\u0026lt;x\u0026gt;\u0026#39; in the comments is the part to be replaced. */\n/* use \u0026#39;.align \u0026lt;x\u0026gt;\u0026#39; to align the following words to 1-byte boundary (disabling word-alignment) */\n/* so that the byte 3 and word 7 is \u0026#34;connected\u0026#34; */\n/* Your code here. (1/6) */\n.align 0\n.word 7, 8, 9\n\n.text\n/* We define \u0026#39;_start_mips\u0026#39; here as the entry of our program. */\nEXPORT(_start_mips)\n.set at\n.set reorder\n\tmtc0    zero, CP0_STATUS\n\tli      sp, 0x84000000\n\t/* Load the address of the string \u0026#39;str\u0026#39; into the first parameter register. */\n\tla      a0, str\n\t/* use \u0026#39;addiu  sp, sp, \u0026lt;x\u0026gt;\u0026#39; to push a proper-sized frame onto the stack for Nonleaf function \u0026#39;print_str\u0026#39;. */\n\t/* Your code here. (2/6) */\n        addiu   sp, sp,-4 \n\tjal     print_str\n\t/* use \u0026#39;addiu  sp, sp, \u0026lt;x\u0026gt;\u0026#39; to restore stack pointer. */\n\t/* Your code here. (3/6) */\n        addiu   sp, sp,4\n\t/* Set the first four parameters. */\n\tli      a0, 0\n\tli      a1, 1\n\tli      a2, 2\n\tli      a3, 3\n\t/* use \u0026#39;addiu  sp, sp, \u0026lt;x\u0026gt;\u0026#39; to push a proper-sized frame onto the stack for Nonleaf function \u0026#39;hello\u0026#39;. */\n\t/* Your code here. (4/6) */\n        addiu   sp, sp, -24\n\tlw      t1, var\t\n\tli      t2, 5\n\t/* use \u0026#39;sw  t1, \u0026lt;x\u0026gt;(sp)\u0026#39; to store t1 at the proper place of the stack */\n\t/* so that t1 is 5th argument of function hello. */\n\t/* Your code here. (5/6) */\n        sw      t1, 16(sp)\n\t/* use \u0026#39;sw  t2, \u0026lt;x\u0026gt;(sp)\u0026#39; to store t2 at the proper place of the stack */\n\t/* so that t2 is 6th argument of function hello. */\n\t/* Your code here. (6/6) */\n        sw      t2, 20(sp)\n\t/* use \u0026#39;j\u0026#39; to call the function \u0026#39;hello\u0026#39;, we use \u0026#39;j\u0026#39; instead of \u0026#39;jal\u0026#39; because \u0026#39;hello\u0026#39; is \u0026#39;noreturn\u0026#39; */\n\tj       hello\n\u003c/code\u003e\u003c/pre\u003e","title":"OSpre-mips"},{"content":"OS预习题2：Makefile ​\t此题只要观察题目中给出的依赖关系树形图即可解决，我的思路是自底向上逐层构建依赖\n​\t源代码为\n.PHONY: clean out: calc case_all ./calc \u0026lt; case_all \u0026gt; out case_all: case_add case_sub case_mul case_div cat case_add case_sub case_mul case_div \u0026gt; case_all case_add: casegen ./casegen \u0026#34;add\u0026#34; 100 \u0026gt; case_add case_sub: casegen ./casegen \u0026#34;sub\u0026#34; 100 \u0026gt; case_sub case_mul: casegen\t./casegen \u0026#34;mul\u0026#34; 100 \u0026gt; case_mul case_div: casegen ./casegen \u0026#34;div\u0026#34; 100 \u0026gt; case_div calc: calc.c gcc -o calc calc.c casegen: casegen.c gcc -o casegen casegen.c clean: rm -f out calc casegen case_* *.o TIPS\n直接执行make相当于构建文件中第一个目标，在这里相当于make out\n关于gcc -o,-o选项为编译结果指定名称，我更喜欢下面写法\ngcc cal.c -o cal 关于Makefile的模版\n\u0026lt;target\u0026gt;: \u0026lt;dependencies\u0026gt; \u0026lt;tab\u0026gt; \u0026lt;command1\u0026gt; ... \u0026lt;tab\u0026gt; \u0026lt;commandb\u0026gt; 关于重定向输入与输出\n我们要为一个程序传递参数，这时可以使用重定向输入\u0026lt;，可以在后面直接给出，或者从文件中给出，例如上面代码中\n./casegen \u0026#34;add\u0026#34; 100 \u0026gt; case_add 若保存在文件中\n./casegen \u0026lt; input.txt \u0026gt; case_add ","permalink":"https://coder0xe.github.io/posts/makefile/","summary":"\u003ch1 id=\"os预习题2makefile\"\u003e\u003ccenter\u003eOS预习题2：Makefile\u003c/center\u003e\u003c/h1\u003e\n\u003cp\u003e​\t此题只要观察题目中给出的依赖关系树形图即可解决，\u003cstrong\u003e我的思路是自底向上逐层构建依赖\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240302111406862\" loading=\"lazy\" src=\"/img/image-20240302111406862.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t源代码为\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e.PHONY: clean\n \nout: calc case_all\n\t./calc \u0026lt; case_all \u0026gt; out\n\ncase_all: case_add case_sub case_mul case_div\n\tcat case_add case_sub case_mul case_div \u0026gt; case_all\n\ncase_add: casegen\n\t./casegen \u0026#34;add\u0026#34; 100 \u0026gt; case_add\n\ncase_sub: casegen\n\t./casegen \u0026#34;sub\u0026#34; 100 \u0026gt; case_sub\n\ncase_mul: casegen\t\n\t./casegen \u0026#34;mul\u0026#34; 100 \u0026gt; case_mul\n\ncase_div: casegen\n\t./casegen \u0026#34;div\u0026#34; 100 \u0026gt; case_div\n\ncalc: calc.c\n\tgcc -o calc calc.c\n\ncasegen: casegen.c\n\tgcc -o casegen casegen.c\n   \nclean:\n    rm -f out calc casegen case_* *.o\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTIPS\u003c/p\u003e","title":"makefile"},{"content":"OS预习题1：c-exercise ​\tOS预习教程中第一道练习题，要求自行实现函数库中几个对于字符串进行操作的函数，为之后的实验打好基础(恢复已经遗忘的C语言记忆)，在做完之后，我搜索了标准库函数中他们的实现，更加简洁优雅。\n1. strlen 我的实现\nsize_t strlen(const char *s) { size_t i = 0; while(s[i] != \u0026#39;\\0\u0026#39;) { i++; } return i; } 关于size_t类型：size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。它是为了方便系统之间的移植而定义的，不同的系统上，定义size_t 可能不一样。**size_t在32位系统上定义为 unsigned int，也就是32位无符号整型。在64位系统上定义为 unsigned long ，也就是64位无符号整形。**size_t 的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。 标准库中的实现\nint strlen(const char *str) { const char *p = str; while(*p != \u0026#39;\\0\u0026#39;) ++p; return p - str; } 可以看出，标准库中的实现优雅之处在于使用了指针间的减法来计算长度。 C语言中的指针运算 ​\t这里参考绿皮书对C语言中的指针运算进行简单回顾。\n​\t若n是一个整形量，p是一个指针，则p+n和p-n是合法的指针运算表达式，指针类型不变，表达式的值由下式确定 $$ value(p \\pm n) \\space = value(p) \\space \\pm n*sizeof(T) $$ ​\t即我们知道指针的移动是以指针变量类型的元素为步长移动的而不是以字节为单位进行移动的（这个bug在后面的strsep中我犯过）\n​\nC语言中其他关于指针的基本概念 指针: 指针即地址，变量类型后加*代表指针变量类型\nint *p = \u0026amp;a 指针的解引用：代表指针指向的内容\nint a = 5; int * p = \u0026amp;a; *p = 5 关于数组名：数组名即为数组首地址，也是数组第一个元素的地址，可以作为指针使用\n常量指针和指针常量\n常量指针：指向常量的指针(这个在strsep中用过，当时以为是指针常量，很奇怪)\nconst char* p 指针常量：固定指向的指针\nchar* const p 这两个总是分不清楚 首先记住指针常量吧，从英文字面上理解\nchar*(指针) const(常量) p 指针与下标 $$ p[n] \\space = \\space *(p+n) $$\n$$ \u0026amp;p[n] = p + n $$\n如果数组index\u0026lt;0说明向当前指针负向移动，否则正向\n2. strcat \u0026amp;\u0026amp; strncat 1. strcat 我的实现\nchar * strcat(char *dst, const char *src) { char *temp = dst; while(*temp != \u0026#39;\\0\u0026#39;){ temp++; } while(*src != \u0026#39;\\0\u0026#39;){ *temp = *src; temp++; src++; } *temp = \u0026#39;\\0\u0026#39;; return dst; } 标准实现\nchar * strcat (char * dst, const char * src) { char * cp = dst; while( *cp ) ++cp; /* Find end of dst */ while( *cp++ = *src++ ) ; /* Copy src to end of dst */ return( dst ); } 2. strncat 我的实现\nchar *strncat(char *dst, const char *src, size_t n){ size_t oplength = n; if(strlen(src) \u0026lt; n) { oplength = strlen(src); } char * temp = dst; while(*temp != \u0026#39;\\0\u0026#39;) { temp++; } for(size_t i = 0;i \u0026lt; oplength;i++) { *temp++ = *src++; } *temp = \u0026#39;\\0\u0026#39;; return dst; } 标准实现\nchar *strncat (char *front, const char *back, unsigned count) { char *start = front; while (*front++) ; front--; while (count--) if ((*front++ = *back++) == \u0026#39;\\0\u0026#39;) return(start); *front = \u0026#39;\\0\u0026#39;; return(start); } 3. strsep 这个函数之前没遇到过，先简单解释一下概念，概括起来就是进行字符串分割\n这个函数定义为 $$ char* strsep(char** stringp, const char* delim) $$\nstringp是指针的指针(虽然不知道为什么这么设计)，他解引用得到的字符串就是我们要处理的字符串 delim是一个分割符字符串，其中的每个字符都是可以用来分隔字符串的分隔符 该函数的主要功能是在字符串中找到第一个出现的分隔符，用 ‘\\0’ 替换它，并返回指向原始分隔符之前的子字符串的指针。然后，通过更新传递给函数的指针来指向原始字符串的下一个位置（这个是教程中的叙述，我认为读起来非常拗口，他的大致意思就是这个函数只会对字符串中从左到右出现的第一个分隔符进行分割，把该位置的字符替换为\\0，之后调整*stringp的位置为该分隔符之后，返回值为原始的*stringp） 如果 strsep 的第一个参数所指向字符串的指针为 NULL（即 *strsep == NULL），那么函数直接返回 NULL，而不会执行任何分割操作。 如果 *stringp 字符串中没有找到任一分隔符， *stringp 会被设置为 NULL。 我的实现\nchar* strsep(char** stringp, const char* delim){ char *temp = *stringp; char *preStringp = *stringp; if(temp == NULL) { return NULL; } else { while(*temp != \u0026#39;\\0\u0026#39;) { const char* delete = delim; while(*delete != \u0026#39;\\0\u0026#39;) { if(*delete == *temp) { *temp = \u0026#39;\\0\u0026#39;; *stringp = temp + 1; return preStringp; } delete++; } temp++; } if(*temp == \u0026#39;\\0\u0026#39;){ *stringp = NULL; } return preStringp; } } 我的代码中出现过一处Bug就是前文提到的指针运算问题，未修改前，最外层while中我使用*stringp作为循环变量，但这个指针类型是字符串指针，一次移动当前字符串的字节大小，出现bug 标准库实现\nchar *strsep(char **stringp, const char *delim) { char *s; const char *spanp; int c, sc; char *tok; if ((s = *stringp)== NULL) return (NULL); for (tok = s;;) { c = *s++; spanp = delim; do { if ((sc =*spanp++) == c) { if (c == 0) s = NULL; else s[-1] = 0; *stringp = s; return (tok); } } while (sc != 0); } } 涉及到char和int形之间的转换，用char形值赋给int形会默认复制为他的ascii值，这里\\0的ascii值为0 ","permalink":"https://coder0xe.github.io/posts/c-exercise/","summary":"\u003ch1 id=\"os预习题1c-exercise\"\u003e\u003ccenter\u003eOS预习题1：c-exercise\u003c/center\u003e\u003c/h1\u003e\n\u003cp\u003e​\tOS预习教程中第一道练习题，要求自行实现函数库中几个对于字符串进行操作的函数，为之后的实验打好基础(\u003cdel\u003e恢复已经遗忘的C语言记忆\u003c/del\u003e)，在做完之后，我搜索了标准库函数中他们的实现，更加简洁优雅。\u003c/p\u003e\n\u003ch2 id=\"1-strlen\"\u003e1. strlen\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e我的实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esize_t strlen(const char *s) {\n    size_t i  = 0;\n    while(s[i] != \u0026#39;\\0\u0026#39;) {\n        i++;\n    }\n    return i;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e关于\u003ccode\u003esize_t\u003c/code\u003e类型：size_t 类型表示\u003cstrong\u003eC中任何对象所能达到的最大长度\u003c/strong\u003e，它是无符号整数。它是为了方便系统之间的移植而定义的，不同的系统上，定义size_t 可能不一样。**size_t在32位系统上定义为 unsigned int，也就是32位无符号整型。在64位系统上定义为 unsigned long ，也就是64位无符号整形。**size_t 的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e标准库中的实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eint strlen(const char *str)\n{\n    const char *p = str;\n    while(*p != \u0026#39;\\0\u0026#39;)\n        ++p;\n    return p - str;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e可以看出，标准库中的实现优雅之处在于使用了指针间的减法来计算长度。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"c语言中的指针运算\"\u003eC语言中的指针运算\u003c/h3\u003e\n\u003cp\u003e​\t这里参考绿皮书对C语言中的指针运算进行简单回顾。\u003c/p\u003e\n\u003cp\u003e​\t\u003cem\u003e\u003cstrong\u003e若n是一个整形量，p是一个指针，则p+n和p-n是合法的指针运算表达式，指针类型不变，表达式的值由下式确定\u003c/strong\u003e\u003c/em\u003e\n$$\nvalue(p \\pm n) \\space = value(p) \\space \\pm n*sizeof(T)\n$$\n​\t即我们知道\u003cstrong\u003e指针的移动是以指针变量类型的元素为步长移动的而不是以字节为单位进行移动的\u003c/strong\u003e（这个bug在后面的strsep中我犯过）\u003c/p\u003e","title":"c-exercise"},{"content":"QEMU ​\t为了开发和运行我们的MOS操作系统，必须要有配套的支持操作系统运行的硬件系统，我们使用硬件模拟器实现。模拟器能够模拟计算机硬件的行为和特性。我们使用QEMU(quick enulator)\n1. QEMU的使用 实验中已经将所有需要用到的QEMU操作写到了Makefile中\n我们的实验基于MIPS架构\n​\t使用QEMU提供的MIPS环境编译运行代码的指令\n// minimal_hello_world.c void printch(char ch) { *((volatile char *)(0xB80003f8U)) = ch; } void print(char *str) { while (*str != \u0026#39;\\0\u0026#39;) { printch(*str); str++; } } void __start() { print(\u0026#34;Hello, world!\\n\u0026#34;); while (1) { } } 编译 编译需要使用交叉编译器mips-linux-gnu-gcc\n$ mips-linux-gnu-gcc \\ -EL \\ -nostdlib \\ -o hello_world.elf \\ minimal_hello_world.c ​\t生成目标文件为hello_world.elf\n运行\n所有的QEMU指令都是qemu-的形式，对于某一体系架构下的模拟，使用\nqemu-system-* 对于小端序的mips架构，对应命令为\nqemu-system-mipsel 运行以上示例代码\n$ qemu-system-mipsel \\ -m 64 \\ -nographic \\ -M malta \\ -no-reboot \\ -kernel hello_world.elf Hello, world! qemu-system-mipsel：指定小端序mips架构 -nographic模拟中不使用图形界面，使用串口输出 -M 制定模拟的目标机器，这里模拟的是MIPS melta开发板 -no-reboot虚拟机直接退出而不是重启 -kernel指定要启动的内核 退出QEMU\nctrl + A+x 2. 在QEMU中使用GDB调试 QEMU原生支持GDB调试\n编译指令中添加-g选项生成可供调试的debug版本\n$ mips-linux-gnu-gcc \\ -g \\ -EL \\ -nostdlib \\ -o hello_world.elf \\ minimal_hello_world.c 运行指令\n$ qemu-system-mipsel \\ -s \\ -S \\ -m 64 \\ -nographic \\ -M malta \\ -no-reboot \\ -kernel hello_world.elf \\ \u0026lt; /dev/null \\ \u0026amp; -S让模拟器不要再一开始就启动处理器 -s等待GDB连接到1234端口（GDB 和 QEMU 的协作是通过远程连接进行） 我们要在同一个终端中运行 QEMU 和 GDB。所以 QEMU 需要在后台运行。这时我们必须将其标准输入重定向为 /dev/null ps指令查看当前终端下运行的进程\n为了适应我们的MIPS架构，需要使用gdb-multiarch进行调试\n进入gdb-multiarch后进行架构设置\n(gdb) set architecture mips (set architecture + tab可以查看所有架构)\n连接QEMU的1234端口\n(gdb) target remote localhost:1234 QEMU不支持run或start\n退出前杀死QEMU进程（防止占用1234端口）\nps查看所有进程，或配合使用grep正则匹配指令\nps | grep qemu kill杀死进程\nkill -9 \u0026lt;id\u0026gt; 或者直接\npkill -9 qemu ","permalink":"https://coder0xe.github.io/posts/qemu/","summary":"\u003ch1 id=\"qemu\"\u003e\u003ccenter\u003eQEMU\u003c/center\u003e\u003c/h1\u003e\n\u003cp\u003e​\t为了开发和运行我们的MOS操作系统，必须要有配套的支持操作系统运行的硬件系统，我们使用硬件模拟器实现。模拟器能够模拟计算机硬件的行为和特性。我们使用QEMU(\u003ccode\u003equick enulator\u003c/code\u003e)\u003c/p\u003e\n\u003ch2 id=\"1-qemu的使用\"\u003e1. QEMU的使用\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e实验中已经将所有需要用到的QEMU操作写到了\u003ccode\u003eMakefile\u003c/code\u003e中\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e我们的实验基于MIPS架构\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t使用QEMU提供的MIPS环境编译运行代码的指令\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// minimal_hello_world.c\nvoid printch(char ch) { *((volatile char *)(0xB80003f8U)) = ch; }\n\nvoid print(char *str) {\n    while (*str != \u0026#39;\\0\u0026#39;) {\n        printch(*str);\n        str++;\n    }\n}\n\nvoid __start() {\n    print(\u0026#34;Hello, world!\\n\u0026#34;);\n    while (1) {\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e编译\u003c/strong\u003e 编译需要使用交叉编译器\u003ccode\u003emips-linux-gnu-gcc\u003c/code\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$ mips-linux-gnu-gcc \\\n        -EL \\\n        -nostdlib \\\n        -o hello_world.elf \\\n        minimal_hello_world.c\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t生成目标文件为\u003ccode\u003ehello_world.elf\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e运行\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e所有的QEMU指令都是\u003ccode\u003eqemu-\u003c/code\u003e的形式，对于某一体系架构下的模拟，使用\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eqemu-system-*\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e对于小端序的mips架构，对应命令为\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eqemu-system-mipsel\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e运行以上示例代码\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$ qemu-system-mipsel \\\n        -m 64 \\\n        -nographic \\\n        -M malta \\\n        -no-reboot \\\n        -kernel hello_world.elf\nHello, world!\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eqemu-system-mipsel\u003c/code\u003e：指定小端序mips架构\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-nographic\u003c/code\u003e模拟中不使用图形界面，使用串口输出\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-M\u003c/code\u003e 制定模拟的目标机器，这里模拟的是\u003ccode\u003eMIPS melta\u003c/code\u003e开发板\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-no-reboot\u003c/code\u003e虚拟机直接退出而不是重启\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-kernel\u003c/code\u003e指定要启动的内核\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e退出QEMU\u003c/p\u003e","title":"QEMU"},{"content":"GDB终端调试 1. 编译产生Debug版本 ​\t我们在操作系统实验中使用gdb在终端中进行代码调试。在之前的章节中，我们已经学到可以使用\ngcc add.c -o adds ​\t指令来对源代码进行编译。但是采用这种方法编译产生的目标程序是Release版本，并不支持我们使用gdb进行调试，要想产生支持gdb调试的Debug版本，我们需要在原编译指令的基础上加入-g参数，具体指令为\ngcc -g add.c -o adds 2. GDB操作 1.进入GDB进行调试 ​\t对编译好的程序运行gdb有两种方式，\n一种是直接指定文件进入gdb模式\ngdb adds 或者先进入gdb模式，再加载可执行文件\n$ gdb (gdb) file \u0026lt;filename\u0026gt; 2.运行程序 (gdb) run 3.退出gdb模式 quit 4. 传入额外参数 // echo.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void usage() { printf(\u0026#34;usage: echo \u0026lt;string\u0026gt;\\n\u0026#34;); exit(-1); } int main(int argc, char *argv[]) { if (argc != 2) { usage(); } printf(\u0026#34;%s\\n\u0026#34;, argv[1]); return 0; } ​\t在C语言中，argc和argv是预留的为main函数传参的参数，其中 $$ argc\\space is \\space short \\space for \\space argument \\space count $$\n$$ argv \\space is \\space short \\space for \\space argument \\space vector $$\n​\t其中argc,argv均包含运行的程序本身，即程序默认有一个参数，是他自己的名字\n或者说在不特殊向程序传参情况下 $$ argc=1 \\space | \\space argv[0] = filename $$ ​\t那么以上代码中的逻辑就显而易见。对于argc != 2的判断事实上就是在判断是不是传入了一个字符串参数，如果没有，提示用户程序用法，强制退出。\n​\t那我们应该如何通过命令行传入参数呢？\n$ gcc -g echo.c -o echo ##编译 $ ./echo \u0026#34;hello,world\u0026#34;! ##或者采用输入重定向的方式 $ ./echo \u0026lt; input.txt ##在这个文件中保存好字符串参数 ​\t如果我们想要为gdb传入参数，同样有两种方法\n$ gdb --args ./echo \u0026#34;hello,world\u0026#34; 需要注意args选项中包含程序名\n或在gdb页面中（个人更加偏向）\n$ gdb (gdb)file ./echo (gdb)set args \u0026#34;hello,world\u0026#34; 更加简洁的，也可以在run时指定参数\nrun args 5.追踪程序运行 5.1 调试 (gdb) start start指令会使程序调试进入main函数的第一行代码/重新运行程序 (gdb) step step指令使我们一步一步执行程序（注：当我们输入一次step后，继续回车即相当于后续输入step） 同时，step指令也会进入函数内部，即如果遇到函数调用，step指令会进入函数调用内部细节（ 相当于jetbrains系列的F7） (gdb) finish finish用于从当前调试函数内部退出 这样就形成一个组合，我们要进入某个函数内部调试——step，从中退出来finish (gdb) next ##相当于jetbrains系列的F8 next指令用于执行当前行并且跳过当前行中任何函数调用（相当于jetbrains系列的F8） (gdb) continue continue指令，停止调试，让程序正常跑完 (gdb) kill kill指令，杀死进程 5.2 设置断点 5.2.1 查看文件内容 设置断点首先要知道断点应该设置在的位置，我们可以通过list指令查看文件内容从而确定我们要设置断点的行号 关于list指令的用法\nlist ##查看当前运行源代码 list \u0026lt;linenumber\u0026gt; list \u0026lt;file\u0026gt;:\u0026lt;linenumber\u0026gt; list \u0026lt;function name\u0026gt; list \u0026lt;file\u0026gt;:\u0026lt;function name\u0026gt; 通过回车继续查看代码内容\n5.2.2 设置断点 break \u0026lt;linenumber\u0026gt; 程序运行会在我们设置的断点处停下，此时可以使用step,next,finish等指令进行调试\n对于我们已经设置好的断点，我们可以使用\ninfo breakpoints 来查看断点信息。\n在上图中我们可以看到断点的各种信息\nNum:断点编号 Type:断点类型 Disp:永久断点/临时断点 Enb:是否启用 以及短点的地址，位置，命中次数等 如果想要暂时禁用某个断点\n(gdb) disable breakpoints \u0026lt;breakpoint_number\u0026gt; 执行后再次查看断点信息可以看到Enb=n\n若果想要直接删除某个断点\n(gdb) delete breakpoints \u0026lt;breakpoint_number\u0026gt; 若想要删除某个位置的所有断点\nclear \u0026lt;position\u0026gt; 5.2.3 临时断点 ​\t事实上start指令本质上是在main函数处添加一个断点并运行程序，这个断点的类型为临时断点，temporary breakpoint,程序只在该断点处暂停一次，之后断点就会自动删除。（运行到该临时断点时临时断点就会被删除）\n通过tbreak指令设置临时断点\n(gdb)tbreak \u0026lt;breakpoint_number\u0026gt; 再次查看断点信息\n5.2.4 条件断点 ​\t条件断点即满足一定条件才中断程序运行的断点\n创建条件断点的方法即为在原指令后加入条件\nbreak \u0026lt;linenumber\u0026gt; if \u0026lt;condition\u0026gt; condition是符合语义的表达式，例如\nbreak 18 if i == 9 break 19 if a \u0026gt; b + 1 若需要修改条件断点中的条件，使用condition指令\nconditon \u0026lt;breakpoint_number\u0026gt; \u0026lt;new_condition\u0026gt; 5.2.5 循环中的断点 若是使用了显式的循环（可以看到循环变量），我们就可以通过循环变量构造条件断点，例如for循环中的i\nbreak 23 if i == 8 若是循环中没有显式的计数，例如遍历链表或使用迭代器等。我们可以使用ignore指令，该指令表示忽略这个断点前times次的访问\nignore \u0026lt;breakpoint_number\u0026gt; \u0026lt;times\u0026gt; 5.3 设置观察点 5.3.1 变值观察点 ​\t对于代码量较小的工程，我们容易定位出其中的bug位置，从而通过设置条件断点等方法进行调试。而对于较大的工程，我们难以判断bug位置，这时可以设置观察点\nwatch \u0026lt;expression\u0026gt; ​\t观察点指定了一个表达式而不指定位置，程序运行时GDB会监视该表达式的取值，当表达式的取值发生变化时程序停止\n​\t举个例子，对于想要在循环中设置断点的情况，例如想要在i==9时停下来调试\nwatch i\u0026gt;=9 ​\t其中i\u0026gt;=9在i\u0026lt;9时取值为0，i==9时取值变为1\n5.3.2 读观察点 ​\t当程序中出现读取目标表达式的操作时停止\nrwatch \u0026lt;expression\u0026gt; 5.3.3 访问观察点 ​\t当程序中出现读取目标表达式或写入目标表达式的值的操作停止\nawatch \u0026lt;expression\u0026gt; 6.查看程序运行时数据 6.1 查看函数调用栈 ​\t查看函数调用栈通过backtrace指令完成，例如我们在fibo程序中n==1时设置断点，并在此时查看调用栈信息\n(gdb) backtrace 6.2 获取变量取值 ​\t我们可以通过print来获取变量的取值，在这个例子中，\n(gdb) print n ​\t即可输出n的值。但是若我们想要获得此时main循环变量中i的值呢？若我们直接print i 则会遇到报错\n​\t这是因为在程序运行过程中系统会为每一个函数调用创建一个栈帧，保存在函数调用栈中，例如上面backtrace输出图。若我们想要打印主函数中变量的值，我们就需要返回到主函数所在栈帧。\n6.3 在函数调用栈帧间移动 ​\t在上面的讲解中，我们位于函数调用的最底层，此时n==1，我们要想打印主函数中i的值，需要先切换到主函数所在的栈帧。\nup [steps] ​\t向调用者的方向移动steps次，即向函数调用顶层移动steps，若我们想要返回顶层\ndown [steps] ​\t向被调用者移动。程序的栈空间向低地址增长，被调用者的栈帧在调用者的栈帧之下！！！\nframe [level] ​\t直接移动到指定的栈帧\n6.4 输出数组 ​\t我们可以打印输出数组变量的值，\n指定元素输出，例如\n输出一定范围内的数组元素\nprint \u0026lt;array_name\u0026gt;[start_index]@\u0026lt;element_number\u0026gt; 即输出数组从start_index开始的element_number个元素\n6.5 反汇编 ​\t将GDB中的机器码转换为汇编代码\ndisassemble [position] disassemble \u0026lt;function\u0026gt; disassemble \u0026lt;start\u0026gt;,\u0026lt;end\u0026gt; 图中箭头表示PC寄存器位置 7.修改运行时程序 调试时动态修改程序的数据或运行，验证bug修复的可行性\n修改指定变量的值\nset variable \u0026lt;variable_name\u0026gt; = \u0026lt;expression\u0026gt; 修改函数的返回值\nreturn \u0026lt;expression\u0026gt; 跳转到指定位置运行\njump \u0026lt;position\u0026gt; 8.使用tui界面进行调试 ​\t使用tui界面进行调试会比纯cli界面查看代码更加友好一些\ngdb -tui ","permalink":"https://coder0xe.github.io/posts/gdb/","summary":"\u003ch1 id=\"gdb终端调试\"\u003e\u003ccenter\u003eGDB终端调试\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"1-编译产生debug版本\"\u003e1. 编译产生Debug版本\u003c/h2\u003e\n\u003cp\u003e​\t我们在操作系统实验中使用\u003ccode\u003egdb\u003c/code\u003e在终端中进行代码调试。在之前的章节中，我们已经学到可以使用\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egcc add.c -o adds\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t指令来对源代码进行编译。但是采用这种方法编译产生的目标程序是\u003cstrong\u003eRelease\u003c/strong\u003e版本，并不支持我们使用\u003ccode\u003egdb\u003c/code\u003e进行调试，要想产生支持\u003ccode\u003egdb\u003c/code\u003e调试的\u003cstrong\u003eDebug\u003c/strong\u003e版本，我们需要在原编译指令的基础上加入\u003ccode\u003e-g\u003c/code\u003e参数，具体指令为\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egcc -g add.c -o adds\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"2-gdb操作\"\u003e2. GDB操作\u003c/h2\u003e\n\u003ch3 id=\"1进入gdb进行调试\"\u003e1.进入GDB进行调试\u003c/h3\u003e\n\u003cp\u003e​\t对编译好的程序运行\u003ccode\u003egdb\u003c/code\u003e有两种方式，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e一种是直接指定文件进入\u003ccode\u003egdb\u003c/code\u003e模式\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egdb adds\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e或者先进入\u003ccode\u003egdb\u003c/code\u003e模式，再加载可执行文件\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$ gdb\n(gdb) file \u0026lt;filename\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2运行程序\"\u003e2.运行程序\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e(gdb) run\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3退出gdb模式\"\u003e3.退出gdb模式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003equit\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4-传入额外参数\"\u003e4. 传入额外参数\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// echo.c\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid usage() {\n    printf(\u0026#34;usage: echo \u0026lt;string\u0026gt;\\n\u0026#34;);\n    exit(-1);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        usage();\n    }\n\n    printf(\u0026#34;%s\\n\u0026#34;, argv[1]);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t在C语言中，\u003ccode\u003eargc\u003c/code\u003e和\u003ccode\u003eargv\u003c/code\u003e是预留的为\u003ccode\u003emain\u003c/code\u003e函数传参的参数，其中\n$$\nargc\\space is \\space short \\space for \\space argument \\space count\n$$\u003c/p\u003e","title":"GDB"},{"content":"OSpre——C 1. 源代码到可执行文件 预处理-\u0026gt;编译-\u0026gt;汇编-\u0026gt;链接 1.1 预处理——处理# gcc -E hello.c -o hello.i ## -E选项 预处理的工作内容：处理#开头的预处理指令 删除#define，展开宏定义 处理条件编译指令，#if,ifdef 处理#include预处理指令，将包含的文件内容插入到该预处理指令的位置 1.2 编译——预处理文件生成汇编代码文件 gcc -S hello.i -o hello.s # -S参数 1.3 汇编——汇编代码转换为机器代码 gcc -c hello.s -o hello.o # -c参数 1.4 链接 ​\t把多个目标文件的代码段放在一起、数据段放在一起，以及库函数等形成可执行文件。\n2. C语言中变量存储类别 2.1 存储期 2.1.1对象与标识符 ​\tC语言中对象是连续的一片内存空间，具有起始地址与大小两个属性。标识符是我们用来访问修改对象的字符串（变量名）\n例如\nint a = 5; // \u0026amp;a = 0x1000 ​\t我们声明了一个int类型，起始地址为0x1000，占用内存大小为4字节的整型变量，变量的标识符为a。\n2.2.2 存储期——变量在内存中的生命周期 静态存储期static：\n使用static关键字定义的变量static int a 在函数外定义的变量(全局变量) 若对象具有静态存储期，则在程序运行期间一直存在。并且对象的属性不变，即对象的起始地址和所占用的内存空间大小不会变化，不初始化自动初始化为0\n自动存储期auto\n不使用static关键字定义的变量（例如局部变量）auto int a\n程序执行到该变量声明的时候会创建变量对应的对象，在执行到该变量作用域结束后释放对象，不进行初始化则初始值不确定。\n如在函数中生命的局部变量，在他的一次调用中的作用域中具有固定的值和地址属性，不同的调用地址属性可能不同 2.2 作用域——标识符在程序中可以被使用的区域 块作用域：块(block)是用花括号括起来的代码区域。定义在块中的变量具有块作用域。块作用域变量的可见范围是从定义处到包含该定义的块的结尾（右花括号）。(对应着局部变量)\nint foo(int a, int b) { int c; //c 作用域开始 { c=1; int d; // d作用域开始 d=0; } // d作用域结束 } // abc作用域结束 注：函数的形式参数块作用域属于函数体块\n文件作用域：在函数外定义的变量，从定义处到文件末尾均可见\n全局变量：文件作用域，静态存储期\n局部变量：块作用域，自动存储期\n2.3 链接 ​\t链接属性：该变量是否可在别的文件中被使用\n内部链接：内部链接变量只能在定义他的文件中使用\n使用static关键字声明的全局变量\nstatic int a = 1;//static 修饰全局变量 外部链接：可以在所有文件中使用\n全局变量默认是外部链接的\nint b = 2//默认全局变量 无链接：变量没有链接属性\n在函数中定义的变量，即只有全局变量有链接属性，局部变量没有\nvoid foo(int c) { int d; } ​\t若要在外部文件中使用具有外部链接属性的变量，需要extern关键字进行引用式声明\n定义式声明：创建对象\n引用式声明：引用其他地方变量\nextern int foo; 2.4 总结 存储类别说明符 变量声明位置 存储期 链接 备注 auto 函数内 自动存储期 无链接 auto 关键字可以省略 static 函数内 静态存储期 无链接 static 函数外 静态存储期 内部链接 无 函数外 静态存储期 外部链接 若要在别的文件中使用这种变量需要使用 extern 关键字进行引用式声明 extern 函数内 静态存储期 引用的变量需要具有外部链接 引用式声明，不会创建对象 extern 函数外 静态存储期 引用的变量需要具有外部链接 引用式声明，不会创建对象 例，有以下三个C语言文件\n/* main.c */ static int v; extern int func(int value); int main() { int value = 1; v = func(value); { extern int value; // 在块中引用变量 value value的作用域为当前代码块 value = 2 v += func(value); } printf(\u0026#34;%d\\n\u0026#34;, v); return 0; } /* value.c */ int value = 2; /* func.c */ int func(int value) { static int x = 1; //static类型 静态存储期 会保留前一次调用后x的值，不会进行重新初始化 int y = 1; // auto类型 每次调用重新初始化 x += value; y += value; return x + y; } ​\tmain.c中引用了value.c中的全局变量和func.c中的函数，编译他们需要同时进行编译\ngcc main.c value.c func.c ./a.out ​\t输出结果为11。\n3. 函数的存储类别 默认函数为外部链接\n使用别的文件中的函数，使用extern关键字进行声明\nextern int bar(int a) 函数内部链接：在函数定义前加上static关键字\n4. 预处理指令 4.1 宏定义 变量式宏定义\n#define N 20 函数式宏定义\n#define MAX(a,b) ((a) \u0026gt; (b) ? (a) : (b)) ​\t预处理器发现程序中的宏后，会用宏等价的替换文本进行替换（只是字符串层面的替换），直到不包含宏为止。\n预处理器只负责对宏定义进行形式上的替换，函数式宏定义的参数没有类型，不做参数检查，即如果参数发生类型错误，在预处理阶段不会报错，在编译阶段报错 4.2 在MOS内核中推荐的函数宏定义形式 #define MACRO_NAME(para1, para2)\\ do {\\ express1;\\ express2;\\ }while(0) 注：在函数宏定义中每一行后添加的,其作用就相当于换行，防止一些离谱的错误 4.3 宏定义运算符 4.3.1 宏参数创建字符串 #运算符 ​\t#是预处理运算符，用于创建字符串，#会把传入的参数自动合并为用双引号括起来的字符串，参数中的多个连续空格会被替换为一个空格。\n#define toStr(s) #s printf(toStr(hello world)); ​\t经过#预处理后得到\nprintf(\u0026#34;hello world!\u0026#34;); ​\t若#在双引号中，需要在#外再加双引号使其发挥作用，例如\n#define PSQR(x) printf(\u0026#34; The square of \u0026#34; #x \u0026#34; is %d\u0026#34;,((x)*(x))) int y = 5; PSQR(y); // 输出：the square of y is 25 4.3.2 预处理器粘合剂 ##运算符 ​\t##运算符的作用是将前后两个预处理符号连接成一个预处理符号\n#define CONCAT(a, b) a##b // CONCAT(con, cat) 展开为 concat 4.3.3 变参宏：...和__VA_ARGS__ 函数的宏定义的参数列表中使用\u0026hellip;表示可变参数，在宏定义中可变参数的部分用__VA_ARGS__表示 #define showlist(...) printf(#__VA_ARGS__) showlist(The first, second, and third items.); ​\t预处理后结果为\nprintf(\u0026#34;The first, second, and third items.\u0026#34;); ​\t若##运算符用在__VA_ARGS__前面,当它为空参数时，##运算符会把他前面的,吃掉\n变参宏编写打印函数用于内核调试 #define DEBUGP(format, ...) printf(format, ## __VA_ARGS__) // DEBUGP(\u0026#34;info no. %d\u0026#34;, 1) 会展开为 printf(\u0026#34;info no. %d\u0026#34;, 1) // DEBUGP(\u0026#34;info\u0026#34;) 会展开为 printf(\u0026#34;info\u0026#34;)，注意展开式中的宏定义中的 format 后的逗号没有了。 4.3.4 关于define undef：\n#undef \u0026lt;macro\u0026gt;取消对宏的定义，可以对\u0026lt;macro\u0026gt;赋新值。若之前没有定义过\u0026lt;macro\u0026gt;则会被忽略\n#include\n#include\u0026lt;name.h\u0026gt; 在标准包含目录中查找该文件 #include\u0026quot;name.h\u0026quot;现在引用该头文件的目录下查找，然后查找标准包含目录 注：使用\u0026lt;\u0026gt;的一般是官方头文件,\u0026ldquo;\u0026ldquo;一般是自行定义的头文件 ifndef:if not define\n常见于头文件的编写中，用于避免头文件的内容被重复包含。\n//例如stdio.h #ifndef _STDIO_H #define _STDIO_H ... #endif 这个规范要应用于自己的编写中\n4.3.5 typedef 与 #define的区别 ​\t区别在于，#define 是单纯的字符串替换，在预处理阶段完成，没有作用域。而 typedef 是给类型一个别名，在编译阶段完成，它有自己的作用域。 typedef 一般用来定义类型的别名，定义与平台无关的数据类型，与 struct 的结合使用等。常见的 typedef 别名风格是以 _t 结尾，如 integer_t 或者 ptr_t。\n#define 出的类型宏可以被其他说明符修饰，但 typedef 定义的别名本身就是一个类型（类型说明符），所以在声明中不能和 unsigned 等其他类型说明符一起出现： #define INTEGER int; unsigned INTEGER n; //没问题 typedef int integer_t; unsigned integer_t n; //错误，不能在 integer_t 前面添加 unsigned typedef 定义的类型名用来连续声明几个变量时，能够保证定义的所有变量均为同一类型，而 #define 则无法保证。 #define PTR_INT int * PTR_INT p1, p2; //p1、p2 类型不相同，宏展开后变为 int *p1, p2; typedef int * ptr_int_t; ptr_int_t p1, p2; //p1、p2 类型相同，它们都是指向 int 类型的指针。 ","permalink":"https://coder0xe.github.io/posts/c-knowledge/","summary":"\u003ch1 id=\"osprec\"\u003e\u003ccenter\u003eOSpre——C\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"1-源代码到可执行文件\"\u003e1. 源代码到可执行文件\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e预处理\u003c/strong\u003e-\u0026gt;\u003cstrong\u003e编译\u003c/strong\u003e-\u0026gt;\u003cstrong\u003e汇编\u003c/strong\u003e-\u0026gt;\u003cstrong\u003e链接\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"11-预处理处理\"\u003e1.1 预处理——处理\u003ccode\u003e#\u003c/code\u003e\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egcc -E hello.c -o hello.i   ## -E选项\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e预处理的工作内容：处理\u003ccode\u003e#\u003c/code\u003e开头的预处理指令\n\u003cul\u003e\n\u003cli\u003e删除\u003ccode\u003e#define\u003c/code\u003e，展开宏定义\u003c/li\u003e\n\u003cli\u003e处理条件编译指令，\u003ccode\u003e#if\u003c/code\u003e,\u003ccode\u003eifdef\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e处理\u003ccode\u003e#include\u003c/code\u003e预处理指令，将包含的文件内容插入到该预处理指令的位置\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"12-编译预处理文件生成汇编代码文件\"\u003e1.2 编译——预处理文件生成汇编代码文件\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egcc -S hello.i -o hello.s   # -S参数\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"13-汇编汇编代码转换为机器代码\"\u003e1.3 汇编——汇编代码转换为机器代码\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egcc -c hello.s -o hello.o   # -c参数\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"14-链接\"\u003e1.4 链接\u003c/h3\u003e\n\u003cp\u003e​\t把多个目标文件的代码段放在一起、数据段放在一起，以及库函数等形成可执行文件。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"生成可执行文件过程.drawio\" loading=\"lazy\" src=\"https://os.buaa.edu.cn/tutorial-embedded/2024%E6%98%A5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A2%84%E4%B9%A0%E6%95%99%E7%A8%8B/assets/c-compilation-process.drawio.svg\"\u003e\u003c/p\u003e\n\u003ch2 id=\"2-c语言中变量存储类别\"\u003e2. C语言中变量存储类别\u003c/h2\u003e\n\u003ch3 id=\"21-存储期\"\u003e2.1 存储期\u003c/h3\u003e\n\u003ch4 id=\"211对象与标识符\"\u003e2.1.1对象与标识符\u003c/h4\u003e\n\u003cp\u003e​\tC语言中\u003cstrong\u003e对象是连续的一片内存空间\u003c/strong\u003e，具有起始地址与大小两个属性。\u003cstrong\u003e标识符是我们用来访问修改对象的字符串（变量名）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e例如\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eint a = 5; // \u0026amp;a = 0x1000\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t 我们声明了一个\u003ccode\u003eint\u003c/code\u003e类型，起始地址为0x1000，占用内存大小为4字节的整型变量，变量的标识符为a。\u003c/p\u003e\n\u003ch4 id=\"222-存储期变量在内存中的生命周期\"\u003e2.2.2 存储期——变量在内存中的生命周期\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e静态存储期static\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用\u003cstrong\u003estatic\u003c/strong\u003e关键字定义的变量\u003ccode\u003estatic int a\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e在函数外定义的变量(\u003cstrong\u003e全局变量\u003c/strong\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e若对象具有静态存储期，则在程序运行期间一直存在。并且对象的属性不变，\u003cstrong\u003e即对象的起始地址和所占用的内存空间大小不会变化，不初始化自动初始化为0\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e自动存储期auto\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e不使用static关键字\u003c/strong\u003e定义的变量（例如局部变量）\u003ccode\u003eauto int a\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e程序执行到该变量\u003cstrong\u003e声明的时候会创建变量对应的对象，在执行到该变量作用域结束后释放对象，不进行初始化则初始值不确定\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如在函数中生命的局部变量，在他的一次调用中的作用域中具有固定的值和地址属性，不同的调用地址属性可能不同\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"22-作用域标识符在程序中可以被使用的区域\"\u003e2.2 作用域——标识符在程序中可以被使用的区域\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e块作用域\u003c/strong\u003e：块(\u003ccode\u003eblock\u003c/code\u003e)是用花括号括起来的代码区域。定义在块中的变量具有块作用域。块作用域变量的可见范围是从定义处到包含该定义的块的结尾（右花括号）。\u003cstrong\u003e(对应着局部变量)\u003c/strong\u003e\u003c/p\u003e","title":"C-knowledge"},{"content":"OO第一单元第一次作业 0.training 想要通过课程组提供的training获取一点点思路QWQ 0.1 training-1 第一部分通过正则表达式的方法将一个只包含数字和“+”“*”符号的表达式转化为后缀表达式\n思路梳理（已经提供好的代码）：\nMainclass：对于该类，分析得到其处理的思路为构建出可以描述每一项的正则表达式，而后在表达式中进行匹配，再分别对获得的每一项进行后缀化(toString)，最后整体后缀化(toString)并输出\n补充正则表达式如下\nprivate static final String patternTerm = \u0026#34;\\\\d+(\\\\*\\\\d+)*\u0026#34;; (该表达式描述了，一项中至少有一个数字以及\u0026gt;=0个形如*number的部分)\n上机tips：关于正则表达式，可以右键之后选择第一项进行检查\nExpr：该类的重点为实现toString方法，由后缀化的项得到后缀化的表达式\n若表达式中只有一项，则该项即为转换后的表达式\n（例如 1 * 2 * 3）\n若表达式中大于等于两项，对于前两项需要特殊处理，后面的项补充为项*的后缀化形式\nStringBuilder sb = new StringBuilder(); sb.append(terms.get(0)); sb.append(\u0026#34; \u0026#34;); /* TODO */ sb.append(terms.get(1)); sb.append(\u0026#34; \u0026#34;); sb.append(\u0026#34;+\u0026#34;); for (int i = 2; i \u0026lt; terms.size(); i++) { sb.append(\u0026#34; \u0026#34;); sb.append(terms.get(i)); sb.append(\u0026#34; \u0026#34;); sb.append(\u0026#34;+\u0026#34;); } Term：该类的重点为实现toString方法，将项转化为后缀表达形式\n在项的构造方法中对因子factors进行了划分，由于项只可能由数字或数字的乘积构成，使用*划分即可\nString[] factorStrs = s.split(\u0026#34;\\\\*\u0026#34;); 同Expr中toString方法，将第0个和第1个因子特判后缀化\n0.2 training-2 第二部分通过递归下降的方法对一层括号，只包含“+”“*”运算符的表达式进行处理，输出其后缀表达式\n思路梳理\n对表达式进行层次化建模（语法树）\nExpr Term Factor number Expr（括号的来源） 分析\nExpr的抽象结构\nterm+term+term\u0026hellip;\nterm的抽象结构\nfactor * factor * factor\nfactor\nnumber factor最底层的结构 Expr从顶层向下调用 ​\t我们做打开括号并转化为后缀表达式的行为主要通过语法分析parser，词法分析lexer相当于parser的辅助类，本质上lexer可以选择在parser中完成，但是分成两个类可以显著降低耦合度。故我们分析的视角以parser展开。\n​\tparser英文即意为语法分析，我们做语法分析的过程显然为从左到右。在这个从左到右扫描的过程中，我们的读取不是以字符为单位，而是以token为单位，即文中的最小单位。这个token就由lexer类完成获取并传递给parser，帮助其理解当前句子的结构。(图片来自公众号oolens)\n​\t这里以列表的形式呈现，实际上在代码的实现中我们的思路是，parser需要知道后面的句子结构，lexer接着向右边扫描，得到的token传递给parser用来分析。即parser相当于“奴役”着lexer。\n​\t当我们理解了parser和lexer的协作关系，就可以尝试理解整体的工作思路。去掉括号后，我们的句子成分包括数字、+、*。我们最底层的“原子”即为数字，+以及*的位置可以通过输出时构建后缀表达式。我们可以得到数据结构上的关系\nExpr掌管terms，在代码实现中使用了HashSet进行管理(个人不是很理解，更加偏向使用ArrayList，使用HashSet会导致输出无序，但结果正确)\nterms掌管factors，HashSet(这里的factors为Number，若为Expr则进行递归调用)\n对于递归调用关系可以如下图所示，这也被称为自顶向下树。\n注：实际上，若将底层因子中的Expr递归调用关系补全，得到的会是一颗更深的树\n​\t在语法解析的过程中，遵循Expr-\u0026gt;Term-\u0026gt;Factor ，下面以一个具体的问题为例进行分析\n例如题目中提供的例子(1+2)*(3+4) ​\t这个例子其实是“一项”，我们要想构建起完整的表达式，应当从底到顶进行，先获取因子，再获取项，再获取表达式，故我们在主函数中调用parseExpr，parseExpr中递归调用parseTerm\u0026hellip;\n​\t我们分析示例parseExpr代码\npublic Expr parseExpr() { Expr expr = new Expr(); //添加表达式中的第一项项，递归调用 expr.addTerm(parseTerm()); //这里需要理解的是，上一行代码在递归调用过程中，分析完成一项，此时lexer也对应移动了一项，这时看拿到的token是不是+ // 即term + term + term ... while (lexer.peek().equals(\u0026#34;+\u0026#34;)) { lexer.next(); expr.addTerm(parseTerm()); } return expr; } ​\t在示例中，只有一项，递归分析两个表达式因子。\n​\t需要注意的是，JAVA中的输出语句System.out.println在输出类对象时，会调用对应的toString方法，故我们需要在Expr,Term,Number层构建toString方法\n​\t我们只需要对每一个层次都建立起toString方法，在每一层中建立该层的后缀表达式，同样向下递归调用即可得到输出，例如在Expr层的toString\nterm term + (term +)* //需要注意的是第一项和第二项的特殊处理 总结来说：所谓递归下降算法，其实就是递归的思想 1.题目需求分析 ​\t读入一个包含加、减、乘、乘方以及括号（括号深度至多一层）的单变量表达式，输出恒等变形展开所有括号后的表达式\n对表达式进行层次化建模：Expr-\u0026gt;Term-\u0026gt;Factor\n表达式(Expr)：由加法和减法运算符连接若干项组成\n注：在第一项之前可以带一个正号或负号，表示第一项的正负\n项(Term)：由乘法运算符连接若干因子组成\n注：在第一个因子之前可以带一个正号或负号，表示第一个因子的正负\n因子(Factor)：设置为接口Interface\n变量因子（幂函数）\n一般形式：x ^ n，n为非负带符号整数**(输入已经保证该带符号整数中不会出现-**) 省略形式：当n==1时简写为x 常数因子\n支持前导0的十进制带符号整数（+可以省略）\n表达式因子\n用一对小括号包裹起来的表达式，可以有指数形式（指数为非负带符号整数）\n2.问题处理流程分析 2.1 预处理 ​\t由于生成法中可能造成的输入字符串中包含连续冗余的+-，空格，前导0等，采用建立processer类的方法对表达式进行预处理，方便后面的语义分析。考虑到后面性能要求中的长度问题，预处理阶段尽量的将字符串长度缩短是好事，我在处理时采用以下的顺序\n删除字符串中的空白字符（空格、\\t） 删除连续的+-(其实就是为这个项确定出符号，或者说统计出负号的个数) 删除不必要的前导+ 删除前导0 ​\t这样的顺序要优于2,3颠倒\n2.2 语法分析 2.2.1 Lexer ​\tLexer主要进行词法分析，他负责从字符串中读到token并传递给Parser，这里我们的token可以用一个枚举类保存。\npublic enum TokenType { NUM,X,MULTI,EXP,ADD,SUB,LP,RP,NULL } ​\t同样沿用training代码中的逻辑，可以用switch语句等保存token。\n2.2.2 Parser ​\t对于parser部分的设计同样沿用了training中的三个方法，根据当前lexer扫描到的token进行语义分析，在我的设计中参考了学长博客中的设计，为项设置出符号属性，在解析表达式时将项的符号传入。这里同样需要注意的是number^pow的形式并不符合形式化表述，我的第一版代码中对这种形式进行了解析\n​\t该类中借鉴了training中代码的三个方法进行解析\nparseExpr parseTerm parseFactor ​\tparseFactor中需要注意的是，读到(，即读到表达式或读到x即读到幂函数，还要再向后读一个看是不是^，如果是则说明该因子有指数(要为表达式设置指数属性)\npublic Expr parseExpr() { Expr expr = new Expr(); int sign = 1;//标记项的符号 if (lexer.getCurTokenType() == TokenType.SUB) { //该项是负项 } else if (lexer.getCurTokenType() == TokenType.ADD) { //该项为正项 } expr.addTerm(parseTerm(sign)); while (//有下一项) { //正负项讨论 } return expr; } // parseExpr将项的符号传入 public Term parseTerm(int sign) { //... while (//有下一个因子) { //... } return term; } public Factor parseFactor() { if (//如果是左括号，说明是表达式) { //跳过LP lexer.next(); Expr expr = parseExpr(); //跳过RP lexer.next(); if (//如果是^) { // } return expr; } else if (//如果是数字) { //... } else if (//如果是减号，说明这是个负数) { //... } else { //如果读到x //如果读到x则还需要判断他的下一个token是不是^ } } 2.3 计算输出 2.3.1计算思路 ​\t在经过语法分析之后，我们已经对表达式自顶向下建立起表达式树，而我们的输出结果，可以表示为多项式的形式 $$ Expr = \\Sigma a_i x^{n_i} $$ ​\t因此我们可以考虑在每一个语法层级都将其转化为多项式形式(构造toPoly方法)，最终递归地得到计算结果。\n​\t为了实现计算，我们定义出单项式类Unit，多项式类Poly。每个单项式以数组的形式管理各个单项式。我们先不考虑各个类中具体的方法实现，先去大体认知这个与表达式树映射架构的多项式树。\n​\t我们的思路是将每一个层级都表现为多项式形式\nnumberFactor：对于数字因子，是树中的叶节点，我们可以简单的表示为只有一项的多项式： $$ numberfactor = numberfactor*x^{0} $$ 这一项即为一个单项式，我们的多项式类中的数组中只保管这一个单项式即可\npowFactor：对于幂函数因子，同样为树中的叶节点，我们可以简单的表示为只有一项的多项式： $$ powfactor = 1*x^{powfactor} $$ 这一项即为一个单项式，我们的多项式类中的数组中只保管这一个单项式即可\nTerm：将term类转换为多项式形式，我们知道，多项式的表达形式为factor*factor*factor，我们只需要将他的各个因子的多项式相乘即可 $$ TermPoly = \\Pi FactorPoly $$\nExpr：将expr类转换为多项式形式，表达式的形式为term + term + term （其中term中包含该项正负号），只需要将构成表达式的各个项的多项式相加即可 $$ ExprPoly = \\Sigma TermPoly $$\n​\t这样又构建起一个递归的过程，自底向上地构建起多项式树。\n​\t经过以上分析，我们知道需要新增的类有\nUnit\nPoly\n需要新增的方法有\n每一个层次的toPoly，包括Expr,Term,Factor\nPoly中的计算方法：\naddPoly multiPoly powPoly 用于最终输出的Unit类和Poly类中的toString\n2.3.2 计算方法实现思路 2.3.2.1 各层级toPoly方法的实现 首先定义出Unit单项式类，其中包含两个属性ceo（系数），pow（指数），Poly类中包含ArrayList \u0026lt;Unit\u0026gt; unitlist ​\t先从比较简单的底层实现，即numberFactor和powFactor\nnumber toPoly\n$$ number*x^0 $$\n只有一项的多项式 pow toPoly\n$$ 1*x^{pow} $$\n只有一项的多项式 Term toPoly\npublic Poly toPoly() { //... for (Factor factor : factors) { //各个因子多项式相乘 } if (this.sign == -1) { //多项式中单项式变号 } return poly; } 需要注意的是，若项的符号为负号，则需要将项中的每一个单项式符号取反，在Poly类中构建方法negate()用于符号取反 Expr toPoly\npublic Poly toPoly() { //... for (Term term : terms) { //各个项多项式相加 } return poly; } 高层级调用低层级的toPoly，自底向上\n2.3.2.2 Poly中计算方法的实现 2.3.2.2.1 addPoly ​\t**计算思路：**我们对两个多项式进行加法，关键的步骤在于合并同类项，我们已知多项式中以数组的数据结构保存着，我们先将两个数组合并为一个数组，之后在一个数组中进行合并同类项。\npublic Poly addPoly(Poly another) { //将两个数组中的单项式合并到一个数组中 for(int i = 0; i \u0026lt; units.size(); i++) { for(int j = i+1; j \u0026lt; units.size(); j++) { //判断标准：指数相同，合并同类项 } } return new Poly(units); } ​\t在数组中进行遍历，若找到和i元素指数相同的j元素，则系数相加到i元素上，删除j元素，并将j回退一位，实际上是保证下次遍历从i+1开始。\n2.3.2.2.2 multiPoly ​\t**计算思路：**我们对两个多项式中各项相乘的结果加入新的多项式变量。这里注意：在我的实现方法中，是从底向上构建表达式，这样在相乘之前，项表达式是空的，需要进行判断，如果是空的，就返回当前因子表达式加入项表达式中，再继续与其他因子表达式相乘，当然还有另一种方法，就是在乘之前就先加进去一个因子表达式\npublic Poly multiPoly(Poly another) { //...这里需要判断是不是空 if(如果为空){ //... } else { for(Unit unit1 : this.unitlist) { for(Unit unit2 : another.unitlist) { //因子多项式相乘 } } return new Poly(units); } } 2.3.2.2.3 negate ​\t对多项式中的每一个单项式的符号进行取反，我采用两步实现，在Poly中进行Unit遍历，在Unit类中利用BigInteger的方法.negate()取反。\n2.3.3 输出思路及方法 ​\t我们在Unit类和Poly类中都要实现toString方法进行递归调用。\n2.3.3.1 unit toString ​\t将每个unit转化为 $$ coe*x^{pow} $$\n2.3.3.2 poly toString ​\t将各个项多项式连接起来，并进行优化输出，常见的优化输出有：\n系数为0：不输出\n系数为1：省略系数，x\n系数为-1：省略系数，-x\n指数为0：输出1\n指数为1：省略指数，x\n之后可以调用之前字符串预处理过程中的几个方法\n去掉连续的+-号\n若第一项为负，则从后面找一个正项放在前面，大概给出这个方法的伪代码，这个方法的思路是：先判断第一项是否为负项（第一个符号是否为负号），之后看是否能找到正项，如果能就把他俩换一下位置，字符串层级的操作要注意substring方法包含左字符不包含右字符\nif (this.input.charAt(0) == \u0026#39;-\u0026#39;) { int addpos = -1; int i = 0; for (i = 0;i \u0026lt; this.input.length();i++) { //找到+号，记录位置 } if (addpos != -1) { //如果找到了+，就找这一项后的符号，将这一项分割出来 for (i = addpos + 1;i \u0026lt; this.input.length();i++) { //... } //处理字符串，将正项一道前面，之后会调用删除前导+的方法，使得表达式缩短一个字符，这么麻烦其实只缩短了一个字符hhhhhh } } 去掉不必要的前导+\n同时要注意如果输出长度为0，要补充输出“0”\n3.后续对于时间复杂度的优化 3.1 对于时间复杂度的分析 ​\t在第一版代码中，构建多项式过程中我们使用arraylist来存储单项式，之后在后续计算过程中的时间复杂度:\naddPoly:O(n^2) multiPoly:O(n^2) powPoly:调用multiPoly,约等于O(n^3) ​\t这样的时间复杂度在面对一些指数比较大的表达式时会出现TLE的情况，后来经过同学的提示，可以使用HashMap来存储单项式，key为指数，value为系数，这样的确可以大大简化时间复杂度，同时也可以省去一个类Unit(~~但是我没舍得删)。另外一个点：可以在每次乘法结束之后都进行一次合并同类项addPoly，这样可以更加减少时间复杂度\naddPoly:O(n) multiPoly:O(n^2) 3.2 具体方法的实现 3.2.1 addPoly public Poly addPoly(Poly another) { Iterator\u0026lt;Map.Entry\u0026lt;Integer, BigInteger\u0026gt;\u0026gt; iterator = this.unitmap.entrySet().iterator(); while (((Iterator\u0026lt;?\u0026gt;) iterator).hasNext()) { Map.Entry\u0026lt;Integer,BigInteger\u0026gt; entry = iterator.next(); int pow = entry.getKey(); BigInteger coe = entry.getValue(); if (another.unitmap.containsKey(pow)) { BigInteger coe1 = another.unitmap.get(pow).add(coe); another.unitmap.put(pow,coe1); } else { another.unitmap.put(pow,coe); } iterator.remove(); } return another; } ​\t主要思路是数学上的多项式合并思路，遍历一个多项式，在另一个多项式中检查是否有这个项的指数，如果有就合并，如果没有就加入到另一个多项式，最终返回另一个多项式\n这里需要注意的是，关于HashMap边遍历边删除的需求，如果使用增强for循环，会报错。需要使用迭代器进行。\nIterator\u0026lt;...\u0026gt; iterator = ...iterator(); while (iterator.hasNext()) { //... iterator.remove(); } 3.2.2 multiPoly public Poly multiPoly(Poly another) { if (this.unitmap.isEmpty()) { return new Poly(another.unitmap); } else { HashMap\u0026lt;Integer, BigInteger\u0026gt; emptyMap = new HashMap\u0026lt;\u0026gt;(); Poly emptypoly = new Poly(emptyMap); HashMap\u0026lt;Integer, BigInteger\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for (int pow1 : this.unitmap.keySet()) { for (int pow2 : another.unitmap.keySet()) { int pow = pow1 + pow2; BigInteger coe = this.unitmap.get(pow1).multiply(another.unitmap.get(pow2)); if (hashMap.containsKey(pow)) { BigInteger coe1 = hashMap.get(pow).add(coe); hashMap.put(pow,coe1); } else { hashMap.put(pow,coe); } } } return new Poly(hashMap); } } 这里不涉及到对于元素的删除等操作，可以使用增强for循环\n这里需要明确java中HashMap的一个特性：当我们向HashMap中加入已经存在的key时，会覆盖掉原来的value，我利用这一点进行了value的更新\nthere is a new \u0026lt;newkey,newvalue\u0026gt; if (newkey exists) { find(key,value) value -\u0026gt; newvalue } else { put\u0026lt;newkey,newvalue\u0026gt; } 3.2.3 negate 同样要注意对于存在的key的value的值的更新\npublic void negate() { for (Integer pow : this.unitmap.keySet()) { BigInteger coe = this.unitmap.get(pow); this.unitmap.put(pow,coe.negate()); } } 4. 代码分析 4.1 UML类图分析 从左到右大致可以分为三个部分，输入，解析，计算输出 4.2 代码复杂度分析 ​\t我使用Metricsreloaded进行分析，先对几个标准进行解释\nCogc：圈复杂度，程序中独立路径的数目 ev(G)：本质复杂度，程序中必须要有的控制流程数目 iv(G)：内在复杂度，程序本质上的复杂度 v(G)：程序体积，程序中独立语句数目 ​\t以下为程序中复杂度超标的方法\n​\t可以看到复杂度主要集中在进行化简输出的部分或对输入字符串进行预处理的方法，字符串预处理方法需要对字符串进行循环遍历并在过程中条件判断，化简输出部分有对每一项指数、系数的讨论，复杂度均较高，其中语义解析部分parseFactor由于有多种因子，复杂度较高。\n5. bug修复 ​\t在第一次作业中强测以及互测均未出现bug，在互测环节中房友的优化输出出现bug，hack数据为1+(x^8)^8\n","permalink":"https://coder0xe.github.io/posts/oo-unit1-hw1/","summary":"\u003ch1 id=\"oo第一单元第一次作业\"\u003e\u003ccenter\u003eOO第一单元第一次作业\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"0training\"\u003e0.training\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e想要通过课程组提供的\u003ccode\u003etraining\u003c/code\u003e获取一点点思路\u003ccode\u003eQWQ\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"01-training-1\"\u003e0.1 training-1\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e第一部分通过正则表达式的方法将一个只包含数字和“+”“*”符号的表达式转化为后缀表达式\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e思路梳理（已经提供好的代码）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eMainclass\u003c/code\u003e：对于该类，分析得到其处理的思路为构建出可以描述每一项的正则表达式，而后在表达式中进行匹配，再分别对获得的每一项进行后缀化(\u003ccode\u003etoString\u003c/code\u003e)，最后整体后缀化(\u003ccode\u003etoString\u003c/code\u003e)并输出\u003c/p\u003e\n\u003cp\u003e补充正则表达式如下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate static final String patternTerm = \u0026#34;\\\\d+(\\\\*\\\\d+)*\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(该表达式描述了，一项中至少有一个数字以及\u003ccode\u003e\u0026gt;=0\u003c/code\u003e个形如\u003ccode\u003e*number\u003c/code\u003e的部分)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e上机tips：关于正则表达式，可以右键之后选择第一项进行检查\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eExpr\u003c/code\u003e：该类的重点为实现\u003ccode\u003etoString\u003c/code\u003e方法，由后缀化的项得到后缀化的表达式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e若表达式中只有一项，则该项即为转换后的表达式\u003c/p\u003e\n\u003cp\u003e（例如 1 * 2 * 3）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e若表达式中大于等于两项，对于前两项需要特殊处理，后面的项补充为\u003ccode\u003e项*\u003c/code\u003e的后缀化形式\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eStringBuilder sb = new StringBuilder();\n            sb.append(terms.get(0));\n            sb.append(\u0026#34; \u0026#34;);\n            /* TODO */\n            sb.append(terms.get(1));\n            sb.append(\u0026#34; \u0026#34;);\n            sb.append(\u0026#34;+\u0026#34;);\n            for (int i = 2; i \u0026lt; terms.size(); i++) {\n                sb.append(\u0026#34; \u0026#34;);\n                sb.append(terms.get(i));\n                sb.append(\u0026#34; \u0026#34;);\n                sb.append(\u0026#34;+\u0026#34;);\n            }\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eTerm\u003c/code\u003e：该类的重点为实现\u003ccode\u003etoString\u003c/code\u003e方法，将项转化为后缀表达形式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在项的构造方法中对因子\u003ccode\u003efactors\u003c/code\u003e进行了划分，由于项只可能由数字或数字的乘积构成，使用\u003ccode\u003e*\u003c/code\u003e划分即可\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eString[] factorStrs = s.split(\u0026#34;\\\\*\u0026#34;);\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e同\u003ccode\u003eExpr\u003c/code\u003e中\u003ccode\u003etoString\u003c/code\u003e方法，将第0个和第1个因子特判后缀化\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"02-training-2\"\u003e0.2 training-2\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e第二部分通过\u003cstrong\u003e递归下降\u003c/strong\u003e的方法对\u003cstrong\u003e一层括号，只包含“+”“*”运算符\u003c/strong\u003e的表达式进行处理，输出其后缀表达式\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e思路梳理\u003c/p\u003e\n\u003cp\u003e对表达式进行层次化建模（语法树）\u003c/p\u003e","title":"OO-Unit1-hw1"},{"content":"OSpre——从CO到OS：MIPS补充 1.OS中对CO中CPU的补充 1.访存 在上学期的实验中我们实现了基于MIPS-C指令集的CPU，OS课程中使用基于MIPS32指令集的CPU\n在CO中，我们的CPU没有虚拟地址机制，访存指令中的地址均为物理地址，物理地址直接到IM和DM中获取数据\n在MIPS32中，汇编指令中的地址为虚拟地址，执行访存操作时，虚拟地址先被送入MMU进行地址翻译、权限检查，检查合法的访存操作，通过MMU得到物理地址\n所有的软件（MIPS汇编，C语言编写软件等）均访问虚拟地址\nMIPS32的MMU支持基于TLB的页式地址翻译\n2.CP0 MIPS32中CP0功能 记录中断及异常信息 特权管理 地址翻译控制 1.中断异常相关 cause寄存器\n15-8位：哪些中断等待处理，15-10位来自硬件，9-8位可以由软件写入。中断请求发生，对应位置置为1 6-2位：异常编码 31位：异常指令是否位于延迟槽 EPC寄存器：保存异常发生的指令对应的PC地址，异常处理后返回\nBadVAddr寄存器：不合法的访存操作触发异常，该寄存器记录触发异常的访存地址\n2.特权管理相关 用户态，内核态\nstatus寄存器\n0位(interrupt enable)：全局中断使能位 15-8位：中断使能位，八个中断输入的使能 第4位和第1位：控制处理器的特权模式 UM = 1(usermode),EXL = 0(exception level)运行在用户态 其他均为内核态 (1)代表用户态，(2)代表内核态\n2.MIPS调用规范 32个通用寄存器\n寄存器编号 助记符 用途 0 zero 值总是为 0 1 at （汇编暂存寄存器）一般由汇编器作为临时寄存器使用。 2-3 v0-v1 用于存放表达式的值或函数的整形、指针类型返回值。 4-7 a0-a3 用于函数传参。其值在函数调用的过程中不会被保存。若函数参数较多，多出来的参数会采用栈进行传递。 8-15 t0-t7 用于存放表达式的值的临时寄存器; 其值在函数调用的过程中不会被保存。 16-23 s0-s7 保存寄存器; 这些寄存器中的值在经过函数调用后不会被改变。 24-25 t8-t9 用于存放表达式的值的临时寄存器; 其值在函数调用的过程中不会被保存。 26-27 k0-k1 仅在内核态下使用。 28 gp 全局指针和内容指针。 29 sp 栈指针。 30 fp或s8 保存寄存器（同 s0-s7）。也可用作帧指针。 31 ra 函数返回地址。 其中加粗的部分，是我们在函数调用中需要保留其值的寄存器。\n栈帧\n每次调用函数时，都会对函数创建一个唯一的栈帧\n用于存储传递给此调用的函数参数的空间、 存储已保存寄存器值的位置 存储子程序返回地址的地方(ra) 用于本地数据存储 ​\t对调用的函数创造一个栈帧实际上就是为他分配一块他能支配的内存空间\n注：我们对于计算机体系结构的理解是基于上学期MIPS-C架构的\n关于传递参数空间：若是调用者向被调用者传递的参数不超过4，则完全可以通过$a0-$a3寄存器传递参数，即子程序只需要访问$a0-$a3寄存器即可访问到他需要的参数的值。但是需要注意：我们在为子函数开辟栈空间时需要开辟保存在a0-a3寄存器中的参数的空间，只不过这部分空间不需要sw参数的值，举个例子，例如调用者只向被调用者传递了一个参数，我们只需要开辟一个参数的空间，但不需要在空间中保存参数值。\n（注：栈是向下生长的，我们为子函数开辟栈空间需要将sp向下移动，子函数调用结束后restore返回到上面）\naddiu sp,sp,-4 又例如我们向被调用者传递了6个参数，那么我们需要4*6=24个字节。其中前四个参数保存在a0-a3，这部分参数不需要在栈空间中保存，即arg0-arg3或sp-sp+16并不需要赋值，我们只需要在栈空间中保存多出来的参数\nsw $s0,20(sp) sw $s1,24(sp) 关于保留寄存器部分：即$s0-$s7，在子函数运行过程中随意使用，结束后改回父函数中原来保存的值。\n关于返回地址部分：在MIPS架构中，子程序执行后跳转需要jr $ra指令完成，我们需要在栈空间中开辟空间保存ra地址。举个例子，比如我们在编写MIPS代码时，涉及到递归调用，这时候就需要在每一层保存好ra值用来返回\n3.叶子子进程 \u0026amp; 非叶子子进程 simple leaf\n不调用任何其他子例程，不使用栈上的任何内存空间（因为其不需要内存来保存局部变量或寄存器的值）。这样的函数不需要栈帧，也不需要更改 sp。\nleaf with data\n需要栈空间的叶函数（但不需要、不调用任何其他子例程），其栈帧可用于本地变量或寄存器的值的保存。这样的函数被调用后应当压栈（栈帧大小应该是 8 的倍数）。但是，ra 并不用保存在栈帧中。\nnonleaf\n函数内调用了其他函数。一个非叶函数的栈帧包含了上一节所述的大部分结构。\n​\n","permalink":"https://coder0xe.github.io/posts/cotoos/","summary":"\u003ch1 id=\"ospre从co到osmips补充\"\u003e\u003ccenter\u003eOSpre——从CO到OS：MIPS补充\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"1os中对co中cpu的补充\"\u003e1.OS中对CO中CPU的补充\u003c/h2\u003e\n\u003ch3 id=\"1访存\"\u003e1.访存\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在上学期的实验中我们实现了基于MIPS-C指令集的CPU，OS课程中使用基于MIPS32指令集的CPU\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在CO中，我们的CPU\u003cstrong\u003e没有虚拟地址机制\u003c/strong\u003e，访存指令中的地址均为物理地址，物理地址直接到IM和DM中获取数据\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在MIPS32中，汇编指令中的地址为\u003cstrong\u003e虚拟地址\u003c/strong\u003e，执行访存操作时，\u003cstrong\u003e虚拟地址\u003c/strong\u003e先被送入\u003cstrong\u003eMMU\u003c/strong\u003e进行\u003cstrong\u003e地址翻译、权限检查\u003c/strong\u003e，检查合法的访存操作，通过\u003cstrong\u003eMMU\u003c/strong\u003e得到物理地址\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e所有的软件（MIPS汇编，C语言编写软件等）均访问\u003cstrong\u003e虚拟地址\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMIPS32的\u003cstrong\u003eMMU\u003c/strong\u003e支持基于\u003cstrong\u003eTLB\u003c/strong\u003e的\u003cstrong\u003e页式地址翻译\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2cp0\"\u003e2.CP0\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMIPS32中CP0功能\n\u003cul\u003e\n\u003cli\u003e记录中断及异常信息\u003c/li\u003e\n\u003cli\u003e特权管理\u003c/li\u003e\n\u003cli\u003e地址翻译控制\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"1中断异常相关\"\u003e1.中断异常相关\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ecause寄存器\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240226105243269\" loading=\"lazy\" src=\"/img/image-20240226105243269.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e15-8位：哪些中断等待处理，15-10位来自硬件，9-8位可以由软件写入。中断请求发生，对应位置置为1\u003c/li\u003e\n\u003cli\u003e6-2位：异常编码\u003c/li\u003e\n\u003cli\u003e31位：异常指令是否位于延迟槽\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eEPC寄存器：保存异常发生的指令对应的PC地址，异常处理后返回\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBadVAddr寄存器：不合法的访存操作触发异常，该寄存器记录触发异常的访存地址\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2特权管理相关\"\u003e2.特权管理相关\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e用户态，内核态\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003estatus寄存器\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240226111809583\" loading=\"lazy\" src=\"/img/image-20240226111809583.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e0位(\u003ccode\u003einterrupt enable\u003c/code\u003e)：全局中断使能位\u003c/li\u003e\n\u003cli\u003e15-8位：中断使能位，八个中断输入的使能\u003c/li\u003e\n\u003cli\u003e第4位和第1位：控制处理器的特权模式\n\u003cul\u003e\n\u003cli\u003eUM = 1(\u003ccode\u003eusermode\u003c/code\u003e),EXL = 0(\u003ccode\u003eexception level\u003c/code\u003e)运行在用户态\u003c/li\u003e\n\u003cli\u003e其他均为内核态\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e(1)代表用户态，(2)代表内核态\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240226112523272\" loading=\"lazy\" src=\"/img/image-20240226112523272.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2mips调用规范\"\u003e2.MIPS调用规范\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e32个通用寄存器\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e寄存器编号\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e助记符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e用途\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e0\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003ezero\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e值总是为 0\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e1\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003eat\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e（汇编暂存寄存器）一般由汇编器作为临时寄存器使用。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e2-3\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003ev0-v1\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e用于存放表达式的值或函数的整形、指针类型返回值。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e4-7\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003ea0-a3\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e用于函数传参。其值在函数调用的过程中不会被保存。若函数参数较多，多出来的参数会采用栈进行传递。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e8-15\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003et0-t7\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e用于存放表达式的值的临时寄存器; 其值在函数调用的过程中不会被保存。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e16-23\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003es0-s7\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e保存寄存器; 这些寄存器中的值在经过函数调用后不会被改变。\u003c/strong\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e24-25\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003et8-t9\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e用于存放表达式的值的临时寄存器; 其值在函数调用的过程中不会被保存。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e26-27\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003ek0-k1\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e仅在内核态下使用。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e28\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003egp\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e全局指针和内容指针。\u003c/strong\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e29\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003esp\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e栈指针。\u003c/strong\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e30\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003efp或s8\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e保存寄存器（同 s0-s7）。也可用作帧指针。\u003c/strong\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e31\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003era\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e函数返回地址。\u003c/strong\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e其中加粗的部分，是我们在函数调用中需要保留其值的寄存器。\u003c/p\u003e","title":"COtoOS"},{"content":"OSpre——工具介绍 1.vim ​\tvim为CLI的文本编辑工具，一些常用的操作如下\nvim有Normal模式和Insert模式\n启动vim后默认在Normal模式\ni进入Insert模式 esc进入Normal模式 在Insert模式下的一些操作\nctrl + p or ctrl + n自动补全 在Normal模式下的一些操作\nx删除当前光标所在的一个字符\n:wq存盘+退出\n:w存盘\n:q退出\n拷贝\\粘贴\nv可视化的选择部分文本\ndd删除当前行，并把删除的行存在剪贴板里\np粘贴剪贴板\nyy拷贝当前行(ddp)\n各种插入模式\na在光标后插入（会进入Insert模式） o（小写O）在当前行后插入一个新行 移动光标\n方向键移动光标\n0移动到行头\n$移动到行尾\n^移动到本行第一个不是blank字符的位置\ng_移动到本行最后一个不是blank字符的位置\nNG移动到第N行\ngg到第一行\nG到最后一行\n搜索\n/pattern搜索pattern的字符串，n切换到下一个 *匹配光标所在单词，移动光标到下一个匹配单词 #匹配光标所在单词，移动光标到上一个匹配单词 重复命令\n.重复上一次的命令 N\u0026lt;command\u0026gt;重复某个命令N次 Undo/Redo\nu Undo ctrl + r Redo 2.GCC ​\t使用gcc作为C语言编译器\n用法：gcc [选项] 源代码文件\n作用：编译源代码文件\n默认编译生成文件名为a.out\n运行c语言代码\ngcc demo.c ./a.out 更改代码内容后需要重新编译\n3.make \u0026amp; Makefile make即为“制作”，他是依赖Makefile文件进行构建的指令 Makefile文件的格式 \u0026lt;target\u0026gt; : \u0026lt;dependencies\u0026gt; [tab] \u0026lt;command_1\u0026gt; [tab] \u0026lt;command_2\u0026gt; ... [tab] \u0026lt;command_n\u0026gt; ##意为### 如果要构建target首先要准备好dependencies，接着执行command中的命令 target：构建目标，目标文件、可执行文件\n编写完Makefile后make target即可进行构建\ndependencies：构建目标依赖的其他文件或目标\ncommand：构建目标的一系列指令\nall：一种约定，同时生成多个目标\n例如使用make all同时生成多个可执行文件\nall: hello bye hello: hello.c gcc -o hello.dqr hello.c bye: bye.c gcc -o bye.dqr bye.c 注：这里的-o选项意为指定生成文件名称 4.ctags ​\t提供代码跳转功能，首先修改~/.vimrc\nset tags=tags set autochdir 执行ctags -R *，产生新文件tags（符号名索引文件）\n将光标移动到变量上\nctrl + ]可以实现跳转\nctrl + o返回跳转前的位置\n5.tmux 基本概念\n会话：打开一个终端窗口输入命令，用户与计算机的临时交互称为“会话” 窗口：会话中打开的终端窗口 窗格：一个窗口可以利用tmux划分为多个窗格 tmux：会话的重要特点是，窗口与其中启动的进程是连在一起的，打开窗口会话开始，关闭窗口，会话结束。tmux可以实现会话与窗口的分离，窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话“绑定”其他窗口\ntmux基本操作\ntmux\n直接启动tmux窗口，对应会话编号从0开始\ntmux new -s \u0026lt;name\u0026gt;\n新建指定名称的会话\ntmux detach\n当前会话与窗口分离，会话和其中的进程在后台运行\n或快捷键ctrl + B + D，tmux快捷键操作中ctrl + B为默认前缀键\ntmux ls\n列出所有tmux会话\ntmux attach -t \u0026lt;session-id\u0026gt;/\u0026lt;session-name\u0026gt;\n接入已经存在的会话\ntmux kill-session -t \u0026lt;session-id\u0026gt;/\u0026lt;session-name\u0026gt;\n杀死某个会话\ntmux rename-session -t \u0026lt;session-id\u0026gt;/\u0026lt;session-name\u0026gt;\ntmux switch -t \u0026lt;session-id\u0026gt;/\u0026lt;session-name\u0026gt;\nctrl + B + %，窗口左右划分\nctrl + B + \u0026quot;，窗口上下划分\nctrl + B + 方向键根据按键方向切换到窗格\nctrl + B + X关闭正在使用的窗格\nctrl + B + space切换窗格布局\n6.git OOpre中涉猎过，以下内容从OS教程网站上复制下来 Git 中的三种储存位置 Git 中的三种储存状态分别是：工作区（Working Directory）、暂存区（Staging Area）和储存库（Repository）。\n一般来说，一个项目在 Git 中是以目录的形式存在的，这个目录包含了工作区（.git 子目录之外的内容）和储存库（.git 子目录）。工作区可以理解为“目前正在编辑的版本”，储存库储存在一个隐藏目录 .git 中（因为它以 . 开头，所以是隐藏的），用来存放提交过的所有版本的内容及其联系。暂存区存放了已经确定修改但尚未提交的文件。暂存区的信息理论上也储存在 .git 目录中，但是在用途上和储存库有区别，因此和储存库的概念区分开来。有关暂存区的详细概念，可以在下一节中了解到。下图是三种储存位置的转移关系，有关图中的操作，在后文中都有介绍。\nGit 中文件的四种储存状态 一个文件，在 Git 目录中有以下四种状态：\n未跟踪（Untracked）：一个文件在储存库的版本信息中没有被记录过。比如在储存库中新建了一个文件，这个文件现在就是未跟踪的状态；在一个非空目录下使用 git init 来初始化一个空储存库，此时这个目录下的所有文件都处于未跟踪的状态。 未修改（Unmodified）：一个文件在跟踪之后一直没有改动过，或者改动已经被提交（即工作区的内容和储存库中的内容相同），则处于未修改状态。当我们修改这个文件时，则会使这个文件变成已修改状态。 已修改（Modified）：一个文件已经被修改（即工作区的内容和储存库中的内容不同），但还没有加入（git add) 到暂存区中。 已暂存（Staged）：一个文件已被加入暂存区。加入暂存区意味着将一个已修改的文件加入下次提交（git commit）需要存入储存库的文件清单中。 四种状态的转换关系如下图所示（图片来自 Pro Git）：\nGit 常用命令 这一部分将对实验中的常用命令进行简单介绍。\ngit init git init 会自动把当前目录变成一个空的 Git 仓库，这样就可以对当前目录下的内容进行版本管理了。\ngit clone git init 创建一个新的储存库，而 git clone \u0026lt;URL\u0026gt; 则是“克隆”一个已有的储存库到当前目录下。通常我们会从一个互联网地址（即 URL，统一资源定位符）进行克隆，所以一般这种操作可以理解为“下载”。\ngit status 这个命令可以查看当前分支的状态，以及当前工作区的变动和暂存区的内容，便于我们对工作区的概况进行掌握。\ngit add 使用这个命令，可以把一个新文件或者已经修改过的文件加入暂存区中。在你完成一部分实验内容之后，可以使用 git add . 将你的所有修改加入暂存区，也可以使用 git add \u0026lt;filename\u0026gt; 来将指定的文件加入暂存区。\ngit restore 我们在修改一个文件之后，可能想要放弃这个修改。当这个文件还没有通过 git add 加入暂存区时，我们可以使用 git restore \u0026lt;filename\u0026gt; 来撤销对这个文件的修改，使其退回到上一个 commit 的状态。如果这个文件已经加入了暂存区，我们可以通过 git restore --staged \u0026lt;filename\u0026gt; 来取消暂存。\ngit checkout 这个命令涉及到分支的知识，分支的概念在这里不会详细介绍，感兴趣的同学可以参考 Pro Git。在我们的实验课程中，可能会涉及在各个 Lab 中进行切换。这时，使用 git checkout lab\u0026lt;x\u0026gt; 可以切换到相应的分支。\n请注意，在切换时，需要保证目前所有文件的状态均为“未修改”（没有修改过，或者已经提交）。\ngit commit 使用 git commit -m \u0026lt;message\u0026gt; 这个命令将暂存区的修改提交到储存库中。当 message 参数有空格时需要把 message 用引号括起来。在提交时，要求给出一段说明性文字。这段文字可以任意填写，但建议按照提交内容填写，以保证多人协作时的可读性。本实验不会涉及多人协作，所以方便自己开发即可。\ngit push 这个命令将本地的 commit 推送到一个远程仓库。在课程实验中，这个命令可以将你的 commit 推送到 GitLab。\ngit pull 这个命令将远程新建的分支下载到本地，并且将远端的更改合并到当前的分支。在利用评测机进行实验分支的初始化之后，可以在开发机中使用这个命令来将新的分支下载到本地。\n7.shell编程 shell脚本：一条一条命令组合起来，放到一个文件中，并且可以直接运行这个文件\nLinux中没有扩展名的概念，约定脚本文件的文件名都以.sh结尾(加不加对运行无影响)\n运行脚本\n./文件名\n为脚本添加执行权限\nchmod +x 文件名\nshell语法基础 1.变量 shell是弱类型语言，定义变量时无需指定类型 var_name=value(不能用空格间隔) 例如\n#!/bin/bash # my first shell script str=\u0026#34;Hello, world!\u0026#34; echo ${str} #!为shebang,shebang后边的内容为脚本文件的解释器\n#注释开头\necho输出命令\n$var_name为获取变量的值，更规范的写为${var_name}\n2.脚本参数 执行语句中，参数以空格分隔，每一个参数在脚本中都是一个字符串变量。第一个参数映射到变量名 1，第二个参数映射到变量名 2，以此类推（参数变量名只能为顺序的1234，不能随便起）\n上例中的脚本增加参数\n#!/bin/bash str=\u0026#34;Hello, $1 and $2!\u0026#34; echo $str 需要注意的是向字符串变量中传递参数字符串变量需为双引号\n其他特殊变量\n$#传递的参数个数 $*一个字符串，内容是传递的全部参数 3.条件与循环 if 条件语句结尾fi表示if语句块结束 需要注意的是除了else分支外其他分支需要加then if condition1 then command11 command12 ...... elif condition2 then command21 command22 ...... else command31 command32 ...... fi while done表示语句块结束 while condition do command1 command2 ... done 对于循环变量的更新 i=1初始化循环变量 let i=i+1或i=$((i+1))更新循环变量 4.函数 定义方式\nfunction fun_name() { body... return int_value; } 返回语句可选，返回值范围[0-255]整数 函数体内第N个参数通过$N获取，当N\u0026gt;=10使用${N} 若函数有返回值，在函数调用后使用$?获取返回值 调用方法\nfun_name param1 param2 ... paramN sed命令编辑和输出文本 用法：sed [选项] ‘命令’ 文本\n选项\n-n安静模式，只显示经过sed处理的内容，否则显示文本的全部内容 -i直接修改读取的文件内容，而不是输出到屏幕。否则只输出不编辑 命令\n\u0026lt;行号\u0026gt;a\u0026lt;内容\u0026gt;,在行号下面插入一行文本\n关于行号\n“数字”：在这一行后新增 “起始行，终止行”：在范围内每一行后新增 省略行号：每一行新增 \u0026ldquo;$\u0026quot;：最后一行后新增 \u0026lt;行号\u0026gt;c\u0026lt;内容\u0026gt;，用内容取代相应行的文本\n\u0026lt;行号\u0026gt;i\u0026lt;内容\u0026gt;，在当前行的上面插入一行文本\n\u0026lt;行号\u0026gt;d，删除该行内容\n\u0026lt;行号\u0026gt;p,输出该行内容\ns/\u0026lt;re\u0026gt;/\u0026lt;string\u0026gt;/将对应行中正则表达式\u0026lt;re\u0026gt;匹配的内容替换为\u0026lt;string\u0026gt;\n此项为针对整个文本进行替换 形如's/str1/str2/g'则对文本中整行范围内的str1替换为str2 形如's/str1/str2/'则对文本中每行中第一个匹配的str1替换为str2 重定向 重定向：命令输出结果输出到文件中N\u0026gt;\nLinux中定义的三种流\nstdin:用0表示 stdout:用1表示 stderr:用2表示 将标准输出保存到文件中，使用1\u0026gt;例如\nls \u0026gt; lsoutput.txt或ls 1\u0026gt; lsoutput.txt\n将标准错误输出保存到文件中，使用2\u0026gt;例如\ngcc 2\u0026gt; gccerr.txt\n问题：尝试自己写一个接受标准输入的 C 语言程序\n解决：将输入文件喂给编译好的可执行程序\u0026lt;\n./scanf.out \u0026lt; input.txt 管道 对命令进行连接，上一个命令的输出为下一个命令的输入 command1|command2|command3 ","permalink":"https://coder0xe.github.io/posts/ospre%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/","summary":"\u003ch1 id=\"ospre工具介绍\"\u003e\u003ccenter\u003eOSpre——工具介绍\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"1vim\"\u003e1.vim\u003c/h2\u003e\n\u003cp\u003e​\tvim为CLI的文本编辑工具，一些常用的操作如下\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003evim有Normal模式和Insert模式\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e启动vim后默认在Normal模式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ei\u003c/code\u003e进入Insert模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eesc\u003c/code\u003e进入Normal模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在\u003ccode\u003eInsert\u003c/code\u003e模式下的一些操作\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ectrl + p or ctrl + n\u003c/code\u003e自动补全\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在\u003ccode\u003eNormal\u003c/code\u003e模式下的一些操作\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ex\u003c/code\u003e删除当前光标所在的一个字符\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e:wq\u003c/code\u003e存盘+退出\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e:w\u003c/code\u003e存盘\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e:q\u003c/code\u003e退出\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e拷贝\\粘贴\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ev\u003c/code\u003e可视化的选择部分文本\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003edd\u003c/code\u003e删除当前行，并把删除的行存在剪贴板里\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ep\u003c/code\u003e粘贴剪贴板\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eyy\u003c/code\u003e拷贝当前行(ddp)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e各种插入模式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e在光标后插入（会进入Insert模式）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eo\u003c/code\u003e（小写O）在当前行后插入一个新行\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e移动光标\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e方向键移动光标\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e0\u003c/code\u003e移动到行头\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$\u003c/code\u003e移动到行尾\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e^\u003c/code\u003e移动到本行第一个不是blank字符的位置\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eg_\u003c/code\u003e移动到本行最后一个不是blank字符的位置\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eN\u003ccode\u003eG\u003c/code\u003e移动到第N行\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003egg\u003c/code\u003e到第一行\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eG\u003c/code\u003e到最后一行\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e搜索\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/pattern\u003c/code\u003e搜索\u003ccode\u003epattern\u003c/code\u003e的字符串，\u003ccode\u003en\u003c/code\u003e切换到下一个\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e匹配光标所在单词，移动光标到下一个匹配单词\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e#\u003c/code\u003e匹配光标所在单词，移动光标到上一个匹配单词\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e重复命令\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.\u003c/code\u003e重复上一次的命令\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eN\u0026lt;command\u0026gt;\u003c/code\u003e重复某个命令N次\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUndo/Redo\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eu\u003c/code\u003e Undo\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ectrl + r\u003c/code\u003e Redo\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2gcc\"\u003e2.GCC\u003c/h2\u003e\n\u003cp\u003e​\t使用gcc作为C语言编译器\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e用法：gcc [选项] 源代码文件\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e作用：编译源代码文件\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e默认编译生成文件名为\u003ccode\u003ea.out\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e运行c语言代码\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-CLI\" data-lang=\"CLI\"\u003egcc demo.c\n./a.out\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e更改代码内容后需要重新编译\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3make--makefile\"\u003e3.make \u0026amp; Makefile\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003emake即为“制作”，他是依赖\u003ccode\u003eMakefile\u003c/code\u003e文件进行构建的指令\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"makefile文件的格式\"\u003eMakefile文件的格式\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u0026lt;target\u0026gt; : \u0026lt;dependencies\u0026gt;\n[tab] \u0026lt;command_1\u0026gt;\n[tab] \u0026lt;command_2\u0026gt;\n...\n[tab] \u0026lt;command_n\u0026gt;\n##意为###\n如果要构建target首先要准备好dependencies，接着执行command中的命令\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003etarget：构建目标，目标文件、可执行文件\u003c/p\u003e","title":"OSpre——工具介绍"},{"content":"OSpre——Linux系统 1.Linux文件系统 Linux文件系统的最顶层是根目录，用/表示，所有文件都存放在根目录下 根目录下放置的二级目录： /boot目录：启动Linux内核 /etc目录：系统配置文件 /home目录：存放普通用户主目录 /root目录：系统管理员（root用户）主目录 /usr目录：用户系统资源存放的目录 \u0026hellip; ~是当前用户主目录的简写 对于一般用户，主目录为/home/用户名 对于root用户，主目录为/root 命令行前符号$代表当前用户为普通用户，#代表当前用户为root用户’ 2.Linux基础命令 1.目录操作 1. cd —— change dictionary cd：切换到某个目录，支持绝对路径和相对路径\n用法：cd [参数] 目录\n.代表当前目录，..代表上一级目录\ncd -切换到上一次访问的目录\ncd ~回到当前用户主目录\ntab键自动补全\n例：下面哪些命令可以切换到 /home/git/test 这个目录？假定你的用户名是 git，你目前所处的目录是 /home/git\n答：cd test | cd ~/test | cd ./test | cd test/\n2. ls —— list dictionary contents ls：列出目录中的文件\n用法：ls [参数] [目录]\n参数：\n-a 列出隐藏的文件 -l每行只列出一个文件 目录：若未给出则列出当前目录下文件\n3. mkdir —— make ditionary mkdir：创建新目录\n用法： mkdir [参数] 目录\n4. rmdir —— remove empty dictionary rmdir：删除空目录\n用法：rmdir [参数] 目录\n5. pwd —— print working dictionary pwd：打印当前工作目录\n用法： pwd\n2.文件操作 1.touch touch：创建新文件\n用法：touch [参数] 文件名\n注：当文件不存在时创建文件，当文件存在时更新时间戳\n2. rm rm：删除文件\n用法：rm [参数] 文件\n参数：\n-r递归删除目录及其中内容，对于非空目录必须有此参数 -f强制删除，不提示用户 -i逐一提示用户将要被删除的文件 常用组合：-rf 3.cp cp：复制文件\n用法：cp [参数] 源文件 目标路径\n若目标路径为文件，则作用为将目标路径中的文件内容替换为源文件中的内容\n若目标路径为目录，则作用为将源文件复制到目标路径\n-r递归复制目录及其子目录内的所有内容\n4.mv mv：移动文件\n用法：mv [参数] 源文件 目标路径\n若目标路径为文件，则作用为将源文件移动为目标路径中的文件\n若目标路径为目录，则作用为将源文件移动到目标路径\n-r递归移动目录及其子目录中的所有内容\n可以在同一目录下进行文件的重命名\nmv text.txt text1.txt 注：mv 会删除源文件\n5.diff diff：用于纯文本文件之间的比较操作\n用法：diff [参数] 文件1 文件2\n参数：\n-b不检查空白字符的不同 -B不检查空行 -q仅检查有无差异，不显示详细信息 6.cat cat:将文件内容输出到标准输出 用法:cat 文件 3.查找操作 1.find 用法：find [路径] \u0026lt;选项\u0026gt; 作用：在给定路径下递归地查找文件，输出符合要求的文件的路径，如果没有给定路径，则在当前目录下查找 选项常用：-name \u0026lt;文件名\u0026gt; 2.grep 用法：grep [参数] PATTERN FILE PATTERN:匹配字符串 FILE:文件或目录的路径（在目录中查找时需要-r参数） grep为匹配文件中的内容查找文件和文件中的匹配位置 参数 -a不忽略二进制数据进行搜索 -i忽略大小写差异 -r从目录中递归查找 -n显示行号 常用组合：-rin 3.tree 用法：tree [选项] [目录名] 作用：输出目录下的文件树 选项 -a列出全部文件 -d只列出目录 4.查看指令详细信息 man \u0026lt;命令名\u0026gt; q退出 /\u0026lt;content\u0026gt;搜索内容 3.终端中常用快捷键 ctrl + C终止当前程序执行 上下方向键切换最近使用过的命令 左右方向键移动光标位置 使用右键复制粘贴 ctrl + Z挂起当前程序，放到后台。 挂起后会显示程序挂起编号job_spec，恢复可用fg [job_spec] ctrl + D终止输入\\退出当前shell ctrl + L清屏，相当于clear ctrl + S暂停终端 ctrl + W让终端继续运行 ","permalink":"https://coder0xe.github.io/posts/ospre/","summary":"\u003ch1 id=\"osprelinux系统\"\u003e\u003ccenter\u003eOSpre——Linux系统\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"1linux文件系统\"\u003e1.Linux文件系统\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLinux文件系统的最顶层是根目录，用\u003ccode\u003e/\u003c/code\u003e表示，所有文件都存放在根目录下\u003c/li\u003e\n\u003cli\u003e根目录下放置的二级目录：\n\u003cul\u003e\n\u003cli\u003e/boot目录：启动Linux内核\u003c/li\u003e\n\u003cli\u003e/etc目录：系统配置文件\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e/home目录：存放普通用户主目录\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e/root目录：系统管理员（root用户）主目录\u003c/li\u003e\n\u003cli\u003e/usr目录：用户系统资源存放的目录\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e~是当前用户主目录的简写\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e对于一般用户，主目录为\u003ccode\u003e/home/用户名\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e对于root用户，主目录为\u003ccode\u003e/root\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e命令行前符号\u003ccode\u003e$\u003c/code\u003e代表当前用户为普通用户，\u003ccode\u003e#\u003c/code\u003e代表当前用户为root用户’\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2linux基础命令\"\u003e2.Linux基础命令\u003c/h2\u003e\n\u003ch3 id=\"1目录操作\"\u003e1.目录操作\u003c/h3\u003e\n\u003ch4 id=\"1-cd--change-dictionary\"\u003e1. cd —— change dictionary\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ecd：切换到某个目录，支持绝对路径和相对路径\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e用法：cd [参数] 目录\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e.\u003c/code\u003e代表当前目录，\u003ccode\u003e..\u003c/code\u003e代表上一级目录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ecd -\u003c/code\u003e切换到上一次访问的目录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ecd ~\u003c/code\u003e回到当前用户主目录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003etab键自动补全\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e例\u003c/strong\u003e：下面哪些命令可以切换到 \u003ccode\u003e/home/git/test\u003c/code\u003e 这个目录？假定你的用户名是 \u003ccode\u003egit\u003c/code\u003e，你目前所处的目录是 \u003ccode\u003e/home/git\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e答\u003c/strong\u003e：\u003ccode\u003ecd test\u003c/code\u003e | \u003ccode\u003e cd ~/test\u003c/code\u003e | \u003ccode\u003e cd ./test\u003c/code\u003e | \u003ccode\u003e cd test/\u003c/code\u003e\u003c/p\u003e\n\u003ch4 id=\"2-ls--list-dictionary-contents\"\u003e2. ls —— list dictionary contents\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003els：列出目录中的文件\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e用法：ls [参数] [目录]\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e-a 列出隐藏的文件\u003c/li\u003e\n\u003cli\u003e-l每行只列出一个文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e目录：若未给出则列出当前目录下文件\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3-mkdir--make-ditionary\"\u003e3. mkdir —— make ditionary\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003emkdir：创建新目录\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e用法： mkdir [参数] 目录\u003c/strong\u003e\u003c/p\u003e","title":"OSpre——Linux系统"},{"content":"从0开始配龙芯杯vivado+vcs虚拟机环境(Ubuntu22.04) 0. mad ​\t为了配置龙芯杯需要的vivado+vcs环境，这个繁琐的过程已经困扰了我两天，重新装了三次虚拟机系统，总结之后决定在配置的过程中写一篇笔记来记录过程，如果这次失败了也方便下一次再来。一开始我采用Ubuntu23.10，后来遇到各种不理解的报错，不知道怎么解决，我就都归结到Ubuntu版本过新上（恼），于是换成Ubuntu22.04镜像文件重新配置(QAQ)，（后来发现确实是因Ubuntu版本有一定问题），所以一定要用Ubuntu22.04啊！！！\n环境的软件版本：\nVmware Workstation Pro 17\nUbuntu 22.04\nvivado 2019.2\nvcs 2018.09\n1.虚拟机初始配置 1.配置中文输入法 ​\t一个新系统自然要先配置好中文输入法，我这里使用ibus框架。\n1.安装汉语支持 ​\tSettings——\u0026gt;Region\u0026amp;Language——\u0026gt;Manage Install Language——\u0026gt;Install/Remove Languages——\u0026gt;Chinese(simplified)——\u0026gt;重启系统\n2.安装ibus框架 sudo apt-get install ibus sudo apt-get install ibus-pinyin sudo ibus-setup#打开ibus设置界面 ​\t在打开的ibus设置界面中在Input Method一栏中添加中文输入法Add——\u0026gt;Chinese——\u0026gt;Intelligent Pinyin\n3.设置系统变量 vim ~/.bashrc #添加系统变量 export GTK_TM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ############ source .bashrc 再次重启使系统变量生效\n4. add Input Source settings——\u0026gt;Keyboard——\u0026gt;Input Source——\u0026gt;add Chinese(Intelligent Pinyin)\n再次重启即可使用中文输入法\n2.安装vmware-tools ​\tvmware-tools是实现主机与虚拟机之间交互的重要软件，网上一些教程通过vmware station上方虚拟机选项卡中的重新安装vmware tools进行。我们可以发现此时该选项为灰色，即使通过网络上的种种办法可以改为黑色可选状态，但在安装过程中会报错Segmentation fault，实际原因是下载的版本过低，与当前系统不适配，我们使用手动命令行下载可以避免\nsudo apt install open-vm-tools sudo apt install open-vm-tools-desktop ###我这里运行到这里需要进行重启 否则会报错找不到包 sudo apt install gnome-shell-extension-prefs sudo apt install nemo 在extensions应用程序中关掉Desktop icon NG(该程序在安装gnome-shell-extension后产生)\n在startup application preference里增加Nemo Desktop程序(该程序在安装gnome-shell-extension之前就有)\n再次重启\n​\t至此我们实现了：\n在主机与虚拟机之间复制粘贴\n虚拟机窗口自适应大小\n通过拖拽文件实现主机与虚拟机之间的复制\n开启共享文件夹\n在虚拟机设置中打开共享文件夹选项——\u0026gt;总是启用——\u0026gt;设置主机路径\n可以通过指令ls /mnt/hgfs查看是否设置成功\n可以看到我设置的共享文件夹名称为shared-folder\n2. vivado2019.2安装 1.安装设置 ​\t在龙芯杯北航云盘中提供了vivado2019.2的安装包，实际上对于龙芯杯我们只需要使用免费的wepack版本即可满足需求，安装需求设置如下，安装最终需要25.22G。\n​\t在安装路径上可以考虑新建一个edaTools文件夹，下设各子文件夹作为各开发软件安装路径。\nhome/dqr/edaTools: vivado synopsys \u0026hellip; 2.安装步骤 下载北航云盘中提供的安装包\n解压安装包（安装包默认下载在Downloads文件夹中）\n进入解压后的文件夹运行\nchmod +x xsetup #修改脚本运行权限 ./xsetup ​\t弹出安装界面\n按照安装设置安装 3.启动vivado ​\t在安装完成之后Ubuntu桌面上会产生vivado的图标，同时可以将vivado加入环境变量，通过在终端中启动vivado。\ndqr@dqr:~$ vivado ​\t将vivado加入环境变量\nvim ~/.bashrc ########content######## # vivado export PATH=$PATH:~/edaTools/vivado/Vivado/2019.2/bin/ alias vivado2019=\u0026#34;~/edaTools/vivado/Vivado/2019.2/bin/vivado\u0026#34; ##################### source ~/.bashrc #激活环境变量 4.解决报错 1.使用终端运行vivado时报错 application-specific initialization failed: couldn\u0026#39;t load file \u0026#34;librdi_commontasks.so\u0026#34;: libtinfo.so.5: cannot open shared object file: No such file or directory 解决方法\nsudo apt-get install libtinfo5 3. vcs安装和激活 1.安装 需要安装scl和vcs，安装链接：https://bhpan.buaa.edu.cn/link/AAE0F74DF381804CD0BCB7D7C0B89EC350\n需要下面四个\nscl_keygen_2030是在主机windows上运行的破解软件 scl_v2018.06即为scl安装包 vcs_mx_vO-2018.09-SP2即为vcs安装包 synopsysinstaller_v5.0是scl和vcs的安装程序 使用snopsysinstaller安装scl和vcs\n在edaTools下建好synopsysinstaller文件夹和synopsys文件夹，将synopsysinstaller_v5.0解压到synopsysinstaller，运行\ndqr@dqr:~/edaTools/synopsysinstaller$ chmod +x SynopsysInstaller_v5.0.run dqr@dqr:~/edaTools/synopsysinstaller$ ./SynopsysInstaller_v5.0.run 安装路径默认回车，然后\ndqr@dqr:~/edaTools/synopsysinstaller$ ./setup.sh 跳出安装界面，第一个配置页面直接next\n在此页面选择安装包位置，安装scl和vcs在此处同理，以scl为例\n选择安装目录，即我们刚才创建的synopsys文件夹\n此处打勾\n重复一遍安装vcs（不必注意安装结束之后的报错）\n2.激活 ​\twindows下运行破解软件，填写虚拟机的hostname和mac地址\nhostname\ndqr@dqr:~/edaTools/synopsysinstaller$ hostname mac地址\ndqr@dqr:~$ sudo apt install net-tools dqr@dqr:~$ ifconfig 在显示的详细信息中mac地址为ether后面部分\n在破解软件中填写hostname和mac地址，注意填写mac地址时要去掉冒号，点击generate后copy\n在dqr@dqr:~/edaTools/synopsys/scl/2018.06/admin/license下新建文件Synopsys.dat并粘贴文件内容，\nvim创建新文件\nvim Synopsys.dat 点击I进入插入模式、粘贴\n在文件第二行后添加自己安装的snpslmd软件路径\n我这里的路径是**~/edaTools/synopsys/scl/2018.06/linux64/bin/snpslmd**\nEsc退出插入模式\n:wq进行保存\n重启虚拟机，关闭占用27000端口的进程\nnetstat -ap | grep 27000 kill -9 XXX(使用27000端口的进程ID) 安装lsb-core库\nsudo apt-get install lsb-core 建立路径\nsudo mkdir /usr/tmp/ sudo chmod 777 /usr/tmp/ 运行进行激活\n~/edaTools/synopsys/scl/2018.06/linux64/bin/lmgrd -c ~/edaTools/synopsys/scl/2018.06/admin/license/Synopsys.dat 添加环境变量(vim ./bashrc)其中hostname和具体路径需要修改\n#synosys tolls list export VCS_HOME=/home/dqr/edaTools/synopsys/vcs-mx/O-2018.09-SP2 export SCL_HOME=/home/dqr/edaTools/synopsys/scl/2018.06 #dev export PATH=$PATH:$VCS_HOME/gui/dve/bin alias dve=\u0026#34;dve\u0026#34; #vcs export PATH=$PATH:$VCS_HOME/bin alias vcs=\u0026#34;vcs\u0026#34; #scl export PATH=$PATH:$SCL_HOME/linux64/bin export VCS_ARCH_OVERRIDE=linux #LICENCE export LM_LICENSE_FILE=27000@dqr alias lmg_vcs=\u0026#39;lmgrd -c /home/dqr/edaTools/synopsys/scl/2018.06/admin/license/Synopsys.dat\u0026#39; 3.进行测试 ​\t在cpucode中新建测试代码test.v\nmodule test; reg a, b; wire c; assign c = a \u0026amp; b; initial begin a = 0; b = 0; #10 a = 1; #10 b = 1; #10 $finish; end endmodule 运行时遇到报错(vcs -full64 test.v)：\n/bin/sh: 0: Illegal option -h 解决\nsudo rm -f /bin/sh sudo ln -s /bin/bash /bin/sh 测试成功（运行测试代码之前一定要进行激活！）\n出现报错\n../../OBJ/lib/saverestoreobj/obj-linux64/kernel.o:(.text+0xc41): undefined reference to pthread_yield 解决\ndqr@dqr:~/edaTools/synopsys/vcs-mx$ mv O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o.bak dqr@dqr:~/edaTools/synopsys/vcs-mx$ objcopy --redefine-sym pthread_yield=sched_yield O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o.bak O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o 出现报错\n/usr/bin/ld: /home/dqr/edaTools/synopsys/vcs-mx/O-2018.09-SP2/linux64/lib/libvcsnew.so: undefined reference to `vfs_set_dir_map\u0026#39; 解决：增加编译选项，修改编译指令为\nvcs -full64 test.v -LDFLAGS -Wl,--no-as-needed 4.vivado+vcs联合仿真 1.设置使用VCS编译 新建Compile Simulation Libraries\n下图中进行的设置：\nSimulation:VCS Compiled library location:编译文件存放目录，我选择在documents下新建 Simulator execetable path:vcs的bin目录 2.设置使用VCS仿真 settings\n设置VCS路径和lib文件路径\n修改编译选项，防止报错Unreferenced to ...\n在三个箭头指向的选项中都将more_options设置为-LDFLAGS -Wl,--no-as-needed\n5.sublime text配置iverilog进行语法检查 安装package control\n安装system verilog 进行语法高亮\n安装verilog gadget\n安装sublimelinter\n安装sublimelinter-contrib-iverilog\n运行脚本安装iverilog\n#!/usr/bin/env bash # This script compiles and installs the master branch iverilog. # Tested on Ubuntu 18.04 SCRIPT_DIR=\u0026#34;$( cd \u0026#34;$( dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34; )\u0026#34; \u0026amp;\u0026amp; pwd )\u0026#34; THREAD_CNT=$(getconf _NPROCESSORS_ONLN) INSTALL_DIR=\u0026#34;/usr/local/iverilog\u0026#34; sudo apt install -y autoconf gperf pushd \u0026#34;/tmp\u0026#34; || exit wget \u0026#34;https://github.com/steveicarus/iverilog/archive/master.zip\u0026#34; -O \u0026#34;iverilog.zip\u0026#34; unzip \u0026#34;iverilog.zip\u0026#34;; rm -f \u0026#34;iverilog.zip\u0026#34; pushd \u0026#34;iverilog-master\u0026#34; || exit autoconf || exit ./configure --prefix=\u0026#34;${INSTALL_DIR}\u0026#34; || exit make -j\u0026#34;${THREAD_CNT}\u0026#34; || exit sudo make install || exit popd || exit rm -rf \u0026#34;iverilog-master\u0026#34; popd || exit 插件和 iverilog 都安装完毕后在 Sublime 中点击Preference -\u0026gt; Package settings -\u0026gt; SublimeLinter -\u0026gt; settings，在打开页面的{ }中输入以下配置代码：(/usr/local/iverilog/bin为iverilog默认bin路径)\n\u0026#34;paths\u0026#34;: { \u0026#34;linux\u0026#34;: [ \u0026#34;/usr/local/iverilog/bin\u0026#34;, ], \u0026#34;osx\u0026#34;: [], \u0026#34;windows\u0026#34;: [], }, \u0026#34;linters\u0026#34;: { \u0026#34;iverilog\u0026#34;: { \u0026#34;disable\u0026#34;: false, \u0026#34;args\u0026#34;: [\u0026#34;-i\u0026#34;], // add the \u0026#34;-i\u0026#34; flag \u0026#34;excludes\u0026#34;: [], }, }, 重启sublime text即可实现语法检查\n","permalink":"https://coder0xe.github.io/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E9%85%8D%E4%B8%80%E4%B8%AA%E9%BE%99%E8%8A%AF%E6%9D%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83/","summary":"\u003ch1 id=\"从0开始配龙芯杯vivadovcs虚拟机环境ubuntu2204\"\u003e从0开始配龙芯杯vivado+vcs虚拟机环境(Ubuntu22.04)\u003c/h1\u003e\n\u003ch2 id=\"0-mad\"\u003e0. mad\u003c/h2\u003e\n\u003cp\u003e​\t为了配置龙芯杯需要的vivado+vcs环境，这个繁琐的过程已经困扰了我两天，重新装了三次虚拟机系统，总结之后决定在配置的过程中写一篇笔记来记录过程，如果这次失败了也方便下一次再来。一开始我采用Ubuntu23.10，后来遇到各种不理解的报错，不知道怎么解决，我就都归结到Ubuntu版本过新上（恼），于是换成Ubuntu22.04镜像文件重新配置(QAQ)，（后来发现确实是因Ubuntu版本有一定问题），\u003cstrong\u003e所以一定要用Ubuntu22.04啊！！！\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e环境的软件版本：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eVmware Workstation Pro 17\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUbuntu 22.04\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003evivado 2019.2\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003evcs 2018.09\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"1虚拟机初始配置\"\u003e1.虚拟机初始配置\u003c/h2\u003e\n\u003ch3 id=\"1配置中文输入法\"\u003e1.配置中文输入法\u003c/h3\u003e\n\u003cp\u003e​\t一个新系统自然要先配置好中文输入法，我这里使用ibus框架。\u003c/p\u003e\n\u003ch4 id=\"1安装汉语支持\"\u003e1.安装汉语支持\u003c/h4\u003e\n\u003cp\u003e​\tSettings——\u0026gt;Region\u0026amp;Language——\u0026gt;Manage Install Language——\u0026gt;Install/Remove Languages——\u0026gt;Chinese(simplified)——\u0026gt;重启系统\u003c/p\u003e\n\u003ch4 id=\"2安装ibus框架\"\u003e2.安装ibus框架\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo apt-get install ibus\nsudo apt-get install ibus-pinyin\nsudo ibus-setup#打开ibus设置界面\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t在打开的ibus设置界面中在\u003ccode\u003eInput Method\u003c/code\u003e一栏中添加中文输入法\u003ccode\u003eAdd——\u0026gt;Chinese——\u0026gt;Intelligent Pinyin\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240208230328350\" loading=\"lazy\" src=\"/img/image-20240208230328350.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"3设置系统变量\"\u003e3.设置系统变量\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evim ~/.bashrc\n#添加系统变量\nexport GTK_TM_MODULE=ibus\nexport XMODIFIERS=@im=ibus\nexport QT_IM_MODULE=ibus\n############\nsource .bashrc\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e再次重启使系统变量生效\u003c/p\u003e\n\u003ch4 id=\"4-add-input-source\"\u003e4. add Input Source\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003esettings——\u0026gt;Keyboard——\u0026gt;Input Source——\u0026gt;add Chinese(Intelligent Pinyin)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240208231504827\" loading=\"lazy\" src=\"/img/image-20240208231504827.png\"\u003e\u003c/p\u003e\n\u003cp\u003e再次重启即可使用中文输入法\u003c/p\u003e\n\u003ch3 id=\"2安装vmware-tools\"\u003e2.安装vmware-tools\u003c/h3\u003e\n\u003cp\u003e​\tvmware-tools是实现主机与虚拟机之间交互的重要软件，网上一些教程通过vmware station上方虚拟机选项卡中的重新安装vmware tools进行。我们可以发现此时该选项为灰色，即使通过网络上的种种办法可以改为黑色可选状态，但在安装过程中会报错Segmentation fault，实际原因是下载的版本过低，与当前系统不适配，我们使用手动命令行下载可以避免\u003c/p\u003e","title":"从0开始配龙芯杯vivado+vcs虚拟机环境(Ubuntu22.04)"},{"content":"P7-Design-Document 0.顶层设计概述 ​\tP7要求为实现MIPS微系统，需要为P6实现的流水线CPU添加异常中断功能，并封装为CPU模块、实现系统桥Bridge、计时器Timer1,Timer2等模块，最终形成MIPS微系统，如下图所示。\n绿色虚线表示已经实现 紫色虚线表示新增部分 红色虚线为改变后的DM接口 P7需要实现的任务如下列表\n任务 解释 计时器 课程组提供代码 系统桥 为CPU提供统一的访问外设的接口，自行实现 协处理器CP0 设置CPU的异常处理功能，反馈CPU的异常信息，自行实现 内部检测异常与流水 CPU检测内部指令执行错误 外部中断响应 CPU需要具有响应外部中断信号的能力 异常处理指令 异常处理程序中，会有一些特殊的指令需要实现 单周期CPU的封装 让CPU从外部看上去是单周期CPU 异常处理程序 利用MARS编写简单的异常处理程序进行测试 施工步骤：\n更改流水线各级使之可以产生异常\n添加CP0处理异常\n添加Bridge与两个外设\n异常与中断\n异常：内部异常 如F级取指异常、D级计算溢出等 中断：来自外部设备，Timer0,Timer1,Interrupt 来自外部设备的中断比内部异常优先级更高 一.功能部件设计 0.新增指令的实现思路 P7中增加四条指令 mtc0 mfc0 eret syscall mtc0 ：写入CP0中寄存器(12/14) 对于mtc0和mfc0指令 ： 读取的CP0寄存器地址均为rd域，由于本实现中采用了集中式译码，故增加数据通路，将原指令的rd域流水下去，作为CP0寄存器地址, CP0_addr\n指令格式 ：\n010000 || 00100 || rt || rd || 00000000000\nmtc0 rt,rd\nMCU ：\nCP0_WE_D T_rs_use = T_rt_use = 3（这里rt的真实使用时间是3，但是并不会对暂停/转发造成影响，Tuse \u0026gt;= Tnew成立，可以通过转发解决） T_new = 0 写入时应当注意 ：Cause寄存器(13)不允许写入，EPC允许写入，SR寄存器部分字段允许写入，其他不允许写入的字段要保持为0\n1 2 3 4 5 6 7 if(A2 == 12) begin `IM \u0026lt;= D_in[15:10]; `EXL \u0026lt;= D_in[1]; `IE \u0026lt;= D_in[0]; end else if (A2 == 14) EPC \u0026lt;= D_in; mfc0 : 读取CP0中寄存器的值(12/13/14) ​\t在M级CP0输出结果与DE输出结果之间加MUX\n指令格式 ： 010000 || 00000 || rt || rd || 00000000000\nmfc0 rt,rd\nMCU :\nRegWrite T_rs_use = T_rt_use = 3 T_new = 3 eret : 从中断/异常处理中返回 MCU中判断后进行流水，D_eret，在M级进行使用跳出异常处理\neret是错误最易发生的一个指令，对于eret的要求有:\n跳转到CP0中EPC寄存器存储的受害PC\n不执行eret后延迟槽中的指令\n不执行延迟槽中的指令我的实现方式(比较优雅 较为推荐)为 ：在D级识别到eret指令后，在F级直接插入nop，同时npc中选择EPC端口\n1 2 3 4 5 6 \\\\ D_MCU_eret : D_eret assign D_eret = op_eret; \\\\ F-D reg 当F级出现取指异常或D级识别到eret指令时 传递指令nop assign F_instr_new = (F_AdEL) ? 32\u0026#39;b0 : (D_eret) : F_instr; \\\\ D_npc assign npc = (D_eret) ? EPC : ... 同时还有两种可能的实现方式 ：\n在D级识别到eret指令后，清D级延迟槽，但是此时应当注意清空延迟槽的条件为(clr \u0026amp;\u0026amp; !stall)，即判断当前非暂停，举一个简单的例子就可以知道，例如D:eret E:mtc0\n**一定要注意信号之间的优先级！**下面给出D级流水线寄存器的代码(我采用集中式译码，好臃肿，更加推荐分布式译码(bushi))\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 always@(posedge clk)begin if(reset )begin instr \u0026lt;= 32\u0026#39;b0; pc \u0026lt;= 32\u0026#39;b0; pc8 \u0026lt;= 32\u0026#39;b0; ExcCode \u0026lt;= 5\u0026#39;b0; BD \u0026lt;= 1\u0026#39;b0; end else if (req) begin instr \u0026lt;= 32\u0026#39;b0; pc \u0026lt;= 32\u0026#39;h0000_4180; pc8 \u0026lt;= 32\u0026#39;h0000_4188; ExcCode \u0026lt;= 5\u0026#39;b0; BD \u0026lt;= 1\u0026#39;b0; end else if (clr \u0026amp;\u0026amp; en) begin instr \u0026lt;= 32\u0026#39;b0; pc \u0026lt;= 32\u0026#39;b0; pc8 \u0026lt;= 32\u0026#39;b0; ExcCode \u0026lt;= 5\u0026#39;b0; BD \u0026lt;= 1\u0026#39;b0; end else if (en) begin instr \u0026lt;= F_instr; pc \u0026lt;= F_pc; pc8 \u0026lt;= F_pc8; ExcCode \u0026lt;= F_ExcCode; BD \u0026lt;= F_BD; end else begin //stall instr \u0026lt;= instr; pc \u0026lt;= pc; pc8 \u0026lt;= pc8; ExcCode \u0026lt;= ExcCode; BD \u0026lt;= BD; end end 在F级输入pc取指时进行特判(这种写法我没有通过，报错处理延迟槽中断后没有跳回跳转指令)，不过多叙述\nsyscall : 系统调用异常 在D级MCU中识别出来并判断为异常即可 0.5关于流水线寄存器/PC选择中的信号优先级问题 2023秋计算机组成教程中课程组对于信号的优先级规定如下\nreset \u0026gt; req \u0026gt; stall\n​\t在流水线寄存器和IFU中pc选择时需要对信号优先级进行判断，推荐使用if_else_if_else语句实现对优先级的判断，非常重要！\n流水线寄存器，以信号最复杂的E级为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 lways@(posedge clk) begin if(reset) begin ... end else if(req) begin ... end else if(clr)begin pc \u0026lt;= D_pc ; // 注意E级暂停时也要对pc,BD信号进行流水 pc8 \u0026lt;= D_pc8 ; BD \u0026lt;= D_BD; ... end else begin ... end end IFU中PC的选择\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 always@(posedge clk)begin if(reset)begin PC \u0026lt;= 32\u0026#39;h0000_3000; PC8 \u0026lt;= 32\u0026#39;h0000_3008; tmp \u0026lt;= 32\u0026#39;b0; end else if (req) begin PC \u0026lt;= npc; PC8 \u0026lt;= npc + 4\u0026#39;b1000; tmp \u0026lt;= npc - 32\u0026#39;h0000_3000; end else if (en)begin PC \u0026lt;= npc; PC8 \u0026lt;= npc + 4\u0026#39;b1000; tmp \u0026lt;= npc - 32\u0026#39;h0000_3000; end else begin PC \u0026lt;= PC; PC8 \u0026lt;=PC8; tmp \u0026lt;= tmp; end 1.CP0 0.数据通路 **宏观PC：**为了将我们的流水线CPU封装为单周期CPU（至少在外界看来是这个样子），提出宏观PC的概念，在宏观PC之前的地址对应的指令均已经完成，在宏观PC之后的地址对应的指令还未完成，依据这一特点我们知道应当将CP0(Coprocessor0)放置在M级流水线。 1.需要处理的异常 0.异常优先级 一条指令发生多个异常，考虑最先发生的异常(F\u0026gt;D\u0026gt;E\u0026gt;M) 多条指令发生异常，也有限考虑最先发生的异常(M\u0026gt;E\u0026gt;D\u0026gt;F)，即将M级异常传入CP0 1.F级异常： PC地址没有字对齐（AdEL） PC地址超过0x3000 ~ 0x6ffc（AdEL） 还需要判断D级不是eret指令，因为eret后“延迟槽”中指令不被执行，即使在F级发生异常也不应被处理/进入异常处理程序。 1 assign F_ExcCode = (!D_eret) \u0026amp;\u0026amp; (F_pc[1:0] != 2\u0026#39;b00) || (F_pc \u0026lt; 32\u0026#39;h0000_3000) || (F_pc \u0026gt; 32\u0026#39;h0000_3fffc) ? ADEL : NONE; 注意F级发生取指错误后要流水空指令nop递交到CP0\n1 F_instr_new = (F_AdEL) ? 32\u0026#39;b0 : (D_eret) ? 32\u0026#39;b0 : F_instr; 1.D级异常： 未知的指令码（RI）\n从MCU中添加输出信号invalid_D，标记当前指令是否为无效指令，注意在MCU中识别nop指令\n1 assign invalid_D = !(cal_R | cal_I | store | load | branch | md | mt | mf | op_jal | op_jr | op_mfc0 | op_mtc0 | op_syscall | op_eret | op_nop | op_syscall); syccall 系统调用异常\n1 2 3 4 assign D_ExcCode_fixed = (D_ExcCode) ? D_ExcCode : (invalid_D) ? RI : (D_syscall) ? SYSCALL : NONE; 2.E级异常： addi、add、sub计算溢出（Ov）: 在MCU中添加输出信号isAriOv_D表示是不是需要判断溢出的运算指令\n1 assign isAriOv_D = op_add | op_addi | op_sub; load类指令计算地址时加法溢出（AdEL）\nstore类指令计算地址时加法溢出（AdES）\n1 2 3 4 assign E_ExcCode_fixed = (E_ExcCode) ? E_ExcCode : (overflow_E \u0026amp;\u0026amp; (DMOp_E == sw || DMOp_E == sh || DMOp_E == sb)) ? ADES : (overflow_E \u0026amp;\u0026amp; (DMOp_E == lw || DMOp_E == lh || DMOp_E == lb)) ? ADEL : (overflow_E \u0026amp;\u0026amp; isAriOv_E) ? OV : NONE; 补位法溢出判断 ​\t依据add,addi,sub原始的指令RTL中对溢出的判断编写.\ntemp = (GPR[rs]31 || GPR[rs]) + (GPR[rt]31 || GPR[rt]) if temp32 ≠ temp31 then SignalException(IntegerOverflow) else GPR[rd] ← temp31..0 endif ​\t以add为例翻译为对应的verilog代码如下\n1 2 3 4 5 6 7 8 9 ext_A = {src_A[31],src_A}; ext_B = {src_B[31],src_B}; ext_AO = ext_A + ext_B; if(ext_AO[32] != ext_AO[31]) begin overflow = 1\u0026#39;b1; end else begin E_AO = ext_AO[31:0]; end 3.M级异常： lw取数地址未 4 字节对齐（AdEL）\nlh取数地址未与 2 字节对齐（AdEL）\nlh、lb取 Timer 寄存器的值（AdEL）\nload型指令取数地址超出 DM、Timer0、Timer1、中断发生器的范围（AdEL）\nsw存数地址未 4 字节对齐（AdES）\nsh存数地址未 2 字节对齐（AdES）\nsh、sb存 Timer 寄存器的值（AdES）\nstore型指令向计时器的 Count 寄存器存值（AdES）\nstore型指令存数地址超出 DM、Timer0、Timer1、中断发生器的范围（AdES）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 wire lhlb_tag = (DMOp_M == lh || DMOp_M == lb); wire load_tag = (DMOp_M == lw || DMOp_M == lh || DMOp_M == lb); wire shsb_tag = (DMOp_M == sh || DMOp_M == sb); wire store_tag = (DMOp_M == sw || DMOp_M == sh || DMOp_M == sb); wire timer_addr = (M_AO \u0026gt;= 32\u0026#39;h7f00 \u0026amp;\u0026amp; M_AO \u0026lt;= 32\u0026#39;h7f0b) || (M_AO \u0026gt;= 32\u0026#39;h7f10 \u0026amp;\u0026amp; M_AO \u0026lt;= 32\u0026#39;h7f1b); wire dm_addr = (M_AO \u0026gt;= 32\u0026#39;h0000 \u0026amp;\u0026amp; M_AO \u0026lt;= 32\u0026#39;h2fff); wire interrupt_addr = (M_AO \u0026gt;= 32\u0026#39;h7f20 \u0026amp;\u0026amp; M_AO \u0026lt;= 32\u0026#39;h7f23); assign M_ExcCode_fixed = (M_ExcCode) ? M_ExcCode : (DMOp_M == lw \u0026amp;\u0026amp; (M_AO[1:0] != 2\u0026#39;b00)) ? ADEL : (DMOp_M == lh \u0026amp;\u0026amp; (M_AO[0] != 1\u0026#39;b0)) ? ADEL : (lhlb_tag \u0026amp;\u0026amp; timer_addr) ? ADEL : (load_tag \u0026amp;\u0026amp; !dm_addr \u0026amp;\u0026amp; !timer_addr \u0026amp;\u0026amp; !interrupt_addr) ? ADEL : (DMOp_M == sw \u0026amp;\u0026amp; (M_AO[1:0] != 2\u0026#39;b00)) ? ADES : (DMOp_M == sh \u0026amp;\u0026amp; (M_AO[0] != 1\u0026#39;b0)) ? ADES : (shsb_tag \u0026amp;\u0026amp; timer_addr) ? ADES : (store_tag \u0026amp;\u0026amp; timer_addr \u0026amp;\u0026amp; M_AO[3:0] == 4\u0026#39;h8) ? ADES : (store_tag \u0026amp;\u0026amp; !dm_addr \u0026amp;\u0026amp; !timer_addr \u0026amp;\u0026amp; !interrupt_addr) ? ADES : NONE; 2.端口定义列表 名称 方向 位宽 描述 产生来源和机制 clk I 1 时钟信号 reset I 1 同步复位信号 A1 I 5 读CP0寄存器编号 指令mfc0 A2 I 5 写CP0寄存器编号 指令mtc0 D_in I 32 写入CP0寄存器的数据 指令mtc0 M_pc I 32 M级PC:发生中断/异常时的PC M_ExcCode I 5 中断/异常的类型 异常功能部件 BD_in I 1 分支延迟槽指令标志 HWInt I 6 6个外部设备的中断 外部设备 WE I 1 CP0寄存器写使能 指令mtc0 EXTClr I 1 SR的EXL位置零 eret_M控制信号输入 req O 1 异常/中断请求 CP0模块确认响应异常/中断 EPC_out O 32 EPC寄存器输出 D_out O 32 CP0寄存器输出数据 指令mfc0 3.内部寄存器列表 ​\t将SR,Cause,EPC都实现为32位！\n寄存器 编号 功能 SR 12 配置异常的功能。 Cause 13 记录异常发生的原因和情况。 EPC 14 记录异常处理结束后需要返回的 PC。 寄存器 功能域 位域 解释 SR（State Register） IM（Interrupt Mask） 15:10 分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过 mtc0 这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。 SR（State Register） EXL（Exception Level） 1 任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。 SR（State Register） IE（Interrupt Enable） 0 全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。 Cause BD（Branch Delay） 31 当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。 Cause IP（Interrupt Pending） 15:10 为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。 Cause ExcCode 6:2 异常编码，记录当前发生的是什么异常。 EPC - - 记录异常处理结束后需要返回的 PC。 4.设计思路 ​\t在CP0中进行处理的指令有mfc0,mtc0\nmfc0 (读) SR Cause EPC mtc0 (写/Cause only read) SR EPC ​\t在CP0中定义三个32位寄存器，并使用宏定义定义寄存器的功能字段\n1.产生异常/中断请求 使用位缩减运算符 | : result = a[0] | a[1] | \u0026hellip;.\n注：外部中断比内部异常优先级更高，即有有中断先处理中断，后处理异常\n1 2 3 wire int_req = (|(HWInt \u0026amp; `IM)) \u0026amp; (!`EXL) \u0026amp; (`IE); // (某一个外设上有中断且允许中断) \u0026amp; (当前不在中断处理中) \u0026amp; (允许中断) wire exc_req = (| M_ExcCode) \u0026amp; (!`EXL); // （有异常）\u0026amp; （当前不在中断处理中） assign req = int_req | exc_req; // request 2.EPC处理 ​\t对于EPC要考虑延迟槽的问题\n若产生异常的为延迟槽中的指令，则跳回到跳转指令，即M_pc - 4\nwire [31:2] tmpEPC = (req) ? ((M_BD) ? M_pc[31:2] -1 : M_pc[31:2]) : EPC; assign EPC_out = {tmpEPC,2\u0026#39;b00}; // 4 byte align 注：对PC进行字对齐处理，后补2\u0026rsquo;b00\n需要注意的是EPC保存当前指令PC的条件是req，即发生了异常时才会对EPC进行更新，这样就保证了EPC中的值在进入异常处理程序之后不会发生改变，识别到eret指令之后跳回到异常指令。\n3.对于延迟槽指令的判断 ​\t延迟槽即跳转指令的下一条指令，所以标记延迟槽指令只需要识别出他的上一条指令是跳转指令(NPCOp_D != 3\u0026rsquo;b000)，并在F级跟随该指令进行流水到M级进行判断即可(无论跳转指令是否跳转)。\n1 F_BD = (NPCOp_D != 3\u0026#39;b000) 2.nop和req在流水线寄存器中的问题 nop ​\t如果沿用P6/P5中暂停时在E级插入nop的写法，这个nop指令的pc和bd信号都为0。此时M级宏观PC会显示错误的值，并且如果此时发生了中断，CP0中存入错误的EPC值。正确的做法是在暂停时让pc和bd继续流水\nreq ​\t发生异常时，需要跳转到异常响应代码并清空流水线内还没有执行完的指令。直接将pc清为0会导致第一条处理异常的代码到达M级之前，宏观PC都是0，故req信号来时需要将pc置为异常代码地址32'h0000_4180\n1 2 3 4 5 6 7 8 9 10 11 12 //以E级为例 always@(posedge clk) begin if(reset | stall | req) begin pc \u0026lt;= (stall) ? D_pc : (req ? 32\u0026#39;h0000_4180 : 32\u0026#39;h0); pc8 \u0026lt;= (stall) ? D_pc8 : (req ? 32\u0026#39;h0000_4188 : 32\u0026#39;h0); BD \u0026lt;= (stall) ? D_BD : 1\u0026#39;b0; ... end else begin ... end end 3.NPC 1.端口定义列表 名称 方向 位宽 描述 req I 1 中断请求 D_eret I 1 D级是否为eret指令 b_result I 1 B类跳转指令是否满足跳转条件 NPCOp I 3 地址选择 F_pc I 32 F级PC输入 D_pc I 32 D级PC输入 b_offset I 32 B类跳转指令偏移 j_address I 26 J类跳转指令偏移 reg_address I 32 寄存器中保存的地址 npc O 32 输出下一PC 2.PC选择逻辑 若发生req中断，跳转到异常处理程序地址 : 32\u0026rsquo;h0000_4180 若执行eret指令，eret将保存在CP0的地址写入PC，从而实现从处理异常程序中跳回到主程序 (同时保证了不会指令eret延迟槽中的指令) 在D级识别到eret，NPC选择EPC输入到F级 1 2 3 4 5 6 7 8 //NPC assign npc = (req) ? 32\u0026#39;h0000_4180 : (D_eret) ? EPC: (NPCOp == 3\u0026#39;b000) ? F_pc + 4\u0026#39;d4 : (NPCOp == 3\u0026#39;b001 \u0026amp;\u0026amp; b_result) ? D_pc + 4\u0026#39;d4 + (b_offset \u0026lt;\u0026lt; 2\u0026#39;b10) : (NPCOp == 3\u0026#39;b010) ? {ADD4[31:28],j_address,2\u0026#39;b00} : (NPCOp == 3\u0026#39;b011) ? reg_address : (F_pc + 4\u0026#39;d4); 4.Bridge 1.端口定义列表 名称 方向 位宽 描述 Addr_in I 32 写入/读取外设的地址 WD_in I 32 写入外设单元的数据 byteen I 4 写入外设单元的使能 DM_RD I 32 DM读取值的输入 T1_RD I 32 Timer1读取值的输入 T0_RD I 32 Timer0读取值的输入 Addr_out O 32 写入/读取外设的地址 WD_out O 32 写入外设单元的数据 RD_out O 32 外设单元的读取值输出 DM_WE O 4 DM写入使能 T1_WE O 1 Timer1写入使能 T0_WE O 1 Timer0写入使能 2.实现代码（对地址的判断） ​\t需要注意的是我们写入的外设中，DM支持按字节访问，即byteen写入使能信号4位表示，写入Timer是按字写入的，一位写入使能信号。\n观察官方Timer端口定义：\ninput [31:2] Addr input [31:0] Din 说明Timer中寄存器为按字写入\n**Timer按字写入：byteen = 4\u0026rsquo;b1111(sw指令) 使用位缩减运算符变为一位 : \u0026amp;byteen = 1\u0026rsquo;b1 **\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 assign Addr_out = Addr_in; assign WD_out = WD_in; wire DM_addr = (Addr_in \u0026gt;= 32\u0026#39;h0000 \u0026amp;\u0026amp; Addr_in \u0026lt;= 32\u0026#39;h2fff); wire T0_addr = (Addr_in \u0026gt;= 32\u0026#39;h7f00 \u0026amp;\u0026amp; Addr_in \u0026lt;= 32\u0026#39;h7f0b); wire T1_addr = (Addr_in \u0026gt;= 32\u0026#39;h7f10 \u0026amp;\u0026amp; Addr_in \u0026lt;= 32\u0026#39;h7f1b); assign DM_WE = (DM_addr) ? byteen : 4\u0026#39;b0; assign T0_WE = (T0_addr) ? \u0026amp;byteen : 1\u0026#39;b0; assign T1_WE = (T1_addr) ? \u0026amp;byteen : 1\u0026#39;b0; assign RD_out = (DM_addr) ? DM_RD : (T0_addr) ? T0_RD : (T1_addr) ? T1_RD : 32\u0026#39;b0; 5.Timer ​\t课程组已经提供实现好的代码，两种模式的有限状态机，具体分析见思考题\n端口定义列表 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 Addr I 30 写入寄存器地址 Din I 32 写入数据 Dout O 32 读取数据 IRQ O 1 定时/定周期产生的中断信号 6.乘除槽处理 2023秋季计算机组成课程对于乘除槽的规定： mult 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。 mthi 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，mtlo 同理。 mult 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。 mthi 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，mtlo 同理。 ​\t即发生异常时若已经启动了乘除槽就不管他，如果还没启动，就不允许启动，只需要在启动乘除槽的条件中加入!req\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 always@(posedge clk)begin if(reset)begin cnt \u0026lt;= 32\u0026#39;b0; busy \u0026lt;= 1\u0026#39;b0; end else if(start \u0026amp;\u0026amp; !req)begin //start claculate busy \u0026lt;= 1\u0026#39;b1; end else if(busy) begin // continue to calculate is not influnced by req if(cnt == delay - 1)begin //next T : busy = 0 cnt \u0026lt;= 32\u0026#39;b0; busy \u0026lt;= 1\u0026#39;b0; end else begin cnt \u0026lt;= cnt + 1\u0026#39;b1; end end end always@(posedge clk)begin if(reset)begin tmpHI \u0026lt;= 32\u0026#39;b0; tmpLO \u0026lt;= 32\u0026#39;b0; HI \u0026lt;= 32\u0026#39;b0; LO \u0026lt;= 32\u0026#39;b0; end else begin if (!busy \u0026amp;\u0026amp; !req) begin //start calcualte case(MDUOp) mult : begin delay \u0026lt;= 4\u0026#39;b0101; //5 {tmpHI,tmpLO} \u0026lt;= $signed(A) * $signed(B); end multu : begin delay \u0026lt;= 4\u0026#39;b0101; {tmpHI,tmpLO} \u0026lt;= $unsigned(A) * $unsigned(B); end div : begin delay \u0026lt;= 4\u0026#39;b1010; //10 tmpLO \u0026lt;= $signed(A) / $signed(B); tmpHI \u0026lt;= $signed(A) % $signed(B); end divu : begin delay \u0026lt;= 4\u0026#39;b1010; tmpLO \u0026lt;= $unsigned(A) / $unsigned(B); tmpHI \u0026lt;= $unsigned(A) % $unsigned(B); end mthi : HI \u0026lt;= A; mtlo : LO \u0026lt;= A; endcase end else begin // // continue to calculate is not influnced by req if(cnt == delay - 1\u0026#39;b1)begin // next T : busy = 0; HI \u0026lt;= tmpHI; LO \u0026lt;= tmpLO; end else begin HI \u0026lt;= HI; LO \u0026lt;= LO; end end end end 二.测试方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 text la\t$ra, pos_1 addi\t$ra, $ra, 1 jr\t$ra ori\t$s0, $0, 100 ori\t$s0, $0, 200 #invalid pos_1: addi\t$s1, $s0, 20 #invalid addi\t$s1, $s0, 50 #F_exc_AdEL nop #you can change it 0xf000000f li\t$t0, 13 mfc0\t$t0, $t1 #D_exc_RI lui\t$s2, 0x7fff lui\t$s3, 0x7fff add\t$s4, $s2, $s3 #E_exc_Ov_add and\t$5, $s2, $s3 lui\t$s2, 0x7fff addi\t$s3, $s2, 0x7fffffff #E_exc_Ov_addi and\t$5, $s2, $s3 lui\t$s2, 0x7fff lui\t$s3, 0x8fff sub\t$s4, $s3, $s2 #E_exc_Ov_sub and\t$5, $s2, $s3 li\t$s0, 0x12345678 sw\t$s0, 0($0) lw\t$s1, 3($0) lw\t$s2, 0($0) #D_exc_AdEL and\t$5, $s2, $s3 li\t$s0, 0x8fffffff sw\t$s0, 0($0) lh\t$s1, 1($0) lh\t$s2, 2($0) #D_exc_AdEL and\t$5, $s2, $s3 li\t$s0, 0x80000000 sw\t$s0, 0($0) lhu\t$s1, 1($0) lhu\t$s2, 2($0) #D_exc_AdEL and\t$5, $s1, $s2 li\t$s0, 0x7f00 li\t$s1, 10 sw\t$s1, 0($s0) lh\t$s2, 0($s0) lw\t$s3, 0($s0) #D_exc_AdEL and\t$5, $s1, $s2 li\t$s0, 0x7010 li\t$s1, 10 sw\t$s1, 0($s0) li\t$s0, 0x2800 sw\t$s1, 0($s0) #D_exc_AdEL and\t$5, $s1, $s2 li\t$s0, 0x12ab34cd sw\t$s0, 3($0) sw\t$s0, 4($0) #D_exc_AdEL and\t$5, $s1, $s2 li\t$s0, 0xabcd sh\t$s0, 1($0) sh\t$s0, 2($0) #D_exc_AdEL and\t$5, $s1, $s2 li\t$s0, 0x7f10 li\t$s1, 10 sh\t$s1, 0($s0) sw\t$s1, 0($s0) #D_exc_AdEL and\t$5, $s1, $s2 li\t$s0, 0x7f10 li\t$s1, 10 sw\t$s1, 8($s0) #D_exc_AdEL and\t$5, $s1, $s2 li\t$s0, 0x8ff0 li\t$s1, 100 sh\t$s1, 0($s0) sh\t$s1, 0($s0) #D_exc_AdEL and\t$5, $s1, $s2 三.思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？ 鼠标和键盘产生中断信号，进入中断处理程序，在中断处理程序中，鼠标和键盘输入信号 请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法） 若自定义入口地址，则很多软件将会不兼容，在程序员视角设计软件的时候，中断处理的入口地址是不重要的，也就是说这是软件和硬件之间的协议。 为何与外设通信需要 Bridge？ 外设的种类繁多，我们通过bridge并且约定某段内存地址对应于某个外设，这样我们就只需要通过访存去实现与外设的联系，指令集会比较的简洁。添加外设时，外设也只需要体现在入口地址的不同而不需要改变CPU的内部结构，让CPU访问外设只需通过地址，这样体现了”高内聚，低耦合”的原则 请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图 模式0 ： 定时中断\n模式1 ： 周期性中断\n画图如下\n倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？ 写入EPC会出错，延迟槽标记信号BD也会出错。 如果是中断或者异常而清空流水线，应该保持原有的PC值，以保证宏观PC的正确。 如果是阻塞而清空流水线，应该要保持原有的PC并且保持原有的BD标志信号。 为什么 jalr 指令为什么不能写成 jalr $31, $31？ 这种操作具有二义性，不知道先跳转还是先链接\n指令集要求 rs 和 rd 不得相等，因为此类指令在重新执行时不具有相同的效果。执行此类指令的结果是不可预测的。此限制允许异常处理程序在分支延迟槽中发生异常时通过重新执行分支来恢复执行。\n","permalink":"https://coder0xe.github.io/posts/p7-design-document/","summary":"\u003ch1 id=\"p7-design-document\"\u003e\u003ccenter\u003eP7-Design-Document\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"0顶层设计概述\"\u003e0.顶层设计概述\u003c/h2\u003e\n\u003cp\u003e​\tP7要求为实现MIPS微系统，需要为P6实现的流水线CPU添加异常中断功能，并封装为CPU模块、实现系统桥Bridge、计时器Timer1,Timer2等模块，最终形成MIPS微系统，如下图所示。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e绿色虚线表示已经实现\u003c/li\u003e\n\u003cli\u003e紫色虚线表示新增部分\u003c/li\u003e\n\u003cli\u003e红色虚线为改变后的DM接口\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231203155826233\" loading=\"lazy\" src=\"/img/image-20231203155826233.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eP7需要实现的任务如下列表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e任务\u003c/th\u003e\n          \u003cth\u003e解释\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e计时器\u003c/td\u003e\n          \u003ctd\u003e课程组提供代码\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e系统桥\u003c/td\u003e\n          \u003ctd\u003e为CPU提供统一的访问外设的接口，自行实现\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e协处理器CP0\u003c/td\u003e\n          \u003ctd\u003e设置CPU的异常处理功能，反馈CPU的异常信息，自行实现\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e内部检测异常与流水\u003c/td\u003e\n          \u003ctd\u003eCPU检测内部指令执行错误\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e外部中断响应\u003c/td\u003e\n          \u003ctd\u003eCPU需要具有响应外部中断信号的能力\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e异常处理指令\u003c/td\u003e\n          \u003ctd\u003e异常处理程序中，会有一些特殊的指令需要实现\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e单周期CPU的封装\u003c/td\u003e\n          \u003ctd\u003e让CPU从外部看上去是单周期CPU\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e异常处理程序\u003c/td\u003e\n          \u003ctd\u003e利用MARS编写简单的异常处理程序进行测试\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e施工步骤\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e更改流水线各级使之可以产生异常\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加CP0处理异常\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加Bridge与两个外设\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e异常与中断\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异常：内部异常 如F级取指异常、D级计算溢出等\u003c/li\u003e\n\u003cli\u003e中断：来自外部设备，Timer0,Timer1,Interrupt\u003c/li\u003e\n\u003cli\u003e来自外部设备的中断比内部异常优先级更高\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"一功能部件设计\"\u003e一.功能部件设计\u003c/h2\u003e\n\u003ch3 id=\"0新增指令的实现思路\"\u003e0.新增指令的实现思路\u003c/h3\u003e\n\u003ch4 id=\"p7中增加四条指令\"\u003e\u003cstrong\u003eP7中增加四条指令\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003emtc0\u003c/li\u003e\n\u003cli\u003emfc0\u003c/li\u003e\n\u003cli\u003eeret\u003c/li\u003e\n\u003cli\u003esyscall\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"mtc0-写入cp0中寄存器1214\"\u003emtc0 ：写入CP0中寄存器(12/14)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e对于mtc0和mfc0指令 ： 读取的CP0寄存器地址均为rd域，由于本实现中采用了集中式译码，故增加数据通路，将原指令的rd域流水下去，作为CP0寄存器地址, CP0_addr\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e指令格式 ：\u003c/p\u003e\n\u003cp\u003e010000 || 00100 || rt || rd || 00000000000\u003c/p\u003e\n\u003cp\u003emtc0 rt,rd\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMCU ：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCP0_WE_D\u003c/li\u003e\n\u003cli\u003eT_rs_use = T_rt_use = 3（这里rt的真实使用时间是3，但是并不会对暂停/转发造成影响，T\u003csub\u003euse\u003c/sub\u003e \u0026gt;= T\u003csub\u003enew\u003c/sub\u003e成立，可以通过转发解决）\u003c/li\u003e\n\u003cli\u003eT_new = 0\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e写入时应当注意 ：Cause寄存器(13)不允许写入，EPC允许写入，\u003cstrong\u003eSR寄存器部分字段允许写入，其他不允许写入的字段要保持为0\u003c/strong\u003e\u003c/p\u003e","title":"P7-design-document"},{"content":"P6课上测试 ​\tP6课上测试内容与P5课上测试内容大概只有第一题计算类型上的区别，变为考察乘除槽的指令\n一.增添指令一般步骤 读懂RTL语言，注意opcode与funct位置，是什么类型的指令，会不会与已经添加过的指令发生冲突(例如P5上机第一题中计算指令与slt指令opcode重复QAQ) 使用课上提供的.class文件在MARS中进行模拟 计算指令是否可以进行归类，cal_R,cal_I;条件跳转指令和条件存储指令一般直接使用check信号对新信号进行特判。 在MCU中从上到下观察是否将新指令加入有效列表 明确新指令的T_use,T_new 二.题型分析 1.涉及到乘除槽的计算类指令 ​\tP6的计算指令会涉及到乘除模块，以madd,maddu,msub,msubu等指令为例。\nmadd : 将两个有符号数相乘，计算结果与之前的HI,LO寄存器中的值相加，而不是覆盖 mddu：将两个无符号数相乘，计算结果与之前的HI,LO寄存器中的值相加，而不是覆盖 msub：将两个有符号数相乘，之前HI,LO中的值减去当前结果 msubu：将两个无符号数相乘，之前HI,LO中的值减去当前结果 1.verilog中的符号性问题 ​\t$signed()关键字的功能为数据如何进行补位，根据递归确定外层+向内传播的表达式符号确定规则，例如在P1中遇到的三目表达式中有无符号数导致整个表达式变为无符号的情况。\n算数（符号）右移表达式中移位立即数不必要声明为有符号 ：$signed(A) \u0026raquo;\u0026gt; B\n为避免$singed()出现的问题，可以使用位扩展进行代替\n1 {{16{imm[15]}},imm}//16位imm符号扩展为32位 2.计算指令中的符号乘除 mult 使用位拼接运算\n1 {tmpHI,tmpLO} \u0026lt;= $signed(A) * $signed(B) madd\n错误写法1\n1 {tmpHI,tmpLO} \u0026lt;= {tmpHI,tmpLO} + $signed(A)*$signed(B) 位拼接运算{tmpHI,tmpLO}默认被当作无符号数，向内传播导致$signed(A)*$signed(B)变为无符号的\n修改为：\n1 {tmpHI,tmpLO} \u0026lt;= $signed({tmpHI,tmpLO}) + $signed(A)*$signed(B) 错误写法2\n1 {tmpHI,tmpLO} \u0026lt;= {tmpHI.tmpLO} + $signed($signed(A)*$signed(B)) 使用$signed()屏蔽了外界符号性的传入，同时屏蔽了位宽信息的传入，由于$signed(A),$signed(B)为32位，则$signed($signed(A)*$signed(B))为32位\n修改为：\n1 2 {tmpHI,tmpLO} \u0026lt;= {tmpHI,tmpLO} + $signed($signed(64\u0026#39;d0) + $signed(A)*$signed(B))// 补充位宽信息 {tmpHI,tmpLO} \u0026lt;= {tmpHI,tmpLO} + $signed({{32{A[31]}},A}*{{32{B[31]}},B})//手动符号位扩展 ps:循环移位计算 ​\tP5课前预习到了循环移位，结果课上第一题就考了循环移位，虽然再次出现概率不大，但是有必要重复一下\n1 2 //循环右移 E_AO \u0026lt;= (src_B \u0026gt;\u0026gt; shamt) | (src_B \u0026lt;\u0026lt; (32\u0026#39;d32 - shamt)); 3.题目实例分析 madd,maddu,msub,msubu等可以直接归结为md类指令，乘法延迟为5，只需注意符号性的问题。\nshl : 交换HI和LO寄存器中的值\n由于非阻塞赋值的特性，无需设置中间变量，直接交换即可 1 2 HI \u0026lt;= LO; LO \u0026lt;= HI; bds : 使用rs和rt寄存器中的值，用较大的数除以较小的数，注意是进行无符号除法\n1 2 3 4 5 6 7 8 if(A \u0026gt; B)begin tmpLO = A / B; tmpHI = A % B; end else begin tmpLO = B / A; tmpHI = B % A; end crt : 将GPR[rs]循环移位得到的32个结果无符号求和，结果记为temp1，将GPR[rt]循环移位得到的32个结果无符号求和，结果记为temp2，比较这两个结果\nif temp1 \u0026lt; temp2 then GPR[rd] = -1 else if temp1 \u0026gt; temp2 then GPR[rd] = 1 else then GPR[rd] = 0 这题算是把循环移位考到头了，循环移位的32种结果即移位0(32)~31位，实现细节上无论左移还是右移得到的和都是相等的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 temp1 = 32\u0026#39;b0; temp2 = 32\u0026#39;b0; for(i=0;i\u0026lt;32;i=i+1)begin temp1 = temp1 + (src_A\u0026gt;\u0026gt;i)|(src_A \u0026lt;\u0026lt; (32\u0026#39;d32 - i)); end for(i=0;i\u0026lt;32;i=i+1)begin temp2 = temp2 + (src_B\u0026gt;\u0026gt;i)|(src_B \u0026lt;\u0026lt; (32\u0026#39;d32 - i)); end if(temp1 \u0026lt; temp2)begin E_AO = -1; end else if(temp1 \u0026gt; temp2)begin E_AO = 1; end else begin E_AO = 0; end 2.条件跳转类指令 1.条件跳转+无条件链接 在CMP模块中添加判断，RegWrite置为1，SelA3选择31号寄存器，SelEMout/SelWout转发PC8数据 2.条件跳转+条件链接 在CMP模块中添加判断，新增信号RegWrite_new，check，对该新增指令进行特判，流水新的RegWrite信号\n1 assign RegWrite_D_new = (check_D) ? (b_result_D ? 1\u0026#39;b1 : 1\u0026#39;b0) : RegWrite_D; 3.条件跳转+不跳转清空延迟槽 在CMP模块中添加判断、特判新信号、当前未暂停（若当前处于暂停则CMP判断结果无效）、当前不满足跳转条件，清空D级流水线寄存器\n为D级流水线寄存器添加clr端口，默认置为0\n1 assign clr = (check_D)\u0026amp;(!stall)\u0026amp;(!b_result_D); 4.题目实例分析 bezal : 若GPR[rt] = 0，则跳转到GPR[rs]，并且链接到$31\n条件跳转+条件链接，加入branch类,check_D,NPCOp,CMPOp，使用RegWrite_new btheq : 若GPR[rs]最高位1与GPR[rt]的相同，则跳转，注意GPR[rs]==0||GPR[rt]==0时不用跳转\n条件跳转+不链接，与bne/beq指令类似，在CMP中新增判断逻辑\n最初的错误写法\n1 2 3 4 5 6 7 8 9 10 11 for(flag1 = 31;flag1 \u0026gt;= 0;flag1 = flag1 - 1)begin if(D_V1[flag1] == 1\u0026#39;b1)begin break; end end for(flag2 = 31;flag2 \u0026gt;= 0;flag2 = flag2 - 1)begin if(D_V2[flag2] == 1\u0026#39;b1)begin break; end end b_result = (flag1 == 0 || flag2 == 0) ? 1\u0026#39;b0 : (flag1 == flag2) ? 1\u0026#39;b1 : 1\u0026#39;b0; 错误点1 ：verilog中不能使用break来跳出for循环！\n修改方法1：可以将跳出条件移到括号内\n1 2 3 for(flag1 = 31;flag1 \u0026gt;= 0 \u0026amp;\u0026amp; (D_V1[flag1] != 1\u0026#39;b1);flag1 = flag1 - 1)begin for(flag2 = 31;flag2 \u0026gt;= 0 \u0026amp;\u0026amp; (D_V2[flag2] != 1\u0026#39;b1);flag2 = flag2 - 1)begin b_result = (D_V1 == 0 || D_V2 == 0) ? 1\u0026#39;b0 : (flag1 == flag2) ? 1\u0026#39;b1 : 1\u0026#39;b0; 修改方法2：使用disable语句跳出for循环，在使用disable跳出循环时，需要为循环起名字\n1 2 3 4 5 6 7 8 9 10 11 for(flag1 = 31;flag1 \u0026gt;= 0;flag1 = flag1 - 1)begin : one if(D_V1[flag1] == 1\u0026#39;b1)begin disable one; end end for(flag2 = 31;flag2 \u0026gt;= 0;flag2 = flag2 - 1)begin : two if(D_V2[flag2] == 1\u0026#39;b1)begin disable two; end end b_result = (D_V1 == 0 || D_V2 == 0) ? 1\u0026#39;b0 : (flag1 == flag2) ? 1\u0026#39;b1 : 1\u0026#39;b0; 错误点2 ： 一开始写法中判断(GPR[rs] ==0 || GPR[rt] == 0)时使用(flag1 == 0 | flag2 == 0)判断，这是错误的，若两个数均为0跳出循环时flag1=flag2=-1\n3.条件存储类 ​\t对于条件存储类load指令，只有到了M级才能确定写入的寄存器，需要对暂停逻辑进行修改。如果D级要读的寄存器后续可能被写入，就要暂停\n1.满足condition写入A，不满足condition写入B ​\t如满足条件向rt号（load类rt即为rd,即为load类原本的rd）写，不满足条件向31号写(流水到M级只剩下rt(rd)号了，所以一般来说一定会出现一个写入常数寄存器，当然也可以从D级增加流水rs段)\nHCU\n1 2 3 4 assign stall_rs_E = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_E ? (D_A1 == E_A3 | D_A1 == 5\u0026#39;d31) : D_A1 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rs \u0026lt; Tnew_E); assign stall_rs_M = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_M ? (D_A1 == M_A3 | D_A1 == 5\u0026#39;d31) : D_A1 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rs \u0026lt; Tnew_M); assign stall_rt_E = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_E ? (D_A2 == E_A3 | D_A2 == 5\u0026#39;d31) : D_A2 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rt \u0026lt; Tnew_E); assign stall_rt_M = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_M ? (D_A2 == M_A3 | D_A2 == 5\u0026#39;d31) : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rt \u0026lt; Tnew_M); MUX\n1 wire M_A3_new = check_M ? (condition ? `rt : 5\u0026#39;d31) : M_A3; 将M_A3_new传入W_reg和HCU\n2.满足condition写入A,不满足condition不写入 ​\t可以将不写入理解为写入0号寄存器\nHCU\n1 2 3 4 5 //按照第一种题型以写成 (check_M ? (D_A2 == 5\u0026#39;d31 | D_A2 == 5\u0026#39;d0): D_A2 == M_A3),因为前面有条件 D_A2 != 5\u0026#39;d0，所以可以简化 assign stall_rs_E = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_E ? (D_A1 == E_A3 ) : D_A1 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rs \u0026lt; Tnew_E); assign stall_rs_M = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_M ? (D_A1 == M_A3 ) : D_A1 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rs \u0026lt; Tnew_M); assign stall_rt_E = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_E ? (D_A2 == E_A3 ) : D_A2 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rt \u0026lt; Tnew_E); assign stall_rt_M = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_M ? (D_A2 == M_A3 ) : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rt \u0026lt; Tnew_M); MUX\n1 wire M_A3_new = check_M ? (condition ? 5\u0026#39;d31 : 5\u0026#39;d0) : M_A3; 3.写入完全取决于DM中取出的数据 ​\t取决于DM中取出的数据则不能确定到底是哪一个，即所有寄存器都有可能被写入\nHCU\n1 2 3 4 assign stall_rs_E = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_E ? 1\u0026#39;b1 : D_A1 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rs \u0026lt; Tnew_E); assign stall_rs_M = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_M ? 1\u0026#39;b1 : D_A1 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rs \u0026lt; Tnew_M); assign stall_rt_E = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_E ? 1\u0026#39;b1 : D_A2 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rt \u0026lt; Tnew_E); assign stall_rt_M = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_M ? 1\u0026#39;b1 : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rt \u0026lt; Tnew_M); MUX\n1 wire M_A3_new = check_M ? DM_out[4:0] : M_A3; ","permalink":"https://coder0xe.github.io/posts/p6%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95/","summary":"\u003ch1 id=\"p6课上测试\"\u003e\u003ccenter\u003eP6课上测试\u003c/center\u003e\u003c/h1\u003e\n\u003cp\u003e​\t\u003cstrong\u003eP6课上测试内容与P5课上测试内容大概只有第一题计算类型上的区别，变为考察乘除槽的指令\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"一增添指令一般步骤\"\u003e一.增添指令一般步骤\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e读懂RTL语言，注意opcode与funct位置，是什么类型的指令，会不会与已经添加过的指令发生冲突(例如P5上机第一题中计算指令与slt指令opcode重复\u003ccode\u003eQAQ\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e使用课上提供的.class文件在MARS中进行模拟\u003c/li\u003e\n\u003cli\u003e计算指令是否可以进行归类，cal_R,cal_I;条件跳转指令和条件存储指令一般直接使用check信号对新信号进行特判。\u003c/li\u003e\n\u003cli\u003e在MCU中从上到下观察是否将新指令加入有效列表\u003c/li\u003e\n\u003cli\u003e明确新指令的T_use,T_new\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"二题型分析\"\u003e二.题型分析\u003c/h2\u003e\n\u003ch3 id=\"1涉及到乘除槽的计算类指令\"\u003e1.涉及到乘除槽的计算类指令\u003c/h3\u003e\n\u003cp\u003e​\tP6的计算指令会涉及到乘除模块，以madd,maddu,msub,msubu等指令为例。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emadd : 将两个有符号数相乘，计算结果与之前的HI,LO寄存器中的值相加，而不是覆盖\u003c/li\u003e\n\u003cli\u003emddu：将两个无符号数相乘，计算结果与之前的HI,LO寄存器中的值相加，而不是覆盖\u003c/li\u003e\n\u003cli\u003emsub：将两个有符号数相乘，之前HI,LO中的值减去当前结果\u003c/li\u003e\n\u003cli\u003emsubu：将两个无符号数相乘，之前HI,LO中的值减去当前结果\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"1verilog中的符号性问题\"\u003e1.verilog中的符号性问题\u003c/h4\u003e\n\u003cp\u003e​\t\u003cstrong\u003e$signed()关键字的功能为数据如何进行补位\u003c/strong\u003e，根据\u003cstrong\u003e递归确定外层+向内传播\u003c/strong\u003e的表达式符号确定规则，例如在P1中遇到的三目表达式中有无符号数导致整个表达式变为无符号的情况。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e算数（符号）右移表达式中移位立即数不必要声明为有符号 ：$signed(A) \u0026raquo;\u0026gt; B\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e为避免$singed()出现的问题，可以使用位扩展进行代替\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{{\u003cspan style=\"color:#bd93f9\"\u003e16\u003c/span\u003e{imm[\u003cspan style=\"color:#bd93f9\"\u003e15\u003c/span\u003e]}},imm}\u003cspan style=\"color:#6272a4\"\u003e//16位imm符号扩展为32位\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2计算指令中的符号乘除\"\u003e2.计算指令中的符号乘除\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003emult  使用位拼接运算\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{tmpHI,tmpLO} \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e $signed(A) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e $signed(B)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003emadd\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e错误写法1\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{tmpHI,tmpLO} \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e {tmpHI,tmpLO} \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e $signed(A)\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e$signed(B)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e位拼接运算{tmpHI,tmpLO}默认被当作无符号数，向内传播导致$signed(A)*$signed(B)变为无符号的\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e修改为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{tmpHI,tmpLO} \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e $signed({tmpHI,tmpLO}) \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e $signed(A)\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e$signed(B)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e错误写法2\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{tmpHI,tmpLO} \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e {tmpHI.tmpLO} \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e $signed($signed(A)\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e$signed(B))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e使用$signed()屏蔽了外界符号性的传入，同时屏蔽了位宽信息的传入，由于$signed(A),$signed(B)为32位，则$signed($signed(A)*$signed(B))为32位\u003c/strong\u003e\u003c/p\u003e","title":"P6课上测试"},{"content":"P6-Design-Document 一.数据通路图示 ​\tP6在P5的基础上新增乘除槽单元、字节使能单元、数据扩展单元，在顶层模块中增加与testbench的接口，将IM与DM外移到testbench中。\n二.功能模块定义 1. MCU 1.端口定义列表 名称 方向 位宽 描述 D_opcode I 6 操作码 D_funct I 6 功能码 SelA3_D O 2 选择写入寄存器地址 RegWrite_D O 1 寄存器堆写入地址 EXTOp_D O 1 立即数扩展信号 SelEMout_D O 1 选择E、M级转发数据 SelWout_D O 2 选择W级转发数据/写入GRF数据 SeLALUB_D O 1 选择ALU_B端口输入数据 SelALUS_D O 1 选择ALU_S端口移位数据 check_D O 1 判定是否为新信号(课上扩展使用) mf_D O 1 mfhi/mflo指令，选择E级输出数据 start_D O 1 乘除类导致延迟的指令信号，只有md类需要 CMPOp_D O 3 B类跳转指令操作码 NPCOp_D O 3 跳转地址选择 ALUOp_D O 4 ALU计算操作 MDUOp_D O 4 乘除类计算操作 DMOp_D O 4 存取指令操作 T_rs_use_D O 2 位于D级用到rs寄存器中值的周期数 T_rt_use_D O 2 位于D级用到rt寄存器中值的周期数 T_new_D O 2 位于D级产生新信号的周期数 注：由于BE模块产生字节使能信号，将原内存写入使能信号MemWrite省去\n2.指令分类与T_use/T_new处理 指令分类如下\n类别 包含的指令 cal_R add,sub,and,or,slt,sltu cal_I andi,ori,addi,lui shift sll shiftv sllv branch beq,bne store sw,sh,sb load lw,lh,lb md（有运算延迟） mult,multu,div,divu mf（读取） mfhi,mflo mt（写入） mthi,mtlo ​\t对指令进行分类的好处是使得控制信号的产生更加简洁，增加指令时可以先考虑它属于哪一类\n1 2 3 4 5 6 7 8 9 assign T_rs_use_D = (branch | op_jr | op_jalr) ? 2\u0026#39;b00 : (cal_R | cal_I | load | store | shiftv | md | mt) ? 2\u0026#39;b01 : 2\u0026#39;b11;//用不到置为3 assign T_rt_use_D = (branch) ? 2\u0026#39;b00 : (cal_R | shift | shiftv | md) ? 2\u0026#39;b01 : 2\u0026#39;b11; assign T_new_D = (load) ? 2\u0026#39;b11 : (cal_R | cal_I | shift | shiftv | mf) ? 2\u0026#39;b10 : 2\u0026#39;b00; 3.HCU 1.端口定义列表 输入信号 方向 位宽 描述 MDUOp_D I 4 D级当前指令是否为乘除指令 D_A1 I 5 D级A1输入 D_A2 I 5 D级A2输入 E_A1 I 5 E级A1输入 E_A2 I 5 E级A2输入 E_A3 I 5 E级A3输入 check_E I 1 课上扩展 start I 1 E级乘除运算启动信号 busy I 1 E级乘除运算进行符号 M_A2 I 5 M级A2输入 M_A3 I 5 M级A3输入 check_M I 1 课上扩展 W_A3 I 5 W级A3输入 RegWrite_E I 1 E级保存的GRF写入使能信号 RegWrite_M I 1 M级保存的GRF写入使能信号 RegWrite_W I 1 W级保存的GRF写入使能信号 T_rs_use I 2 D级中MCU输出的T_rs_use_D信号 T_rt_use I 2 D级中MCU输出的T_rt_use_D信号 T_new_E I 2 E级中T_new_E输入 T_new_M I 2 M级中T_new_M输入 T_new_W I 2 W级中T_new_W输入 输出信号 位宽 作用级 描述 FwdCMPD1 2 D 对HMUX_CMP_D1输出进行选择 FwdCMPD2 2 D 对HMUX_CMP_D2输出进行选择 FwdALUA 2 E 对HMUX_ALU_A输出进行选择 FwdALUB 2 E 对HMUX_ALU_B输出进行选择 FwdDM 1 M 对HMUX_DM的输出进行选择 stall 1 D,F,M 暂停信号 2.暂停与转发 将P5中列举出的8种暂停情况合并为4种，更加简洁且易于扩展\n针对乘除槽增加暂停信号\n当 busy 信号或 start 信号为 1 时，mult, multu, div, divu, mfhi, mflo, mthi, mtlo 等乘除法相关的指令均被阻塞在 D 流水级\n转发与P5相比未作改动\n1 2 3 4 5 6 7 8 wire stall_rs_e = (T_rs_use \u0026lt; T_new_E)\u0026amp;\u0026amp;(D_A1 == E_A3)\u0026amp;\u0026amp;(D_A1 != 5\u0026#39;b0)\u0026amp;\u0026amp;(RegWrite_E); wire stall_rs_m = (T_rs_use \u0026lt; T_new_M)\u0026amp;\u0026amp;(D_A1 == M_A3)\u0026amp;\u0026amp;(D_A1 != 5\u0026#39;b0)\u0026amp;\u0026amp;(RegWrite_M); wire stall_rs = stall_rs_e | stall_rs_m ; wire stall_rt_e = (T_rt_use \u0026lt; T_new_E)\u0026amp;\u0026amp;(D_A2 == E_A3)\u0026amp;\u0026amp;(D_A2 != 5\u0026#39;b0)\u0026amp;\u0026amp;(RegWrite_E); wire stall_rt_m = (T_rt_use \u0026lt; T_new_M)\u0026amp;\u0026amp;(D_A2 == M_A3)\u0026amp;\u0026amp;(D_A2 != 5\u0026#39;b0)\u0026amp;\u0026amp;(RegWrite_M); wire stall_rt = stall_rt_e | stall_rt_m ; wire stall_mdu = (MDUOp_D != 4\u0026#39;b0000)\u0026amp;\u0026amp;(busy | start); assign stall = stall_rs | stall_rt | stall_mdu; 3.ALU 1.端口定义列表 名称 方向 位宽 描述 src_A I 32 操作数1 src_B I 32 操作数2 shamt_f I 5 移位数据 ALUOp I 3 运算类型 AO O 32 运算结果 2.ALUOp编码与运算选择 ALU运算 ALUOp编码 + 0000 - 0001 | 0010 \u0026amp; 0011 load to higher half (lui) 0100 signed compare (slt) 0101 unsigned compare(sltu) 0110 \u0026laquo; 0111 4.EXT 端口定义列表 名称 方向 位宽 描述 imm I 16 D级16位立即数 EXTOp I 1 选择进行符号扩展/零扩展 imm_32 I 32 位扩展结果 5.GRF 1.端口定义列表 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 rs I 5 rs寄存器 rt I 5 rt寄存器 rd I 5 rd寄存器 pc I 32 指令执行地址 datawrite I 32 写入数据选择 RegWrite I 1 写入使能 dataread1 O 32 读rs寄存器 dataread2 O 32 读rt寄存器 注意：这里的RegWrite,datawirte,A3(rd),pc信号均来自W级\n2.GRF内部转发 ​\t设计GRF内部转发逻辑：GRF既是D级的一个部件又是W级之后的流水线寄存器。当W级写GRF，D级读GRF时，如果读取寄存器与写入寄存器为同一寄存器时不进行转发，新值虽然被写入GRF但流入E级的值依然为旧值。\n判断条件：当写入信号RegWrite有效且A1==A3或A2==A3时，将写入值作为对应输出值\n判断逻辑如下:\n1 2 //forward assign dataread1 = (RegWrite \u0026amp;\u0026amp; rs == rd \u0026amp;\u0026amp; rd != 0) ? datawrite : grf[rs]; 6.IFU 端口定义列表 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 en I 1 使能信号(~stall) npc I 32 下一指令地址 pc O 32 F级当前地址 pc8 O 32 输出PC+8，随流水段传递(jal考虑延迟槽) instr O 32 取出的指令 7.NPC 1.端口定义列表 名称 方向 位宽 描述 D_pc I 32 D级PC F_pc I 32 F级PC b_result I 1 D级CMP模块判断结果 b_offset I 32 B类指令的跳转地址 j_address I 26 J类指令跳转地址 reg_address I 32 跳转到寄存器中的地址(jr) NPCOp I 3 地址选择信号 npc O 32 程序下一条指令地址 2.NPCOp编码与地址选择 NPCOp编码 选择跳转地址 000 F_pc + 4 001(B) \u0026amp;\u0026amp; b_result D_pc + 4 + (b_offset \u0026laquo; 2\u0026rsquo;b10) 010(jal) {(D_pc + 4)[31:28],j_address,2\u0026rsquo;b00} 011(jr) reg_address 注：NPC是横跨D级和E级的模块，如果是beq或jal等指令，则需要在D_pc基础上进行操作，否则为F_pc+4\n8.CMP 1.端口定义列表 名称 方向 位宽 描述 D_V1 I 32 GRF中读出的rs寄存器的值 D_V2 I 32 GRF中读出的rt寄存器的值 CMPOp I 3 选择比较类型 b_result O 1 是否满足B类跳转指令的跳转条件 2.CMPOp编码与对应指令 当前只实现beq，该信号的设置更大的意义在于其可扩展性，便于课上添加指令\nCMPOp编码 对应指令 000 beq 001 bne \u0026hellip; \u0026hellip; 9.MDU 1.端口定义列表 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 start I 1 开始乘除运算信号 MDUOp I 4 乘除操作 A I 32 操作数A B I 32 操作数B out I 32 mfhi/mflo输出结果 busy I 1 正在执行乘除运算指示信号 2.MDUOp编码与对应指令 DMOp编码 对应指令 0000 非乘除指令，记为nop 0001 mult 0010 multu 0011 div 0100 divu 0101 mfhi 0110 mflo 0111 mthi 1000 mtlo 3.代码实现逻辑 乘法mult/multu延迟5周期，除法div/divu延迟10周期，在计算出结果后存储在tmpHI,tmpLO中，等到耗满延迟再转存入HI,LO.mfhi/mflo从HI,LO中读取。 设置计数器 判断是否达到该种运算的延迟(delay)，若达到，则将数值从tmp转存入HI/LO，同时将busy信号置0 实际上得到的结果为64位的结果，使用{tmpHI,tmpLO}位拼接写法进行拆分。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // counter always@(posedge clk)begin if(reset)begin cnt \u0026lt;= 32\u0026#39;b0; busy \u0026lt;= 1\u0026#39;b0; end else if(start)begin //start claculate busy \u0026lt;= 1\u0026#39;b1; end else if(busy) begin if(cnt == delay - 1)begin //next T : busy = 0 cnt \u0026lt;= 32\u0026#39;b0; busy \u0026lt;= 1\u0026#39;b0; end else begin cnt \u0026lt;= cnt + 1\u0026#39;b1; end end end always@(posedge clk)begin if(reset)begin tmpHI \u0026lt;= 32\u0026#39;b0; tmpLO \u0026lt;= 32\u0026#39;b0; HI \u0026lt;= 32\u0026#39;b0; LO \u0026lt;= 32\u0026#39;b0; end else begin if (!busy) begin //进行新运算 case(MDUOp) mult : begin delay \u0026lt;= 4\u0026#39;b0101; //5 {tmpHI,tmpLO} \u0026lt;= $signed(A) * $signed(B); end multu : begin delay \u0026lt;= 4\u0026#39;b0101; {tmpHI,tmpLO} \u0026lt;= $unsigned(A) * $unsigned(B); end div : begin delay \u0026lt;= 4\u0026#39;b1010; //10 tmpLO \u0026lt;= $signed(A) / $signed(B); tmpHI \u0026lt;= $signed(A) % $signed(B); end divu : begin delay \u0026lt;= 4\u0026#39;b1010; tmpLO \u0026lt;= $unsigned(A) / $unsigned(B); tmpHI \u0026lt;= $unsigned(A) % $unsigned(B); end mthi : HI \u0026lt;= A; mtlo : LO \u0026lt;= A; endcase end else begin //保持老运算 if(cnt == delay - 1\u0026#39;b1)begin // next T : busy = 0; HI \u0026lt;= tmpHI; LO \u0026lt;= tmpLO; end else begin HI \u0026lt;= HI; LO \u0026lt;= LO; end end end end // mfhi/mflo为组合逻辑 assign out = (MDUOp == mfhi)? HI : (MDUOp == mflo)? LO : 32\u0026#39;b0; endmodule 10.BE 1.端口定义列表 名称 方向 位宽 描述 address I 32 存数据地址 DMOp I 4 存数操作 WD_in I 32 未经处理的存入数据 byteen O 4 字节使能信号 WD_out O 32 处理后的存入数据(字/半字/字节) 注：byteen为存入字节使能信号、对应位置的值为1表示允许存入，如sw-\u0026gt;byteen = 1111 2.DMOp编码与存数操作 DMOp 对应指令 0001 sw 0010 sh 0011 sb 11.DE 1.端口定义列表 名称 方向 位宽 描述 address I 32 取数地址 DMOp I 4 取数操作 RD_in I 32 未经处理的取出数据 RD_out O 32 处理后的取出数据 2.DMOp编码与取数操作 DMOp 对应指令 1000 lw 1001 lh 1010 lb 12.MUX 1.功能多路选择器 1.MUX_A3 D级写入寄存器选择 端口定义列表 名称 方向 位宽 描述 D_instr_rs I 5 instr中rs段 D_instr_rt I 5 instr中rt段 SelA3_D I 2 rd选择信号 D_A3 O 5 写入寄存器A3 选择信号与结果 SelA3_D D_A3 2\u0026rsquo;b10 31 2\u0026rsquo;b01 rd 2\u0026rsquo;b00 rt 2.MUX_ALU_B ALUB端口选择 端口定义列表 名称 方向 位宽 描述 E_V2_f I 32 转发后的V2 E_E32 I 32 32位立即数 SelALUB_E I 1 选择信号 E_ALU_B O 32 输出到ALUB端口的结果 选择信号与结果 SelALUB_E E_ALU_B 1\u0026rsquo;b1 E_E32 1\u0026rsquo;b0 E_V2_f 3.MUX_E_out 选择E级转发数据 端口定义列表 名称 方向 位宽 描述 E_E32 I 32 32位立即数 E_pc8 I 32 流水PC8(jal) SelEMout_E I 1 选择信号 E_out O 32 E级转发数据 选择信号与结果 SelEMout_E E_out 1\u0026rsquo;b1 E_pc8 1\u0026rsquo;b0 E_E32 4.MUX_M_out 选择M级转发数据 端口定义列表 名称 方向 位宽 描述 M_AO I 32 M级ALU计算结果 M_pc8 I 32 流水PC8(jal) SelEMout_M I 1 选择信号 M_out O 32 M级转发数据 选择信号与结果 SelEMout_M M_out 1\u0026rsquo;b1 M_pc8 1\u0026rsquo;b0 M_AO 5.MUX_W_out 选择W级转发数据 端口定义列表 名称 方向 位宽 描述 W_AO I 32 W级ALU计算结果 W_DR I 32 W级DM中读取出的数据 W_pc8 I 32 W级流水PC8(jal) SelWout_W I 2 选择信号 W_out O 32 W级转发数据/GRF写入数据 选择信号与结果 SelWout_W W_out 2\u0026rsquo;b10 W_pc8 2\u0026rsquo;b01 W_DR 2\u0026rsquo;b00 W_AO 6.MUX_MDU_ALU选择E级输出数据 端口定义列表 名称 方向 位宽 描述 E_AO I 32 ALU输出 E_MDU_out I 32 MDU输出 E_mf I 1 是否为mf类指令 E_AO_new O 32 E级输出值 选择信号与结果 E_mf E_AO_new 1 E_MDU_out 0 E_AO 2.转发多路选择器 1.HMUX_CMP_D1 CMP模块rs寄存器值转发 端口定义列表 名称 方向 位宽 描述 GRF_RD1 I 32 GRF中读取出的rs值 M_out I 32 M级转发数据 E_out I 32 E级转发数据 FwdCMPD1 I 2 选择信号 D_V1_f O 32 转发后的rs寄存器值 ​\t注：转发寄存器中有数据优先级的问题，越新产生的数据优先级越高，考虑到GRF中内部转发的逻辑，事实上GRF_RD1也代表着潜在的W级转发数据，但是仍然不破坏优先级关系E\u0026gt;M\u0026gt;W\n选择信号与结果 FwdCMPD1 D_V1_f 2\u0026rsquo;b10 E_out 2\u0026rsquo;b01 M_out 2\u0026rsquo;b00 GRF_RD1 2.HMUX_CMP_D2 CMP模块rt寄存器值转发 端口定义列表 名称 方向 位宽 描述 GRF_RD2 I 32 GRF中读取出的rt值 M_out I 32 M级转发数据 E_out I 32 E级转发数据 FwdCMPD2 I 2 选择信号 D_V2_f O 32 转发后的rt寄存器值 选择信号与结果 FwdCMPD2 D_V1_f 2\u0026rsquo;b10 E_out 2\u0026rsquo;b01 M_out 2\u0026rsquo;b00 GRF_RD2 3.HMUX_ALU_A ALU模块V1值转发/MDU输入V1 端口定义列表 名称 方向 位宽 描述 E_V1 I 32 GRF中读取出的rs值 M_out I 32 M级转发数据 W_out I 32 W级转发数据 FwdALUA I 2 选择信号 E_V1_f O 32 转发后的V1值 选择信号与结果 FwdALUA E_V1_f 2\u0026rsquo;b10 M_out 2\u0026rsquo;b01 W_out 2\u0026rsquo;b00 E_V1 4.HMUX_ALU_B ALU模块V2值转发/MDU输入V2 端口定义列表 名称 方向 位宽 描述 E_V2 I 32 GRF中读取出的rt值 M_out I 32 M级转发数据 W_out I 32 W级转发数据 FwdALUB I 2 选择信号 E_V2_f O 32 转发后的V2值 选择信号与结果 FwdALUB E_V2_f 2\u0026rsquo;b10 M_out 2\u0026rsquo;b01 W_out 2\u0026rsquo;b00 E_V2 5.HMUX_DM DM写入数据转发 端口定义列表 名称 方向 位宽 描述 M_V2 I 32 M级V2 W_out I 32 W级转发数据 FwdDM I 1 选择信号 M_V1_f O 32 DM写入数据 选择信号与结果 FwdDM M_V1_f 1\u0026rsquo;b1 W_out 1\u0026rsquo;b0 M_V2 6.HMUX_NPC NPC模块跳转寄存器值转发 端口定义列表 名称 方向 位宽 描述 GRF_RD1 I 32 GRF中读取出的rs值 M_out I 32 M级转发数据 E_out I 32 E级转发数据 FwdCMPD1 I 2 选择信号 D_RA_f O 32 转发后的rs寄存器值 ​\t注：其实可以共用CMPD1的转发数据\n选择信号与结果 FwdCMPD1 D_RA_f 2\u0026rsquo;b10 E_out 2\u0026rsquo;b01 M_out 2\u0026rsquo;b00 GRF_RD1 13.流水线寄存器 1.D_REG 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 en I 1 ~stall（冻结D级） F_instr I 32 F级取指令 F_pc I 32 F级PC F_pc8 I 32 F级PC+8(jal) D_instr O 32 D级执行指令 D_pc O 32 D级PC D_pc8 O 32 D级PC+8 2.E_REG 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 clr I 1 stall(清空E级) D_V1 I 32 D级GRF中读取rs寄存器的值 D_V2 I 32 D级GRF中读取rt寄存器的值 D_A1 I 5 D级A1 D_A2 I 5 D级A2 D_A3 I 5 D级A3 D_E32 I 32 32位立即数 D_pc I 32 D级pc D_pc8 I 32 D级pc+8 T_new_D I 2 D级T_new RegWrite_D I 1 D级GRF写入使能 start_D I 1 D级乘除指令开始信号 SelEMout_D I 1 E、M级转发数据选择信号 SelWout_D I 1 W级转发数据选择信号 SelALUB_D I 1 ALUB端口数据选择 ALUOp_D I 4 ALU操作选择 DMOp_D I 4 DM操作选择 MDUOp_D I 4 乘除指令操作 E_V1 O 32 E_V2 O 32 E_A1 O 5 E_A2 O 5 E_A3 O 5 E_E32 O 32 E_pc O 32 E_pc8 O 32 T_new_E O 2 RegWrite_E O 1 SelEMout_E O 1 SelWout_E O 2 SelALUB_E O 1 ALUOp_E O 3 DMOp_E O 3 3.M_REG 名称 方向 位宽 描述 clk I 1 reset I 1 E_AO I 32 E级ALU/MDU输出 E_V2 I 32 注意：E_V2不是D_V2,而是经过转发后的D_V2_f E_A2 I 5 E_A3 I 5 E_pc I 32 E_pc8 I 32 T_new_E I 2 RegWrite_E I 1 start_E I 1 SelEMout_E I 1 SelWout_E I 1 DMOp_E I 4 M_AO O 32 M_V2 O 5 M_A2 O 5 M_A3 O 5 M_pc O 32 M_pc8 O 32 T_new_M O 2 RegWrite_M O 1 SelEMout_M O 1 SelWout_M O 2 DMOp_M O 3 4.W_REG 名称 方向 位宽 描述 clk I 1 reset I 1 M_AO I 32 M_DR I 32 M级DM中读出的数据 M_A3 M_pc I 32 M_pc8 I 32 SelWout_M I 2 T_new_M I 2 RegWrite_M I 1 W_AO O 32 W_DR O 32 W_A3 O 5 W_pc O 32 W_pc8 O 32 SelWout_W O 2 T_new_W O 2 RegWrite_W O 1 三.测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 li $0 -1590414783 li $1 -1387657999 li $2 97336612 li $3 -1971889419 li $4 1148790734 li $5 -289210629 li $6 1026640559 li $7 1852052372 li $8, 7860 sltu $4, $0, $1 srav $4, $1, $6 or $6, $0, $4 xor $0, $6, $6 nor $3, $5, $2 slt $0, $5, $3 ori $5, $1, -31050 or $5, $2, $6 subu $1, $2, $6 sltu $4, $4, $3 lbu $0, 878($0) slt $2, $2, $2 or $6, $2, $4 srav $1, $7, $0 sll $0, $7, 7 srlv $6, $3, $6 nor $3, $3, $7 or $5, $7, $2 div $4, $8 sltu $7, $3, $2 sllv $6, $2, $0 srlv $5, $5, $5 mtlo $0 addu $0, $5, $4 slt $6, $7, $6 addu $5, $1, $1 mfhi $1 nor $4, $5, $5 srav $3, $5, $4 sltiu $3, $4, 7080 and $3, $0, $4 or $7, $5, $5 xor $5, $3, $3 andi $2, $6, 25900 xori $1, $5, 18289 srlv $0, $6, $5 slt $4, $6, $2 ori $7, $3, -32729 lh $7, 1250($0) sllv $7, $4, $4 addu $4, $1, $2 xori $7, $0, 11378 srl $4, $4, 5 addu $6, $5, $6 srav $7, $3, $4 slti $1, $5, -24158 multu $6, $8 sltu $6, $0, $1 四.思考题 1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？\n乘除法都有较高的延迟，若整合进ALU，则进行乘除法的时候，所有的运算类指令都只能阻塞在D级，造成了极大的性能损失。单独设置MDU的话，无关的指令还能正常的在ALU运行，效率较高。 HI，LO寄存器并不是通用寄存器，和其他通用寄存器的用法不一致，不能通过非乘除法指令修改和访问，因此不需要置于GRF中，内置在MDU中即可。 2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。\n真实的流水线CPU采用的乘法是有加法器和移位器循环，具体实现过程为：\n首先CPU会初始化三个通用寄存器用来存放被乘数，乘数，部分积。 部分积寄存器初始化为0。 判断乘数寄存器的低位是0|1，如果为0则将乘数寄存器右移一位，同时将部分积寄存器也右移一位。 在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位。 同时部分积寄存器高位补0。如果为1则将部分积寄存器加上被乘数寄存器，再进行移位操作。 当所有乘数位处理完成后部分积寄存器做高位，乘数寄存器做低位就是最终乘法结果。\n还有另一种乘法的方式：\n只需两个寄存器，A[31:0],B[63:0]，A初始化为被乘数，B初始化为乘数。 每一次取B的最低位，为1则将A[31:0]+B[63:32] -\u0026gt; B[63:32]，为0则不操作。 每次将B \u0026raquo; 1，然后高位补0。\n除法实现：\n与乘法的操作基本相反，首先CPU会初始化三个寄存器,用来存放被除数，除数，部分商。余数(被除数与除数比较的结果)放到被除数的有效高位上。CPU做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。首先CPU会把被除数bit位与除数bit位对齐，然后再让对齐的被除数与除数比较(双符号位判断)。比如01-10=11(前面的1是符号位) 1-2=-1 计算机通过符号位和后一位的bit位来判断大于和小于，那么01-10=11 就说明01小于10，如果得数为01就代表大于，如果得数为00代表等于。如果得数大于或等于则将比较的结果放到被除数的有效高位上然后再商寄存器上商：1 并向后多看一位(上商就是将商的最低位左移1位腾出商寄存器最低位上新的商)如果得数小于则上商：0 并向后多看一位然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数。\n3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？\n除cnt和busy置位以外全是组合逻辑的操作（不然可能会多出来一个空周期） 对于乘除指令： 将busy_E，start_E，MDUOp_D传入HCU 然后md暂停信号为(busy_E | start_E) \u0026amp; (MDUOp_D != 4'b0000) 4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）\n对于需要写入的位置更加的直观，相当于将DMWE、DMOP写入的A[1:0]用四位字节使能信号表示，十分的统一。 5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？\n按字节读写的时候，我们获得的是一字节，但是我们如果要lw或lh的话我们就需要拼接。如果是sw或sh的话我们需要多次存入。 若用lb，sb，lh，sh这种非取字的读写时，按字节读可以省去，取位，拼接的步骤，效率要优于按字读写。 6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？\nNPC统一，NPC统一为一个模块 指令分类，cal_R,cal_I,shift,shiftv,branch,load,store等 每一级设置outMUX，只需在MCU中控制outSel即可决定转发值及写入寄存器的值 7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？\n在常规测试通过后，我们可以将T_rsUse和T_rtUse相同的指令归类为同一需求指令，把T_new相同的指令归类为同一供给指令。 所以可以在new方面有下列指令：add，lw，jal，mfhi 在rsUse方面有下面情况：add，sll，lw，beq，jr，mult，mthi 然后对着转发的时间表，设计测试数据： 复制# rs0_E1 add $t0, $t1, $t2 beq $t0, $t3, label1 nop # rs0_E2 lw $t0, 0($t1) beq $t0, $t3, label1 nop #rs0_E0 jal label1 nop ori $t0, $0, 0x1234 label1: jr $ra nop .... 8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。\n手动构造策略见上 完全随机生成有几大不足之处，如无法保证内存对齐，无法保证延迟槽中没有跳转分支，无法避免一定几率的死循环等等 但可以加入策略： 比如只用t0-t6寄存器以保证产生足够多的冲突 在检测到生成跳转后禁用跳转指令 检测到内存不对齐可以不生成等等 ","permalink":"https://coder0xe.github.io/posts/p6-design-document/","summary":"\u003ch1 id=\"p6-design-document\"\u003e\u003ccenter\u003eP6-Design-Document\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"一数据通路图示\"\u003e一.数据通路图示\u003c/h2\u003e\n\u003cp\u003e​\tP6在P5的基础上新增乘除槽单元、字节使能单元、数据扩展单元，在顶层模块中增加与testbench的接口，将IM与DM外移到testbench中。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231130193453498\" loading=\"lazy\" src=\"/img/image-20231130193453498.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"二功能模块定义\"\u003e二.功能模块定义\u003c/h2\u003e\n\u003ch3 id=\"1-mcu\"\u003e1. MCU\u003c/h3\u003e\n\u003ch4 id=\"1端口定义列表\"\u003e1.端口定义列表\u003c/h4\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e名称\u003c/th\u003e\n          \u003cth\u003e方向\u003c/th\u003e\n          \u003cth\u003e位宽\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eD_opcode\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e6\u003c/td\u003e\n          \u003ctd\u003e操作码\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eD_funct\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e6\u003c/td\u003e\n          \u003ctd\u003e功能码\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelA3_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e选择写入寄存器地址\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRegWrite_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e寄存器堆写入地址\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eEXTOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e立即数扩展信号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelEMout_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e选择E、M级转发数据\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelWout_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e选择W级转发数据/写入GRF数据\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSeLALUB_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e选择ALU_B端口输入数据\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelALUS_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e选择ALU_S端口移位数据\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003echeck_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e判定是否为新信号(课上扩展使用)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003emf_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003emfhi/mflo指令，选择E级输出数据\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003estart_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e乘除类导致延迟的指令信号，只有md类需要\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCMPOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e3\u003c/td\u003e\n          \u003ctd\u003eB类跳转指令操作码\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eNPCOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e3\u003c/td\u003e\n          \u003ctd\u003e跳转地址选择\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eALUOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n          \u003ctd\u003eALU计算操作\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMDUOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n          \u003ctd\u003e乘除类计算操作\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDMOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n          \u003ctd\u003e存取指令操作\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eT_rs_use_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e位于D级用到rs寄存器中值的周期数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eT_rt_use_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e位于D级用到rt寄存器中值的周期数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eT_new_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e位于D级产生新信号的周期数\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e注：由于BE模块产生字节使能信号，将原内存写入使能信号MemWrite省去\u003c/strong\u003e\u003c/p\u003e","title":"P6-design-document"},{"content":"P5课上测试 一.增添指令一般步骤 明确指令RTL，可以使用课上提供的.class文件进行模拟 明确非转发数据通路：可以在单周期中思考新指令的行为，构思出数据通路 考虑转发： 考虑GRF的五位写入地址是否正确，一般在第二步已经调整完毕，但是像lwer,lhso等条件存储类指令只有在M级中从DM中取出数据后才能明确写入地址，需要在M级将写入地址再次修改 明确新指令的T_rs_use,T_rt_use,T_new,用不到的寄存器设置为T_rs/rt_use = 3 二.课上测试题型分析 1.计算指令——在E级就可以完成所有操作 ​\t新增的计算指令一般只需要增加ALU的功能，但是计算行为会稍稍复杂一些，Tnew和Tuse与calc_R或calc_I型保持一致即可\n例如 循环左移\n1 2 if(B[4:0] == 5\u0026#39;b0) out = A; else out = A \u0026lt;\u0026lt; B[4:0] | A \u0026gt;\u0026gt; (6\u0026#39;d32 - B[4:0]) 2.条件跳转类——在D级就可以完成所有操作 条件跳转 + 无条件链接 条件跳转 + 条件链接 条件跳转 + 条件（无条件）链接 + 不跳转时清空延迟槽 1.条件跳转 增加CMP中的判断功能 2.无条件链接 D级将RegWrite置为1，跟随流水并更改A3(31)，最后在W级选择PC8作为写入数据 3.条件链接 在D级根据CMP模块的输出结果判断RegWrite是否有效 设置一个check信号用以确定当前指令是否为新指令，进行流水 1 2 3 4 5 6 7 wire D_RegWrite_new = check_D ? (D_CMP_out ? 1\u0026#39;b1 : 1\u0026#39;b0) : RegWrite_D; //判断是否为新信号 如果是就已经隐含着regwrite=1,只需对CMP结果进行判断 //如果不是就保留原信号 //uut E_reg top_e_reg( .RegWrite_D(D_RegWrite_new), ); 4.不跳转时清空延迟槽 根据CMP输出结果判断是否要清空D级流水寄存器(这就是hyggge学长P5教程中D级clr信号接口的原因QAQ) 注意：当前为stall状态则不能清空延迟槽，此时传入CMP模块的不是新值，判断无效 1 2 3 4 5 wire D_reg_clr = check_D \u0026amp; ~D_CMP_out \u0026amp; ~stall //新信号 \u0026amp; 不跳转 \u0026amp; 不暂停 D_reg top_d_reg( .D_clr(D_reg_clr) //加入到同步复位列表中 ); 3.条件存储类——在M级就可以完成所有操作 在原来基础上修改stall控制信号，如果D级的指令要读寄存器，而且后面的新指令可能要写这个寄存器，那么就stall 修改写入A3地址并传入W_reg和HCU 1. condition1 condition成立 ：将DM中值写入A condition不成立 ：将DM中值写入B 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //第一种题型(eg：condition满足向rt号写，否则写31号) assign stall_rs_E = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_E ? (D_A1 == E_A3 | D_A1 == 5\u0026#39;d31) : D_A1 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rs \u0026lt; Tnew_E); assign stall_rs_M = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_M ? (D_A1 == M_A3 | D_A1 == 5\u0026#39;d31) : D_A1 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rs \u0026lt; Tnew_M); assign stall_rt_E = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_E ? (D_A2 == E_A3 | D_A2 == 5\u0026#39;d31) : D_A2 == E_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rt \u0026lt; Tnew_E); assign stall_rt_M = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_M ? (D_A2 == M_A3 | D_A2 == 5\u0026#39;d31) : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rt \u0026lt; Tnew_M); //更改写入寄存器地址(eg：condition满足向rt号写，否则写31号) wire M_A3_new = check_M ? (condition ? `rt : 5\u0026#39;d31) : M_A3; //uut W_reg top_w_reg( .M_A3(M_A3_new), ); HCU top_hcu( .M_A3(M_A3_new), ); 2.condition2 conditon成立 ：向31号写 condition不成立 ：不写（写入0号寄存器） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //按照第一种题型以写成 (check_M ? (D_A2 == 5\u0026#39;d31 | D_A2 == 5\u0026#39;d0): D_A2 == M_A3),因为前面有条件 D_A2 != 5\u0026#39;d0，所以可以简化 assign stall_rs_E = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_E ? D_A2 == 5\u0026#39;d31 : D_A2 == M_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rs \u0026lt; Tnew_E); assign stall_rs_M = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_M ? D_A2 == 5\u0026#39;d31 : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rs \u0026lt; Tnew_M); assign stall_rt_E = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_E ? D_A2 == 5\u0026#39;d31 : D_A2 == M_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rt \u0026lt; Tnew_E); assign stall_rt_M = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_M ? D_A2 == 5\u0026#39;d31 : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rt \u0026lt; Tnew_M); //更改写入寄存器地址(eg：condition满足向31号写，否则不写) wire M_A3_new = check_M ? (condition ? 5\u0026#39;d31 : 5\u0026#39;d0) : M_A3; //uut W_reg top_w_reg( .M_A3(M_A3_new), ); HCU top_hcu( .M_A3(M_A3_new), ); 3.condition3 condition满足时写入DM中值的低五位 这种情况下可能写入所有的寄存器，直接暂停 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //第三种题型 (eg：condition满足时写入位置为DM的读取值的低五位) assign stall_rs_E = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_E ? 1\u0026#39;b1 : D_A2 == M_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rs \u0026lt; Tnew_E); assign stall_rs_M = (D_A1 != 5\u0026#39;d0) \u0026amp; (check_M ? 1\u0026#39;b1 : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rs \u0026lt; Tnew_M); assign stall_rt_E = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_E ? 1\u0026#39;b1 : D_A2 == M_A3) \u0026amp; (RFWrite_E) \u0026amp; (Tuse_rt \u0026lt; Tnew_E); assign stall_rt_M = (D_A2 != 5\u0026#39;d0) \u0026amp; (check_M ? 1\u0026#39;b1 : D_A2 == M_A3) \u0026amp; (RFWrite_M) \u0026amp; (Tuse_rt \u0026lt; Tnew_M); //更改写入寄存器地址(eg：写入位置为DM的读取值的低五位) wire M_A3_new = check_M ? DM_out[4:0] : M_A3; //uut W_reg top_w_reg( .M_A3(M_A3_new), ); HCU top_hcu( .M_A3(M_A3_new), ); ","permalink":"https://coder0xe.github.io/posts/p5%E8%AF%BE%E4%B8%8A%E6%B5%8B%E8%AF%95/","summary":"\u003ch1 id=\"p5课上测试\"\u003e\u003ccenter\u003eP5课上测试\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"一增添指令一般步骤\"\u003e一.增添指令一般步骤\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e明确指令RTL，可以使用课上提供的.class文件进行模拟\u003c/li\u003e\n\u003cli\u003e明确非转发数据通路：可以在单周期中思考新指令的行为，构思出数据通路\u003c/li\u003e\n\u003cli\u003e考虑转发：\n\u003cul\u003e\n\u003cli\u003e考虑GRF的五位写入地址是否正确，一般在第二步已经调整完毕，但是像lwer,lhso等条件存储类指令只有在M级中从DM中取出数据后才能明确写入地址，需要在M级将写入地址再次修改\u003c/li\u003e\n\u003cli\u003e明确新指令的T_rs_use,T_rt_use,T_new,用不到的寄存器设置为T_rs/rt_use = 3\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"二课上测试题型分析\"\u003e二.课上测试题型分析\u003c/h2\u003e\n\u003ch3 id=\"1计算指令在e级就可以完成所有操作\"\u003e1.计算指令——在E级就可以完成所有操作\u003c/h3\u003e\n\u003cp\u003e​\t新增的计算指令一般只需要增加ALU的功能，但是计算行为会稍稍复杂一些，Tnew和Tuse与calc_R或calc_I型保持一致即可\u003c/p\u003e\n\u003cp\u003e例如 \u003cstrong\u003e循环左移\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(B[\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e) out \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e A;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e out \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e A \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e B[\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e A \u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e (\u003cspan style=\"color:#bd93f9\"\u003e6\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d32\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e B[\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2条件跳转类在d级就可以完成所有操作\"\u003e2.条件跳转类——在D级就可以完成所有操作\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e条件跳转 + 无条件链接\u003c/li\u003e\n\u003cli\u003e条件跳转 + 条件链接\u003c/li\u003e\n\u003cli\u003e条件跳转 + 条件（无条件）链接 + 不跳转时清空延迟槽\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"1条件跳转\"\u003e1.条件跳转\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e增加CMP中的判断功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2无条件链接\"\u003e2.无条件链接\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eD级将RegWrite置为1，跟随流水并更改A3(31)，最后在W级选择PC8作为写入数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3条件链接\"\u003e3.条件链接\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在D级根据CMP模块的输出结果判断RegWrite是否有效\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e设置一个check信号用以确定当前指令是否为新指令，进行流水\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e D_RegWrite_new \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e check_D \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e (D_CMP_out \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e RegWrite_D;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//判断是否为新信号 如果是就已经隐含着regwrite=1,只需对CMP结果进行判断\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//如果不是就保留原信号\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//uut\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eE_reg top_e_reg(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .RegWrite_D(D_RegWrite_new),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"4不跳转时清空延迟槽\"\u003e4.不跳转时清空延迟槽\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e根据CMP输出结果判断是否要清空D级流水寄存器(这就是hyggge学长P5教程中D级clr信号接口的原因\u003ccode\u003eQAQ\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e注意：当前为stall状态则不能清空延迟槽，此时传入CMP模块的不是新值，判断无效\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e D_reg_clr \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e check_D \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e~\u003c/span\u003eD_CMP_out \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e~\u003c/span\u003estall  \u003cspan style=\"color:#6272a4\"\u003e//新信号 \u0026amp; 不跳转 \u0026amp; 不暂停\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eD_reg top_d_reg(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .D_clr(D_reg_clr) \u003cspan style=\"color:#6272a4\"\u003e//加入到同步复位列表中\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"3条件存储类在m级就可以完成所有操作\"\u003e3.条件存储类——在M级就可以完成所有操作\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在原来基础上修改stall控制信号，如果D级的指令要读寄存器，而且后面的新指令可能要写这个寄存器，那么就stall\u003c/li\u003e\n\u003cli\u003e修改写入A3地址并传入W_reg和HCU\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"1-condition1\"\u003e1. condition1\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003econdition成立 ：将DM中值写入A\u003c/li\u003e\n\u003cli\u003econdition不成立 ：将DM中值写入B\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//第一种题型(eg：condition满足向rt号写，否则写31号)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rs_E \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_E \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e E_A3 \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e D_A1 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A1 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e E_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_E) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rs \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_E);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rs_M \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3 \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e D_A1 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A1 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_M) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rs \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_M);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rt_E \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_E \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e E_A3 \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e E_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_E) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_E);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rt_M \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3 \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_M) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_M);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//更改写入寄存器地址(eg：condition满足向rt号写，否则写31号)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e M_A3_new \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e (condition \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e `rt \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e M_A3; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//uut\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eW_reg top_w_reg(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .M_A3(M_A3_new),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHCU top_hcu(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .M_A3(M_A3_new),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"2condition2\"\u003e2.condition2\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003econditon成立 ：向31号写\u003c/li\u003e\n\u003cli\u003econdition不成立 ：不写（写入0号寄存器）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//按照第一种题型以写成  (check_M ? (D_A2 == 5\u0026#39;d31 | D_A2 == 5\u0026#39;d0): D_A2 == M_A3),因为前面有条件 D_A2 != 5\u0026#39;d0，所以可以简化\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rs_E \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_E \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_E) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rs \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_E);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rs_M \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_M) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rs \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_M);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rt_E \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_E \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_E) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_E);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rt_M \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_M) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_M);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//更改写入寄存器地址(eg：condition满足向31号写，否则不写)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e M_A3_new \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e (condition \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d31\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e M_A3; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//uut\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eW_reg top_w_reg(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .M_A3(M_A3_new),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHCU top_hcu(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .M_A3(M_A3_new),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"3condition3\"\u003e3.condition3\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003econdition满足时写入DM中值的低五位\u003c/li\u003e\n\u003cli\u003e这种情况下可能写入所有的寄存器，直接暂停\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//第三种题型 (eg：condition满足时写入位置为DM的读取值的低五位) \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rs_E \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_E \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_E) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rs \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_E);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rs_M \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A1 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_M) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rs \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_M);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rt_E \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_E \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_E) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_E);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e   stall_rt_M \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (D_A2 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;d0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e D_A2 \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e M_A3) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (RFWrite_M) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e (Tuse_rt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e Tnew_M);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//更改写入寄存器地址(eg：写入位置为DM的读取值的低五位)  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e M_A3_new \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e check_M \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e DM_out[\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e M_A3; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//uut\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eW_reg top_w_reg(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .M_A3(M_A3_new),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eHCU top_hcu(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .M_A3(M_A3_new),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"P5课上测试"},{"content":"P5-pipeline-CPU-Design-Document 零.数据通路描述 ​\tMIPS架构的五级流水线CPU数据通路有以下五个阶段：\n取指阶段F(Fetch):从指令存储器中读取指令\n译码阶段D(Decode):从寄存器文件中读取源操作数并对指令译码得到控制信号\n执行阶段E(Execute):使用ALU执行计算\n存储阶段M(Memory):读或写数据存储\n写回阶段(Writeback):将结果写回到寄存器文件\n​\t通过在五个阶段之间加入寄存器来保存前面周期产生的数据(最后一个阶段的寄存器即为GRF),形成五级流水线CPU，数据通路如下图表示：\n一.数据命名规范(checkstyle) 在控制信号连线名末尾加上“_阶段字母”，如NPCOp_D,用于区分所属的阶段 在流水线寄存器输出信号前加上“阶段字母_\u0026quot;，如：D_A1,用以区分所属阶段 功能部件输出信号前加上功能部件名称 常规MUX命名采用\u0026quot;MUX-部件名-端口名”的命名方式，选择信号命名为\u0026quot;Sel+部件名+端口名\u0026quot; 转发MUX命名采用\u0026quot;HMUX-部件名-端口名\u0026quot;的命名方式，选择信号命名为\u0026quot;Fwd+部件名+端口名\u0026quot; 二.部件设计 1.MCU(main control unit) 1.端口定义列表 ​\t主控制单元模块负责对指令进行译码以及产生控制信号，本CPU的设计采用集中式译码，在P5中需要完成的指令及其需要的控制信号列表如下，其中有些控制信号对应多路选择器的选择。\n名称 方向 位宽 描述 D_opcode I 6 D级输出opcode D_funct I 6 D级输出funct SelA3_D I 2 选择当前指令要写入的寄存器，写入E级流水线寄存器 RegWrite_D O 1 GRF写入使能 MemWrite_D O 1 DM写入使能 EXTOp_D O 1 对立即数进行符号扩展还是0扩展 SelEMout_D O 1 选择E，M级转发数据信号 SelWout_D O 2 选择W级转发数据信号 SelALUB_D O 1 ALU的B端口rt数据与32位立即数的选择 CMPOp_D O 3 D级B类指令比较选择 NPCOp_D O 3 写入NPC选择 ALUOp_D O 3 ALU操作信号 DMOp_D O 3 DM操作信号 T_rs_use_D O 2 指令处在D级时还有多少个周期需要使用rs寄存器的值 T_rt_use_D O 2 指令处在D级时还有多少个周期需要使用rt寄存器的值 T_new_D O 2 指令处在D级时还有多少个周期可以产生写入寄存器的新值 2.分指令梳理控制信号 指令 取高电平的控制信号和ALUOp add SelA3_D = 2\u0026rsquo;b01, RegWrite, ALUOp = 3\u0026rsquo;b000, NPCOp = 3\u0026rsquo;b000; sub SelA3_D = 2\u0026rsquo;b01, RegWrite, ALUOp = 3\u0026rsquo;b001, NPCOp = 3\u0026rsquo;b000; ori RegWrite,ALUSrc, SelALUB, ALUOp=3\u0026rsquo;b010, NPCOp = 3\u0026rsquo;b000; lui RegWrite,ALUSrc, SelALUB, ALUOp=3\u0026rsquo;b011, NPCOp = 3\u0026rsquo;b000; lw RegWrite, SelWout = 2\u0026rsquo;b01, SelALUB, EXTOp, ALUOp=3\u0026rsquo;b000, NPCOp = 3\u0026rsquo;b000; sw MemWrite, SelALUB, EXTOp, ALUOp=3\u0026rsquo;b000, NPCOp = 3\u0026rsquo;b000; beq CMPOp = 3\u0026rsquo;b000,EXTOp, NPCOp = 3\u0026rsquo;b001, CMPOp = 3\u0026rsquo;b000; jal RegWrite, SelA3_D = 2\u0026rsquo;b10, NPCOp = 3\u0026rsquo;b010; jr NPCOp = 3\u0026rsquo;b11; nop 相当于sll $0,$0,0，不需要进行特殊处理 3.译码方式的改动 ​\t在P4中，我才用使用reg类型变量记录指令识别的形式，在always块中每次都为代表所有信号的寄存器赋初值0，这样会导致pc一直自增下去，程序不断向后跑(虽然在上机时无影响)，在蒋老师的测评机上会出现多输出的情况。在P5中，使用wire类型进行指令的识别，当识别的指令为x时，所有指令对应的wire都是不定值x，导致MCU中输出的控制信号为x，使得pc停下来，可以正常在蒋老师的测评机上跑结果。\n1 wire op_add = (D_opcode == R \u0026amp;\u0026amp; D_funct == add); 2.HCU(hazard control unit) 1.数据冒险中的供给需求模型 1.供给者与需求者分析 需求者： 引用某个reg值的component 供给者：保存有reg新结果的流水线寄存器 ​\t我们假设指令前进到必须使用某一寄存器的值的流水阶段时，这个寄存器的值一定已经产生，并存储于后续某个流水线寄存器中，不管需要的值有没有计算出，都要进行转发，即暴力转发。\n供给者及其产生的数据 流水级 产生数据 MUX\u0026amp;选择信号 MUX输出名 E E_E32,E_pc8 MUX_E_out\u0026amp;SelEMOut E_out M M_AO,M_pc8 MUX_M_out\u0026amp;SelEMout M_out W W_AO,W_RD,W_pc8 MUX_W_out\u0026amp;SelWOut W_out 需求者及其产生的数据 ​\t注：表格中选择数据表示是哪一个流水段产生的结果，实际数据来自流水段寄存器的转发而不是流水段中的部件\n接收端口 选择数据 HMUX\u0026amp;选择信号 MUX输出名 CMP_D1 D_V1,E_out,M_out HMUX_CMP_D1\u0026amp;FwdCPMD1 D_V1_f(orward) CMP_D2 D_V2,E_out,M_out HMUX_CMP_D2\u0026amp;FwdCPMD2 D_V2_f ALU_A D_V1,E_out,M_out HMUX_ALU_A\u0026amp;FwdALUA E_V1_f ALU_B D_V2,E_out,M_out HMUX_ALU_B\u0026amp;FwdALUB E_V2_f DM_WD M_V2,W_out HMUX_DM\u0026amp;FwdDM M_V1_f NPC_ra D_V1,E_out,M_out HMUX_CMP_D1\u0026amp;FwdCPMD1 D_V1_f ​\t注：对于jr跳转指令，跳转到rs寄存器的值，故可以与CMP_D1共用同一个转发多路选择器产生的结果，但是我选择单独实现\n2.Tuse /Tnew 数据冒险可以转化为需求与供给的匹配问题：\nTuse：数据到了D级后还需要多少个周期要使用寄存器的值\nTnew: 位于E级及其后各流水线的指令，再经过多少个时钟周期能够产生要写入寄存器的结果。\nTuse \u0026lt; Tnew : 暂停install\nTuse \u0026gt;=Tnew: 转发forward，注意：我们进行转发从来都是从流水线寄存器进行转发而不是从部件产生结果进行转发，故从部件产生结果到存储到流水线寄存器可以进行转发还需要一个时钟周期\nTuse固定不变，可以从MCU译码后直接传入HCU\n采取的集中式译码中，Tnew随流水递减，在每一级流水段中传给HCU\nTnew-E = max (Tnew-D - 1 , 0) Tnew-M = max (Tnew-E - 1 , 0) 在当前指令集下 Tnew-W = 0 2.冒险分析 1.对指令构建Tuse-Tnew表 add/sub/ori/lui : 在D阶段译码之后在E级ALU使用寄存器rs和(rt)的值，还需一个时钟周期存入E级流水线寄存器 lw : 只用到rs寄存器中的值用来计算取数地址，经过两个周期在DM处取出结果存入W级寄存器 sw : 只涉及到存入DM，不产生新的数据 beq : 在D级进行操作数相等比较 jal : 将PC+8存入ra寄存器 jr : 在D级使用rs寄存器中的值作为跳转pc 注意：！！！对于不需要使用到该寄存器的指令，T_rs_use / T_rt_use需要置为3，最初我的错误是不进行处理，即T_rs_use = T_rt_use = 0，这样会导致很多不必要的暂停的发生，具体在测评中会表现为TLE！因为T_rs_use和T_rt_use的范围为0-2，将T_rs_use,T_rt_use标记为3可以规避掉所有的暂停情况！\n2.stall/forward控制列表 ​\t用当前指令用到的寄存器的对应的Tuse与该寄存器新值当前所在流水段对应部件的Tnew进行比对，如果\nTuse \u0026gt;= Tnew，则通过转发解决 Tuse \u0026lt; Tnew ，则只能进行暂停 从上表可以归结出需要进行暂停的四种情况\nE_Tnew = 2,Tuse=0 E_Tnew = 2,Tuse = 1 E_Tnew = 1,Tuse = 0 M_Tnew = 1,Tuse = 0 暂停：冻结PC计数器，冻结D级寄存器，清空E级寄存器\n3.基础指令的数据通路/各个流水段需要传递的信号 列表如下所示：\n4.HCU设计 1.端口定义列表 输入信号 方向 位宽 描述 D_A1 I 5 D级A1输入 D_A2 I 5 D级A2输入 E_A1 I 5 E级A1输入 E_A2 I 5 E级A2输入 E_A3 I 5 E级A3输入 M_A2 I 5 M级A2输入 M_A3 I 5 M级A3输入 W_A3 I 5 W级A3输入 RegWrite_E I 1 E级保存的GRF写入使能信号 RegWrite_M I 1 M级保存的GRF写入使能信号 RegWrite_W I 1 W级保存的GRF写入使能信号 T_rs_use I 2 D级中MCU输出的T_rs_use_D信号 T_rt_use I 2 D级中MCU输出的T_rt_use_D信号 T_new_E I 2 E级中T_new_E输入 T_new_M I 2 M级中T_new_M输入 T_new_W I 2 W级中T_new_W输入 输出信号 位宽 作用级 描述 FwdCMPD1 2 D 对HMUX_CMP_D1输出进行选择 FwdCMPD2 2 D 对HMUX_CMP_D2输出进行选择 FwdALUA 2 E 对HMUX_ALU_A输出进行选择 FwdALUB 2 E 对HMUX_ALU_B输出进行选择 FwdDM 1 M 对HMUX_DM的输出进行选择 stall 1 D,F,M 暂停信号 注：暂停机制：冻结PC,冻结D级，清空E级，即stall信号作用于IFU,D_REG,E_REG\n2.控制转发/暂停的内部逻辑 暂停的内部逻辑 ​\t经过前面的分析，可知暂停信号stall的产生一共有八种情况，rs,rt各四种，最后或在一起即可。记号stall_rs0_e1表示暂停中T_rs_use=0\u0026amp;\u0026amp;T_new_E = 1的情况，对应的表达式为:\n1 stall_rs0_e1 = (T_rs_use == 2\u0026#39;b00)\u0026amp;\u0026amp;(T_new_E = 2\u0026#39;b01)\u0026amp;\u0026amp;(D_A1 == E_A3)\u0026amp;\u0026amp;(D_A1 != 5\u0026#39;b0)\u0026amp;\u0026amp;(RegWrite_E) ​\t与逻辑表达式中前两项为对时间状态的判断，后三项为对寄存器状态的判断，即判断此时E级能写入且写入的寄存器为D级的rs且不是0寄存器。\n转发的内部逻辑 ​\t注：在流水段中，较先进入流水的指令在流水段较深的位置，我们进行转发只会对前序指令的运算结果进行转发，故会出现靠后流水段的转发选择信号较少，例如在M级对DM部件的转发 只会涉及到一个流水线寄存器输出的信号W_out，而在E级对ALU_A的转发信号有两个信号来自流水线寄存器，M_out,W_out.\n​\t转发逻辑涉及到优先级的判断，即对最新产生的结果进行转发，可以通过三目运算符实现，将优先级更高的结果(值更新的结果)放在三目运算符判断的前面并为选择信号编码，我采用的编码方式为优先级从低到高编码增加。判断能进行转发的关键条件为T_new=0\n例如：\n1 2 3 assign FwdCMPD1 = (T_new_E == 2\u0026#39;b00)\u0026amp;\u0026amp;(E_A3 == D_A1)\u0026amp;\u0026amp;(D_A1 != 5\u0026#39;b0)\u0026amp;\u0026amp;(RegWrite_E) ? 2\u0026#39;b10 : (T_new_M == 2\u0026#39;b00)\u0026amp;\u0026amp;(M_A3 == D_A1)\u0026amp;\u0026amp;(D_A1 != 5\u0026#39;b0)\u0026amp;\u0026amp;(RegWrite_M) ? 2\u0026#39;b01 : 2\u0026#39;b00; 3.ALU 1.端口定义列表 名称 方向 位宽 描述 src_A I 32 操作数1 src_B I 32 操作数2 ALUOp I 3 运算类型 AO O 32 运算结果 2.ALUOp编码与运算选择 ALU运算 ALUOp编码 + 0000 - 0001 | 0010 load to higher half(lui) 0011 \u0026laquo; 0100 signed compare (slt) 0101 unsigned compare(sltu) 0110 ​\t将beq指令在ALU中判断两个操作数是否相等的操作移动到D级模块CMP中，使得跳转指令在D级就可以完成判断，流水线只会顺序多执行一条指令。\n4.EXT 端口定义列表 名称 方向 位宽 描述 imm I 16 D级16位立即数 EXTOp I 1 选择进行符号扩展/零扩展 imm_32 I 32 位扩展结果 5.GRF 1.端口定义列表 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 rs I 5 rs寄存器 rt I 5 rt寄存器 rd I 5 rd寄存器 pc I 32 指令执行地址 datawrite I 32 写入数据选择 RegWrite I 1 写入使能 dataread1 O 32 读rs寄存器 dataread2 O 32 读rt寄存器 注意：这里的RegWrite,datawirte,A3(rd),pc信号均来自W级\n2.GRF内部转发 ​\t设计GRF内部转发逻辑：GRF既是D级的一个部件又是W级之后的流水线寄存器。当W级写GRF，D级读GRF时，如果读取寄存器与写入寄存器为同一寄存器时不进行转发，新值虽然被写入GRF但流入E级的值依然为旧值。\n判断条件：当写入信号RegWrite有效且A1==A3或A2==A3时，将写入值作为对应输出值\n判断逻辑如下:\n1 2 //forward assign dataread1 = (RegWrite \u0026amp;\u0026amp; rs == rd \u0026amp;\u0026amp; rd != 0) ? datawrite : grf[rs]; 6.IFU 端口定义列表 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 en I 1 使能信号(~stall) npc I 32 下一指令地址 pc O 32 F级当前地址 pc8 O 32 输出PC+8，随流水段传递(jal考虑延迟槽) instr O 32 取出的指令 7.NPC 1.端口定义列表 名称 方向 位宽 描述 D_pc I 32 D级PC F_pc I 32 F级PC b_result I 1 D级CMP模块判断结果 b_offset I 32 B类指令的跳转地址 j_address I 26 J类指令跳转地址 reg_address I 32 跳转到寄存器中的地址(jr) NPCOp I 3 地址选择信号 npc O 32 程序下一条指令地址 2.NPCOp编码与地址选择 NPCOp编码 选择跳转地址 000 F_pc + 4 001(B) \u0026amp;\u0026amp; b_result D_pc + 4 + (b_offset \u0026laquo; 2\u0026rsquo;b10) 010(jal) {(D_pc + 4)[31:28],j_address,2\u0026rsquo;b00} 011(jr) reg_address 注：NPC是横跨D级和E级的模块，如果是beq或jal等指令，则需要在D_pc基础上进行操作，否则为F_pc+4\n8.CMP 1.端口定义列表 名称 方向 位宽 描述 D_V1 I 32 GRF中读出的rs寄存器的值 D_V2 I 32 GRF中读出的rt寄存器的值 CMPOp I 3 选择比较类型 b_result O 1 是否满足B类跳转指令的跳转条件 2.CMPOp编码与对应指令 当前只实现beq，该信号的设置更大的意义在于其可扩展性，便于课上添加指令\nCMPOp编码 对应指令 000 beq \u0026hellip; \u0026hellip; 9.DM 1.端口定义列表 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 MemWrite I 1 写入使能 address I 32 写入/读取数据的地址 pc I 32 当前指令地址 DMOp I 3 执行操作 2.DMOp编码与对应指令 ​\t该信号的设置更大的意义在于其可扩展性，便于课上添加指令\nDMOp编码 对应指令 000 sw 100 lw \u0026hellip; \u0026hellip; 10.MUX 1.功能多路选择器 1.MUX_A3 D级写入寄存器选择 端口定义列表 名称 方向 位宽 描述 D_instr_rs I 5 instr中rs段 D_instr_rt I 5 instr中rt段 SelA3_D I 2 rd选择信号 D_A3 O 5 写入寄存器A3 选择信号与结果 SelA3_D D_A3 2\u0026rsquo;b10 31 2\u0026rsquo;b01 rd 2\u0026rsquo;b00 rt 2.MUX_ALU_B ALUB端口选择 端口定义列表 名称 方向 位宽 描述 E_V2_f I 32 转发后的V2 E_E32 I 32 32位立即数 SelALUB_E I 1 选择信号 E_ALU_B O 32 输出到ALUB端口的结果 选择信号与结果 SelALUB_E E_ALU_B 1\u0026rsquo;b1 E_E32 1\u0026rsquo;b0 E_V2_f 3.MUX_E_out 选择E级转发数据 端口定义列表 名称 方向 位宽 描述 E_E32 I 32 32位立即数 E_pc8 I 32 流水PC8(jal) SelEMout_E I 1 选择信号 E_out O 32 E级转发数据 选择信号与结果 SelEMout_E E_out 1\u0026rsquo;b1 E_pc8 1\u0026rsquo;b0 E_E32 4.MUX_M_out 选择M级转发数据 端口定义列表 名称 方向 位宽 描述 M_AO I 32 M级ALU计算结果 M_pc8 I 32 流水PC8(jal) SelEMout_M I 1 选择信号 M_out O 32 M级转发数据 选择信号与结果 SelEMout_M M_out 1\u0026rsquo;b1 M_pc8 1\u0026rsquo;b0 M_AO 5.MUX_W_out 选择W级转发数据 端口定义列表 名称 方向 位宽 描述 W_AO I 32 W级ALU计算结果 W_DR I 32 W级DM中读取出的数据 W_pc8 I 32 W级流水PC8(jal) SelWout_W I 2 选择信号 W_out O 32 W级转发数据/GRF写入数据 选择信号与结果 SelWout_W W_out 2\u0026rsquo;b10 W_pc8 2\u0026rsquo;b01 W_DR 2\u0026rsquo;b00 W_AO 2.转发多路选择器 1.HMUX_CMP_D1 CMP模块rs寄存器值转发 端口定义列表 名称 方向 位宽 描述 GRF_RD1 I 32 GRF中读取出的rs值 M_out I 32 M级转发数据 E_out I 32 E级转发数据 FwdCMPD1 I 2 选择信号 D_V1_f O 32 转发后的rs寄存器值 ​\t注：转发寄存器中有数据优先级的问题，越新产生的数据优先级越高，考虑到GRF中内部转发的逻辑，事实上GRF_RD1也代表着潜在的W级转发数据，但是仍然不破坏优先级关系E\u0026gt;M\u0026gt;W\n选择信号与结果 FwdCMPD1 D_V1_f 2\u0026rsquo;b10 E_out 2\u0026rsquo;b01 M_out 2\u0026rsquo;b00 GRF_RD1 2.HMUX_CMP_D2 CMP模块rt寄存器值转发 端口定义列表 名称 方向 位宽 描述 GRF_RD2 I 32 GRF中读取出的rt值 M_out I 32 M级转发数据 E_out I 32 E级转发数据 FwdCMPD2 I 2 选择信号 D_V2_f O 32 转发后的rt寄存器值 选择信号与结果 FwdCMPD2 D_V1_f 2\u0026rsquo;b10 E_out 2\u0026rsquo;b01 M_out 2\u0026rsquo;b00 GRF_RD2 3.HMUX_ALU_A ALU模块V1值转发 端口定义列表 名称 方向 位宽 描述 E_V1 I 32 GRF中读取出的rs值 M_out I 32 M级转发数据 W_out I 32 W级转发数据 FwdALUA I 2 选择信号 E_V1_f O 32 转发后的V1值 选择信号与结果 FwdALUA E_V1_f 2\u0026rsquo;b10 M_out 2\u0026rsquo;b01 W_out 2\u0026rsquo;b00 E_V1 4.HMUX_ALU_B ALU模块V2值转发 端口定义列表 名称 方向 位宽 描述 E_V2 I 32 GRF中读取出的rt值 M_out I 32 M级转发数据 W_out I 32 W级转发数据 FwdALUB I 2 选择信号 E_V2_f O 32 转发后的V2值 选择信号与结果 FwdALUB E_V2_f 2\u0026rsquo;b10 M_out 2\u0026rsquo;b01 W_out 2\u0026rsquo;b00 E_V2 5.HMUX_DM DM写入数据转发 端口定义列表 名称 方向 位宽 描述 M_V2 I 32 M级V2 W_out I 32 W级转发数据 FwdDM I 1 选择信号 M_V1_f O 32 DM写入数据 选择信号与结果 FwdDM M_V1_f 1\u0026rsquo;b1 W_out 1\u0026rsquo;b0 M_V2 6.HMUX_NPC NPC模块跳转寄存器值转发 端口定义列表 名称 方向 位宽 描述 GRF_RD1 I 32 GRF中读取出的rs值 M_out I 32 M级转发数据 E_out I 32 E级转发数据 FwdCMPD1 I 2 选择信号 D_RA_f O 32 转发后的rs寄存器值 ​\t注：其实可以共用CMPD1的转发数据\n选择信号与结果 FwdCMPD1 D_RA_f 2\u0026rsquo;b10 E_out 2\u0026rsquo;b01 M_out 2\u0026rsquo;b00 GRF_RD1 11.流水线寄存器 1.D_REG 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 en I 1 ~stall（冻结D级） F_instr I 32 F级取指令 F_pc I 32 F级PC F_pc8 I 32 F级PC+8(jal) D_instr O 32 D级执行指令 D_pc O 32 D级PC D_pc8 O 32 D级PC+8 2.E_REG 名称 方向 位宽 描述 clk I 1 时钟信号 reset I 1 同步复位信号 clr I 1 stall(清空E级) D_V1 I 32 D级GRF中读取rs寄存器的值 D_V2 I 32 D级GRF中读取rt寄存器的值 D_A1 I 5 D级A1 D_A2 I 5 D级A2 D_A3 I 5 D级A3 D_E32 I 32 32位立即数 D_pc I 32 D级pc D_pc8 I 32 D级pc+8 T_new_D I 2 D级T_new RegWrite_D I 1 D级GRF写入使能 MemWrite_D I 1 D级DM写入使能 SelEMout_D I 1 E、M级转发数据选择信号 SelWout_D I 1 W级转发数据选择信号 SelALUB_D I 1 ALUB端口数据选择 ALUOp_D I 3 ALU操作选择 DMOp_D I 3 DM操作选择 E_V1 O 32 E_V2 O 32 E_A1 O 5 E_A2 O 5 E_A3 O 5 E_E32 O 32 E_pc O 32 E_pc8 O 32 T_new_E O 2 RegWrite_E O 1 MemWrite_E O 1 SelEMout_E O 1 SelWout_E O 2 SelALUB_E O 1 ALUOp_E O 3 DMOp_E O 3 3.M_REG 名称 方向 位宽 描述 clk I 1 reset I 1 E_AO I 32 E级ALU计算结果 E_V2 I 32 注意：E_V2不是D_V2,而是经过转发后的D_V2_f E_A2 I 5 E_A3 I 5 E_pc I 32 E_pc8 I 32 T_new_E I 2 RegWrite_E I 1 MemWrite_E I 1 SelEMout_E I 1 SelWout_E I 1 DMOp_E I 3 M_AO O 32 M_V2 O 5 M_A2 O 5 M_A3 O 5 M_pc O 32 M_pc8 O 32 T_new_M O 2 RegWrite_M O 1 MemWrite_M O 1 SelEMout_M O 1 SelWout_M O 2 DMOp_M O 3 4.W_REG 名称 方向 位宽 描述 clk I 1 reset I 1 M_AO I 32 M_DR I 32 M级DM中读出的数据 M_A3 M_pc I 32 M_pc8 I 32 SelWout_M I 2 T_new_M I 2 RegWrite_M I 1 W_AO O 32 W_DR O 32 W_A3 O 5 W_pc O 32 W_pc8 O 32 SelWout_W O 2 T_new_W O 2 RegWrite_W O 1 12.顶层连接 完整数据通路图QAQ\n流水级中的主要模块：\nF级 ：IFU D级 ：MCU,GRF,EXT,CMP,NPC(注意！一开始被教程中的图误导，放在了F级) E级 : ALU M级 ：DM 顶层 ：HCU 三. test //祖传强测代码 case0: ori $t0, $zero, 8 add $t1, $t0, $zero case1: ori $t0, $zero, 8 ori $t2, $zero, 12 add $t1, $t0, $zero case2: ori $t0, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 13 add $t1, $t0, $zero case3: ori $t0, $zero, 8 add $t1, $zero, $t0 case4: ori $t0, $zero, 8 ori $t2, $zero, 12 add $t1, $zero, $t0 case5: ori $t0, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 13 add $t1, $zero, $t0 case6: lui $t0, 8 add $t1, $t0, $zero case7: lui $t0, 8 lui $t2, 12 add $t1, $t0, $zero case8: lui $t0, 8 lui $t2, 12 lui $t3, 14 add $t1, $t0, $zero case9: lui $t0, 8 add $t1, $zero, $t0 case10: lui $t0, 8 lui $t2, 12 add $t1, $zero, $t0 case11: lui $t0, 8 lui $t2, 12 lui $t3, 14 add $t1, $zero, $t0 case12: lui $t0, 8 add $t1, $zero, $t0 add $t2, $t1, $zero case13: lui $t0, 8 add $t1, $zero, $t0 add $t3, $t0, $t0 add $t2, $t1, $zero case14: lui $t0, 8 add $t1, $zero, $t0 add $t3, $t0, $t0 add $t4, $t0, $t0 add $t2, $t1, $t1 case15: ori $t0, $zero, 8 ori $t1, $zero, 12 ori $t2, $zero, 16 ori $t3, $zero, 20 ori $t4, $zero, 24 ori $t5, $zero, 28 sw $t1, 0($t0) ori $s0, $zero, 4 ori $s1, $zero, 8 ori $s2, $zero, 12 lw $t6, 0($t0) add $t7, $t6, $t6 case16: ori $t0, $zero, 8 ori $t1, $zero, 12 ori $t2, $zero, 16 ori $t3, $zero, 20 ori $t4, $zero, 24 sw $t1, 0($t0) ori $s0, $zero, 4 ori $s1, $zero, 8 ori $s2, $zero, 12 lw $t6, 0($t0) ori $t5, $zero, 28 add $t7, $t6, $t6 case17: ori $t0, $zero, 8 ori $t1, $zero, 12 ori $t2, $zero, 16 ori $t3, $zero, 20 ori $t4, $zero, 24 sw $t1, 0($t0) ori $s0, $zero, 4 ori $s1, $zero, 8 ori $s2, $zero, 12 lw $t6, 0($t0) ori $t5, $zero, 28 ori $t8, $zero, 32 add $t7, $t6, $t6 case18: ori $t0, $zero, 8 ori $t1, $zero, 12 ori $t2, $zero, 16 jal change1 add $t3, $ra, $ra ori $t4, $zero, 20 ori $t5, $zero, 24 change1: ori $t6, $zero, 20 case19: ori $t0, $zero, 8 ori $t1, $zero, 12 ori $t2, $zero, 16 jal change2 ori $t4, $zero, 20 ori $t5, $zero, 24 change2: add $t3, $ra, $ra ori $t6, $zero, 20 ori $t7, $zero, 24 case20: ori $t0, $zero, 8 ori $t1, $zero, 12 ori $t2, $zero, 16 jal change3 ori $t4, $zero, 20 ori $t5, $zero, 24 change3: ori $t6, $zero, 20 add $t3, $ra, $ra ori $t6, $zero, 20 ori $t7, $zero, 24 case21:\tori $t0, $zero, 8 ori $t1, $t0, 12 case22: ori $t0, $zero, 8 ori $t2, $zero, 20 ori $t1, $t0, 12 case23: ori $t0, $zero, 8 ori $t2, $zero, 20 ori $t3, $zero, 24 ori $t1, $t0, 12 case24: ori $t0, $zero, 8 ori $t1, $zero, 20 ori $t2, $zero, 24 ori $t3, $zero, 12 ori $t4, $zero, 16 sub $t5, $t0, $t1 ori $t6, $t5, 13 case25: ori $t0, $zero, 8 ori $t1, $zero, 20 ori $t2, $zero, 24 ori $t3, $zero, 12 ori $t4, $zero, 16 sub $t5, $t0, $t1 ori $t7, $zero, 20 ori $t6, $t5, 13 case26: ori $t0, $zero, 8 ori $t1, $zero, 20 ori $t2, $zero, 24 ori $t3, $zero, 12 ori $t4, $zero, 16 sub $t5, $t0, $t1 ori $t7, $zero, 20 ori $t8, $zero, 24 ori $t6, $t5, 13 case27: ori $t0, $zero, 8 ori $t1, $zero, 20 ori $t2, $zero, 4 ori $t3, $zero, 12 ori $t4, $zero, 16 sw $t0, 0($t1) lw $t5, 0($t1) ori $t6, $t5, 13 case28: ori $t0, $zero, 8 ori $t1, $zero, 20 ori $t2, $zero, 4 ori $t3, $zero, 12 ori $t4, $zero, 16 sw $t0, 0($t1) lw $t5, 0($t1) ori $t7, $zero, 20 ori $t6, $t5, 13 case29: ori $t0, $zero, 8 ori $t1, $zero, 20 ori $t2, $zero, 4 ori $t3, $zero, 12 ori $t4, $zero, 16 sw $t0, 0($t1) lw $t5, 0($t1) ori $t7, $zero, 20 ori $t8, $zero, 24 ori $t6, $t5, 13 case30: ori $t0, $zero, 8 ori $t1, $zero, 20 jal change4 ori $t2, $ra, 8 ori $t3, $zero, 14 change4: ori $t4, $zero, 18 ori $t5, $zero, 22 ori $t6, $zero, 26 case31: ori $t0, $zero, 8 ori $t1, $zero, 20 jal change5 ori $t2, $zero, 4 ori $t3, $zero, 14 change5: ori $t4, $ra, 18 ori $t5, $zero, 22 ori $t6, $zero, 26 case32: ori $t0, $zero, 8 ori $t1, $zero, 20 jal change6 ori $t2, $zero, 4 ori $t3, $zero, 14 change6: ori $t7, $zero, 6 ori $t4, $ra, 18 ori $t5, $zero, 22 ori $t6, $zero, 26 case33: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 9 ori $t3, $zero, 12 sw $t1, 0($t0) sw $t2, 4($t0) sw $t3, 8($t0) occasionl1:\t#R_E_RS sub $t4, $t1, $t0 lw $t5, 0($t4) occasionl2:\t#R_M_RS sub $t5, $t3, $t0 ori $zero, $zero, 5 lw $t6, 0($t5) occasionl3:\t#R_W_RS add $t6, $t0, $t1 ori $s0, $zero, 12 ori $s1, $zero, 16 lw $t7, 0($t6) case34: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 9 ori $t3, $zero, 12 sw $t1, 0($t0) sw $t2, 4($t0) sw $t3, 8($t0) occasionl4:\t#R_E_RS ori $t4, $zero, 4 lw $t5, 0($t4) occasionl5:\t#R_M_RS ori $t5, $zero, 8 ori $zero, $zero, 5 lw $t6, 0($t5) occasionl6:\t#R_W_RS ori $t6, $zero, 12 ori $s0, $zero, 12 ori $s1, $zero, 16 lw $t7, 0($t6) case35: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 sw $t0, 0($zero) sw $t1, 0($t0) sw $t2, 0($t1) sw $t3, 4($t1) occasionl7:\t#ld_E_RS lw $t4, 0($t0) lw $t5, 0($t4) occasionl8:\t#ld_M_RS lw $t5, -4($t0) add $zero, $zero, $t1 lw $t6, 0($t5) occasionl9:\t#ld_W_RS lw $t6, 4($t0) ori $s0, $zero, 1 ori $s1, $zero, 2 lw $t7, 0($t6) case36: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 ori $t4, $zero, 20 occasions1:\t#R_E_RS add $t5, $t0, $t1 sw $t2, 0($t5) occasions2:\t#R_M_RS sub $t6, $t2, $t1 ori $s0, $zero, 12 sw $t3, 4($t6) occasions3:\t#R_W_RS sub $t7, $t4, $t0 ori $s1, $zero, 4 ori $s2, $zero, 8 sw $t4, 0($t7) occasions4:\t#R_E_RT sub $t5, $t1, $t0 sw $t5, 0($t0) occasions5:\t#R_M_RT sub $t5, $t2, $t0 ori $s0, $zero, 2 sw $t5, 4($t2) occasions6:\t#R_W_RT add $t6, $t3, $t4 ori $s0, $zero, 1 ori $s1, $zero, 2 sw $t6, 0($t1) case37: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 ori $t4, $zero, 20 occasions7:\t#I_E_RS ori $t5, $zero, 12 sw $t2, 0($t5) occasions8:\t#I_M_RS ori $t6, $zero, 4 ori $s0, $zero, 12 sw $t3, 4($t6) occasions9:\t#I_W_RS ori $t7, $zero, 16 ori $s1, $zero, 4 ori $s2, $zero, 8 sw $t4, 0($t7) occasions10:\t#I_E_RT lui $t5, 3 sw $t5, 0($t0) occasions11:\t#I_M_RT lui $t5, 1 ori $s0, $zero, 2 sw $t5, 4($t2) occasions12:\t#I_W_RT ori $zero, $zero, 9 ori $s0, $zero, 1 ori $s1, $zero, 2 sw $zero, 0($t1) case38: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 ori $t4, $zero, 20 sw $t0, 0($zero) sw $t1, 0($t0) sw $t2, 4($t0) sw $t3, 8($t0) occasions13:\t#ld_E_RS lw $t5, 0($t0) sw $t2, 0($t5) occasions14:\t#ld_M_RS lw $t6, 0($t0) ori $s0, $zero, 12 sw $t3, 4($t6) occasions15:\t#ld_W_RS lw $t7, 4($t0) ori $s1, $zero, 4 ori $s2, $zero, 8 sw $t4, 0($t7) occasions16:\t#ld_E_RT lw $t5, 0($t2) sw $t5, 0($t0) occasions17:\t#ld_M_RT lw $t5, 4($t2) ori $s0, $zero, 2 sw $t5, 4($t2) occasions18:\t#ld_W_RT lw $t6, 4($t0) ori $s0, $zero, 1 ori $s1, $zero, 2 sw $t6, 0($t1) case39: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 sub $t4, $t0, $t1 occasionbr1:\t#R_E_RS add $t5, $t0, $t1 beq $t5, $t2, changeb1 ori $s0, $zero, 1 ori $s1, $zero, 2 changeb1: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbr2:\t#R_M_RS add $t6, $t0, $t1 ori $s0, $zero, 1 beq $t6, $t2, changeb2 ori $s0, $zero, 1 ori $s1, $zero, 2 changeb2: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbr3:\t#R_W_RS add $t7, $t0, $t1 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t7, $t2, changeb3 ori $s0, $zero, 1 ori $s1, $zero, 2 changeb3: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbr4:\t#R_E_RT sub $t5, $t1, $t2 beq $t4, $t5, changeb4 ori $s0, $zero, 1 ori $s1, $zero, 2 changeb4: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbr5:\t#R_M_RT sub $t6, $t1, $t2 ori $s0, $zero, 1 beq $t4, $t6, changeb5 ori $s0, $zero, 1 ori $s1, $zero, 2 changeb5: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbr6:\t#R_W_RT sub $t7, $t1, $t2 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t4, $t7, changeb6 ori $s0, $zero, 1 ori $s1, $zero, 2 changeb6: ori $s2, $zero, 3 ori $s3, $zero, 4 case40: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 sub $t4, $t0, $t1 occasionbru1:\t#R_E_RS add $t5, $t0, $t1 beq $t5, $t3, changebru1 ori $s0, $zero, 1 ori $s1, $zero, 2 changebru1: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbru2:\t#R_M_RS add $t6, $t0, $t1 ori $s0, $zero, 1 beq $t6, $t3, changebru2 ori $s0, $zero, 1 ori $s1, $zero, 2 changebru2: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbru3:\t#R_W_RS add $t7, $t0, $t1 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t7, $t3, changebru3 ori $s0, $zero, 1 ori $s1, $zero, 2 changebru3: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbru4:\t#R_E_RT sub $t5, $t1, $t2 beq $t3, $t5, changebru4 ori $s0, $zero, 1 ori $s1, $zero, 2 changebru4: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbru5:\t#R_M_RT sub $t6, $t1, $t2 ori $s0, $zero, 1 beq $t3, $t6, changebru5 ori $s0, $zero, 1 ori $s1, $zero, 2 changebru5: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbru6:\t#R_W_RT sub $t7, $t1, $t2 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t3, $t7, changebru6 ori $s0, $zero, 1 ori $s1, $zero, 2 changebru6: ori $s2, $zero, 3 ori $s3, $zero, 4 case41: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 sub $t4, $t0, $t1 occasionbi1:\t#I_E_RS ori $t5, $zero, 16 beq $t5, $t3, changebi1 ori $s0, $zero, 1 ori $s1, $zero, 2 changebi1: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbi2:\t#I_M_RS ori $t6, $zero, 16 ori $s0, $zero, 1 beq $t6, $t3, changebi2 ori $s0, $zero, 1 ori $s1, $zero, 2 changebi2: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbi3:\t#I_W_RS ori $t7, $zero, 16 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t7, $t3, changebi3 ori $s0, $zero, 1 ori $s1, $zero, 2 changebi3: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbi4:\t#I_E_RT ori $t5, $zero, 8 beq $t1, $t5, changebi4 ori $s0, $zero, 1 ori $s1, $zero, 2 changebi4: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbi5:\t#I_M_RT ori $t6, $zero, 8 ori $s0, $zero, 1 beq $t1, $t6, changebi5 ori $s0, $zero, 1 ori $s1, $zero, 2 changebi5: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbi6:\t#I_W_RT ori $t7, $zero, 8 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t1, $t7, changebi6 ori $s0, $zero, 1 ori $s1, $zero, 2 changebi6: ori $s2, $zero, 3 ori $s3, $zero, 4 case42: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $t3, $zero, 16 sub $t4, $t0, $t1 occasionbiu1:\t#I_E_RS ori $t5, $zero, 16 beq $t5, $t2, changebiu1 ori $s0, $zero, 1 ori $s1, $zero, 2 changebiu1: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbiu2:\t#I_M_RS ori $t6, $zero, 16 ori $s0, $zero, 1 beq $t6, $t2, changebiu2 ori $s0, $zero, 1 ori $s1, $zero, 2 changebiu2: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbiu3:\t#I_W_RS ori $t7, $zero, 16 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t7, $t2, changebiu3 ori $s0, $zero, 1 ori $s1, $zero, 2 changebiu3: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbiu4:\t#I_E_RT ori $t5, $zero, 8 beq $t2, $t5, changebiu4 ori $s0, $zero, 1 ori $s1, $zero, 2 changebiu4: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbiu5:\t#I_M_RT ori $t6, $zero, 8 ori $s0, $zero, 1 beq $t2, $t6, changebiu5 ori $s0, $zero, 1 ori $s1, $zero, 2 changebiu5: ori $s2, $zero, 3 ori $s3, $zero, 4 occasionbiu6:\t#I_W_RT ori $t7, $zero, 8 ori $s0, $zero, 1 ori $s1, $zero, 2 beq $t2, $t7, changebiu6 ori $s0, $zero, 1 ori $s1, $zero, 2 changebiu6: ori $s2, $zero, 3 ori $s3, $zero, 4 case43: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $s0, $zero, 1 sw $t0, 0($zero) sw $t1, 4($zero) sw $t2, 8($zero) ori $s0, $zero, 1 ori $s1, $zero, 2 occasionbld1:\t#ld_E_RS lw $t3, 0($t0) beq $t3, $t1, changebld1 ori $s0, $zero, 1 ori $s1, $zero, 2 changebld1: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbld2:\t#ld_M_RS lw $t4, 0($t0) ori $s2, $zero, 2 beq $t4, $t1, changebld2 ori $s0, $zero, 1 ori $s1, $zero, 2 changebld2: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbld3:\t#ld_W_RS lw $t5, 0($t0) ori $s2, $zero, 2 ori $s3, $zero, 3 beq $t5, $t1, changebld3 ori $s0, $zero, 1 ori $s1, $zero, 2 changebld3: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbld4:\t#ld_E_RT lw $t6, 0($t0) beq $t6, $t1, changebld4 ori $s0, $zero, 1 ori $s1, $zero, 2 changebld4: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbld5:\t#ld_M_RT lw $t7, 0($t0) ori $s2, $zero, 2 beq $t7, $t1, changebld5 ori $s0, $zero, 1 ori $s1, $zero, 2 changebld5: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbld6:\t#ld_W_RT lw $t8, 0($t0) ori $s2, $zero, 2 ori $s3, $zero, 3 beq $t8, $t1, changebld6 ori $s0, $zero, 1 ori $s1, $zero, 2 changebld6: ori $s2, $zero, 2 ori $s3, $zero, 3 case44: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 12 ori $s0, $zero, 1 sw $t0, 0($zero) sw $t1, 4($zero) sw $t2, 8($zero) ori $s0, $zero, 1 ori $s1, $zero, 2 occasionbldu1:\t#ld_E_RS lw $t3, 0($t0) beq $t3, $t0, changebldu1 ori $s0, $zero, 1 ori $s1, $zero, 2 changebldu1: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbldu2:\t#ld_M_RS lw $t4, 0($t0) ori $s2, $zero, 2 beq $t4, $t0, changebldu2 ori $s0, $zero, 1 ori $s1, $zero, 2 changebldu2: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbldu3:\t#ld_W_RS lw $t5, 0($t0) ori $s2, $zero, 2 ori $s3, $zero, 3 beq $t5, $t0, changebldu3 ori $s0, $zero, 1 ori $s1, $zero, 2 changebldu3: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbldu4:\t#ld_E_RT lw $t6, 0($t0) beq $t0, $t6, changebldu4 ori $s0, $zero, 1 ori $s1, $zero, 2 changebldu4: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbldu5:\t#ld_M_RT lw $t7, 0($t0) ori $s2, $zero, 2 beq $t0, $t7, changebldu5 ori $s0, $zero, 1 ori $s1, $zero, 2 changebldu5: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbldu6:\t#ld_W_RT lw $t8, 0($t0) ori $s2, $zero, 2 ori $s3, $zero, 3 beq $t0, $t8, changebldu6 ori $s0, $zero, 1 ori $s1, $zero, 2 changebldu6: ori $s2, $zero, 2 ori $s3, $zero, 3 case45: ori $t0, $zero, 4 ori $t1, $zero, 0x000039a0 ori $t2, $zero, 0x000039c0 ori $t3, $zero, 0x000039a4 ori $t4, $zero, 0x00003a04 occasionbj1:\t#jal_M_RS jal changebj1 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj1: beq $ra, $t1, changebj11 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj11: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbj2:\t#jal_W_RS jal changebj2 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj2: ori $s2, $zero, 2 beq $ra, $t2, changebj21 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj21: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbj3:\t#jal_M_RT jal changebj3 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj3: beq $t3, $ra, changebj31 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj31: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbj4:\t#jal_W_RT jal changebj4 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj4: ori $s2, $zero, 2 beq $t4, $ra, changebj41 ori $s0, $zero, 1 ori $s1, $zero, 2 changebj41: ori $s2, $zero, 2 ori $s3, $zero, 3 case46: ori $t0, $zero, 4 ori $t1, $zero, 0x0000399c ori $t2, $zero, 0x000039bc ori $t3, $zero, 0x000039e0 ori $t4, $zero, 0x00003a00 occasionbju1:\t#jal_M_RS jal changebju1 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju1: beq $ra, $t1, changebju11 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju11: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbju2:\t#jal_W_RS jal changebju2 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju2: ori $s2, $zero, 2 beq $ra, $t2, changebju21 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju21: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbju3:\t#jal_M_RT jal changebju3 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju3: beq $t3, $ra, changebju31 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju31: ori $s2, $zero, 2 ori $s3, $zero, 3 occasionbju4:\t#jal_W_RT jal changebju4 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju4: ori $s2, $zero, 2 beq $t4, $ra, changebju41 ori $s0, $zero, 1 ori $s1, $zero, 2 changebju41: ori $s2, $zero, 2 ori $s3, $zero, 3 case47: ori $t0, $zero, 4 ori $t1, $zero, 0x00003010 ori $t2, $zero, 0x00003030 ori $t3, $zero, 0x00003050 ori $t4, $zero, 0x00003070 occasionjms1:\t#jal_M_RS jal changejms1 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 2 ori $s3, $zero, 3 j case48 ori $s4, $zero, 4 changejms1: jr $ra ori $s0, $zero, 1 ori $s1, $zero, 2 case48: ori $t0, $zero, 4 ori $t1, $zero, 0x00003010 ori $t2, $zero, 0x00003030 ori $t3, $zero, 0x00003050 ori $t4, $zero, 0x00003070 occasionjws1:\t#jal_W_RS jal changejws1 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 2 ori $s3, $zero, 3 j case49 ori $s4, $zero, 4 changejws1: ori $s3, $zero, 3 jr $ra ori $s0, $zero, 1 ori $s1, $zero, 2 case49: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 0x00003b58 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 occasionres1:\t#R_E_RS add $t3, $t0, $t2 jr $t3 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 case50: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 0x00003b88 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 occasionrms1:\t#R_M_RS add $t3, $t0, $t2 ori $s0, $zero, 1 jr $t3 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 case51: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 0x00003bbc ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 occasionrws1:\t#R_W_RS add $t3, $t0, $t2 ori $s0, $zero, 1 ori $s1, $zero, 2 jr $t3 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 case52: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 0x00003bec ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 occasionies1:\t#I_E_RS ori $t3, $t2, 0 jr $t3 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 case53: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 0x00003c1c ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 occasionims1:\t#I_M_RS ori $t3, $t2, 0 ori $s0, $zero, 1 jr $t3 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 case54: ori $t0, $zero, 4 ori $t1, $zero, 8 ori $t2, $zero, 0x00003c50 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 occasioniws1:\t#I_W_RS ori $t3, $t2, 0 ori $s0, $zero, 1 ori $s1, $zero, 2 jr $t3 ori $s0, $zero, 1 ori $s1, $zero, 2 ori $s2, $zero, 3 case55: ori $t0, $zero, 0X00003c84 ori $t1, $zero, 0X00003008 ori $s0, $zero, 0 ori $s0, $zero, 0 sw $t0, 0($zero) sw $t1, 4($zero) ori $s0, $zero, 0 ori $s0, $zero, 0 occasionldes1:\t#ld_E_RS lw $t2, 0($zero) jr $t2 ori $s0, $zero, 0 ori $s0, $zero, 0 ori $s0, $zero, 0 case56: ori $t0, $zero, 0X00003cbc ori $t1, $zero, 0X00003008 ori $s0, $zero, 0 ori $s0, $zero, 0 sw $t0, 0($zero) sw $t1, 4($zero) ori $s0, $zero, 0 ori $s0, $zero, 0 occasionldms1:\t#ld_M_RS lw $t2, 0($zero) ori $s0, $zero, 0 jr $t2 ori $s0, $zero, 0 ori $s0, $zero, 0 ori $s0, $zero, 0 case57: ori $t0, $zero, 0X00003cf8 ori $t1, $zero, 0X00003008 ori $s0, $zero, 0 ori $s0, $zero, 0 sw $t0, 0($zero) sw $t1, 4($zero) ori $s0, $zero, 0 ori $s0, $zero, 0 occasionldws1:\t#ld_W_RS lw $t2, 0($zero) ori $s0, $zero, 0 ori $s0, $zero, 0 jr $t2 ori $s0, $zero, 0 ori $s0, $zero, 0 ori $s0, $zero, 0 四.思考题 1.我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子 我们使用两个寄存器值的时间最早来到了D级，所以很可能会引发暂停.\n如下面这种情况，若beq的结果在E级产生，则不需要暂停，可以转发，但是现在beq在D级的时候lw还在M级，没有产生结果，需要暂停。\n1 2 3 lw $t0, 0($0) nop beq $t0, $t0, label 2.因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？ 因为延迟槽的存在，跳转指令的后一条必然会执行，所以需要把PC+8写入寄存器，不然jr时延迟槽内的指令会再执行一次 3.我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？ 会导致时钟周期变长、时钟频率降低，整体花费时间变长 4.我们为什么要使用 GPR 内部转发？该如何实现？ 为了保持W级的写入和此时D级的读出是同一个值，规避数据冒险。实现方法就是在RF模块里加上一个MUX，判断当冲突条件满足时，转发。 5.我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？ 见第二部分HCU的分析 6.在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置 对于计算类：首先改变MCU，注意每个指令的控制信号的对应，再改ALU的结构，增加输出选择 对于访存类：改变MCU+修改DM增加相应的功能 对于跳转类：修改MCU+NPC相应功能修改 小技巧：寻找已有的指令中与新增的指令相似的指令（可能不止一条），然后顺着这几条指令改。 7.简要描述你的译码器架构，并思考该架构的优势以及不足 ​\t我采用了集中式译码，优势是不需要编写多个译码器，缺点是流水线寄存器比较难以维护。\n","permalink":"https://coder0xe.github.io/posts/p5-pipeline-cpu-design-document/","summary":"\u003ch1 id=\"p5-pipeline-cpu-design-document\"\u003e\u003ccenter\u003eP5-pipeline-CPU-Design-Document\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"零数据通路描述\"\u003e零.数据通路描述\u003c/h2\u003e\n\u003cp\u003e​\tMIPS架构的五级流水线CPU数据通路有以下五个阶段：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e取指阶段F(Fetch):从指令存储器中读取指令\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e译码阶段D(Decode):从寄存器文件中读取源操作数并对指令译码得到控制信号\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e执行阶段E(Execute):使用ALU执行计算\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e存储阶段M(Memory):读或写数据存储\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e写回阶段(Writeback):将结果写回到寄存器文件\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\t通过在五个阶段之间加入寄存器来保存前面周期产生的数据(最后一个阶段的寄存器即为GRF),形成五级流水线CPU，数据通路如下图表示：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"P5-pipeline\" loading=\"lazy\" src=\"/img/image-20231122234113510.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"一数据命名规范checkstyle\"\u003e一.数据命名规范(checkstyle)\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e在控制信号连线名末尾加上“_阶段字母”，如NPCOp_D,用于区分所属的阶段\u003c/li\u003e\n\u003cli\u003e在流水线寄存器输出信号前加上“阶段字母_\u0026quot;，如：D_A1,用以区分所属阶段\u003c/li\u003e\n\u003cli\u003e功能部件输出信号前加上功能部件名称\u003c/li\u003e\n\u003cli\u003e常规MUX命名采用\u0026quot;MUX-部件名-端口名”的命名方式，选择信号命名为\u0026quot;Sel+部件名+端口名\u0026quot;\u003c/li\u003e\n\u003cli\u003e转发MUX命名采用\u0026quot;HMUX-部件名-端口名\u0026quot;的命名方式，选择信号命名为\u0026quot;Fwd+部件名+端口名\u0026quot;\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"二部件设计\"\u003e二.部件设计\u003c/h2\u003e\n\u003ch3 id=\"1mcumain-control-unit\"\u003e1.MCU(main control unit)\u003c/h3\u003e\n\u003ch4 id=\"1端口定义列表\"\u003e1.端口定义列表\u003c/h4\u003e\n\u003cp\u003e​\t主控制单元模块负责对指令进行译码以及产生控制信号，本CPU的设计采用集中式译码，在P5中需要完成的指令及其需要的控制信号列表如下，其中有些控制信号对应多路选择器的选择。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e名称\u003c/th\u003e\n          \u003cth\u003e方向\u003c/th\u003e\n          \u003cth\u003e位宽\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eD_opcode\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e6\u003c/td\u003e\n          \u003ctd\u003eD级输出opcode\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eD_funct\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e6\u003c/td\u003e\n          \u003ctd\u003eD级输出funct\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelA3_D\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e选择当前指令要写入的寄存器，写入E级流水线寄存器\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRegWrite_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003eGRF写入使能\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMemWrite_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003eDM写入使能\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eEXTOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e对立即数进行符号扩展还是0扩展\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelEMout_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003e选择E，M级转发数据信号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelWout_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e选择W级转发数据信号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSelALUB_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n          \u003ctd\u003eALU的B端口rt数据与32位立即数的选择\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCMPOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e3\u003c/td\u003e\n          \u003ctd\u003eD级B类指令比较选择\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eNPCOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e3\u003c/td\u003e\n          \u003ctd\u003e写入NPC选择\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eALUOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e3\u003c/td\u003e\n          \u003ctd\u003eALU操作信号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDMOp_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e3\u003c/td\u003e\n          \u003ctd\u003eDM操作信号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eT_rs_use_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e指令处在D级时还有多少个周期需要使用rs寄存器的值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eT_rt_use_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e指令处在D级时还有多少个周期需要使用rt寄存器的值\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eT_new_D\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n          \u003ctd\u003e指令处在D级时还有多少个周期可以产生写入寄存器的新值\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"2分指令梳理控制信号\"\u003e2.分指令梳理控制信号\u003c/h4\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e指令\u003c/th\u003e\n          \u003cth\u003e取高电平的控制信号和ALUOp\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eadd\u003c/td\u003e\n          \u003ctd\u003eSelA3_D = 2\u0026rsquo;b01, RegWrite, ALUOp = 3\u0026rsquo;b000, NPCOp = 3\u0026rsquo;b000;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003esub\u003c/td\u003e\n          \u003ctd\u003eSelA3_D = 2\u0026rsquo;b01, RegWrite, ALUOp = 3\u0026rsquo;b001, NPCOp = 3\u0026rsquo;b000;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eori\u003c/td\u003e\n          \u003ctd\u003eRegWrite,ALUSrc, SelALUB, ALUOp=3\u0026rsquo;b010, NPCOp = 3\u0026rsquo;b000;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003elui\u003c/td\u003e\n          \u003ctd\u003eRegWrite,ALUSrc, SelALUB, ALUOp=3\u0026rsquo;b011, NPCOp = 3\u0026rsquo;b000;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003elw\u003c/td\u003e\n          \u003ctd\u003eRegWrite, SelWout = 2\u0026rsquo;b01, SelALUB, EXTOp, ALUOp=3\u0026rsquo;b000, NPCOp = 3\u0026rsquo;b000;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003esw\u003c/td\u003e\n          \u003ctd\u003eMemWrite, SelALUB, EXTOp, ALUOp=3\u0026rsquo;b000, NPCOp = 3\u0026rsquo;b000;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ebeq\u003c/td\u003e\n          \u003ctd\u003eCMPOp = 3\u0026rsquo;b000,EXTOp, NPCOp = 3\u0026rsquo;b001, CMPOp = 3\u0026rsquo;b000;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ejal\u003c/td\u003e\n          \u003ctd\u003eRegWrite, SelA3_D = 2\u0026rsquo;b10, NPCOp = 3\u0026rsquo;b010;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ejr\u003c/td\u003e\n          \u003ctd\u003eNPCOp = 3\u0026rsquo;b11;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003enop\u003c/td\u003e\n          \u003ctd\u003e相当于sll $0,$0,0，不需要进行特殊处理\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"3译码方式的改动\"\u003e3.译码方式的改动\u003c/h4\u003e\n\u003cp\u003e​\t在P4中，我才用使用reg类型变量记录指令识别的形式，在always块中每次都为代表所有信号的寄存器赋初值0，这样会导致pc一直自增下去，程序不断向后跑(虽然在上机时无影响)，在蒋老师的测评机上会出现多输出的情况。在P5中，使用wire类型进行指令的识别，当识别的指令为x时，所有指令对应的wire都是不定值x，导致MCU中输出的控制信号为x，使得pc停下来，可以正常在蒋老师的测评机上跑结果。\u003c/p\u003e","title":"P5-pipeline-CPU-Design-Document"},{"content":"P4-Verilog-CPU-Design-Document 零.数据通路描述(P4设计文档中最好加上P3图) ​\t本次设计文档基于P3-logisim-CPU的设计文档完成，P4的主要任务即为将logisim电路映射到verilog代码(看图写话？)，对上次P3中实现的每个模块单独建立module.v，利用verilog语言对其行为进行建模，注意本次CPU设计中，不同于P3的异步复位，P4在各模块中使用同步复位!!!，verilog语言表示同步复位与异步复位如下代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //同步复位表示方法 always@(posedge clk) begin if(reset) begin PC \u0026lt;= 32\u0026#39;h0000_3000; end else begin PC \u0026lt;= npc; end end //异步复位表示方法 将复位信号加入敏感信号列表 always@(posedge clk or posedge reset) begin if(reset) begin PC \u0026lt;= 32\u0026#39;h0000_3000; end else begin PC \u0026lt;= npc; end end 一.模块设计 1.IFU取指令单元 ​\tIFU中存储单元有PC寄存器和存储指令的ROM。IFU中存储指令要求的ROM大小为16KiB，即4096*32bit。在verilog语言中使用寄存器数组实现对ROM的模拟，即4096个32位的寄存器。使用系统命令$readmemh(\u0026quot;code.txt,ROM\u0026quot;)将code.txt中的16进制代码读入名为ROM的数组中，由于PC同步复位到32\u0026rsquo;h0000_3000，而ROM中对应存储第一条指令的地址为0，即PC寄存器中存储的地址与真实ROM地址存在0x0000_3000差量，故设计reg [31:0] tmp存储实际的地址，即pc-0x0000_3000，进而读出指令的地址为tmp[13:2]。\n1.端口定义列表: 名称 方向 位宽 功能 clk I 1 时钟信号 reset I 1 同步复位信号 npc I [31:0] 下一指令地址 pc O [31:0] 当前指令地址 instr O [31:0] 当前执行指令 2.设计代码: 需要注意的是利用系统任务$readmemh向ROM中读入数据需要单独在initial块中进行，\n1 2 3 4 //初始化ROM中内容 initial begin $readmemh(\u0026#34;code.txt\u0026#34;,ROM); end 3.small tip : add source的用法 ​\t对于code.txt的导入和上机时对于下载代码的导入，使用add source功能方便快捷，之前一直不知道这个功能，麻烦了好多QAQ\n之前使用新建文件之后移动到该文件夹下的方法，在很多环境下无法成功读取入IM(例如机房电脑和虚拟机)，add source 插图如下\n注：使用add source对代码进行改动是可以同步到原文件的!\n2. IS指令分线器 ​\t此模块的功能比较简单，由组合逻辑完成，传入当前运行的指令将其分割。\n端口定义列表: 名称 方向 位宽 功能 instr I [31:0] 输入执行指令码 opcode O [5:0] 操作码 rs O [4:0] rs rt O [4:0] rt rd O [4:0] rd shamt O [4:0] 移位 funct O [5:0] 功能码 imm O [15:0] 立即数 address O [25:0] J类指令跳转地址 3. NPC地址计算单元 端口定义列表: 名称 方向 位宽 功能 pc I [31:0] 当前地址 offset I [31:0] B类跳转地址 j_address I [25:0] J类跳转地址 reg_address I [31:0] 4. GRF寄存器堆 端口定义列表 名称 方向 位宽 功能 clk I 1 时钟信号 reset I 1 同步复位信号 rs I [4:0] 读寄存器1 rt I [4:0] 读寄存器2 rd I 5 写寄存器 RegWrite I 1 写入使能 pc I [31:0] 当前指令地址 writedata I [31:0] 写入 readdata1 O [31:0] 寄存器1中存储的数值 readdata2 O [31:0] 寄存器2中存储的数值 5. ALU计算单元 端口定义列表 名称 方向 位宽 功能 src_A I [31:0] 操作数1 src_B I [31:0] 操作数2 ALUOp I [3:0] ALU操作类型 shamt I [4:0] 移位量 flowjudge I 1 是否进行溢出判断(目前只有addi) equal O 1 判断两个操作数是否相等 overflow O 1 溢出信号 result O [31:0] 计算结果 6. Controller控制器 ​\t采用与或门的思路对指令进行识别并产生相应的控制信号\n1.端口定义列表: 名称 方向 位宽 功能 opcode I [5:0] 操作码 funct I [5:0] 功能码 MemtoReg O 1 选择将DM中的数据存储到GRF RegDst O 1 选择写入寄存器地址(只有R型指令有效) ALUSrc O 1 选择ALU第二个操作数(RD2/imm_32) RegWrite O 1 寄存器堆写入使能信号 MemWrite O 1 DM中RAM写入使能信号 flowjudge O 1 进行运算溢出判断(当前指令集中只有addi有效) shiftvar O 1 选择以寄存器的[4:0]位进行移位 ralink O 1 定向向31号寄存器中写入(jal指令) PCtoReg O 1 将PC+4值作为写入数据存入寄存器堆(jal/jalr) EXTOp O 1 对立即数进行符号/0扩展 branch O 1 是否为B类跳转指令 branchOp O [2:0] 对B类跳转指令进行编码 ALUOp O [3:0] ALU操作控制信号 LSOp O [2:0] DM操作控制信号 NPCOp O [1:0] NPC地址选择信号 注：控制信号在对应使用模块中进行说明，P4的控制信号中取消了P3中的MemRead信号，感觉上要简洁一些\n2.设计代码示例——我的控制器风格 ​\t设计代码比较长，只举例说明，好传统是利用localparam定义opcode和funct，用case语句进行分支选择而不是if-else\n注意：每次信号传入时的寄存器集体清零操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 module Controller( input [5:0] opcode, input [5:0] funct, output reg MemtoReg, output reg MemWrite, output reg ALUSrc, output reg RegWrite, output reg EXTOp, output reg RegDst, output reg PCtoReg, output reg ralink, output reg shiftvar, output reg flowjudge, //由于要求实现的add sub不进行溢出判断 应该当前实现的指令中需要判断的只有addi output reg Branch, output wire [2:0] branchOp, output wire [1:0] NPCOp, output wire [3:0] ALUOp, output wire [2:0] LSOp ); //有寄存器赋初值问题 //R型指令 //(运算) reg op_add; ... localparam R = 6\u0026#39;b000000; localparam _add = 6\u0026#39;b100000; ... //识别指令 always@(*) begin //控制信号清0 op_add = 1\u0026#39;b0; case(opcode) R : begin case(funct) _add : op_add = 1\u0026#39;b1; ... endcase end ... endcase //连接输出 RegWrite = op_add | ... ; endmodule 3.指令与控制信号汇总表 控制信号 有效指令 MemtoReg lw,lh,lb,lhu,lbu RegDst add,sub,and,or,xor,nor,sll,srl,sra,sllv,srlv,srav,slt,sltu,jr,jalr(R型指令) ALUSrc sw,lw,sh,sb,lh,lhu,lb,lhu,lui,addi,addiu,andi,ori,xori,slti,sltiu RegWrite slt,sltu,xor,nor,or,and,add,sub,lui,ori,andi,xori,addi,addiu,lw,lh,lb,lhu,lbu,jal,jalr,sll,srl,sra,sllv,srlv,srav,slti,sltiu MemWrite sw,sb,sh flowjudge addi shiftvar sllv,srlv,srav ralink jal PCtoReg jal,jalr EXTOp addi,addiu,slti,sltiu,sw,sh,sb,lw,lh,lb,lhu,lbu,beq,bne,bgtz,bgez,bltz,blez Branch beq,bne,bgtz,bgez,bltz,blez branchOp[2] bne branchOp[1] bgtz,blez branchOp[0] bgez,blez,bltz ALUOp[3] srl,srlv,sra,srav,slt,sltu,slti,sltiu ALUOp[2] sll,sllv,xori,nor,lui,xor ALUOp[1] add,addi,addiu,sub,nor,sll,sllv,slt,slti,sltiu,sw,sh,sb,lw,lh,lhu,lb,lbu ALUOp[0] or,ori,sub,xor,xori,sll,sllv,sra,srav,sltu,sltiu NPCOp[1] jalr,jr,j,jal NPCOp[0] jalr,jr,beq,bne,bgtz,bgez,bltz,blez LSOp[2] lh,lhu,lb,lbu LSOp[1] lb,lbu,lw,sb LSOp[0] sh,lw,lhu,lbu 7. EXT符号扩展单元 端口定义列表 名称 方向 位宽 功能 imm I [15:0] 进行扩展的16位立即数 EXTOp I 1 选择进行符号扩展或0扩展 imm_31 O [31:0] 进行扩展后的结果 8. DM数据存储 1.端口定义列表 名称 方向 位宽 功能 address I [31:0] 写入/读取地址 datawrite I [31:0] 写入数据 MemWrite I 1 RAM写入使能信号 clk I 1 时钟信号 reset I 1 同步复位信号 LSOp I [2:0] 对/字/半字/字节操作 readata O [31:0] 读出数据 LSOp编码与对应指令 LSOp编码 对应的存/取指令 000 sw 001 sh 010 sb 011 lw 100 lh 101 lhu 110 lb 111 lbu 2.设计代码: ​\t依旧是延续P3中先将对应地址处数据读出再插入的思想，其中存储为时序逻辑，读取为组合逻辑。(但是写起来要比logisim简单太多),使用3072个32位寄存器数组模拟RAM。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 //要求的容量为12KB 3072*32bit module DM( input clk, input reset, input MemWrite, input [2:0] LSOp, //w h b input [31:0] address, input [31:0] datawrite, output [31:0] dataread ); reg [31:0] RAM[3071:0]; localparam sw = 3\u0026#39;b000; localparam sh = 3\u0026#39;b001; localparam sb = 3\u0026#39;b010; localparam lw = 3\u0026#39;b011; localparam lh = 3\u0026#39;b100; localparam lhu = 3\u0026#39;b101; localparam lb = 3\u0026#39;b110; localparam lbu = 3\u0026#39;b111; //读出该地址处存储的数据 reg tmp = RAM[address[13:2]]; // write to RAM integer i = 0; always@(posedge clk) begin if(reset) begin for(i = 0 ; i \u0026lt; 3072 ; i = i + 1) begin RAM[i] \u0026lt;= 32\u0026#39;b0; end end else if (MemWrite) begin //对LSOp进行分类 if(LSOp == sw) begin RAM[address[13:2]] \u0026lt;= datawrite; end else if (LSOp == sh) begin if(address[1] == 1\u0026#39;b1) begin RAM[address[13:2]] \u0026lt;= {datawrite[15:0],tmp[15:0]}; end else begin RAM[address[13:2]] \u0026lt;= {tmp[31:16],datawrite[15:0]}; end end else if (LSOp == sb) begin if(address[1:0] == 2\u0026#39;b00) begin RAM[address[13:2]] \u0026lt;= {tmp[31:8],datawrite[7:0]}; end else if (address[1:0] == 2\u0026#39;b01) begin RAM[address[13:2]] \u0026lt;= {tmp[31:16],datawrite[7:0],tmp[7:0]}; end else if (address[1:0] == 2\u0026#39;b10) begin RAM[address[13:2]] \u0026lt;= {tmp[31:24],datawrite[7:0],tmp[15:0]}; end else begin RAM[address[13:2]] \u0026lt;= {datawrite[7:0],tmp[23:0]}; end end end end //read from RAM always@(*)begin if(LSOp == lw) begin dataread = tmp; end else if (LSOp == lh) begin // sign-extend if(address[1] == 1\u0026#39;b0) begin dataread = {{16{tmp[15]}},tmp[15:0]}; end else begin dataread = {{16{tmp[31]}},tmp[31:16]}; end end else if (LSOp == lhu) begin if(address[1] == 1\u0026#39;b0) begin dataread = {16\u0026#39;b0,tmp[15:0]}; end else begin dataread = {16\u0026#39;b0,tmp[31:16]}; end end else if (LSOp == lb) begin if(address[1:0] == 2\u0026#39;b00) begin dataread = {{24{tmp[7]}},tmp[7:0]}; end else if (address[1:0] == 2\u0026#39;b01) begin dataread = {{24{tmp[15]}},tmp[15:8]}; end else if (address[1:0] == 2\u0026#39;b10) begin dataread = {{24{tmp[23]}},tmp[23:16]}; end else begin dataread = {{24{tmp[31]}},tmp[31:24]}; end end else begin if(address[1:0] == 2\u0026#39;b00) begin dataread = {24\u0026#39;b0,tmp[7:0]}; end else if (address[1:0] == 2\u0026#39;b01) begin dataread = {24\u0026#39;b0,tmp[15:8]}; end else if (address[1:0] == 2\u0026#39;b10) begin dataread = {24\u0026#39;b0,tmp[23:16]}; end else begin dataread = {24\u0026#39;b0,tmp[31:24]}; end end end endmodule 9.Sel-B B类指令判断单元 1.端口定义列表 名称 方向 位宽 功能 data I [31:0] rs寄存器中的值 judge I [4:0] 区分bltz/bgez branchOp I [2:0] 指令编码 equal I 1 beq判断相等 branch I 1 是否为B类指令 result O 1 执行B类跳转指令 branchOp编码与对应指令 branchOp编码 对应指令 000 beq 001 bltz 001 bgez 010 bgtz 011 blez 100 bne 2.设计代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 module SelectB( input [31:0] data, input [4:0] judge, //实际上只用最后一位 input equal, input Branch, input [2:0] branchOp, output reg result ); localparam beq = 3\u0026#39;b000; localparam bgez_bltz = 3\u0026#39;b001; localparam bgtz = 3\u0026#39;b010; localparam blez = 3\u0026#39;b011; localparam bne = 3\u0026#39;b100; always@(*)begin case(branchOp) beq : result = equal \u0026amp; Branch; bne : result = (~equal) \u0026amp; Branch; bgez_bltz : begin if(judge[0] == 1\u0026#39;b1) begin result = ($signed(data) \u0026gt;= 32\u0026#39;b0) \u0026amp; Branch; end else begin result = ($signed(data) \u0026lt; 32\u0026#39;b0) \u0026amp; Branch; end end bgtz : result = ($signed(data) \u0026gt; 32\u0026#39;b0) \u0026amp; Branch; blez : result = ($signed(data) \u0026lt;= 32\u0026#39;b0) \u0026amp; Branch; endcase end endmodule 10.MUX多路选择器集成文件 ​\t将电路中用到的四个多路选择器在MUX.v中保存为四个模块，在mips.v中进行调用.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 //寄存器写入地址选择 rt / rd / ra module selTorD ( input [4:0] rt, input [4:0] rd, input wire RegDst, output [4:0] r0 ); assign r0 = (RegDst == 1\u0026#39;b1) ? rd : rt; endmodule // rtd / ra? module selR0orRA( input [4:0] r0, input ralink, output [4:0] RegAddr ); assign RegAddr = (ralink == 1\u0026#39;b1) ? 5\u0026#39;b11111 : r0; endmodule //寄存器写入数据选择 module ALUorDM( input [31:0] ALUresult, input [31:0] DMdata, input MemtoReg, output [31:0] data0 ); assign data0 = (MemtoReg == 1\u0026#39;b1) ? DMdata : ALUresult; endmodule module data0orPC( input [31:0] data0, input [31:0] pc, input PCtoReg, output [31:0] RegData ); assign RegData = (PCtoReg == 1\u0026#39;b1) ? pc : data0; endmodule //ALU移位选择 module RegorShamt( input [4:0] shamt, input [31:0] readdata1, input shiftvar, output [4:0] shift ); assign shift = (shiftvar == 1\u0026#39;b1) ? readdata1[4:0] : shamt; endmodule //ALU src_B选择 module ALUsrc_B( input [31:0] readdata2, input[31:0] offset, //imm_32 input ALUSrc, output [31:0] DatatoSrcB ); assign DatatoSrcB = (ALUSrc == 1\u0026#39;b1) ? offset : readdata2; endmodule 11.顶层电路连接 ​\t顶层电路连接主要是利用与端口位宽配对的wire类型变量连接起实例化的各个模块。模块实例化使用指定端口的模式例如\n1 2 3 4 5 6 7 8 9 10 11 IS top_is( .instr(instr), .opcode(opcode), .rs(rs), .rt(rt), .rd(rd), .shamt(shamt), .funct(funct), .imm(imm), .address(j_address) ); 注意：确保在顶层电路中的所有连线(wire型变量)都要提前声明好位宽，我出的大部分bug都是因为这个原因，用到一个新的连线时立马声明该变量，否则ISE运行并不会报错，而是将该变量作为位宽为1处理，导致数据丢失，体现在在仿真时出现红线或蓝线，但是这种情况下ISE会给WARNING\nWARNING:\n1 WARNING: File \u0026#34;C:/Users/123/Desktop/P4-CPU/mips.v\u0026#34; Line 92. For instance uut/top_ALUorDM/, width 32 of formal port ALUresult is not equal to width 1 of actual signal ALUresult. 二.test scheme ​\t编写测试数据如下，对顶层模块建立testbench进行仿真模拟即可而不需要对各个模块分别模拟。\nlui $0, 19569 lui $1, 39483 lui $2, 18131 lui $3, 22132 lui $4, 24751 lui $5, 54167 lui $6, 26566 lui $7, 45168 lui $8, 33552 lui $9, 8645 lui $10, 60414 lui $11, 33459 lui $12, 53176 lui $13, 47958 lui $14, 2778 lui $15, 60761 lui $16, 2966 lui $17, 51490 lui $18, 46369 lui $19, 35006 lui $20, 64454 lui $21, 52806 lui $22, 21466 lui $23, 39517 lui $24, 11681 lui $25, 46088 lui $26, 61510 lui $27, 30570 lui $28, 37526 lui $29, 15029 lui $30, 40281 lui $31, 43390 ori $0 $17, 19261 ori $1 $19, 12907 ori $2 $20, 48520 ori $3 $23, 60075 ori $4 $13, 57134 ori $5 $19, 17016 ori $6 $3, 58700 ori $7 $3, 22848 ori $8 $20, 15970 ori $9 $13, 34258 ori $10 $18, 49197 ori $11 $4, 11904 ori $12 $7, 54536 ori $13 $3, 6104 ori $14 $23, 16686 ori $15 $2, 41533 ori $16 $16, 59774 ori $17 $25, 45854 ori $18 $3, 64205 ori $19 $30, 56319 ori $20 $13, 26681 ori $21 $28, 32553 ori $22 $17, 3876 ori $23 $16, 54173 ori $24 $11, 45867 ori $25 $24, 43728 ori $26 $24, 33566 ori $27 $5, 43487 ori $28 $24, 31006 ori $29 $4, 8142 ori $30 $10, 38515 ori $31 $16, 40043 ori $t0, $zero, 0 ori $t1, $zero, 12288 ori $t2, $zero, 4 lui $at, 0xffff ori $at, $at, 0xdf92 label_2bc0125f7fa011ee863a00007f000001: beq $t0, $t1, label_2bc012607fa011ee8f8e00007f000001 nop sw $v0, 8302($at) add $v0, $v0, $v1 add $t0, $t0, $t2 add $at, $at, $t2 beq $0, $0, label_2bc0125f7fa011ee863a00007f000001 nop label_2bc012607fa011ee8f8e00007f000001: ori $s4, $v1, 34376 lui $a1, 32325 add $a1, $v0, $v0 add $t6, $s5, $a1 lui $s3, 54505 sub $v0, $t6, $t9 sub $s3, $t6, $a3 add $s7, $s1, $t9 lui $t8, 35300 ori $t1, $s7, 45350 sub $a0, $s0, $s0 sub $t1, $s6, $s1 ori $t6, $t8, 412 sub $a2, $t0, $t2 lui $s4, 32853 add $s5, $s0, $a0 ori $t9, $s2, 11912 ori $t5, $t6, 11999 lui $t5, 56242 sub $t9, $a2, $a2 sub $t0, $t4, $a2 sub $t3, $t9, $s1 ori $s5, $s6, 58937 sub $t5, $a2, $s3 ori $t7, $a1, 18664 sub $s3, $t8, $t0 lui $a0, 12092 lui $t3, 64848 lui $a0, 9488 sub $t9, $s1, $t8 lui $s7, 16221 add $v1, $t4, $t7 ori $a0, $t7, 60726 lui $s2, 10927 ori $v0, $a3, 13512 ori $a1, $s0, 15142 sub $t5, $t3, $t1 lui $s5, 2741 sub $s4, $t8, $t3 add $v0, $t3, $a0 add $s5, $s7, $a0 ori $t5, $a1, 24324 ori $t3, $s4, 35988 sub $t8, $s4, $s1 sub $s6, $s7, $t5 add $s7, $t3, $t2 add $s3, $v0, $t9 sub $t1, $s3, $a3 sub $t8, $t4, $s6 ori $s5, $t2, 23014 ori $s6, $s3, 63729 ori $t9, $s2, 121 ori $s4, $v1, 34411 lui $t1, 37485 sub $s3, $a2, $a0 sub $t6, $t0, $s1 add $s2, $s2, $s1 add $s5, $s3, $a1 sub $s3, $s3, $s1 sub $t3, $t7, $t4 ori $t6, $s6, 24400 ori $s5, $a1, 52111 add $t5, $t9, $s5 lui $s1, 64114 add $s6, $t5, $v1 lui $s2, 50457 lui $v0, 16829 sub $s2, $t3, $t7 ori $a3, $t9, 49220 sub $a3, $t0, $s4 sub $a3, $s7, $s4 add $s5, $s4, $a2 lui $s0, 55025 add $s1, $s1, $t0 add $a0, $t4, $t9 add $t0, $s4, $v0 ori $a3, $t3, 28342 add $v1, $a1, $a0 sub $t0, $t2, $s7 lui $v1, 40464 lui $a2, 50250 lui $t1, 57460 add $v1, $a2, $v0 sub $s5, $t8, $t1 add $s7, $v1, $s6 ori $t5, $t3, 32301 ori $s5, $t7, 40728 sub $s0, $a0, $t9 sub $t3, $t2, $t9 lui $s7, 6500 add $a2, $t7, $t2 add $s3, $s0, $s4 sub $v0, $t8, $a3 lui $t2, 33066 add $s7, $v1, $a0 ori $s0, $t2, 62213 sub $s7, $s4, $v0 lui $s1, 65402 lui $a2, 47639 lui $s5, 26593 ori $t0, $zero, 0 ori $t1, $zero, 12288 ori $t2, $zero, 4 lui $at, 0xffff ori $at, $at, 0xd918 label_2bc0628f7fa011ee9e7700007f000001: beq $t0, $t1, label_2bc094567fa011ee879600007f000001 nop lw $v0, 9960($at) add $v0, $v0, $v1 add $t0, $t0, $t2 add $at, $at, $t2 beq $0, $0, label_2bc0628f7fa011ee9e7700007f000001 nop label_2bc094567fa011ee879600007f000001: 三.思考题 1.addr信号从哪里来？addr位数为什么是[13:2]? ​\taddr信号来自ALU的计算结果，DM中RAM是按照字寻址，而传入的地址为字节，故左移两位，按字取地址\n2.比较两种控制器示例 ​\t第二种依靠信号进行输出更好，符合电路的或逻辑，便于进行后续开发，只需要在后边补充或运算元素，举例如下\n1 assign RegWrite = op_add | op_sbu | op_and ... 3.比较同步复位与异步复位中reset与clk信号优先级 异步复位：reset优先级高于clk，无论何时都会复位 同步复位：reset优先级低于clk，只有在时钟上升沿才会进行复位 4.请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的 ​\taddi相比addiu加入了溢出检测,add相比addu加入溢出检测\n​\t以add和addu为例，有符号运算中最高位为符号位，关于add指令的RTL语言描述如下:\n1 2 3 4 5 temp \u0026lt;- (GPR[rs]31 || GPR[rs]) + (GPR[rt]31 || GPR[rt]) if temp32 != temp31 (32位的temp != 31位的temp) SignalException(IntegerOverflow) else GPR[rd] \u0026lt;- temp ​\t当GPR[rs]和[rt]的第30位都为1且符号位相同时，就分别对应着正数和负数的溢出情况，则temp32 != temp31判断溢出，抛出异常，如不检测溢出，则不会抛出异常，正常计算，故是等价的。\n","permalink":"https://coder0xe.github.io/posts/p4-verilog-cpu/","summary":"\u003ch1 id=\"p4-verilog-cpu-design-document\"\u003e\u003ccenter\u003eP4-Verilog-CPU-Design-Document\u003c/center\u003e\u003c/h1\u003e\n\u003ch2 id=\"零数据通路描述p4设计文档中最好加上p3图\"\u003e零.数据通路描述(P4设计文档中最好加上P3图)\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231121015155892\" loading=\"lazy\" src=\"/img/image-20231121015155892.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t本次设计文档基于P3-logisim-CPU的设计文档完成，P4的主要任务即为将logisim电路映射到verilog代码(看图写话？)，对上次P3中实现的每个模块单独建立\u003ccode\u003emodule.v\u003c/code\u003e，利用verilog语言对其行为进行建模，注意本次CPU设计中，不同于P3的异步复位，P4在各模块中使用\u003ccode\u003e同步复位!!!\u003c/code\u003e，verilog语言表示同步复位与异步复位如下代码:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//同步复位表示方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk) \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(reset) \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        PC \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u0026#39;h0000\u003c/span\u003e_3000;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        PC \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e npc; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//异步复位表示方法   将复位信号加入敏感信号列表\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk \u003cspan style=\"color:#ff79c6\"\u003eor\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e reset) \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(reset) \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        PC \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u0026#39;h0000\u003c/span\u003e_3000;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        PC \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e npc;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"一模块设计\"\u003e一.模块设计\u003c/h2\u003e\n\u003ch3 id=\"1ifu取指令单元\"\u003e1.IFU取指令单元\u003c/h3\u003e\n\u003cp\u003e​\tIFU中存储单元有PC寄存器和存储指令的ROM。IFU中存储指令要求的ROM大小为16KiB，即4096*32bit。在verilog语言中使用寄存器数组实现对ROM的模拟，即4096个32位的寄存器。使用系统命令\u003ccode\u003e$readmemh(\u0026quot;code.txt,ROM\u0026quot;)\u003c/code\u003e将code.txt中的16进制代码读入名为ROM的数组中，由于PC同步复位到32\u0026rsquo;h0000_3000，而ROM中对应存储第一条指令的地址为0，即PC寄存器中存储的地址与真实ROM地址存在0x0000_3000差量，故设计\u003ccode\u003ereg [31:0] tmp\u003c/code\u003e存储实际的地址，即\u003ccode\u003epc-0x0000_3000\u003c/code\u003e，进而读出指令的地址为\u003ccode\u003etmp[13:2]\u003c/code\u003e。\u003c/p\u003e","title":"支持40条指令P4_Verilog_CPU"},{"content":"CPU Design Document 1. CPU Design 1.总体设计 ​\t通过对于《计算机组成与设计》一书的阅读，对于P3的CPU设计我有如下思考，设计MIPS架构的CPU的本质在于从指令存储器中读出32位MIPS指令，并对MIPS指令进行解析进而完成指令中要求的操作。在本次实验中，要求实现的指令有add,sub,ori,lw,sw,beq,lui,nop其中，R型指令有add,sub,I型指令有ori,lw,sw,beq,lui，特殊的有nop指令，32位全为0。\nRIJ类型指令图:\n此次实验中要求实现的基本指令：\nR型 Operation Op-Code rs rt rd shamt(移位) func add 000000 00000 100000 sub 000000 00000 100010 I型 Operation Op-Code rs rt 16-bit-immediate-value ori 001101 lw 100011 sw 101011 beq 000100 lui 001111 nop ​\t32\u0026rsquo;b0\n​\t将我们要实现的CPU分为几个模块：IFU（取指令单元），GRF（寄存器堆），ALU（算术逻辑单元），DM（数据存储器），EXT（扩展单元），Controller（控制器）。\n下面给出设计电路模块图：\n1. IFU取指令单元 ​\t由于题目中要求寄存器的0x00003000对应ROM的0地址，即第一条指令的地址，且寄存器异步复位到初值0x00003000，这里涉及到类似于为寄存器赋初值的操作，可以对寄存器进行地址映射，利用寄存器当前值完成“赋初值”，当寄存器值为0时加上0x00003000进行下一个地址NPC的计算，而在计算取ROM中指令地址时再减去0x00003000。注意寄存器中保存的为以字节为单位的偏移量，ROM中一条指令为4个字节，需要将pc寄存器中的值右移两位后才对应到ROM中对应的行地址。\n2.NPC计算下一条指令地址 ​\t利用PCSrc信号选择取出PC+4地址的指令还是进行beq跳转得到的地址，应当注意的是beq中跳转为以字为单位，要先对移位量shift左移两位得到对应的字节偏移量。\n3.ALU计算单元 ALUOp 运算 是否判断溢出 0000 and no 0001 or no 0010 addu no 0011 subu no 0010 add yes（结合控制信号judge-overflow选择是否进行判断溢出问题） 0011 sub yes 0100 lui no 0101 xor no 0110 nor no 0111 logical-left no 1000 logical-right no 1001 Arth-right no 1010 sign-compare no 1011 unsigned-compare no 注：由于教程中要求对于add sub不实现溢出判断 即把add sub当作addu subu用，而在指令中不具体实现addu subu\n4. GRF寄存器堆 ​\t寄存器中有32个通用寄存器，\n注意0号寄存器的值只能为0，故将使能端WE设置为常量0 在写入端的解复用器DMX需要设置为三态，否则在写入一个值的时候其他值会被清零 5.Controller总控制器 ​\tController的输入为读取出指令的Op-Code,即[31:26]位，输出为八个控制信号，其中输送给ALU Controller的控制信号ALUOp为2位，下面对不同指令需要哪些控制信号进行分析，对不同指令按照其Op-Code进行分类.\n1. R型指令 1. 数据通路 2.输出信号 Op-Code:000000，对R型指令对应的Controller输出情况列表\n信号名称 取值情况 RegDst 1 ALUSrc 0 MemtoReg 0 RegWrite 1 MemRead 0 MemWrite 0 Branch 0 EXTOp 0 2.lw指令 1.数据通路 2.输出信号 Op-Code:100011，对应的输出情况列表\n信号名称 取值情况 RegDst 0 ALUSrc 1 MemtoReg 1 RegWrite 1 MemRead 1 MemWrite 0 Branch 0 EXTOp 1 3.sw指令 1.数据通路 2.输出信号 Op-Code:101011\n信号名称 取值情况 RegDst x ALUSrc 1 MemtoReg x RegWrite 0 MemRead 0 MemWrite 1 Branch 0 EXTOp 1 4.beq指令 1.数据通路 2.输出信号 Op-Code: 000100\n信号名称 取值情况 RegDst x ALUSrc 0 MemtoReg x RegWrite 0 MemRead 0 MemWrite 0 Branch 1 EXTOp 1 注：由于sw与beq指令中都不需要向寄存器中存储数字，即RegWrite=0,此时RegDst与MemtoReg可以为不定值x因为无论为多少都不会写入\n5.lui指令 1.数据通路 ​\t将原16位imm后拼接16位0，存入目标寄存器，位拼接操作在ALU中实现，对应操作编码为1000。此处rs寄存器为$0。\n2.输出信号 Op-Code:001111，对应的输出情况列表\n信号名称 取值情况 RegDst 0 ALUSrc 1 MemtoReg 0 RegWrite 1 MemRead 0 MemWrite 0 Branch 0 EXTOp 0 6.ori指令 1.数据通路 2.输出信号 Op-Code:001101\n需要注意的是ori指令中16位立即数的范围是:0~65535,如果位数超出16位则会发生截断保留低位\n信号名称 取值情况 RegDst 0 ALUSrc 1 MemtoReg 0 RegWrite 1 MemRead 0 MemWrite 0 Branch 0 EXTOp 0 注：不需要向DM中进行读或写操作，MemRead=MemWrite=0\n指令操作码 操作 func ALU动作 ALU控制信号 lw 取字 xxxxxx 加 0010 sw 存字 xxxxxx 加 0010 beq 相等跳转 xxxxxx 减 0110 add 加 100000 加 0010 sub 减 100010 减 0110 and 与 100100 与 0000 or 或 100101 或 0001 ori 或立即数 xxxxxx 或 0001 lui 存半字 xxxxxx 低位拼接0 1000 7.利用与或门阵列实现对指令的识别和产生相应的控制信号 1.指令识别 ​\t对于指令的识别主要用到32位指令中的opcode字段([31-26]位)与funct字段([5:0]位)，只有R型指令会利用funct字段进行指令的识别，其他类型指令只需要opcode字段即可。思路是，先利用opcode进行识别，识别出除R型指令之外的其他类型具体指令后，再利用funct字段对R型指令进行识别。\n2.产生控制信号 ​\t我将理论课中介绍的Controller与ALU Controller合并为一个整体，Controller产生的控制信号直接控制ALU进行运算，运用或阵列进行操作，只将输出信号表中为1的接到对应的信号或门上，对于0或x值均无连接，连接时有一个小技巧为将opcode与funct点为该指令的码，之后只需要将亮色的线连接到与门上。\n8.对补充的指令的实现思路进行总结 1.补充的R型指令 运算指令\n通过在ALU中传递不同的ALUOp实现，如add,sub,and,or,nor,xor\n移位指令\n如sll,srl,sllv,srlv,sra,srav,在ALU中通过Shifter实现逻辑左移，逻辑右移，算术右移。其中sll,srl,sra是将rt中的数值移动s([4:0]位立即数)位存储到rd中，在ALU的传入移位量端口控制信号shiftvar=0，sllv,srlv,srav将rt中的值移动rs位后存储入rd，需要注意的是rs只取低五位，相当于s\u0026lt;——GPR[rs]4...0，控制信号shiftvar=1。\n置位指令\nslt,sltu(set if less than)，同样在在ALU中实现，slt对两个操作数进行符号比较，sltu对两个操作数进行无符号比较，比较结果进行0扩展至32位赋值到rd\n跳转指令\njr,jalr.跳转指令需要着重进行分析，\njr :跳转到寄存器rs中存储的地址，在电路中对应GRF中读取的数据RD1，在NPC模块中实现跳转。 jalr: PC跳转到GPR[rs]中保存的地址，并将当前PC+4保存在GPR[rd]中，相比jr多了将PC+4存入GPR[RD]的功能。在NPC模块中输出PC+4，在寄存器堆写入数据端口，控制信号PC+4=1，(控制信号PC+4只有jal和halr指令会涉及到将当前PC+4存入寄存器)选择写入寄存器信号RegDst=1，ralink=0（控制信号ralink=1时写入31号寄存器,jal指令专属） 2.补充的J型指令 ​\t跳转指令在NPC中实现。\nj ，j跳转指令默认的地址为26位，需要在NPC模块中进行补全，形式为(PC+4)31...28 | j-address |00 jal指令与j指令计算地址的方式相同，同时将PC+4存入31号寄存器即ra寄存器，给出重要的控制信号:ralink=1,pc+4=1,jump=1 3.补充的I型指令 运算指令\n凡是带立即数运算的如addi,subi,ori,andi等都需要在ALU控制信号ALUSrc=1，选择符号扩展后的32位立即数，运算控制信号ALUOp与R类运算相同\nB类跳转指令\n注意：B类跳转指令对16位地址偏移量都是进行符号扩展，Control Unit输出branch，branchOp,完成对具体指令的识别，对于是否满足条件进行跳转的判断则在sel-B模块中实现，尤其要注意在sel-B模块中由于是要进行大于0小于0的判断，比较器应该选择为有符号的。其中beq和bne指令由ALU中输出信号equal判定。\n置位指令\nslti,sltiu，比较时对第二个操作数ALUSrc=1\n访存指令\nsw,sh,sb,lw,lh,lb,lbu,lhu等指令的具体实现已经在HorB模块中有了比较详细的叙述，利用address[1:0]进行判断并进行\u0026quot;插入\u0026quot;操作\n6.DM数据存储 ​\t一定要注意DM需要时钟信号控制！DM在时钟上升沿写入数据，一开始没有给DM加时钟信号导致数据没有及时存入QAQ。\n​\t**补充指令sb,lb,sh,lh,lbu,lhu，在DM模块中增加新模块HorB，根据控制信号b or h选择按照byte进行操作还是按照half word进行操作。**首先分析传入地址，传入地址是以字节为单位的，我们可以在已知对字/半字/字节操作的的情况下，分析出具体的半字/字节。记传入地址最后两位address[1:0]\n操作单位 address[1:0] 操作对象 word 00 字 half word 00 第一个半字节 half word 10 第二个半字节 byte 00 第一个字节 byte 01 第二个字节 byte 10 第三个字节 byte 11 第四个字节 ​\t思路：当操作类型为load(读取)：先读取出来一个字，再从中选择部分进行load，当操作类型为save(存入)：先读取出来对应地址上的一个字，再在相应位置上插入想要存入的内容，这就要求sb,lb,sh,lh,lbu,lhu进行操作前需要先从对应地址上读取，即MemRead = 1.\n电路图如下：\n7.EXT位扩展 ​\t位扩展单元由EXTOp信号控制，选择进行符号扩展还是0扩展，其中sw,lw,beq均为符号扩展，ori为0扩展。\n8.sel-B具体判断B指令 ​\t实现的B类型跳转指令有,beq,bne,bgez,bgtz,blez,bltz。可以大致分为两类。第一类为beq,bne，这两个指令是对于两个操作数进行比较然后进行跳转（比较在ALU中完成），第二类中都是进行与0的比较（在sel-B中完成）。branchOp列表如下:\nbranchOp 指令 000 beq 001 bltz 001 bgez 010 bgtz 011 blez 100 bne ​\t其中beq指令与bne指令都由equal信号判断，故对于beq\\bne的选择通过最高位选择。在001编码中，对bltz和bgez进行了合并，因为这两种指令的opcode一致为000001，故在control unit中无法实现对这两种指令的识别，需要利用这两种指令的[20:16]进行分辨，即judge信号，bltz:00000,bgez:00001，这样实际上需要选择的只有四个信号，利用branchOp的低两位进行判断，电路图如下：\n尤其需要注意的是：在sel-B模块中比较器应当选择有符号的而不是unsigned，因为他们都是与0进行比较，而在ALU模块中slt指令需要进行符号比较，sltu指令需要进行无符号比较.\n2. test scheme ​\t课下测试利用课程组提供的jar包进行测试，从MARS中导出16进制文件load到我的单周期CPU中，运行CPU，将存储在寄存器中的数据与MARS运行结果进行比对。\n1.基本指令测试 1. ori-test ​\tori指令中的立即数为无符号扩展，不存在复数的情况，测试指令\nori $a0,$0,123 ori $a1,$a0,456 2. lui-test lui $a2,123 #符号位为0 lui $a3,0xffff #符号位为1 3. add-test lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 4.sw-test ori $a0,$0,1 ori $a1,$0,2 ori $a2,$0,3 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) 5.lw-test ori $a0,$0,1 ori $a1,$0,2 ori $a2,$0,3 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) 6.beq-test ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) 7.将以上指令综合测试 ori $a0, $0, 123 ori $a1, $a0, 456 lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) sw $a3, 12($t0) sw $s0, 16($t0) sw $s1, 20($t0) sw $s2, 24($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) ​\t需要注意的是MARS设置中不应当开启delayed branching，否则会运行跳转指令如beq的下一条指令，与本地CPU不符\n2.补充指令后计算指令综合测试 3.补充指令后访存指令综合测试 .text li\t$s0, 0xABCF1234 li\t$s1, 0x1234ABCD li\t$s2, 0xa1b2c3d4 li\t$s3, 0x7fff0000 sb\t$s1, 100($0) sb\t$s2, 103($0) sb\t$s3, 105($0) sb\t$s4, 107($0) sh\t$s4, 108($0) sh\t$s3, 110($0) sh\t$s2, 112($0) sh\t$s1, 114($0) sw\t$s0, 0($0) sw\t$s1, 4($0) sw\t$s2, 8($0) sw\t$s3, 12($0) lw\t$t0, 0($0) lw\t$t1, 4($0) lw\t$t2, 8($0) lw\t$t3, 12($0) sw\t$t0, 16($0) sw\t$t1, 20($0) sw\t$t2, 24($0) sw\t$t3, 28($0) lb\t$t0, 3($0) lb\t$t1, 7($0) lb\t$t2, 11($0) lb\t$t3, 13($0) sw\t$t0, 32($0) sw\t$t1, 36($0) sw\t$t2, 40($0) sw\t$t3, 44($0) lbu\t$t0, 3($0) lbu\t$t1, 7($0) lbu\t$t2, 11($0) lbu\t$t3, 13($0) sw\t$t0, 48($0) sw\t$t1, 52($0) sw\t$t2, 56($0) sw\t$t3, 60($0) lh\t$t0, 2($0) lh\t$t0, 4($0) lh\t$t0, 8($0) lh\t$t0, 12($0) sw\t$t0, 64($0) sw\t$t1, 68($0) sw\t$t2, 72($0) sw\t$t3, 76($0) lhu\t$t0, 2($0) lhu\t$t0, 6($0) lhu\t$t0, 8($0) lhu\t$t0, 12($0) sw\t$t0, 80($0) sw\t$t1, 84($0) sw\t$t2, 88($0) sw\t$t3, 92($0) li\t$v0, 10 syscall 4.补充指令后跳转指令综合测试 .text main:\tli\t$s0, 0 li\t$s1, -1000 li\t$s2, 1000 lui\t$s3, 0x8000\t#s3 is -2147483648 lui\t$s4, 0x8000 ori\t$s4, 0x0001\t#s4 is -2147483647 lui\t$s5, 0x7fff ori\t$s5, 0xffff\t#s5 is 2147483647 lui\t$s6, 0x7fff ori\t$s6, 0xfffe\t#s6 is 2147483646 beq_1:\tbeq\t$s0, $s0, beq_1_test beq_10: beq\t$s5, $s6, beq_10_test beq_end: bne_1:\tbne\t$s0, $s1, bne_1_test bne_10:\tbne\t$s3, $s3, bne_10_test bne_end: blez_1: blez\t$s0, blez_1_test blez_10: blez\t$s6, blez_10_test blez_end: bgtz_1:\tbgtz\t$s2,bgtz_1_test bgtz_10: bgtz\t$s1,bgtz_10_test bgtz_end: jal_1:\tjal\tjal_1_test jal_5:\tjal\tjal_5_test jal_end: jalr_1:\tor\t$v0, $0, 12916 jalr\t$v1, $v0 jalr_5:\tor\t$v0, $0, 12948 jalr\t$v1, $v0 sw\t$t0, 0($s0) sw\t$t1, 0($s0) sw\t$t2, 0($s0) sw\t$t3, 0($s0) sw\t$t4, 0($s0) sw\t$t5, 0($s0) li\t$v0, 10 syscall beq_1_test: addi\t$t0,$t0, 1 j\tbeq_10 beq_10_test: addi\t$t0,$t0, 1 j\tbeq_end bne_1_test: addi\t$t1,$t1, 1 j\tbne_10 bne_10_test:addi\t$t1,$t1, 1 j\tbne_end blez_1_test:\taddi\t$t2,$t2, 1 j\tblez_10 blez_10_test:\taddi\t$t2,$t2, 1 j\tblez_end bgtz_1_test:\taddi\t$t3,$t3 1 j\tbgtz_10 bgtz_10_test:\taddi\t$t3,$t3 1 j\tbgtz_end jal_1_test:\taddi\t$t4, $4, 1 jr\t$ra jal_5_test:\taddi\t$t4, $4, 1 jr\t$ra jalr_1_test:\taddi\t$t5, $t5, 1 jr\t$v1 jalr_5_test:\taddi\t$t5, $t5, 1 jr\t$v1 2.编写python脚本完成自动化测试 ​\t利用正则表达式替换，对ROM中内容进行改写，并生成新的电路。\n1 2 3 4 5 6 7 8 9 10 11 12 import os import re #generate ROM-File command=\u0026#34;java -jar MARS_mod.jar CPUtest.asm nc mc CompactTextAtZero a dump .text HexText rom.txt\u0026#34; os.system(command) content = open(\u0026#34;rom.txt\u0026#34;).read() #write ROM-File to Circle—File cur = open(\u0026#34;CPU.circ\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;).read() cur = re.sub(r\u0026#39;addr/data: 12 32([\\s\\S]*)\u0026lt;/a\u0026gt;\u0026#39;,\u0026#34;addr/data: 12 32\\n\u0026#34; + content + \u0026#34;\u0026lt;/a\u0026gt;\u0026#34;, cur) with open(\u0026#34;cpu_remake.circ\u0026#34;,\u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as file: file.write(cur) ​\t注意：cpu_remake是根据原CPU新生成的文件，若有改动应该在原CPU中完成，若在cpu_remake中进行改动，改动会发生“丢失”，因为cpu_remake的每一次生成都是根据CPU生成\n3.思考题 1.单周期CPU的模块中哪些发挥状态存储功能，哪些发挥状态转移功能？ ​\t答：在单周期CPU中，我们以splitter为界可以将CPU分为一个Moore机与一个Mealy机，两个状态机各有一个状态存储模块与一个状态转移模块。状态存储：IM,GRF,DM，状态转移：NPC,ALU\n2.IM使用ROM，DM使用RAM，GRF使用Register合理吗 ​\t合理，Information Memory用来存储运行的程序指令，要保证程序不会被更改，使用ROM（Read Only Memory）， Data Memory是数据存储区，需要进行写入和读取，使用RAM。\n3.额外实现的单元 ​\t我将IFU中的取指令功能与计算下一指令地址的逻辑分开，计算下一指令地址的功能单独由NPC模块实现，包括对B型和J型指令的跳转。具体细分判断B类型跳转指令的sel-B模块，HorB，存储或读取时对字节和半字进行操作的模块。\n4.nop空指令不需要加入信号真值表 ​\t实际上nop指令会被识别为sll指令，具体形式为sll $0,$0,0，即将0号寄存器左移0位，确实不会发生影响。\n5.评价MIPS指令及汇编语言一节中测试样例的强度 ​\t测试样例的覆盖是不全面的，有些寄存器没有用到，有些负数的特殊情况没有涉及，跳转的指令没有涉及等。\n","permalink":"https://coder0xe.github.io/posts/p3-logisim-cpu-design/","summary":"\u003ch2 id=\"cpu-design-document\"\u003e\u003ccenter\u003eCPU Design Document\u003c/center\u003e\u003c/h2\u003e\n\u003ch3 id=\"1-cpu-design\"\u003e1. CPU Design\u003c/h3\u003e\n\u003ch4 id=\"1总体设计\"\u003e1.总体设计\u003c/h4\u003e\n\u003cp\u003e​\t通过对于《计算机组成与设计》一书的阅读，对于\u003ccode\u003eP3\u003c/code\u003e的CPU设计我有如下思考，设计MIPS架构的CPU的本质在于从指令存储器中读出32位MIPS指令，并对MIPS指令进行解析进而完成指令中要求的操作。在本次实验中，要求实现的指令有\u003ccode\u003eadd\u003c/code\u003e,\u003ccode\u003esub\u003c/code\u003e,\u003ccode\u003eori\u003c/code\u003e,\u003ccode\u003elw\u003c/code\u003e,\u003ccode\u003esw\u003c/code\u003e,\u003ccode\u003ebeq\u003c/code\u003e,\u003ccode\u003elui\u003c/code\u003e,\u003ccode\u003enop\u003c/code\u003e其中，R型指令有\u003ccode\u003eadd,sub\u003c/code\u003e,I型指令有\u003ccode\u003eori,lw,sw,beq,lui\u003c/code\u003e，特殊的有\u003ccode\u003enop\u003c/code\u003e指令，32位全为0。\u003c/p\u003e\n\u003cp\u003eRIJ类型指令图:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231029210509165\" loading=\"lazy\" src=\"/img/image-20231029210509165.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此次实验中要求实现的基本指令：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eR型\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003eOperation\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003eOp-Code\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003ers\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003ert\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003erd\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003eshamt(移位)\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003efunc\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eadd\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e000000\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e00000\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e100000\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003esub\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e000000\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e00000\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e100010\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eI型\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003eOperation\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003eOp-Code\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003ers\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003ert\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e16-bit-immediate-value\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eori\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e001101\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003elw\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e100011\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003esw\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e101011\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003ebeq\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e000100\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003elui\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e001111\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003enop\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\t32\u0026rsquo;b0\u003c/p\u003e\n\u003cp\u003e​\t将我们要实现的CPU分为几个模块：IFU（取指令单元），GRF（寄存器堆），ALU（算术逻辑单元），DM（数据存储器），EXT（扩展单元），Controller（控制器）。\u003c/p\u003e","title":"支持40条指令P3_logisim_CPU"},{"content":"OOpre课程结课总结 ——22373362杜启嵘 ​\t经历九周的OOpre课程的学习，我对面向对象编程有了基本的认识。从类、对象、方法等的基本概念，到最后一次迭代作业涉及到的设计模式，我循序渐进地学习到基本的面向对象编程思想(虽然我的代码仍然不够面向对象QAQ)。\n一.代码的最终架构和过程中的重构 ​\t在五次作业的迭代中，我进行了多次代码的重构，前几次作业中的重构我认为是合理的，最后一次作业中的重构是把超过500行的类中的部分方法强行抽离出来放进静态方法类，并把参数分成几行避免行字数超过100字(面向OO-checkstyle的重构)。\n1.第一次重构 ​\t在第三次作业中进行了实际上是两次重构，第一次在面临主类中的主方法行数超过60行，对方法中分指令执行的代码抽离出来声明为单独的方法，在编写JUnit时进行了第二次重构，由于第一版代码中解析输入逻辑与代码执行逻辑杂糅，而在编写JUnit时无法对输入进行操作，改为使用课程组提供的利用“二维数组”在统一存储输入内容，在inputhandler类中读取二维数组进行指令解析，这样的架构就能编写满足覆盖率的JUnit，下图为简单的架构图。\n二.第二次重构 ​\t第四次作业中新增了战斗日志的概念，我一开始的处理中并没有对fightlog建类，只是在Adventure中建立容器来存储代表战斗日志的字符串，导致处理逻辑比较复杂，结果因为一个方法中的错误逻辑挂了强测，在修改强测的过程中完成了对代码的重构，新增fightlog类，架构图如下\n三.第三次重构 ​\t在最后一次迭代开发中，由于类的行数限制，我不得不将一个类拆成两个类，在静态方法类中进行传参，属于是一次很丑陋的重构。\n2.使用JUnit的心得体会 ​\t使用JUnit可以在提交测评机之前进行本地测试，可以通过构造数据计算预期结果比对程序输出结果判断程序的正确性，在第六次作业完成过程中涉及到很多计算还有精度的问题，使用JUnit在本地进行测试可以找出一些问题。编写JUnit过程中达到分支覆盖对于验证正确性也有很大帮助，第六次作业中继承关系中覆盖不同子类进行测试帮助我找到了一些bug。在当下阶段使用JUnit的不足在于构造数据过于简单，没有对边界条件进行测试(毕竟手搓复杂数据真的很难绷QWQ)，总体来说在几次作业的迭代中，我通过使用JUnit实现了对于程序的本地测试，并且能够发现一些bug，使第一次提交至少通过数据点多了一些。\n3.学习OOpre的心得体会 ​\t从面向过程到面向对象的编程思维的转变对于我来说还是有一些难度，我的代码中的很多编写也不够面向对象，导致方法行数爆炸，类行数爆炸，处理逻辑复杂。但是在几次迭代中，我也对面向对象有了基本的认识\n理解面向对象的核心概念：面向对象编程是一种基于对象的思维方式。它的核心概念包括类、对象、封装、继承和多态。要想掌握面向对象编程，首先要理解这些概念的含义和关系 不断练习和总结经验：面向对象编程是一种需要不断实践和经验积累的编程方式。通过不断地练习和实践，才能更好地理解和应用面向对象编程的技巧。同时，还要及时总结经验教训，找到自己的不足之处并加以改进 阅读和理解优秀的面向对象代码：课程结束后学习优秀代码 4.对OOpre课程的简单建议 提高中测强度，尽量中测程度的数据过了就不要挂强测(强测挂了真的好压力) 指导书中部分内容可以进行细化，尤其是第七次作业的指导书，对于不同设计模式的解释可以再细致一点(?) ","permalink":"https://coder0xe.github.io/posts/oopre%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"oopre课程结课总结\"\u003e\u003ccenter\u003e\u003ccode\u003eOOpre\u003c/code\u003e课程结课总结\u003c/center\u003e\u003c/h2\u003e\n\u003cdiv style = \"text-align:right\"\u003e——22373362杜启嵘\u003c/div\u003e\n\u003cp\u003e​\t经历九周的\u003ccode\u003eOOpre\u003c/code\u003e课程的学习，我对面向对象编程有了基本的认识。从类、对象、方法等的基本概念，到最后一次迭代作业涉及到的设计模式，我循序渐进地学习到基本的面向对象编程思想(虽然我的代码仍然不够面向对象\u003ccode\u003eQAQ\u003c/code\u003e)。\u003c/p\u003e\n\u003ch3 id=\"一代码的最终架构和过程中的重构\"\u003e一.代码的最终架构和过程中的重构\u003c/h3\u003e\n\u003cp\u003e​\t在五次作业的迭代中，我进行了多次代码的重构，前几次作业中的重构我认为是合理的，最后一次作业中的重构是把超过500行的类中的部分方法强行抽离出来放进静态方法类，并把参数分成几行避免行字数超过100字(面向\u003ccode\u003eOO-checkstyle\u003c/code\u003e的重构)。\u003c/p\u003e\n\u003ch4 id=\"1第一次重构\"\u003e1.第一次重构\u003c/h4\u003e\n\u003cp\u003e​\t在第三次作业中进行了实际上是两次重构，第一次在面临主类中的主方法行数超过60行，对方法中分指令执行的代码抽离出来声明为单独的方法，在编写JUnit时进行了第二次重构，由于第一版代码中解析输入逻辑与代码执行逻辑杂糅，而在编写JUnit时无法对输入进行操作，改为使用课程组提供的利用“二维数组”在统一存储输入内容，在\u003ccode\u003einputhandler\u003c/code\u003e类中读取二维数组进行指令解析，这样的架构就能编写满足覆盖率的JUnit，下图为简单的架构图。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231104151340439\" loading=\"lazy\" src=\"/img/image-20231104151340439.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"二第二次重构\"\u003e二.第二次重构\u003c/h4\u003e\n\u003cp\u003e​\t第四次作业中新增了战斗日志的概念，我一开始的处理中并没有对fightlog建类，只是在Adventure中建立容器来存储代表战斗日志的字符串，导致处理逻辑比较复杂，结果因为一个方法中的错误逻辑挂了强测，在修改强测的过程中完成了对代码的重构，新增fightlog类，架构图如下\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231018143221078\" loading=\"lazy\" src=\"/img/image-20231018143221078.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"三第三次重构\"\u003e三.第三次重构\u003c/h4\u003e\n\u003cp\u003e​\t在最后一次迭代开发中，由于类的行数限制，我不得不将一个类拆成两个类，在静态方法类中进行传参，属于是一次很丑陋的重构。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"259e9015bf179c9426e9149f5f2b4be\" loading=\"lazy\" src=\"/img/image-20231018143221078.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"2使用junit的心得体会\"\u003e2.使用JUnit的心得体会\u003c/h3\u003e\n\u003cp\u003e​\t使用JUnit可以在提交测评机之前进行本地测试，可以通过构造数据计算预期结果比对程序输出结果判断程序的正确性，在第六次作业完成过程中涉及到很多计算还有精度的问题，使用JUnit在本地进行测试可以找出一些问题。编写JUnit过程中达到分支覆盖对于验证正确性也有很大帮助，第六次作业中继承关系中覆盖不同子类进行测试帮助我找到了一些bug。在当下阶段使用JUnit的不足在于构造数据过于简单，没有对边界条件进行测试(毕竟手搓复杂数据真的很难绷\u003ccode\u003eQWQ\u003c/code\u003e)，总体来说在几次作业的迭代中，我通过使用JUnit实现了对于程序的本地测试，并且能够发现一些bug，使第一次提交至少通过数据点多了一些。\u003c/p\u003e\n\u003ch3 id=\"3学习oopre的心得体会\"\u003e3.学习OOpre的心得体会\u003c/h3\u003e\n\u003cp\u003e​\t从面向过程到面向对象的编程思维的转变对于我来说还是有一些难度，我的代码中的很多编写也不够面向对象，导致方法行数爆炸，类行数爆炸，处理逻辑复杂。但是在几次迭代中，我也对面向对象有了基本的认识\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e理解面向对象的核心概念：面向对象编程是一种基于对象的思维方式。它的核心概念包括类、对象、封装、继承和多态。要想掌握面向对象编程，首先要理解这些概念的含义和关系\u003c/li\u003e\n\u003cli\u003e不断练习和总结经验：面向对象编程是一种需要不断实践和经验积累的编程方式。通过不断地练习和实践，才能更好地理解和应用面向对象编程的技巧。同时，还要及时总结经验教训，找到自己的不足之处并加以改进\u003c/li\u003e\n\u003cli\u003e阅读和理解优秀的面向对象代码：课程结束后学习优秀代码\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"4对oopre课程的简单建议\"\u003e4.对OOpre课程的简单建议\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e提高中测强度，尽量中测程度的数据过了就不要挂强测(强测挂了真的好压力)\u003c/li\u003e\n\u003cli\u003e指导书中部分内容可以进行细化，尤其是第七次作业的指导书，对于不同设计模式的解释可以再细致一点(?)\u003c/li\u003e\n\u003c/ol\u003e","title":"OOpre总结"},{"content":"Translate C recursive function into MIPS ​\t如何规范合理地把C语言中的递归函数翻译成MIPS assembly?这个问题令我头疼了一天，翻了网上很多教程总是感觉说的很浅，或者是重复着用MIPS编写计算阶乘的例子，找不到合适的教程对于一个迷茫的新手来说是一件非常绝望的事，经过我求助身边的大佬们，大佬们的一些分享，让我逐渐明白编写中的一些要点，并总结出一些编写规则。\n一.C中的递归函数 ​\t对于编写MIPS程序，我们一般是先写出对应的C代码，再一句句翻译成MIPS语言。递归函数也是函数，从函数类型上看，应该有无返回值和有返回值这两种粗浅的大类，其中无返回值是一种值得注意的类型。\n1.无返回值类型 ​\t在无返回值的递归函数中，我们往往只能看见递归层次中的return，但是实际上无返回值类型的返回语句可以省略，即程序运行结束时的return;可以省略，在翻译时，题目可能就会使用省略这一种写法，需要注意这个“隐藏”的return并在MIPS中自行编写。例如如i下C程序\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; void print() { printf(\u0026#34;hello world!\u0026#34;); (return;) } int main() { print(); } 2.有返回值类型 ​\t有返回值类型常见的为int等，有返回值类型的函数必须“显式“地说明出返回值，如果有分支，则在每个分支中都需要进行返回值的说明，这一类函数可以明显地看出哪里需要return对于编写比较友好，例如计算阶乘的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int calculate(int n) { if(n == 1) { return 1; } else { return n*calculate(n-1); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,calculate(n)); return 0; } 二.举例说明我的翻译规范 0.总体概括 ​\t无论是有无返回值的递归函数，在翻译时都需要遵循默认的守则，例如使用$a0~$a3进行函数参数的传递，如果是有返回值的类型则使用$v0~$v1传递返回值，调用者使用s(saved)寄存器,维护t(temporary)寄存器，被调用者随意使用t寄存器，维护s寄存器\u0026hellip;\u0026hellip;.\n1.无返回值类型 ​\t无返回值类型的函数在翻译时一定要注意补充可能不写出的”隐式“return!\n1.全排列数的生成 1. C code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int symbol[7],array[7]; int n; void FullArray(int index) { int i; if(index \u0026gt;= n){ for(i=0;i\u0026lt;n;i++){ printf(\u0026#34;%d\u0026#34;,array[i]); } printf(\u0026#34;\\n\u0026#34;); return; } for(i=0;i\u0026lt;n;i++){ if(symbol[i]==0){ array[index] = i+1; symbol[i] = 1; FullArray(index+1); symbol[i]=0; } } } int main(){ int i; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); FullArray(0); return 0; } 2. MIPS code .data array : .space 1024 symbol : .space 1024 space : .asciiz \u0026#34; \u0026#34; enter : .asciiz \u0026#34;\\n\u0026#34; .macro end li $v0,10 syscall .end_macro .macro readinteger(%ans) li $v0,5 syscall move %ans,$v0 .end_macro .macro printinteger(%ans) li $v0,1 move $a0,%ans syscall .end_macro .macro printspace li $v0,4 la $a0,space syscall .end_macro .macro printenter li $v0,4 la $a0,enter syscall .end_macro .macro push(%src) sw %src,0($sp) subi $sp,$sp,4 .end_macro .macro pop(%des) addi $sp,$sp,4 lw %des,0($sp) .end_macro .text readinteger($s0) # n move $a0,$zero jal FullArray end FullArray: bge\t$a0, $s0, print_init move $t0,$zero loop: beq $t0,$s0,end_loop sll $t1,$t0,2 lw $t2,symbol($t1) bne $t2,$zero,else addi $t3,$t0,1 sll $s2,$a0,2 sw $t3,array($s2) li $t4,1 sw $t4,symbol($t1) push($ra) push($t0) push($a0) addi $a0,$a0,1 jal FullArray pop($a0) pop($t0) pop($ra) sll $t1,$t0,2 sw $zero,symbol($t1) else: addi $t0,$t0,1 j loop end_loop: //这一段即对应函数末尾隐式的return;!!!!!!!!!!!!!!!! jr $ra print_init: move $t0,$zero print_loop: beq $t0,$s0,print_loop_end sll $t1,$t0,2 lw $t2,array($t1) printinteger($t2) printspace addi $t0,$t0,1 j print_loop print_loop_end: printenter jr $ra 3. analyse 补全return ​\t全排列数的生成是一个典型的无返回值递归函数，在课程组提供的C代码中并没有写”显式“的return，我们将其补全之后可以得到如下更为完整的C代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void FullArray(int index) { int i; if(index \u0026gt;= n){ for(i=0;i\u0026lt;n;i++){ printf(\u0026#34;%d\u0026#34;,array[i]); } printf(\u0026#34;\\n\u0026#34;); return; } for(i=0;i\u0026lt;n;i++){ if(symbol[i]==0){ array[index] = i+1; symbol[i] = 1; FullArray(index+1); symbol[i]=0; } } (return;) } ​\t这样我们就可以更加清楚的指导有两处需要进行jr $ra，一处为递归终止条件处向上递归，另一处为函数运行结束。\n对于寄存器的维护（push,pop） ​\t我们知道在递归函数中需要维护跳转地址寄存器$ra等，在此题目中，我们分析进入递归的部分\n1 2 3 4 5 6 7 8 for(i=0;i\u0026lt;n;i++){ if(symbol[i]==0){ array[index] = i+1; symbol[i] = 1; FullArray(index+1); symbol[i]=0; } } ​\t显然，传递给函数的参数，存储index的变量也应当被维护，比较不明显（第一次写没注意）的是对于循环变量i的维护，想想就很容易知道，i是需要进行维护的，在一次递归从下至顶结束之后，还要进行对symbol的赋值以及继续进行循环。\npush($ra) push($t0) push($a0) addi $a0,$a0,1 jal FullArray pop($a0) pop($t0) pop($ra) ​\t我的处理是只在进行递归调用的部分进行寄存器的push\u0026amp;\u0026amp;pop,这样相比于教程中的在函数开始时进行push,跳出时pop我认为有一定先进性：\n维护位置集中，如果需要维护循环变量，优势更加明显 跳转return时只需要一句话jr $ra，若采用在函数开始时push，则每一次跳转都需要pop，这种方式更加简洁 2.哈密顿回路 1. C code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; int G[8][8]; // 采用邻接矩阵存储图中的边 int book[8]; // 用于记录每个点是否已经走过 int m, n, ans; void dfs(int x) { book[x] = 1; int flag = 1, i; // 判断是否经过了所有的点 for (i = 0; i \u0026lt; n; i++) { flag \u0026amp;= book[i]; } // 判断是否形成一条哈密顿回路 if (flag \u0026amp;\u0026amp; G[x][0]) { ans = 1; return; } // 搜索与之相邻且未经过的边 for (i = 0; i \u0026lt; n; i++) { if (!book[i] \u0026amp;\u0026amp; G[x][i]) { dfs(i); } } book[x] = 0; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int i, x, y; for (i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); G[x - 1][y - 1] = 1; G[y - 1][x - 1] = 1; } // 从第0个点（编号为1）开始深搜 dfs(0); printf(\u0026#34;%d\u0026#34;, ans); return 0; } //输出0 代表不具有回路 输出1 代表具有回路 2. MIPS code .data G : .space 1024 book : .space 32 .macro readinteger(%des) li $v0,5 syscall move %des,$v0 .end_macro .macro matrixGetIndex(%des,%i,%j) multu %i,$s1 mflo %des add %des,%des,%j sll %des,%des,2 .end_macro .macro vectorGetIndex(%des,%i) sll %des,%i,2 .end_macro .macro printinteger(%src) li $v0,1 move $a0,%src syscall .end_macro .macro end li $v0,10 syscall .end_macro .macro push(%src) sw %src,0($sp) subi $sp,$sp,4 .end_macro .macro pop(%des) addi $sp,$sp,4 lw %des,0($sp) .end_macro .text main: readinteger($s0) # n readinteger($s1) # m move $t0,$zero loop: beq $t0,$s1,loop_end readinteger($t2) #x readinteger($t3) #y subi $t2,$t2,1 subi $t3,$t3,1 li $t4,1 matrixGetIndex($t5,$t2,$t3) sw $t4,G($t5) matrixGetIndex($t5,$t3,$t2) sw $t4,G($t5) addi $t0,$t0,1 j loop loop_end: move $a0,$zero jal dfs printinteger($v1) end # $a0 is x # $t1 is 1 dfs: vectorGetIndex($t0,$a0) li $t1,1 sw $t1,book($t0) move $t2,$t1 # $t2 is flag move $t0,$zero dfs_loop: beq $t0,$s0,end_dfs_loop vectorGetIndex($t3,$t0) lw $t4,book($t3) and $t2,$t2,$t4 addi $t0,$t0,1 j dfs_loop end_dfs_loop: matrixGetIndex($t3,$a0,$zero) lw $t4,G($t3) and $t5,$t2,$t4 beq $t5,$t1,exit move $t0,$zero dfs_loop_2: beq $t0,$s0,dfs_loop_2_end vectorGetIndex($t2,$t0) lw $t3,book($t2) matrixGetIndex($t2,$a0,$t0) lw $t4,G($t2) seq $t3,$t3,$zero and $t5,$t3,$t4 beq $t5,$t1,recursive addi $t0,$t0,1 j dfs_loop_2 dfs_loop_2_end: sll $t8,$a0,2 sw $zero,book($t8) jr $ra recursive: push($a0) push($ra) push($t0) move $a0,$t0 jal dfs pop($t0) pop($ra) pop($a0) addi $t0,$t0,1 j dfs_loop_2 exit: li $v1,1 jr $ra 3. analyse ​\t这个题目也是一个典型的void类型recursive function，我们需要将他隐式的return补全\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void dfs(int x) { book[x] = 1; int flag = 1, i; // 判断是否经过了所有的点 for (i = 0; i \u0026lt; n; i++) { flag \u0026amp;= book[i]; } // 判断是否形成一条哈密顿回路 if (flag \u0026amp;\u0026amp; G[x][0]) { ans = 1; return; } // 搜索与之相邻且未经过的边 for (i = 0; i \u0026lt; n; i++) { if (!book[i] \u0026amp;\u0026amp; G[x][i]) { dfs(i); } } book[x] = 0; (return;) } ​\t对于寄存器的push\u0026amp;\u0026amp;pop不再赘述\n2.有返回值类型 计算阶乘 1. C code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int calculate(int n) { if(n == 1) { return 1; } else { return n*calculate(n-1); } } int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,calculate(n)); return 0; } 2. MIPS code .macro end li $v0, 10 syscall .end_macro .macro getInt(%des) li $v0, 5 syscall move %des, $v0 .end_macro .macro printInt(%src) move $a0, %src li $v0, 1 syscall .end_macro .macro push(%src) sw %src, 0($sp) subi $sp, $sp, 4 .end_macro .macro pop(%des) addi $sp, $sp, 4 lw %des, 0($sp) .end_macro .text main: getInt($s0) move $a0, $s0 jal factorial move $s1, $v0 printInt($s1) end factorial: bne $a0, 1, else li $v0, 1 j exit else: push($ra) push($a0) subi $a0,$a0,1 jal factorial pop($a0) ###########先恢复原值n pop($ra) mul $v0,$a0,$v0 exit: jr $ra 3.analyse ​\t有返回值类型的一道典型题目，使用$v0接收返回值，需要注意的是计算n*f(n-1)时需要先将$a0恢复原值，即先pop后运算!!!\n三.概括总结 ​\t以上内容是我在P2课下总结的一些经验，还是那句老话：只有在机组上机之前学计组才效率最高！（虽然今天是周日）\n​\t概括地说为以下几点:\n常见的在递归中需要维护的寄存器有$ra，对函数的传参$a0，如果在循环中进行递归则还需要维护循环变量i 对于void型的递归函数要懂得把隐式表达的return翻译出来！ 在递归步骤集中进行push\u0026amp;\u0026amp;pop，这样在实现跳转时只需要jr $ra，对于要进行算术运算的，尤其要注意先pop后运算。 jal function ——\u0026gt; jr $ra ","permalink":"https://coder0xe.github.io/posts/function/","summary":"\u003ch2 id=\"translate--c-recursive-function-into-mips\"\u003eTranslate  C recursive function into MIPS\u003c/h2\u003e\n\u003cp\u003e​\t如何规范合理地把C语言中的递归函数翻译成\u003ccode\u003eMIPS assembly\u003c/code\u003e?这个问题令我头疼了一天，翻了网上很多教程总是感觉说的很浅，或者是重复着用MIPS编写计算阶乘的例子，找不到合适的教程对于一个迷茫的新手来说是一件非常绝望的事，经过我求助身边的大佬们，大佬们的一些分享，让我逐渐明白编写中的一些要点，并总结出一些编写规则。\u003c/p\u003e\n\u003ch3 id=\"一c中的递归函数\"\u003e一.C中的递归函数\u003c/h3\u003e\n\u003cp\u003e​\t对于编写MIPS程序，我们一般是先写出对应的C代码，再一句句翻译成MIPS语言。递归函数也是函数，从函数类型上看，应该有无返回值和有返回值这两种粗浅的大类，其中无返回值是一种值得注意的类型。\u003c/p\u003e\n\u003ch4 id=\"1无返回值类型\"\u003e1.无返回值类型\u003c/h4\u003e\n\u003cp\u003e​\t在无返回值的递归函数中，我们往往只能看见递归层次中的\u003ccode\u003ereturn\u003c/code\u003e，但是实际上无返回值类型的返回语句可以省略，即程序运行结束时的\u003ccode\u003ereturn;\u003c/code\u003e可以省略，在翻译时，题目可能就会使用省略这一种写法，需要注意这个“隐藏”的\u003ccode\u003ereturn\u003c/code\u003e并在MIPS中自行编写。例如如i下C程序\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-C\" data-lang=\"C\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eprint\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eprintf\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;hello world!\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    (\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e;)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003emain\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#50fa7b\"\u003eprint\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"2有返回值类型\"\u003e2.有返回值类型\u003c/h4\u003e\n\u003cp\u003e​\t有返回值类型常见的为int等，有返回值类型的函数必须“显式“地说明出返回值，如果有分支，则在每个分支中都需要进行返回值的说明，这一类函数可以明显地看出哪里需要\u003ccode\u003ereturn\u003c/code\u003e对于编写比较友好，例如计算阶乘的示例\u003c/p\u003e","title":"translate C recursive function into MIPS"},{"content":"P2课下\u0026amp;\u0026amp;常用MIPS宏定义 ​\tMIPS是一门非常灵活的语言，在编写过程中可以非常直观地感受到对内存的操作（虽然我编写MIPS都是照着C语言一句一句翻译），但也正因为是这样，使得MIPS编码看起来有一点繁琐，我们可以使用自己定义的宏macro进行代码风格的改善，将可以复用的代码抽离出来，类似于C语言中的函数。\n1. MIPS——macro ​\tMIPS中宏定义的方法是\n//无参数宏定义 .macro name //statement .end_macro //有参数宏定义 .macro name(%parameter1,%parameter2,...) //statement .end_macro 1. end .macro end li $v0,10 syscall .end_macro 2. readinteger .macro readinteger(%des) li $v0,5 syscall move %des,$v0 .end_macro 3. printinteger .macro printinterger(%src) li $v0,1 move $a0,%src syscall .end_macro 4. printstr .macro printstr(%src) li $v0,4 la $v0,%src syscall .end_macro 5. 函数调用push .macro push(%src) sw %src,0($sp) subi ge$sp,$sp,4 .end_macro 6. 函数调用pop .macro pop(%des) addi $sp,$sp,4 lw %des,0($sp) .end_macro 7.一维数组计算地址偏移量 .macro getVectorAddress(%des,%col) sll %des,%col,2 .end_macro 8.二维数组计算地址偏移量 .macro getMatrixAddress(%des,%i,%j) multu %i,col（矩阵的列数） mflo %des add %des,%des,%j sll %des,%des,2 .end_macro 注意：一定是乘上矩阵的列数！QAQ之前乘了矩阵的行数还是看内存发现的bug\n9.直接打印字符串 .macro printStr(%str) .data tmpLabel: .asciiz %str .text li $v0, 4 la $a0, tmpLabel syscall .end_macro 3.典型的易错点 1.调用子函数中的跳转应当用jal ​\tjal即jump and link在进行跳转的同时，将PC+4存入$ra寄存器，通过j $ra返回到跳转前的下一条语句。写递归的时候递归调用用了j function之后就寄了\u0026hellip;\u0026hellip;\n2.循环等普通标签跳转用j ​\tj即jump，跳到标签位置，在循环的编写中经常使用到，例如\n#一维情况 loop: beq $t0,$s0,loop_end //statement addi $t0,$t0,1 j loop loop_end: //statement #二维情况 loop_1: beq $t0,$s0,loop_1_end move $t1,$zero #第二层循环变量清0 loop_2: beq $t1,$s1,loop_2_end //statement loop_2_end: addi $t0,$t0,1 j loop_1 loop_1_end: //statement 3.对变量的初始化要写在循环外 ​\t我知道这个问题很弱智，可是弱智的我很爱出错；例如\nloop_1: beq $t0,$s0,loop_1_end loop_2: beq $t1,$s1,loop_2_end move $t1,$zero #error!!!!!!!!! //statement loop_2_end: addi $t0,$t0,1 j loop_1 loop_1_end: ​\t这样写这个循环就永远出不来力！！！！！\n​\t跳转到循环时，初始化步骤只有第一次跳转到才进行，应该在循环外进行变量初始化，代码结构类似于这样\ncalculate: move $t0,$zero loop_1: ... move $t1,$zero loop_2: ... 4.存储问题 ​\t为什么会经常弄混lw与sw啊！一定要注意了！另外一定要小心，有的时候想着存字符的话只需要一个字节，使用sb操作，但是地址偏移量用了四个字节\u0026hellip;\u0026hellip;需要格外细心！\n​\t另外，在申请数组空间上，切记要申请出4的倍数(1 word = 4 bytes)，否则在运行过程中可能会报出字没有对齐的错误，为字符串申请空间写在最后更好，也是为了防止没有字对齐！\n4.MIPS中运算 乘法 mult : hi寄存器中存储乘法结果的高32位，lo寄存器中存储乘法结果的低32位 除法 div : hi寄存器中保存除法结果的余数，lo寄存器保存除法结果的商 注意：MIPS中不提供求模运算，但是可以利用除法完成，即做除法之后取hi寄存器中的余数结果mfhi 加法 add addi 减法 sub subi 与 and 或 or 异或 xor ","permalink":"https://coder0xe.github.io/posts/p2%E8%AF%BE%E4%B8%8Bandmips%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/","summary":"\u003ch2 id=\"p2课下常用mips宏定义\"\u003eP2课下\u0026amp;\u0026amp;常用MIPS宏定义\u003c/h2\u003e\n\u003cp\u003e​\tMIPS是一门非常灵活的语言，在编写过程中可以非常直观地感受到对内存的操作（虽然我编写MIPS都是照着C语言一句一句翻译），但也正因为是这样，使得MIPS编码看起来\u003ccode\u003e有一点繁琐\u003c/code\u003e，我们可以使用自己定义的宏\u003ccode\u003emacro\u003c/code\u003e进行代码风格的改善，将可以复用的代码抽离出来，类似于C语言中的函数。\u003c/p\u003e\n\u003ch3 id=\"1-mipsmacro\"\u003e1. MIPS——macro\u003c/h3\u003e\n\u003cp\u003e​\tMIPS中宏定义的方法是\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e//无参数宏定义\n.macro  name\n\n//statement\n\n.end_macro\n\n//有参数宏定义\n.macro name(%parameter1,%parameter2,...)\n\n//statement\n\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"1-end\"\u003e1. end\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro end\nli $v0,10\nsyscall\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"2-readinteger\"\u003e2. readinteger\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro readinteger(%des)\nli $v0,5\nsyscall\nmove %des,$v0\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"3-printinteger\"\u003e3. printinteger\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro printinterger(%src)\nli $v0,1\nmove $a0,%src\nsyscall\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"4-printstr\"\u003e4. printstr\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro printstr(%src)\nli $v0,4\nla $v0,%src\nsyscall\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"5-函数调用push\"\u003e5. 函数调用push\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro push(%src)\nsw %src,0($sp)\nsubi ge$sp,$sp,4\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"6-函数调用pop\"\u003e6. 函数调用pop\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro pop(%des)\naddi $sp,$sp,4\nlw %des,0($sp)\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"7一维数组计算地址偏移量\"\u003e7.一维数组计算地址偏移量\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro getVectorAddress(%des,%col)\nsll %des,%col,2\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"8二维数组计算地址偏移量\"\u003e8.二维数组计算地址偏移量\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.macro getMatrixAddress(%des,%i,%j)\nmultu %i,col（矩阵的列数）\nmflo %des\nadd %des,%des,%j\nsll %des,%des,2\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e注意：一定是乘上矩阵的列数！\u003ccode\u003eQAQ\u003c/code\u003e之前乘了矩阵的行数还是看内存发现的bug\u003c/strong\u003e\u003c/p\u003e","title":"P2课下\u0026\u0026MIPS常用宏定义"},{"content":"OOpre_HW_5:常见bug分析 ​\t本次作业的任务比较简单，对课程组给出的代码进行debug,只有中测，让我这种挂了强测的鼠鼠好欣慰。\n一.输入解析类错误 ​\t常见的有scanner一类的函数，我们需要注意的无非以下几个函数的功能\n1 2 3 1. scanner.next(); //读取下一个字符串 2. scanner.nextint();//读取下一个数字 3. scanner.nextLine();//读取下一行字符串 ​\t作业中出现了几次使用scanner.nextLine()方法读取下一个字符串的错误，这种错误还是比较明显的。\n二.深克隆与浅克隆 ​\t在我的作业代码中，对于深克隆和浅克隆共出现了一个功能中的两次错误，即克隆小队的操作和克隆士兵的操作。\n1.浅克隆 ​\t浅克隆即只对对象的引用进行克隆，换句话说是创建出来新的一个指针，与原对象指向相同的一块内存空间。本质上两个引用指向的是同一个实例，一个指针对对象进行修改，另一个指针进行访问时就会体现出这种修改。例如:\n1 2 Team team1 = new Team(123456,\u0026#34;dqr\u0026#34;); Team team2 = team1; 2.深克隆 ​\t深克隆不仅要创建出新的引用，还要开辟出新的内存空间，本质上就是一个新的变量，只不过变量的构造方法中传入参数是需要被克隆的对象的参数。\n1 2 Team team1 = new Team(123456,\u0026#34;dqr\u0026#34;); Team team2 = new Team(team1.getID(),team1.getName()); 三.相等比较 ==/equals ? ==是比较两个引用是否是同一个对象 equals为内容比较，比如名字，咒语等等 四.遍历容器：迭代器删除 ​\t对于容器中的元素删除，我们可能经常会用到“边遍历边删除的操作”\n1 2 3 for (Dog dog:arrayList){ arrayList.remove(dog); } ​\t这种操作会报错如下:\n1 2 3 Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911) at java.util.ArrayList$Itr.next(ArrayList.java:861) ​\t正确的做法是删除的时候不应该使用for循环，而应该使用迭代器遍历删除\n1 2 3 4 5 6 Iterator\u0026lt;Dog\u0026gt;iterator= arrayList.iterator(); while (iterator.hasNext()){ Dog dog=iterator.next(); iterator.remove(); System.out.println(dog.name); } ","permalink":"https://coder0xe.github.io/posts/hw-5bug%E5%88%86%E6%9E%90/","summary":"\u003ch2 id=\"oopre_hw_5常见bug分析\"\u003eOOpre_HW_5:常见bug分析\u003c/h2\u003e\n\u003cp\u003e​\t本次作业的任务比较简单，对课程组给出的代码进行debug,只有中测，让我这种挂了强测的鼠鼠好欣慰。\u003c/p\u003e\n\u003ch4 id=\"一输入解析类错误\"\u003e一.输入解析类错误\u003c/h4\u003e\n\u003cp\u003e​\t常见的有\u003ccode\u003escanner\u003c/code\u003e一类的函数，我们需要注意的无非以下几个函数的功能\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e1. scanner.\u003cspan style=\"color:#50fa7b\"\u003enext\u003c/span\u003e(); \u003cspan style=\"color:#6272a4\"\u003e//读取下一个字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e2. scanner.\u003cspan style=\"color:#50fa7b\"\u003enextint\u003c/span\u003e();\u003cspan style=\"color:#6272a4\"\u003e//读取下一个数字\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e3. scanner.\u003cspan style=\"color:#50fa7b\"\u003enextLine\u003c/span\u003e();\u003cspan style=\"color:#6272a4\"\u003e//读取下一行字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t作业中出现了几次使用\u003ccode\u003escanner.nextLine()\u003c/code\u003e方法读取下一个字符串的错误，这种错误还是比较明显的。\u003c/p\u003e\n\u003ch4 id=\"二深克隆与浅克隆\"\u003e二.深克隆与浅克隆\u003c/h4\u003e\n\u003cp\u003e​\t在我的作业代码中，对于深克隆和浅克隆共出现了一个功能中的两次错误，即克隆小队的操作和克隆士兵的操作。\u003c/p\u003e\n\u003ch5 id=\"1浅克隆\"\u003e1.浅克隆\u003c/h5\u003e\n\u003cp\u003e​\t浅克隆即只对对象的引用进行克隆，换句话说是创建出来新的一个指针，与原对象指向相同的一块内存空间。本质上两个引用指向的是同一个实例，一个指针对对象进行修改，另一个指针进行访问时就会体现出这种修改。例如:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTeam team1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e Team(123456,\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;dqr\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTeam team2 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e team1;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"2深克隆\"\u003e2.深克隆\u003c/h5\u003e\n\u003cp\u003e​\t深克隆不仅要创建出新的引用，还要开辟出新的内存空间，本质上就是一个新的变量，只不过变量的构造方法中传入参数是需要被克隆的对象的参数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTeam team1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e Team(123456,\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;dqr\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTeam team2 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e Team(team1.\u003cspan style=\"color:#50fa7b\"\u003egetID\u003c/span\u003e(),team1.\u003cspan style=\"color:#50fa7b\"\u003egetName\u003c/span\u003e());\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"三相等比较-equals-\"\u003e三.相等比较 ==/equals ?\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e==是比较两个引用是否是同一个对象\u003c/li\u003e\n\u003cli\u003eequals为内容比较，比如名字，咒语等等\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"四遍历容器迭代器删除\"\u003e四.遍历容器：迭代器删除\u003c/h4\u003e\n\u003cp\u003e​\t对于容器中的元素删除，我们可能经常会用到“边遍历边删除的操作”\u003c/p\u003e","title":"OOpre_HW_5:常见bug分析"},{"content":"HW_4强测修复\u0026amp;\u0026amp;代码重构 ​\t**OOpre_HW_4是我打的最快的一次！**然而在代码风格上却不够面向对象，而且代码业务逻辑上有问题，没有成功通过强测(只得了33分)，在挂掉强测之后，我痛定思痛，决定先重构代码架构再进行逻辑修复。\n一.代码架构 ​\t上图是课程组推荐的代码架构，回顾我的第一版代码，主要有以下两个问题:\n输入解析逻辑放在main类中，导致main代码冗长 没有对fightlog进行建类，而是将fightlog作为附属于adventure的数据处理，导致代码结构耦合复杂 ​\t经过一晚上的代码构想和助教的交流，我将代码架构修改为下图：\n​\t在这次的代码逻辑中，我将fightlog视作一个个与adventure同级的个体建类（这个是最重要的思想，想了好久），fightlog中存储战斗日志的模式，攻击时间、攻击者的名字，被攻击者的名字ArrayList,这里需要注意，对于ArrayList\u0026lt;String\u0026gt; attackedname，应当分情况存储\nmode == 1,此时attackedname == null\nmode == 2,此时attackedname中只有一个元素\nmode == 3,此时attackedname中包含所有被攻击者的元素\n二.bug修复 1.正则表达式修复 ​\t正则表达式出错使得战斗日志输入解析错误，导致后续从二维数组中读取时出现NullPointerException，这就是强测第一次的报错,只能说第一篇博客发早了，传播了错误的正则表达式。下面附上通过强测的正则表达式\n1 2 3 Pattern p = Pattern.compile(\u0026#34;(\\\\d{4}/\\\\d{2})-([^@#-]+)-([^@#-]+)\u0026#34;); Pattern p1 = Pattern.compile(\u0026#34;(\\\\d{4}/\\\\d{2})-([^@#-]+)@([^@#-]+)-([^@#-]+)\u0026#34;); Pattern p2 = Pattern.compile(\u0026#34;(\\\\d{4}/\\\\d{2})-([^@#-]+)@#-([^@#-]+)\u0026#34;); 2.对于携带概念的再纠正 ​\t我们知道，在第三次作业中，我对于携带的处理是为每个物品设置一个becarreid属性，在后续的处理中，如“使用”等操作，都需要进行是否“携带”概念的判断，在这次作业中，我发现了上次强测没有测出来的bug，OP9（）中对于同名装备进行替换时，没有判断是否携带，下面附上改正后代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public void OP9(int i) { int advId = Integer.parseInt(inputInfo.get(i).get(1)); int equId = Integer.parseInt(inputInfo.get(i).get(2)); Adventure man = adventures.get(advId); Equipment equipment = null; ArrayList\u0026lt;Equipment\u0026gt; equipments = man.returnequ(man); for (Equipment item : equipments) { if (item.getID(item) == equId) { equipment = item; break; } } String name = equipment.getName(equipment); //检查当前想要携带的装备是否存在同名 如果有则进行替换 Equipment equipment1 = null; for (Equipment item : equipments) { if (item.getName(item).equals(name) \u0026amp;\u0026amp; item.getBecarried(item)) { //已经被携带的同名装备 equipment1 = item; break; } } if (equipment1 != null) { equipment1.reset(equipment1); } equipment.set(equipment); } ​\t需要注意的是\u0026amp;\u0026amp;item.getBecarried(item),这种错误我出现了两次了，下次一定要注意，名字符合的同时要判断是否携带。\n后记 ​\t这是第一次挂了强测进行bug修复，总的来说非常惊险刺激，但是同样收获很大。\n对于代码架构的改善，更加面向对象 学会了利用vscode进行文件比对，通过比对输出debug好方便 利用vscode进行文件比对 ​\t1.在文件内右键——\u0026gt;2.command palette——\u0026gt;2.compare active file with\u0026hellip;\n​\t就可以获得直观的文件比较体验，整个人都开朗了起来！\n","permalink":"https://coder0xe.github.io/posts/hw-4%E5%BC%BA%E6%B5%8B%E4%BF%AE%E5%A4%8D/","summary":"\u003ch2 id=\"hw_4强测修复代码重构\"\u003eHW_4强测修复\u0026amp;\u0026amp;代码重构\u003c/h2\u003e\n\u003cp\u003e​\t**OOpre_HW_4是我打的最快的一次！**然而在代码风格上却不够面向对象，而且代码业务逻辑上有问题，没有成功通过强测(只得了33分)，在挂掉强测之后，我痛定思痛，决定先重构代码架构再进行逻辑修复。\u003c/p\u003e\n\u003ch3 id=\"一代码架构\"\u003e一.代码架构\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231018141155681\" loading=\"lazy\" src=\"/img/image-20231018141155681.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t上图是课程组推荐的代码架构，回顾我的第一版代码，主要有以下两个问题:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e输入解析逻辑放在main类中，导致main代码冗长\u003c/li\u003e\n\u003cli\u003e没有对\u003ccode\u003efightlog\u003c/code\u003e进行建类，而是将\u003ccode\u003efightlog\u003c/code\u003e作为附属于adventure的数据处理，导致代码结构耦合复杂\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\t经过一晚上的代码构想和助教的交流，我将代码架构修改为下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231018141155681\" loading=\"lazy\" src=\"/img/image-20231018143221078.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t在这次的代码逻辑中，我将\u003ccode\u003efightlog\u003c/code\u003e视作一个个与\u003ccode\u003eadventure\u003c/code\u003e同级的个体建类（\u003cstrong\u003e这个是最重要的思想，想了好久\u003c/strong\u003e），\u003ccode\u003efightlog\u003c/code\u003e中存储战斗日志的模式，攻击时间、攻击者的名字，被攻击者的名字\u003ccode\u003eArrayList\u003c/code\u003e,这里需要注意，对于\u003ccode\u003eArrayList\u0026lt;String\u0026gt; attackedname\u003c/code\u003e，应当分情况存储\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003emode == 1,此时\u003ccode\u003eattackedname == null\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003emode == 2,此时\u003ccode\u003eattackedname\u003c/code\u003e中只有一个元素\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003emode == 3,此时\u003ccode\u003eattackedname\u003c/code\u003e中包含所有被攻击者的元素\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二bug修复\"\u003e二.bug修复\u003c/h3\u003e\n\u003ch4 id=\"1正则表达式修复\"\u003e1.正则表达式修复\u003c/h4\u003e\n\u003cp\u003e​\t\u003cstrong\u003e正则表达式出错使得战斗日志输入解析错误，导致后续从二维数组中读取时出现\u003ccode\u003eNullPointerException\u003c/code\u003e，这就是强测第一次的报错\u003c/strong\u003e,只能说第一篇博客发早了，传播了错误的正则表达式。下面附上通过强测的正则表达式\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-Java\" data-lang=\"Java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePattern p \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Pattern.\u003cspan style=\"color:#50fa7b\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;(\\\\d{4}/\\\\d{2})-([^@#-]+)-([^@#-]+)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePattern p1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Pattern.\u003cspan style=\"color:#50fa7b\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;(\\\\d{4}/\\\\d{2})-([^@#-]+)@([^@#-]+)-([^@#-]+)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePattern p2 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Pattern.\u003cspan style=\"color:#50fa7b\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;(\\\\d{4}/\\\\d{2})-([^@#-]+)@#-([^@#-]+)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"2对于携带概念的再纠正\"\u003e2.对于携带概念的再纠正\u003c/h4\u003e\n\u003cp\u003e​\t我们知道，在第三次作业中，我对于携带的处理是为每个物品设置一个\u003ccode\u003ebecarreid\u003c/code\u003e属性，在后续的处理中，如“使用”等操作，都需要进行是否“携带”概念的判断，在这次作业中，我发现了上次强测没有测出来的bug，OP9（）中对于同名装备进行替换时，没有判断是否携带，下面附上改正后代码:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eOP9\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e i)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e advId \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#50fa7b\"\u003eparseInt\u003c/span\u003e(inputInfo.\u003cspan style=\"color:#50fa7b\"\u003eget\u003c/span\u003e(i).\u003cspan style=\"color:#50fa7b\"\u003eget\u003c/span\u003e(1));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e equId \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#50fa7b\"\u003eparseInt\u003c/span\u003e(inputInfo.\u003cspan style=\"color:#50fa7b\"\u003eget\u003c/span\u003e(i).\u003cspan style=\"color:#50fa7b\"\u003eget\u003c/span\u003e(2));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Adventure man \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e adventures.\u003cspan style=\"color:#50fa7b\"\u003eget\u003c/span\u003e(advId);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Equipment equipment \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enull\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ArrayList\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eEquipment\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e equipments \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e man.\u003cspan style=\"color:#50fa7b\"\u003ereturnequ\u003c/span\u003e(man);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (Equipment item : equipments) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (item.\u003cspan style=\"color:#50fa7b\"\u003egetID\u003c/span\u003e(item) \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e equId) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                equipment \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e item;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        String name \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e equipment.\u003cspan style=\"color:#50fa7b\"\u003egetName\u003c/span\u003e(equipment);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#6272a4\"\u003e//检查当前想要携带的装备是否存在同名 如果有则进行替换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Equipment equipment1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enull\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (Equipment item : equipments) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (item.\u003cspan style=\"color:#50fa7b\"\u003egetName\u003c/span\u003e(item).\u003cspan style=\"color:#50fa7b\"\u003eequals\u003c/span\u003e(name) \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e item.\u003cspan style=\"color:#50fa7b\"\u003egetBecarried\u003c/span\u003e(item)) { \u003cspan style=\"color:#6272a4\"\u003e//已经被携带的同名装备\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                equipment1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e item;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (equipment1 \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enull\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            equipment1.\u003cspan style=\"color:#50fa7b\"\u003ereset\u003c/span\u003e(equipment1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        equipment.\u003cspan style=\"color:#50fa7b\"\u003eset\u003c/span\u003e(equipment);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t需要注意的是\u003ccode\u003e\u0026amp;\u0026amp;item.getBecarried(item)\u003c/code\u003e,这种错误我出现了两次了，下次一定要注意，名字符合的同时要判断是否携带。\u003c/p\u003e","title":"OOpre_HW_4强测修复\u0026\u0026代码架构重构"},{"content":"P1上机——verilog完成部件设计以及状态机 ​\t永远在周一晚上上机之前才是我学计组效率最高的时候\n​\t——地球人\n一.三段式状态机的设计 ​\t在上机之前我心血来潮想要把自己编写状态机的代码风格从一直以来的一段式更新为三段式，在看了网上好多有的没的真真假假对对错错的写法之后，我决定转头求助蒋老师和曾老师，果然得到了靠谱的答案，并成功应用到晚上的上机中QAQ。\n​\t分段思路：就如同状态机的设计图，有三个模块：状态转移逻辑(组合逻辑)，状态存储（时序逻辑），输出逻辑（组合逻辑），在verilog中分段实现即可，逻辑更加清晰。具体来说可以写成always-always-assign这种形式，当然最后一段也可以写成always.\n​\t下面给出示例代码:\n​\tMoore型 输出逻辑中对状态进行判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 module moore_example( input in; input clk; input rst_n; output check; ); localparam s0 = 4\u0026#39;b0001; localparam s1 = 4\u0026#39;b0010; localparam s2 = 4\u0026#39;b0100; localparam s3 = 4\u0026#39;b1000; reg [3:0] state; reg [3:0] n_state; //状态存储逻辑 always@(posedge clk or negedge rst_b)begin if(!rst_n)begin state \u0026lt;= s0; end else begin state \u0026lt;= n_state; end end //状态转移逻辑 一般来说两层case嵌套逻辑更加清楚 always@(*)begin case(state)begin s0: begin case(in)begin 1\u0026#39;b1:n_state = s1; 1\u0026#39;b0:n_state = s0; end end //省略其他部分 default: n_state = s0; end end //输出逻辑 assign check = (state == s3)?1\u0026#39;b1:1\u0026#39;b0; ​\tMealy型 输出逻辑中对当前状态和输入进行判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 module moore_example( input in; input clk; input rst_n; output check; ); localparam s0 = 4\u0026#39;b0001; localparam s1 = 4\u0026#39;b0010; localparam s2 = 4\u0026#39;b0100; localparam s3 = 4\u0026#39;b1000; reg [3:0] state; reg [3:0] n_state; //状态存储逻辑 always@(posedge clk or negedge rst_b)begin if(!rst_n)begin state \u0026lt;= s0; end else begin state \u0026lt;= n_state; end end //状态转移逻辑 一般来说两层case嵌套逻辑更加清楚 always@(*)begin case(state)begin s0: begin case(in)begin 1\u0026#39;b1:n_state = s1; 1\u0026#39;b0:n_state = s0; end end //省略其他部分 default: n_state = s0; end end //输出逻辑 assign check = (state == s2 \u0026amp;\u0026amp; in == 1\u0026#39;b0)?1\u0026#39;b1:1\u0026#39;b0; 三段式状态机的逻辑果然清晰好多！\n二.上机题目简记 1.32位向量乘法 1.题意复现 ​\t计算32位向量乘法\n2.我的解法 ​\t这个题目比较签到题，相当于推荐题目中的Voter_Plus的简化版，毕竟只用到了组合逻辑中的循环，速速AC！\n1 2 3 4 5 6 7 8 reg [31:0] cnt;//计数器 向量中每一位只会出现0/1 integer i;//计数变量 always@(*)begin for(i=0;i\u0026lt;32;i=i+1)begin cnt = cnt + vector_a[i]*vector_b[i]; end end assign out = cnt; 2.coloring涂色问题 1.题意复现 ​\t题意为：DQR闲着没事涂色玩，一共有红(2'b00)、绿(2'b01)、蓝(2'b10)三种颜色，涂色的规则如下:\n不允许有三个连续的颜色相同的色块 不允许红色与绿色相邻 ​\t如果出现非法的情况，将输出端口check置为1，并将最近涂的颜色擦除，进行下一次上色。\n2.我的解法 ​\t这个题目不知道有没有更好的解法，但是我是通过设计14状态的Moore状态机实现的，这里我对于红绿相邻的情况进行了比较细致的分类:\n红绿 红红绿 绿红 绿绿红 ​\t这样做的好处是便于进行“颜色的擦除“，即状态的回退，下面附上状态转移图\n​\t进行一下简单的解释：\n状态中表示连续颜色的检测，即遇到与上一次不同的颜色时直接跳转，如\n1 state == R ; in == B ; n_state = B; 在外侧的红绿相邻状态中，状态转移实际上是与他们的上一状态相同的，因为擦除颜色相当于回到上一状态\n3.数字匹配numberNest 1.题意复现 ​\t定义两个相同数字之间的部分为”数字匹配“，要求如下:\n一个数字的匹配中的数字必须比这个数大，如123321合理,12322321不合理 一个数字匹配的下一个数字只能比这个数字大1，如12344321合理，1331不合理 ​\t输入的序列合理时输出0，不合理输出1，题目保证输入的序列从1开始并且输入的数字在1-5之间。\n2.讨论区的解法（这题我当时挂了） 1.状态机 ​\t按照当前输入数字进行设计状态，6个就够了。\n2.两个if法(lrgg起的名字 我也不知道为什么QAQ) ​\t在任何状态下，合理的输入只有两种：\nin = state + 1;这代表进行下一个数字的匹配 state = state + 1; in = state;序列结束了当前匹配，state = state - 1; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 module numberNest( input [2:0] in; input rst_n; input clk; output check; ); reg [2:0] state;//表示当前状态，同时也是上一个输入的数字 always@(posedge clk or negedge rst_n)begin if(!rst_n)begin check \u0026lt;= 0; state \u0026lt;= 0; end else begin //开始下一数字匹配 if(in == state + 1)begin check \u0026lt;= 0; state \u0026lt;= state + 1; end else if(in == state) begin //结束当前数字匹配 check \u0026lt;= 0; state \u0026lt;= state - 1; end else begin //输入数字不合法 check \u0026lt;= 1; state \u0026lt;= 0; end end end 代码好短，lrgg好强！\n三.后记 1.检测特定序列的另一种解法:序列缓存法 ​\t在verilog状态机中，我们经常遇到设计状态机来匹配特定后缀的字符串的问题，以往我们会设计出一个状态机，但是事实上我们可以缓存一个需要匹配的字符串长度的数组来存下已经输入的字符，输入新字符时将最早进来的字符顶出，相当于移位寄存器或者说是一个队列。\n​\t下面以匹配字符串1101为例，代码分成两个部分，一部分更新缓存序列，一部分根据序列内容输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 module sequence_detect( input clk, input rst_n, input a, output reg match ); reg [3:0] str; always@(posedge clk or negedge rst_n) begin if(rst_n ==1\u0026#39;b0) begin str \u0026lt;=4\u0026#39;b0000; end else begin str \u0026lt;= {str[2:0],a}; //最左侧出队 end\tend always@(posedge clk or negedge rst_n) begin if(rst_n ==1\u0026#39;b0) match \u0026lt;=\u0026#39;d0; else if(a_reg == 4\u0026#39;b1101) match \u0026lt;=\u0026#39;d1; else match \u0026lt;=\u0026#39;d0; end endmodule 2.以饮料售货机为例说明Mealy状态机比Moore状态机少状态 ​\t假设我们有这样的一个饮料售货机，每次只能投入0.5元或1元，饮料的售价为两元，当购买成功时sell = 1,并输出找零change。\n我们知道对于一个相同的情景可以设计出两种状态机，这里我们先考虑Moore状态机。\n1.Moore状态机 ​\t对于Moore状态机我们应当列出全部的状态，即投入货币的金额，我们可以以一种售价附近最小粒度的思想来解决状态个数问题，\n0,0.5,1,1.5,2,2.5共6个状态，在2,2.5状态时输出1.\n2.Mealy状态机 ​\t对于Mealy状态机，当当前状态(已经投放金额)+当前投币大于两元时就应该输出sell==1并输出找零，无需2,2.5这两个状态。\n​\t这样我们就可以理解Moore型比Mealy型状态多，Mealy型比Moore型输出早\n","permalink":"https://coder0xe.github.io/posts/p1%E4%B8%8A%E6%9C%BA%E6%97%A5%E5%BF%97/","summary":"\u003ch2 id=\"p1上机verilog完成部件设计以及状态机\"\u003eP1上机——verilog完成部件设计以及状态机\u003c/h2\u003e\n\u003cp\u003e​\t\u003cstrong\u003e永远在周一晚上上机之前才是我学计组效率最高的时候\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e​\t\t\t\t\t\t\t\t\t\t\t\t\t——地球人\u003c/p\u003e\n\u003ch3 id=\"一三段式状态机的设计\"\u003e一.三段式状态机的设计\u003c/h3\u003e\n\u003cp\u003e​\t在上机之前我心血来潮想要把自己编写状态机的代码风格从一直以来的一段式更新为三段式，在看了网上好多有的没的真真假假对对错错的写法之后，我决定转头求助蒋老师和曾老师，果然得到了靠谱的答案，并成功应用到晚上的上机中\u003ccode\u003eQAQ\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e​\t\u003cstrong\u003e分段思路：就如同状态机的设计图，有三个模块：状态转移逻辑(组合逻辑)，状态存储（时序逻辑），输出逻辑（组合逻辑）\u003c/strong\u003e，在verilog中分段实现即可，逻辑更加清晰。具体来说可以写成\u003ccode\u003ealways-always-assign\u003c/code\u003e这种形式，当然最后一段也可以写成always.\u003c/p\u003e\n\u003cp\u003e​\t下面给出示例代码:\u003c/p\u003e\n\u003cp\u003e​\t\u003cstrong\u003eMoore型\u003c/strong\u003e  输出逻辑中对状态进行判断\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e41\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003emodule\u003c/span\u003e moore_example(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e in;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e clk;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e rst_n;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eoutput\u003c/span\u003e check;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003elocalparam\u003c/span\u003e s0 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0001\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003elocalparam\u003c/span\u003e s1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0010\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003elocalparam\u003c/span\u003e s2 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0100\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003elocalparam\u003c/span\u003e s3 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1000\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ereg\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] state;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ereg\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] n_state;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//状态存储逻辑\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk \u003cspan style=\"color:#ff79c6\"\u003eor\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enegedge\u003c/span\u003e rst_b)\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003e!\u003c/span\u003erst_n)\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            state \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e s0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \tstate \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e n_state; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//状态转移逻辑  一般来说两层case嵌套逻辑更加清楚\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e)\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003ecase\u003c/span\u003e(state)\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003es0:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ecase\u003c/span\u003e(in)\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003en_state \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e s1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003en_state \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e s0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#6272a4\"\u003e//省略其他部分\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             \u003cspan style=\"color:#ff79c6\"\u003edefault\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                n_state \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e s0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//输出逻辑\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e check  \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (state \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e s3)\u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t\u003cstrong\u003eMealy型\u003c/strong\u003e 输出逻辑中对当前状态和输入进行判断\u003c/p\u003e","title":"P1上机日志"},{"content":"P1_L1_voter_plus时序逻辑与组合逻辑的分模块编写\u0026amp;\u0026amp;阻塞赋值、非阻塞赋值 一.问题提出 ​\t在完成P1_L1_voter_plus一题时，由于需要对输入中1的位数进行统计，我第一次使用到for循环语句来统计输入中1的个数，原码类似于下例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module test_for ( input [7:0] in, input clk, input rst, output reg [7:0] out ); integer i; always @(posedge clk or posedge rst) begin : test if(rst) begin out \u0026lt;= 8\u0026#39;b0; end else begin for(i=0;i\u0026lt;8;i=i+1) begin if(in[i]) out \u0026lt;= out + 1\u0026#39;b1; end end end endmodule ​\t此段代码并不能成功实现在一个时钟周期内实现统计个数的功能。仿真如下:\n​\t我们发现事实上一个周期过后只是将out+1;并没有实现累加功能，这就涉及到阻塞赋值与非阻塞赋值的问题\n二.阻塞赋值与非阻塞赋值 ​\t在代码规范中，我们知道应该在时序逻辑中使用非阻塞赋值，在组合逻辑中使用阻塞赋值。我们知道阻塞赋值是实时更新的，即等号右边的操作数会立即赋值给等号左边，而非阻塞赋值是并行的，在代码块中会保存所有的“右值”，在语句块结束后进行统一赋值。非阻塞赋值的赋值形式类似于寄存器，在下一周期进行值的更新。我们知道for循环相当于一种简写，如果将上述的for循环展开:\n1 2 3 4 out \u0026lt;= out + (in[0]==1\u0026#39;b1)?1\u0026#39;b1:1\u0026#39;b0; out \u0026lt;= out + (in[1]==1\u0026#39;b1)?1\u0026#39;b1:1\u0026#39;b0; out \u0026lt;= out + (in[2]==1\u0026#39;b1)?1\u0026#39;b1:1\u0026#39;b0; ...... ​\t显然在时序逻辑中构成对同一寄存器的多次赋值行为，引起竞争，最终表现为只将out+1。\n​\t因此我们知道在一个时钟周期内实现累加行为是不能通过时序逻辑实现的，只能通过组合逻辑\n1 2 3 4 5 6 7 8 9 always@(*)begin cnt1 = 32\u0026#39;b0; for(i=0;i\u0026lt;32;i=i+1) begin if(voted_np[i])begin cnt1 = cnt1 + 1\u0026#39;b1; end end end 三.verilog描述电路的理解 ​\t我认为可以将非阻塞赋值认为是描述时序电路的方法，而将阻塞赋值理解为描述组合电路的方法。这样我们知道编写代码时如果混用阻塞赋值与非阻塞赋值可以理解为将时序电路与组合电路混用。如果我们能在编写verilog代码之前大致对电路的架构有一个构想，分清楚哪一些是组合逻辑，哪一些是时序逻辑，编写出的代码无疑是更加符合规范的。（从三段状态机中得到启发）\n​\t这是我根据voter_plus画出的logisim电路，通过电路图我们可以明确的知道涉及到投票状态存储的是时序电路，而对于result的计算则是实实在在的组合逻辑，这样我们就可以将时序逻辑与组合逻辑分开来编写，使得代码结构更加清晰。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 module VoterPlus ( input wire clk, input wire reset, input wire [31:0] np, input wire [7:0] vip, input wire vvip, output [7:0] result ); integer i; integer j; reg [31:0] cnt1; reg [31:0] cnt2; reg cnt3; reg [31:0] voted_np; reg [7:0] voted_vip; reg voted_vvip; always @(posedge clk or posedge reset) begin if (reset) begin cnt1 \u0026lt;= 32\u0026#39;b0; cnt2 \u0026lt;= 32\u0026#39;b0; cnt3 \u0026lt;= 1\u0026#39;b0; voted_np \u0026lt;= 32\u0026#39;b0; voted_vip \u0026lt;= 8\u0026#39;b0; voted_vvip \u0026lt;= 1\u0026#39;b0; end else begin voted_np\u0026lt;=voted_np|np; voted_vip\u0026lt;=voted_vip|vip; voted_vvip\u0026lt;=voted_vvip|vvip; end end always@(*)begin cnt1 = 32\u0026#39;b0; cnt2 = 8\u0026#39;b0; cnt3 = 1\u0026#39;b0; for(i=0;i\u0026lt;32;i=i+1) begin if(voted_np[i])begin cnt1 = cnt1 + 1\u0026#39;b1; end end for(j=0;j\u0026lt;8;j=j+1) begin if(voted_vip[j])begin cnt2 = cnt2 + 1\u0026#39;b1; end end if(voted_vvip) begin cnt3 = 1\u0026#39;b1; end end assign result = (reset)? 0 : cnt1 + cnt2*4 + cnt3*16; endmodule ​\t以上代码中，我们在时序逻辑中描述寄存器中状态的变化，计算过程则由组合逻辑完成，其中bit_adder的功能相当于由循环完成，由此我们对于verilog的理解更加加深，作为HDL:hardware describe language，编写verilog时心中有电路确实会使代码编写更加清晰。以后应当注意将组合逻辑和时序逻辑分开编写的写法！\n附录：lpf大佬 \u0026amp;\u0026amp; xmgg\u0026rsquo;s code 以下为lpf大佬代码,同样是将组合逻辑和时序逻辑分开描述，但是没有使用for循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 module VoterPlus( input clk, input reset, input [31:0] np, input [7:0] vip, input vvip, output [7:0] result ); reg [31:0] ii; reg [7:0] jj; reg kk; reg [7:0] s=0; assign result = (reset == 1) ? 0 : ((ii[0]+ii[1]+ii[2]+ii[3]+ii[4]+ii[5]+ii[6] +ii[7]+ii[8]+ii[9]+ii[10]+ii[11]+ii[12]+ii[13] +ii[14]+ii[15]+ii[16]+ii[17]+ii[18]+ii[19]+ii[20] +ii[21]+ii[22]+ii[23]+ii[24]+ii[25]+ii[26]+ii[27] +ii[28]+ii[29]+ii[30]+ii[31]) +(jj[0]+jj[1]+jj[2]+jj[3]+jj[4]+jj[5]+jj[6]+jj[7])*4 +kk*16); always@(posedge clk or posedge reset) begin if(reset == 0) begin ii \u0026lt;= ii | np; jj \u0026lt;= jj | vip; kk \u0026lt;= kk | vvip; end else begin ii \u0026lt;= 0; jj \u0026lt;= 0; kk \u0026lt;= 0; end end endmodule xmgg\u0026rsquo;s code：一段式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 module VoterPlus( input clk, input reset, input [31:0] np, input [7:0] vip, input vvip, output [7:0] result ); reg [7:0] sum; reg [31:0] r_np; reg [7:0] r_vip; reg r_vvip; always@(posedge clk or posedge reset) if(reset)begin sum \u0026lt;= 8\u0026#39;b0; r_np \u0026lt;= 32\u0026#39;b0; r_vip \u0026lt;= 8\u0026#39;b0; r_vvip \u0026lt;= 1\u0026#39;b0; end else begin for(n=0;n\u0026lt;32;i=i+1) begin if(np[n]\u0026amp;\u0026amp; !r_np[n]) begin sum = sum + 8\u0026#39;d1; r_np[n]=1\u0026#39;b1; end end for(n=0;n\u0026lt;8;n=n+1) begin if(vip[n]1\u0026amp;\u0026amp;!r_vip[n]) begin sum = sum + 8\u0026#39;d4; r_vip[n]=1\u0026#39;b1; end end if(vvip \u0026amp;\u0026amp; !r_vvip) begin sum = sum + 8\u0026#39;d16; r_vvip = 1\u0026#39;b1; end end assign result = sum; ","permalink":"https://coder0xe.github.io/posts/verilog%E7%BC%96%E5%86%99%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E4%B8%8E%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB/","summary":"\u003ch2 id=\"p1_l1_voter_plus时序逻辑与组合逻辑的分模块编写阻塞赋值非阻塞赋值\"\u003eP1_L1_voter_plus时序逻辑与组合逻辑的分模块编写\u0026amp;\u0026amp;阻塞赋值、非阻塞赋值\u003c/h2\u003e\n\u003ch3 id=\"一问题提出\"\u003e一.问题提出\u003c/h3\u003e\n\u003cp\u003e​\t在完成P1_L1_voter_plus一题时，由于需要对输入中1的位数进行统计，我第一次使用到for循环语句来统计输入中1的个数，原码类似于下例。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003emodule\u003c/span\u003e test_for (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e7\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] in,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e clk,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e rst,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003eoutput\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003ereg\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e7\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] out\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003einteger\u003c/span\u003e i;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e @(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk \u003cspan style=\"color:#ff79c6\"\u003eor\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e rst) \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e test\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(rst)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tout \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e8\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(i\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;i\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e8\u003c/span\u003e;i\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ei\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in[i])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tout \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e out \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eendmodule\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t此段代码并不能成功实现在一个时钟周期内实现统计个数的功能。仿真如下:\u003c/p\u003e","title":"verilog编写电路中的时序逻辑与组合逻辑分离"},{"content":"verilog(P1课前复习) 长文，做好战斗准备！\n1.同步复位与异步复位 1.同步复位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //复位信号高电平有效 always@(posedge clk) begin if(clr) begin status \u0026lt;= 4\u0026#39;b0000; end else begin //statement end end //复位信号低电平有效 always@(posedge clk) begin if(!clr) begin status \u0026lt;= 4\u0026#39;b0000; end else begin //statement end end 2.异步复位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //复位信号高电平有效 always@(posedge clk or posedge clr) begin if(clr) begin status \u0026lt;= 4\u0026#39;b0000; end else begin //statement end end //复位信号低电平有效 always@(posedge clk or negedge clr) begin if(!clr) begin status \u0026lt;= 4\u0026#39;b0000; end else begin //statement end end ​\t异步复位将clr加入敏感符号列表\n2.为状态机编写可显示状态名称的testbench ​\t**编写testbench是我们在本地进行模块动态语法检查和功能检查的重要手段：一定要在本地编写testbench!不编写testbench的语法检查不完全！**编写testbench的一个重要目的是进行debug,但是Isim默认的仿真波形图只有输入变量和输出变量，引出第一步：在波形图中添加模块中变量进行查看。\n1.如何在波形图中添加其他变量 如果在左侧页面没有Instance and Process窗口，左上方菜单栏:View-\u0026gt;panel,添加想要查看的窗口 在Instance and Process窗口中展开tb模块，展开uut实例，点击下面的选项，在右侧Objects窗口中就会出现此模块中包含的变量，右键变量名，选择Add to wave window即可加入到波形图中进行查看。实操如下图所示。 2.如何显示出表示状态的字符串 ​\t我们知道，在编写testbench时我们不会额外引入变量，而只是对输入端口进行模拟，故如果想要在波形图中查看状态名称，就要在verilog module中添加用于存储与状态对应的字符串变量的寄存器变量，之后将这个变量添加到查看波形图中。添加变量并建立起与状态之间的对应关系如下例。\n1 2 3 4 5 6 7 8 9 10 `ifndef SYSTHESIS reg [23:0] state_string; always@(*)begin case(status): s0:state_string = \u0026#34;s0\u0026#34;; s1:state_string = \u0026#34;s1\u0026#34;; default:state_string = \u0026#34;s99\u0026#34;; endcase end `endif ​\t在波形图中显示的数值默认都是多位二进制，可以点击变量右键-\u0026gt;Radix，将字符串更改为ASCII表示。\n注意：\nstate_string的位宽由最大显示字符个数决定1word = 8bits,即位宽 = 字符数*8\n提交文件中编写此宏定义语句块并不会影响正常测评\n3.在testbench模块中模拟输入 ​\t这里直接给出例子，模拟比较简单，注意延迟时间的设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 module block_tb; // Inputs reg clk; reg reset; reg [7:0] in; // Outputs wire result; // Instantiate the Unit Under Test (UUT) BlockChecker uut ( .clk(clk), .reset(reset), .in(in), .result(result) ); initial begin // Initialize Inputs clk = 0; reset = 1; in = 0; // Wait 10 ns for global reset to finish #10; // Add stimulus here #10 reset = 0; in = \u0026#34;a\u0026#34;; #10 in = \u0026#34; \u0026#34;; end always #5 clk = ~clk; endmodule 注意：\n时序逻辑中有reset信号的一定要初始化为1再修改为0 在初始化模块外编写时钟信号always #5 clk = ~clk,这里表示时钟周期为5ns 3.verilog代码规范 1.变量命名 1.信号名称采用全小写，单词之间下划线分隔，snake_case 2.信号低电平有效时用_n后缀表示，rst_n 2.组合逻辑 1.采用always描述组合逻辑时，列表内用*而不是列举敏感信号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //right always@(*) begin if(rst_n)begin c = a + b; end else begin c = 1\u0026#39;b0; end end //worse always@(a,b) begin if(rst_n)begin c = a + b; end else begin c = 1\u0026#39;b0; end end 2.always块中如果使用if,则每个分支下都需要进行赋值 3.组合逻辑中只使用阻塞赋值= 4.可以使用assign表示组合逻辑 5.对于复杂表达式涉及到符号性，确定最外层表达式符号+向内传播，或者直接将有符号运算抽离出来设置变量（更加建议） 3.时序逻辑 1.一般情况下使用上升沿posedge进行触发 2.只使用非阻塞赋值 \u0026lt;= 3.使用localparam命名状态机各个状态 1 2 3 4 5 6 // GOOD localparam sInit = 2\u0026#39;d0; localparam sIdle = 2\u0026#39;d1; localparam sWork = 2\u0026#39;d2; localparam sDone = 2\u0026#39;d3; reg [1:0] state; 4.不要在敏感列表以外的地方使用时钟信号 5.不要在多个always块内为同一变量赋值 4.数制与位拼接 ​\t在P1_Q3_ext一题中，我遇到了位拼接相关的问题，总结如下：\n在verilog语法中，当常量不说明位数时默认为32位，进制为十进制，故在位拼接中应尤其注意指明常量的位数 截取某一信号的某几位in[n:m] 表示,如果表示全部保留这个信号，直接用变量名表达in 表示重复的位数，16{imm[15]}外也应有大括号，表达为{16{imm[15]}} 5.关于assign与always@(*)——组合逻辑的转写 ​\t在P1课下提交的六指令ALU构造中，遇到了有关符号数处理的相关问题，在初始状态下的assign+三目运算符+子表达式的情况下很容易就将子表达式的符号性自顶向下传播没了QWQ导致运算结果错误，我的初版代码中，将表达式状态拆分为assign+三目运算符+变量的形式，即将运算提前存储在wire变量中,三目运算符实际上是对值进行选择，这样也就无所谓符号问题。\n​\t在复习过程中，我突然想到这种复杂的由多个三目运算符构成的表达式完全可以由分支结构代替，在编写的过程中我发现：\n在always块中进行赋值的只能为reg类型的变量，故需要设置新的变量来存储值，或者改变输出端口的数据类型(这两种方法都可以AC) assign不能在always块或initial块中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //将输出端口改为reg类型，直接在always块中进行赋值 module alu ( input [31:0] A, input [31:0] B, input [2:0] ALUOp, output reg [31:0] C ); always @(*) begin if(ALUOp == 3\u0026#39;b000) C = A + B; else if(ALUOp == 3\u0026#39;b001) C = A - B; else if(ALUOp == 3\u0026#39;b010) C = A \u0026amp; B; else if(ALUOp == 3\u0026#39;b011) C = A | B; else if(ALUOp == 3\u0026#39;b100) C = A \u0026gt;\u0026gt; B; else C = $signed(A)\u0026gt;\u0026gt;\u0026gt;B; end endmodule //设置中间变量寄存器，最后 assign C = tmp; module alu ( input [31:0] A, input [31:0] B, input [2:0] ALUOp, output [31:0] C ); reg [31:0] tmp; always @(*) begin if(ALUOp == 3\u0026#39;b000) tmp = A + B; else if(ALUOp == 3\u0026#39;b001) tmp = A - B; else if(ALUOp == 3\u0026#39;b010) tmp = A \u0026amp; B; else if(ALUOp == 3\u0026#39;b011) tmp = A | B; else if(ALUOp == 3\u0026#39;b100) tmp = A \u0026gt;\u0026gt; B; else tmp = $signed(A)\u0026gt;\u0026gt;\u0026gt;B; end assign C = tmp; endmodule 6.组合逻辑语法和时序逻辑语法 注意：verilog中无自增自减运算符\n1.initial ​\tinitial后紧跟的语句或顺序语句块在硬件仿真开始时就会进行，且只会运行一次，可以用于为寄存器赋初值，initial块是不可综合的！因此，考虑到综合性，我们一般使用reset信号进行赋初值操作。\n1 2 3 4 reg a; initial begin a = 1\u0026#39;b0; end 2.always ​\talways块在时序逻辑和组合逻辑中都有应用，需要注意的是always块中不能使用assign语句。不能在多个always块中对一个变量进行赋值且always块中只能对reg型变量进行赋值。\n1 2 3 4 5 6 7 8 9 10 //组合逻辑 reg型数据与阻塞赋值配合 always@(*) begin a = A + B; end //时序逻辑 非阻塞赋值 always@(posedge clk) begin a \u0026lt;= A + B; end 3.if ​\tif-else if -else模块只能出现在顺序块中，顺序块(以begin开始，以end表示结束),所有的else语句都应写出。\n1 2 3 4 5 6 7 8 9 //组合逻辑 always@(*)begin if(a\u0026gt;b)begin out = a; end else begin out = b; end end 5.case ​\tcase语句只能出现在顺序块中，分支也只能是语句或顺序块，case语句一定要注意编写default,不要忘记endcase!\n1 2 3 4 5 6 7 8 9 10 always@(posedge clk) begin case(data) 0: out \u0026lt;= 4; 1: out \u0026lt;= 5; 2: out \u0026lt;= 2; 3: out \u0026lt;= 1 default : out \u0026lt;= 0; endcase end 6.for ​\t循环变量可以为integer或reg类型，使用reg类型作为循环变量时要合理设置位宽。\n1 2 3 4 5 6 7 8 9 10 11 12 13 module test( input [1:0] x, output reg [3:0] ans //将输出变量定义为reg类型可以直接在always中进行赋值 ); integer i;//循环变量定义在always语句块之外 always @(*) begin ans = 0; for(i=0;i\u0026lt;3;i=i+1) begin ans = ans + x; end end endmodule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //七人投票表决器 module vote7 ( input [6:0] vote, output reg pass ); reg [2:0] sum; integet i; always@(vote)begin sum = 3\u0026#39;b000; for(i = 0; i \u0026lt; 7 ; i = i + 1) begin if(vote[i]) sum = sum + 1; end if(sum \u0026gt;= 3\u0026#39;d4) pass = 1\u0026#39;b1; else pass = 1\u0026#39;b0; end endmodule 7.while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //统计八位二进制数中1的位数 module counts1_while( input clk, input [7:0] rega, output reg [3:0] count ); always@(posedge clk)begin:count1 reg[7:0] tempreg; count = 0; tempreg = rega; while(tempreg)begin if(tempreg[0]) count = count + 1; tempreg = tempreg \u0026gt;\u0026gt; 1\u0026#39; end end endmodule ","permalink":"https://coder0xe.github.io/posts/verilog/","summary":"\u003ch3 id=\"verilogp1课前复习\"\u003everilog(P1课前复习)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e长文，做好战斗准备！\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"1同步复位与异步复位\"\u003e1.同步复位与异步复位\u003c/h4\u003e\n\u003ch5 id=\"1同步复位\"\u003e1.同步复位\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//复位信号高电平有效\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(clr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0000\u003c/span\u003e; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#6272a4\"\u003e//statement\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//复位信号低电平有效\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003e!\u003c/span\u003eclr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0000\u003c/span\u003e; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#6272a4\"\u003e//statement\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"2异步复位\"\u003e2.异步复位\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//复位信号高电平有效\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk \u003cspan style=\"color:#ff79c6\"\u003eor\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(clr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0000\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#6272a4\"\u003e//statement\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//复位信号低电平有效\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e@(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk \u003cspan style=\"color:#ff79c6\"\u003eor\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enegedge\u003c/span\u003e clr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003e!\u003c/span\u003eclr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0000\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#6272a4\"\u003e//statement\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t\u003cstrong\u003e异步复位将clr加入敏感符号列表\u003c/strong\u003e\u003c/p\u003e","title":"verilog"},{"content":"语句块模拟检查 P1_L1_BlockChecker 一.题目要求 1.题目描述 ​\t输入ASCII字母和空格，一个或多个连续出现的字母构成单词，单词不区分大小写，单词之间由一个或多个空格分隔开。检查工具检查自复位之后的输入中，begin和end是否能匹配。\n注：\n匹配的begin必须出现在end之前 一个begin只能匹配一个end 允许出现嵌套 出现不能按照规则匹配的begin或end,则匹配失败 保证在模块使用前进行复位 2.IO定义 信号名 方向 描述 clk I 时钟信号 reset I 异步复位信号 in[7:0] I 当前输入的ASCII码 result O 当前输入能否完成begin和end匹配 注意：输出result为“当前”的判断结果，即随着状态更新\n2.状态转移图 解释：\n所有的单词都以空格表示结束对应回到S0状态 如果之前没有出现过begin就出现end,之后无论输入什么都会输出0，设置为单独的状态S10，这个状态是自环的，无论输入什么都会回到S10，并输出0. 3.verilog代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 module BlockChecker ( input wire clk, input wire reset, input wire [7:0] in, output reg result ); reg [31:0] begin_cnt; reg [15:0] status; `define S0 16\u0026#39;b0000_0000_0000_0001 `define S1 16\u0026#39;b0000_0000_0000_0010 `define S2 16\u0026#39;b0000_0000_0000_0100 `define S3 16\u0026#39;b0000_0000_0000_1000 `define S4 16\u0026#39;b0000_0000_0001_0000 `define S5 16\u0026#39;b0000_0000_0010_0000 `define S6 16\u0026#39;b0000_0000_0100_0000 `define S7 16\u0026#39;b0000_0000_1000_0000 `define S8 16\u0026#39;b0000_0001_0000_0000 `define S9 16\u0026#39;b0000_0010_0000_0000 `define S10 16\u0026#39;b0000_0100_0000_0000 always @(posedge clk or posedge reset) begin if(reset) begin begin_cnt \u0026lt;= 32\u0026#39;b0; status \u0026lt;= `S0; result \u0026lt;= 1\u0026#39;b1; end else begin case (status) `S0: //empty begin if(in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else if (in == \u0026#34;e\u0026#34;||in == \u0026#34;E\u0026#34;) begin status = `S7; end else if (in == \u0026#34;b\u0026#34;||in == \u0026#34;B\u0026#34;) begin status = `S1; end else begin status = `S6; end end `S1: //b begin if(in == \u0026#34;e\u0026#34;||in == \u0026#34;E\u0026#34;) begin status = `S2; end else if (in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else begin status \u0026lt;= `S6; end end `S2: //be begin if(in == \u0026#34;g\u0026#34;||in == \u0026#34;G\u0026#34;) begin status \u0026lt;= `S3; end else if (in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else begin status \u0026lt;= `S6; end end `S3: //beg begin if(in == \u0026#34;i\u0026#34;||in == \u0026#34;I\u0026#34;) begin status \u0026lt;= `S4; end else if (in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else begin status \u0026lt;= `S6; end end `S4: //begi begin if(in == \u0026#34;n\u0026#34;||in == \u0026#34;N\u0026#34;) begin status \u0026lt;= `S5; result \u0026lt;= 1\u0026#39;b0; end else if (in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else begin status \u0026lt;= `S6; end end `S5: begin if(in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; begin_cnt \u0026lt;= begin_cnt + 1; end else begin status \u0026lt;= `S6; if(begin_cnt == 32\u0026#39;b0000) begin result \u0026lt;= 1\u0026#39;b1; end else begin result \u0026lt;= result; end end end `S6: begin if(in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else begin status \u0026lt;= `S6; end end `S7: begin if(in == \u0026#34;n\u0026#34;||in ==\u0026#34;N\u0026#34;) begin status = `S8; end else if (in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else begin status \u0026lt;= `S6; end end `S8: begin if(in == \u0026#34;d\u0026#34;||in == \u0026#34;D\u0026#34;) begin if(begin_cnt == 32\u0026#39;b0001) //只剩余一个begin 可以完成配对 begin status \u0026lt;= `S9; result \u0026lt;= 1\u0026#39;b1; end else begin status \u0026lt;= `S9; result \u0026lt;= 1\u0026#39;b0; end end else if (in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; end else begin status \u0026lt;= `S6; end end `S9: begin if(in == \u0026#34; \u0026#34;) //确定匹配到的一定是end begin if(begin_cnt == 32\u0026#39;b0) //还没有出现过begin 这种情况无论后便出现什么都是0 begin status \u0026lt;= `S10; result \u0026lt;= 1\u0026#39;b0; end else if(begin_cnt == 32\u0026#39;b1) begin status \u0026lt;= `S0; result \u0026lt;= 1\u0026#39;b1; begin_cnt = 32\u0026#39;b0000; end else if(begin_cnt \u0026gt; 32\u0026#39;b1) begin status \u0026lt;= `S0; result \u0026lt;= 1\u0026#39;b0; begin_cnt = begin_cnt - 32\u0026#39;b0001; end end else //匹配到的不是end begin status \u0026lt;= `S6; if(begin_cnt==32\u0026#39;b0) begin result \u0026lt;= 1\u0026#39;b1; end else begin result \u0026lt;= 1\u0026#39;b0; end end end `S10: begin status \u0026lt;= `S10; result \u0026lt;= 1\u0026#39;b0; end default: begin status \u0026lt;= status; result \u0026lt;= result; end endcase end end endmodule 4.一个坑点 `S5: begin if(in == \u0026#34; \u0026#34;) begin status \u0026lt;= `S0; begin_cnt \u0026lt;= begin_cnt + 1; end else begin status \u0026lt;= `S6; if(begin_cnt == 32\u0026#39;b0000) begin result \u0026lt;= 1\u0026#39;b1; end else begin result \u0026lt;= result; end end end ​\t在进行单词begin的匹配时，需要对是否成功的匹配到begin做判断，一开始在两种之间来回改，后来才想到这是两种情况应该使用分支结构：\n如果之前没有成功匹配过begin:现在也没有匹配到begin,则下一周期输出应该是1，在这种情况下应当将匹配N时改动的result复位回1\n如果之前成功匹配过begin:当前的匹配结果不应当影响之前的结果\n1 result \u0026lt;= result 而不应当进行复位，如例子\n1 begin begina 这时即使第二次匹配begin失败，输出result也应当为1\n​\n5.特别致谢hugo \u0026amp;\u0026amp; xmgg 帮忙看我的bug QAQ ","permalink":"https://coder0xe.github.io/posts/blockchecker/","summary":"\u003ch3 id=\"语句块模拟检查-p1_l1_blockchecker\"\u003e语句块模拟检查 P1_L1_BlockChecker\u003c/h3\u003e\n\u003ch4 id=\"一题目要求\"\u003e一.题目要求\u003c/h4\u003e\n\u003ch5 id=\"1题目描述\"\u003e1.题目描述\u003c/h5\u003e\n\u003cp\u003e​\t\u003cstrong\u003e输入ASCII字母和空格\u003c/strong\u003e，一个或多个连续出现的字母构成单词，单词不区分大小写，单词之间由一个或多个空格分隔开。检查工具检查自复位之后的输入中，begin和end是否能匹配。\u003c/p\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e匹配的begin必须出现在end之前\u003c/li\u003e\n\u003cli\u003e一个begin只能匹配一个end\u003c/li\u003e\n\u003cli\u003e允许出现嵌套\u003c/li\u003e\n\u003cli\u003e出现不能按照规则匹配的begin或end,则匹配失败\u003c/li\u003e\n\u003cli\u003e保证在模块使用前进行复位\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"2io定义\"\u003e2.IO定义\u003c/h5\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e信号名\u003c/th\u003e\n          \u003cth\u003e方向\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eclk\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e时钟信号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ereset\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e异步复位信号\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ein[7:0]\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e当前输入的ASCII码\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eresult\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e当前输入能否完成begin和end匹配\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e注意：输出result为“当前”的判断结果，即随着状态更新\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"2状态转移图\"\u003e2.状态转移图\u003c/h4\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231012005200540\" loading=\"lazy\" src=\"/img/P1_state.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解释\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e所有的单词都以空格表示结束对应回到S0状态\u003c/li\u003e\n\u003cli\u003e如果之前没有出现过begin就出现end,之后无论输入什么都会输出0，设置为单独的状态S10，这个状态是自环的，无论输入什么都会回到S10，并输出0.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"3verilog代码实现\"\u003e3.verilog代码实现\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 46\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 47\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 48\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 49\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 50\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 51\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 52\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 53\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 54\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 55\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 56\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 57\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 58\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 59\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 60\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 61\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 62\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 63\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 64\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 65\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 66\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 67\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 68\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 69\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 70\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 71\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 72\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 73\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 74\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 75\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 76\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 77\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 78\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 79\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 80\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 81\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 82\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 83\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 84\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 85\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 86\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 87\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 88\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 89\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 90\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 91\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 92\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 93\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 94\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 95\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 96\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 97\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 98\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 99\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e100\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e101\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e102\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e103\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e104\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e105\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e106\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e107\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e108\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e109\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e110\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e111\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e112\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e113\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e114\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e115\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e116\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e117\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e118\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e119\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e120\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e121\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e122\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e123\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e124\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e125\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e126\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e127\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e128\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e129\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e130\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e131\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e132\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e133\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e134\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e135\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e136\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e137\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e138\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e139\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e140\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e141\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e142\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e143\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e144\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e145\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e146\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e147\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e148\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e149\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e150\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e151\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e152\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e153\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e154\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e155\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e156\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e157\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e158\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e159\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e160\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e161\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e162\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e163\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e164\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e165\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e166\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e167\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e168\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e169\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e170\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e171\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e172\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e173\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e174\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e175\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e176\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e177\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e178\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e179\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e180\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e181\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e182\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e183\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e184\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e185\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e186\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e187\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e188\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e189\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e190\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e191\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e192\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e193\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e194\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e195\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e196\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e197\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e198\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e199\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e200\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e201\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e202\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e203\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e204\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e205\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e206\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e207\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e208\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e209\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e210\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e211\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e212\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e213\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e214\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e215\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e216\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e217\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e218\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e219\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e220\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e221\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e222\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e223\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e224\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e225\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e226\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e227\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e228\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e229\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e230\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e231\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003emodule\u003c/span\u003e BlockChecker (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e clk,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e reset,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e7\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] in,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eoutput\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003ereg\u003c/span\u003e result\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ereg\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] begin_cnt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ereg\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e15\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] status;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S0 16\u0026#39;b0000_0000_0000_0001\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S1 16\u0026#39;b0000_0000_0000_0010\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S2 16\u0026#39;b0000_0000_0000_0100\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S3 16\u0026#39;b0000_0000_0000_1000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S4 16\u0026#39;b0000_0000_0001_0000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S5 16\u0026#39;b0000_0000_0010_0000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S6 16\u0026#39;b0000_0000_0100_0000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S7 16\u0026#39;b0000_0000_1000_0000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S8 16\u0026#39;b0000_0001_0000_0000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S9 16\u0026#39;b0000_0010_0000_0000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003e`define S10 16\u0026#39;b0000_0100_0000_0000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ealways\u003c/span\u003e @(\u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e clk \u003cspan style=\"color:#ff79c6\"\u003eor\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eposedge\u003c/span\u003e reset) \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(reset)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003ecase\u003c/span\u003e (status)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S0\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e//empty\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;E\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e `S7;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;B\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e `S1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S1\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e   \u003cspan style=\"color:#6272a4\"\u003e//b\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;E\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e `S2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S2\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e     \u003cspan style=\"color:#6272a4\"\u003e//be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;g\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;G\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S3;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S3\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e   \u003cspan style=\"color:#6272a4\"\u003e//beg\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;i\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;I\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S4;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S4\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#6272a4\"\u003e//begi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;n\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;N\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S5;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S5\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0000\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e result;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S6\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S7\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;n\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;N\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e `S8;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S8\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;d\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003ein \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;D\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0001\u003c/span\u003e)  \u003cspan style=\"color:#6272a4\"\u003e//只剩余一个begin 可以完成配对\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S9;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S9;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S9\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(in \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e)  \u003cspan style=\"color:#6272a4\"\u003e//确定匹配到的一定是end\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e)  \u003cspan style=\"color:#6272a4\"\u003e//还没有出现过begin 这种情况无论后便出现什么都是0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0000\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S0;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e begin_cnt \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0001\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e//匹配到的不是end\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S6;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(begin_cnt\u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            `S10\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e `S10;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e  \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003edefault\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003ebegin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                status \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e status;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                result \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;=\u003c/span\u003e result;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eendcase\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eendmodule\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"4一个坑点\"\u003e4.一个坑点\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-veri\" data-lang=\"veri\"\u003e  `S5:\n            begin\n                if(in == \u0026#34; \u0026#34;)\n                begin\n                    status \u0026lt;= `S0;\n                    begin_cnt \u0026lt;= begin_cnt + 1;\n                end\n                else\n                begin\n                    status \u0026lt;= `S6;\n                    if(begin_cnt == 32\u0026#39;b0000)\n                    begin\n                    result \u0026lt;= 1\u0026#39;b1;\n                    end\n                    else\n                    begin\n                    result \u0026lt;= result;\n                    end\n                end\n            end\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e​\t\u003cstrong\u003e在进行单词begin的匹配时，需要对是否成功的匹配到begin做判断，一开始在两种之间来回改，后来才想到这是两种情况应该使用分支结构\u003c/strong\u003e：\u003c/p\u003e","title":"P1_L1_BlockChecker"},{"content":"P1_L3_ALU \u0026amp;\u0026amp; Verilog中的符号处理 1.问题引入 AC? WA? ​\t在做P1课下提交中的6处理ALU时，我发现了一件怪事，两个看似只是添加了变量差别的程序居然跑起来一个能够通过测试，一个不能，下面附上AC代码和WA代码。\nAC代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module alu ( input [31:0] A, input [31:0] B, input [2:0] ALUOp, output [31:0] C ); wire [31:0] add = A + B; wire [31:0] sub = A - B; wire [31:0] with = A \u0026amp; B; wire [31:0] huo = A | B; wire [31:0] logic_shift = A \u0026gt;\u0026gt; B; wire [31:0] math_shift = $signed(A) \u0026gt;\u0026gt;\u0026gt; B; assign C = (ALUOp == 3\u0026#39;b000) ? add: (ALUOp == 3\u0026#39;b001) ? sub: (ALUOp == 3\u0026#39;b010) ? with: (ALUOp == 3\u0026#39;b011) ? huo: (ALUOp == 3\u0026#39;b100) ? logic_shift: (ALUOp == 3\u0026#39;b101) ? math_shift: 32\u0026#39;b000; endmodule WA代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module alu ( input [31:0] A, input [31:0] B, input [2:0] ALUOp, output [31:0] C ); assign C = (ALUOp == 3\u0026#39;b000) ? A + B: (ALUOp == 3\u0026#39;b001) ? A - B: (ALUOp == 3\u0026#39;b010) ? A \u0026amp; B: (ALUOp == 3\u0026#39;b011) ? A | B: (ALUOp == 3\u0026#39;b100) ? A \u0026gt;\u0026gt; B: (ALUOp == 3\u0026#39;b101) ? $signed(A) \u0026gt;\u0026gt;\u0026gt; B: 32\u0026#39;b000; endmodule ​\t这两份代码的区别表面上看似乎只是AC版本使用变量存储了运算结果，实际上是verilog处理有符号表达式的问题\n2.回顾verilog对于符号表达式的处理规则 ​\tverilog对于符号处理分为两个过程：\n最外层表达式的确定 向内传播 1.最外层表达式的符号确定 ​\t对于上下文决定的表达式，其符号与位宽和运算符无关，由其子表达式决定，可以简单概括为：**其子表达式中有一个为无符号则最外层表达式就是无符号的。**如果用树状图来判断，我们需要递归的判断到表达式树的叶子节点。以我们程序中出现bug的表达式为例。\n​\t可以发现，当我们不用变量来存储表达式的时候，这个大表达式分解到叶子节点(原子公式)，可以发现，大部分叶子节点都是无符号的，这样一层层向上递推，得到最外层的表达式同样为无符号的。\n2.向内传播 ​\t所谓向内传播，当我们确定好最外层为无符号后，无符号的属性就会沿着“树枝”传到每一个子表达式，最后影响到底层叶子节点的符号性。bug实例就是这样，当我们将无符号传递到叶子节点时，$signed(A)会被强制转换为unsigned,这样就会出现符号右移失败的问题.\n3.总结 ​\t在AC代码中我们通过提前使用变量计算出表达式的方法防止了表达式符号传播的问题，将问题转化为仅仅是“选择输出”，可以记住这种经验，对于复杂的表达式避免使用$signed,如果需要使用可以将这一部分单独抽离出来作为一个变量。\n​\t详见verilog教程部分\n","permalink":"https://coder0xe.github.io/posts/p1%E8%AF%BE%E4%B8%8Balu%E4%B8%8Everilog%E7%AC%A6%E5%8F%B7%E5%A4%84%E7%90%86/","summary":"\u003ch3 id=\"p1_l3_alu--verilog中的符号处理\"\u003eP1_L3_ALU \u0026amp;\u0026amp; Verilog中的符号处理\u003c/h3\u003e\n\u003ch4 id=\"1问题引入-ac-wa\"\u003e1.问题引入 AC? WA?\u003c/h4\u003e\n\u003cp\u003e​\t在做P1课下提交中的6处理ALU时，我发现了一件怪事，两个看似只是添加了变量差别的程序居然跑起来一个能够通过测试，一个不能，下面附上AC代码和WA代码。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAC代码\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-verilog\" data-lang=\"verilog\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003emodule\u003c/span\u003e alu (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] A,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] B,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003einput\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] ALUOp,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eoutput\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] C\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] add \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e A \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e B;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] sub \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e A \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e B;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] with \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e A \u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003e B;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] huo \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e A \u003cspan style=\"color:#ff79c6\"\u003e|\u003c/span\u003e B;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] logic_shift \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e A \u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e B;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003ewire\u003c/span\u003e [\u003cspan style=\"color:#bd93f9\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e] math_shift \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e $signed(A) \u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e B;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003eassign\u003c/span\u003e C \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e (ALUOp \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b000\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eadd:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               (ALUOp \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b001\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003esub:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               (ALUOp \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b010\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003ewith:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               (ALUOp \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b011\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003ehuo:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               (ALUOp \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b100\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003elogic_shift:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               (ALUOp \u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b101\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003emath_shift:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e\u0026#39;b000\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eendmodule\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eWA代码\u003c/strong\u003e\u003c/p\u003e","title":"P1_L3_ALU \u0026\u0026 Verilog中的符号处理"},{"content":"OOpre_HW4 : 正则表达式 1.实现思路 ​\t这次作业实现思路上没有特别大难度(只新增了四条指令)，但实际上作业体验下来相当于新增了一条指令，很多功能可以顺带着实现。即在我的做法中OP14()是进行战斗日志存储的方法，OP15(),OP16(),OP17(),只是将存好的战斗日志输出出来。\n​\t沿用“二维数组”的输入解析法，特判操作数为14时进行多行输入，引用变量row代表实际的行数(因为战斗日志不算在指令条数n内)，利用正则表达式对输入的战斗日志进行解析，下面附上我的冗长的正则表达式\n1 2 3 Pattern p = Pattern.compile(\u0026#34;(\\\\d{4}/\\\\d{2})-([^\\\\s@#-]+)-([^\\\\s@#-]+)\u0026#34;); Pattern p1 = Pattern.compile(\u0026#34;(\\\\d{4}/\\\\d{2})-([^\\\\s^@#-]+)@([^\\\\s@#-]+)-([^\\\\s@#-]+)\u0026#34;); Pattern p2 = Pattern.compile(\u0026#34;(.*/.*)-(.*)@#-(.*)\u0026#34;); //这一条是助教改进的，还没太理解 ​\t之后按照题目叙述按部就班从二维数组中取出元素操作即可。这里我将战斗日志分为三个部分：\n​\t注意：战斗日志的存储只能使用ArrayList只有这样才满有序性！\n总表，在inputhandler中设置，在OP14()中读出后就将其加入总表，这样相当于沿着完整的时间线存入了战斗日志，对于OP15()的完成比较简单，只需要使用正则表达式从中提取出来，下面附上我的正则表达式（其实只需要对日期进行匹配）\n1 Pattern p = Pattern.compile(date + \u0026#34;.+\u0026#34;); 下设在Adventure类中的attacklog和attackedlog分别记录这个人作为攻击者和被攻击的战斗记录，需要注意的是在实际操作中攻击者增加attacklog同时被攻击者要增加attackedlog。\n​\t沿着这个思路实现就好，但是助教说不够“面向对象”。(查我代码库QAQ)。\n2.BUGS ​\t这次作业遇到的bug是我de时间最长的一次WWW.有很多粗心，也有一些逻辑上的不周到(第一遍写的时候没有反应过来)，甚至还有笔误。这次作业我遇到的bug大部分都是输出错误，虽然要来回找很繁琐但是不值得记录，只有一个逻辑上的错误比较烦心，整整看了三个小时才通过比较AC输出调试出来，心态很崩\n下面是错误代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public boolean useequ(Adventure man, Adventure man1,String name) { Equipment equipment = null; for (Equipment item : man.equipments) { if (item.getName(item).equals(name)) { equipment = item; break; } } if (equipment != null) { if(equipment.getBecarried(equipment)){ int level = man.level; man1.hitpoint = man1.hitpoint - equipment.getStar() * level; System.out.println(man1.getId(man1) + \u0026#34; \u0026#34; + man1.gethitpoint(man1)); return true; } } return false; } ​\t这种实现思路的错误之处在于：在我之前的迭代思路中，“背包”是一个概念而不是一个实体，在总库equipments中进行查找时，完全可能找到名字符合但是并没有携带的equipment（即但从名字找equipment不具有唯一性，可能会找错），这样就会使得永远也加不进去战斗日志，之前的迭代作业我们知道，一个人同名的装备只能有一件状态为carried，对于名字和是否携带的双重判断才是正确的逻辑。\n下面是正确代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public boolean useequ(Adventure man, Adventure man1,String name) { Equipment equipment = null; for (Equipment item : man.equipments) { if (item.getName(item).equals(name)) { if (item.getBecarried(item)) { equipment = item; break; } } } if (equipment != null) { int level = man.level; man1.hitpoint = man1.hitpoint - equipment.getStar() * level; System.out.println(man1.getId(man1) + \u0026#34; \u0026#34; + man1.gethitpoint(man1)); return true; } return false; } ","permalink":"https://coder0xe.github.io/posts/oopre-hw4/","summary":"\u003ch3 id=\"oopre_hw4--正则表达式\"\u003eOOpre_HW4 : 正则表达式\u003c/h3\u003e\n\u003ch4 id=\"1实现思路\"\u003e1.实现思路\u003c/h4\u003e\n\u003cp\u003e​\t这次作业实现思路上没有特别大难度(只新增了四条指令)，但实际上作业体验下来相当于新增了一条指令，很多功能可以顺带着实现。即在我的做法中\u003ccode\u003eOP14()\u003c/code\u003e是进行战斗日志存储的方法，\u003ccode\u003eOP15()\u003c/code\u003e,\u003ccode\u003eOP16()\u003c/code\u003e,\u003ccode\u003eOP17()\u003c/code\u003e,只是将存好的战斗日志输出出来。\u003c/p\u003e\n\u003cp\u003e​\t沿用“二维数组”的输入解析法，特判操作数为14时进行多行输入，引用变量\u003ccode\u003erow\u003c/code\u003e代表实际的行数(因为战斗日志不算在指令条数n内)，利用正则表达式对输入的战斗日志进行解析，下面附上我的冗长的正则表达式\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePattern p \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Pattern.\u003cspan style=\"color:#50fa7b\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;(\\\\d{4}/\\\\d{2})-([^\\\\s@#-]+)-([^\\\\s@#-]+)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePattern p1 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Pattern.\u003cspan style=\"color:#50fa7b\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;(\\\\d{4}/\\\\d{2})-([^\\\\s^@#-]+)@([^\\\\s@#-]+)-([^\\\\s@#-]+)\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePattern p2 \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Pattern.\u003cspan style=\"color:#50fa7b\"\u003ecompile\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;(.*/.*)-(.*)@#-(.*)\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#6272a4\"\u003e//这一条是助教改进的，还没太理解\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t之后按照题目叙述按部就班从二维数组中取出元素操作即可。这里我将战斗日志分为三个部分：\u003c/p\u003e\n\u003cp\u003e​\t\u003cstrong\u003e注意：战斗日志的存储只能使用\u003ccode\u003eArrayList\u003c/code\u003e只有这样才满有序性！\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e总表，在\u003ccode\u003einputhandler\u003c/code\u003e中设置，在\u003ccode\u003eOP14()\u003c/code\u003e中读出后就将其加入总表，这样相当于沿着完整的时间线存入了战斗日志，对于\u003ccode\u003eOP15()\u003c/code\u003e的完成比较简单，只需要使用正则表达式从中提取出来，下面附上我的正则表达式（其实只需要对日期进行匹配）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePattern p \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Pattern.\u003cspan style=\"color:#50fa7b\"\u003ecompile\u003c/span\u003e(date \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;.+\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e下设在\u003ccode\u003eAdventure\u003c/code\u003e类中的\u003ccode\u003eattacklog\u003c/code\u003e和\u003ccode\u003eattackedlog\u003c/code\u003e分别记录这个人作为攻击者和被攻击的战斗记录，需要注意的是在实际操作中攻击者增加\u003ccode\u003eattacklog\u003c/code\u003e同时被攻击者要增加\u003ccode\u003eattackedlog\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\t沿着这个思路实现就好，但是助教说不够“面向对象”。(查我代码库\u003ccode\u003eQAQ\u003c/code\u003e)。\u003c/p\u003e\n\u003ch4 id=\"2bugs\"\u003e2.BUGS\u003c/h4\u003e\n\u003cp\u003e​\t这次作业遇到的bug是我de时间最长的一次\u003ccode\u003eWWW\u003c/code\u003e.有很多粗心，也有一些逻辑上的不周到(第一遍写的时候没有反应过来)，甚至还有笔误。这次作业我遇到的bug大部分都是输出错误，虽然要来回找很繁琐但是不值得记录，只有一个逻辑上的错误比较烦心，整整看了三个小时才通过比较AC输出调试出来，心态很崩\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e下面是错误代码\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eboolean\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003euseequ\u003c/span\u003e(Adventure man, Adventure man1,String name) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Equipment equipment \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enull\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (Equipment item : man.\u003cspan style=\"color:#50fa7b\"\u003eequipments\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (item.\u003cspan style=\"color:#50fa7b\"\u003egetName\u003c/span\u003e(item).\u003cspan style=\"color:#50fa7b\"\u003eequals\u003c/span\u003e(name)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    equipment \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e item;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#ff79c6\"\u003ebreak\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e (equipment \u003cspan style=\"color:#ff79c6\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enull\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(equipment.\u003cspan style=\"color:#50fa7b\"\u003egetBecarried\u003c/span\u003e(equipment)){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \t\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e level \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e man.\u003cspan style=\"color:#50fa7b\"\u003elevel\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \tman1.\u003cspan style=\"color:#50fa7b\"\u003ehitpoint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e man1.\u003cspan style=\"color:#50fa7b\"\u003ehitpoint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e equipment.\u003cspan style=\"color:#50fa7b\"\u003egetStar\u003c/span\u003e() \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e level;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \tSystem.\u003cspan style=\"color:#50fa7b\"\u003eout\u003c/span\u003e.\u003cspan style=\"color:#50fa7b\"\u003eprintln\u003c/span\u003e(man1.\u003cspan style=\"color:#50fa7b\"\u003egetId\u003c/span\u003e(man1) \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e man1.\u003cspan style=\"color:#50fa7b\"\u003egethitpoint\u003c/span\u003e(man1));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003etrue\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003efalse\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t这种实现思路的错误之处在于：在我之前的迭代思路中，“背包”是一个概念而不是一个实体，在总库\u003ccode\u003eequipments\u003c/code\u003e中进行查找时，完全可能找到名字符合但是并没有携带的\u003ccode\u003eequipment\u003c/code\u003e（即但从名字找\u003ccode\u003eequipment\u003c/code\u003e不具有唯一性，可能会找错），这样就会使得永远也加不进去战斗日志，之前的迭代作业我们知道，一个人同名的装备只能有一件状态为\u003ccode\u003ecarried\u003c/code\u003e，对于名字和是否携带的双重判断才是正确的逻辑。\u003c/p\u003e","title":"OOpre_HW4"},{"content":"CO-P0-logisim ​\t写在前面:10.9晚上机有三道题目，笔者只侥幸通过了其中两道，记录一下思路，分享一下拙见QAQ,如有错误还请指正！(os:上机还是很辛苦的\u0026hellip;\u0026hellip;)\n1.找最小 1.思路探究 ​\t题目的大意为，输入五个八位二进制数字，完成电路，输出没有出现过的最小正整数，例如，输入为:0,3,2,1,7,那么最小的没有出现过的正整数为4.\n​\t题意分析：如果能够想到将输入转换为独热码就可以比较直观地理解问题！我们考虑：这个所求的最小正整数最大是多少？可以想到，找最小正整数的过程类似于找一个“空隙”，如果我们将五位输入按从小到大顺序排好，记为a[n]，那么最小正整数会出现的条件:\n1 a[n-1] + 1 \u0026lt; a[n] ​\t我们可以发现：最小正整数最大的时候即为五个输入为1，2，3，4，5；此时最小正整数大小为6.故我们可以知道最小正整数的出现范围为16。这一点对我们的解题过程很关键，因为这一认知告诉我们：无论输入如何，我们只需要去找从16之间没有出现过的最小数即为我们所求的最小正整数。\n​\t然后：我们怎么知道数字有没有出现过呢？常规的二进制编码可能较难实现，但是选择独热码是一个比较直观的选择，将每个输入转换为独热码，最后或起来\u0026hellip;\u0026hellip;.到这里思路已经明晰，实现电路吧！\n2.电路设计 1.转换为独热码电路 one-hot encoder ​\t这里做出判断，大于6就当作0处理，需要注意的是，八位独热码中0也被编码，即为图中所示，因为要求是正整数，所以无论是否输入0，第0位应该被默认占位，这一点在主电路中也有处理。\n2.main ​\t在主电路的处理中，我们添加一个“输入0”，将第0位占位，保证是正整数。\n2.回字迷宫 ​\t从迷宫中的1位置出发，绕回字迷宫行走，00向北，01向南，10向西，11向东，如果当前输入的方向有位置，就输出进入位置的编号，若没有位置，就输出当前位置编号，使用mealy状态机实现，注意1位置的编号为1。\n​\t这个题目比较简单，无脑的把状态逻辑和输出逻辑分开列真值表就可以解决\u0026hellip;\u0026hellip;题目里一共八个状态，建议还是使用四位编码吧，从0001开始编码，这样可以在输出逻辑时好看一些，笔者采用三位编码，导致输出时的数字要比状态数字大1，有点费心神。\n​\t打表技巧：将输入利用splitter分解成1位输入到模块中，这样在模块中便于进行analyze功能和debug\u0026hellip;\u0026hellip;毕竟将多位传输进模块，在打完表之后要进行位拼接，这个过程走线比较逆天，另外如果逻辑错了不好进行debug,需要将拼接好的位数再展开\u0026hellip;\u0026hellip;.\n3.十六进制匹配 ​\t此题笔者是通过打真值表实现，比较麻烦，下面附上状态转移图\n​\t课程组提供的标准解法中利用三个寄存器存储最近输入的状态，这种做法比较巧妙，引用讨论区中助教的回答\n","permalink":"https://coder0xe.github.io/posts/p0-logisim/","summary":"\u003ch3 id=\"co-p0-logisim\"\u003e\u003ccode\u003eCO-P0-logisim\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e​\t\u003cstrong\u003e写在前面\u003c/strong\u003e:10.9晚上机有三道题目，笔者只侥幸通过了其中两道，记录一下思路，分享一下拙见\u003ccode\u003eQAQ\u003c/code\u003e,如有错误还请指正！(\u003ccode\u003eos\u003c/code\u003e:上机还是很辛苦的\u0026hellip;\u0026hellip;)\u003c/p\u003e\n\u003ch4 id=\"1找最小\"\u003e1.找最小\u003c/h4\u003e\n\u003ch5 id=\"1思路探究\"\u003e1.思路探究\u003c/h5\u003e\n\u003cp\u003e​\t题目的大意为，输入五个八位二进制数字，完成电路，输出没有出现过的最小正整数，例如，输入为:0,3,2,1,7,那么最小的没有出现过的正整数为4.\u003c/p\u003e\n\u003cp\u003e​\t\u003cstrong\u003e题意分析\u003c/strong\u003e：如果能够想到将输入转换为独热码就可以比较直观地理解问题！我们考虑：这个所求的最小正整数最大是多少？可以想到，找最小正整数的过程类似于找一个“空隙”，如果我们将五位输入按从小到大顺序排好，记为a[n]，那么最小正整数会出现的条件:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea[n\u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e a[n]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t我们可以发现：最小正整数最大的时候即为五个输入为1，2，3，4，5；此时最小正整数大小为6.故我们可以知道最小正整数的出现范围为1\u003cdel\u003e6。这一点对我们的解题过程很关键，因为这一认知告诉我们：无论输入如何，我们只需要去找从1\u003c/del\u003e6之间没有出现过的最小数即为我们所求的最小正整数。\u003c/p\u003e\n\u003cp\u003e​\t然后：我们怎么知道数字有没有出现过呢？常规的二进制编码可能较难实现，但是选择独热码是一个比较直观的选择，将每个输入转换为独热码，最后或起来\u0026hellip;\u0026hellip;.到这里思路已经明晰，实现电路吧！\u003c/p\u003e\n\u003ch5 id=\"2电路设计\"\u003e2.电路设计\u003c/h5\u003e\n\u003ch6 id=\"1转换为独热码电路-one-hot-encoder\"\u003e1.转换为独热码电路 one-hot encoder\u003c/h6\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231015144304665\" loading=\"lazy\" src=\"/img/image-20231010091656740.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t这里做出判断，大于6就当作0处理，需要注意的是，八位独热码中0也被编码，即为图中所示，因为要求是正整数，所以无论是否输入0，第0位应该被默认占位，这一点在主电路中也有处理。\u003c/p\u003e\n\u003ch6 id=\"2main\"\u003e2.main\u003c/h6\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231015144304665\" loading=\"lazy\" src=\"/img/image-20231010092011068.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t在主电路的处理中，我们添加一个“输入0”，将第0位占位，保证是正整数。\u003c/p\u003e\n\u003ch4 id=\"2回字迷宫\"\u003e2.回字迷宫\u003c/h4\u003e\n\u003cp\u003e​\t从迷宫中的1位置出发，绕回字迷宫行走，00向北，01向南，10向西，11向东，如果当前输入的方向有位置，就输出进入位置的编号，若没有位置，就输出当前位置编号，使用mealy状态机实现，注意1位置的编号为1。\u003c/p\u003e\n\u003cp\u003e​\t这个题目比较简单，无脑的把状态逻辑和输出逻辑分开列真值表就可以解决\u0026hellip;\u0026hellip;题目里一共八个状态，建议还是使用四位编码吧，从0001开始编码，这样可以在输出逻辑时好看一些，笔者采用三位编码，导致输出时的数字要比状态数字大1，有点费心神。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231015144304665\" loading=\"lazy\" src=\"/img/image-20231010093726813.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t\u003cstrong\u003e打表技巧\u003c/strong\u003e：将输入利用splitter分解成1位输入到模块中，这样在模块中便于进行analyze功能和debug\u0026hellip;\u0026hellip;毕竟将多位传输进模块，在打完表之后要进行位拼接，这个过程走线比较逆天，另外如果逻辑错了不好进行debug,需要将拼接好的位数再展开\u0026hellip;\u0026hellip;.\u003c/p\u003e\n\u003ch4 id=\"3十六进制匹配\"\u003e3.十六进制匹配\u003c/h4\u003e\n\u003cp\u003e​\t此题笔者是通过打真值表实现，比较麻烦，下面附上状态转移图\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231015144304665\" loading=\"lazy\" src=\"/img/image-20231015143959738.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t\t课程组提供的标准解法中利用三个寄存器存储最近输入的状态，这种做法比较巧妙，引用讨论区中助教的回答\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231015144304665\" loading=\"lazy\" src=\"/img/image-20231015144304665.png\"\u003e\u003c/p\u003e","title":"P0-logisim"},{"content":"P0课下提交 ​\t本次P0课下提交部分全部为logisim有关内容，五个电路题目我没有一题是一遍过的QAQ,在做每个题目的过程中或多或少都会发现一些疏漏点，本篇笔记的初衷是记录一下做题思路(毕竟.circ文件不支持添加笔记)以及在做题过程中遇到的一些坑点。\n1.CRC校验码的生成 名称 方向 描述 A[7 : 0] I 8位原数据帧 B[3 : 0] I 除数 C[10 : 0] O 8位原数据帧+3位余数 1.被除数的生成 ​\t被除数为8位原数据帧 + (除数位数-1)位0，在题目中具体下来即补全为11位被除数。这时我们发现，按照题目中的提示，按照4位除法来搭建电路，而一个11位数应当可以进行8次4位补位除法(同样参考商的位数是8位可以得到答案，不要被竖式计算过程中似乎计算除法模块小于8次迷惑，做出难以名状的事情)。\n2.模二除法 ​\t在此题目中涉及到模二除法的使用，这是一个新概念，模二除法在结果上等于两位进行异或的答案，但是进行模二除法的前提是最高位需要为1(已经保证除数的最高位为1)，即保证被除数与除数的最高位相同。这样我们可以知道，能进行除法的四位数为```1xxx```,这样得到的余数为```0xxx```，型为```0xxx```的数字不满足进行模二除法的条件，需要进行借位，直到最高位变为1才进行计算，这是根据题目中给出的样例得到的。\r3.电路设计 ​\t通过以上分析我们知道，当前补全的四位能否进行模二除法的关键在于它的最高位，如果当前四位数字的最高位为1则进行模二除法，并传递余数到下一级，如果当前最高位为0则将数字左移一位，传递给下一级，如此传递直到最高位为1满足进行除法的条件。由于我们知道余数一定是三位且在进行下一级除法前需要拼接被除数的下一位，因此在四位除法中输出设计为3位。下面给出电路。\n2.主电路搭建 ​\t主电路主要实现8级除法的连接(传入下一位)，这里需要注意的是在进行输出输出时都需要进行处理，输入时在原数据后补加3位0，输出时在原数据后补加3位余数。此题用到许多的splitter。\n2.实现GRF ​\t这一题主体上的功能比较单一，即对寄存器进行简单的读写操作，但是这个题目中却有很多的细节值得细细品味。而且此题的电路图过于复杂且重复，因此只展示部分电路连接。\n1.一个弱智问题MUX与DMX ​\t对于MUX与DMX我要好好品味，毕竟Ppre挂掉就是因为对多路选择器的功能不够熟悉QAQ!。\n1.DMX ​\tDMX通常用于输入端选择输入到哪里的情况，短边连接输入信号，长边连接多个可以被选择的输入到的位置。\n端口说明:\n短边连接输入信号(data) 长边连接多个输入路径选择 腰上一个使能端口(include enable)，一个选择输入到第几个路径的输入信号(select),这里需要注意的是一些情况下可以不选择启用使能端口，在启用使能端口时，腰上会出现两个接口点，如何去区分功能？端口上有一个灰色点的是select! 2.MUX ​\tMUX通常用于选择多方数据中的一个来进行输出，长边连接多个可以进行输出的信号，短边进行输出。\n端口说明:\n短边进行输出(output)\n长边上连接多个可供进行输出的信号\n腰上一个使能端口(include enable)，一个选择输出第几路数据的信号(select)，同样，上面标记有灰色点的为选择信号。\n3.总结 ​\tDMX用于输入到哪里的选择，MUX用于输出哪个的选择。选择信号为腰上标记灰色点的端口。DMX与MUX在此题中配对放置。\n使能端的勾选视情况而定。\n2.DMX的three-state ​\t在我进行电路搭建的过程中，我习惯性的将three-state设置为no,在此次搭建过程中，由于需要向32个不同的寄存器中写入数据，我发现在写入数据时每当我向新的寄存器写入数据，之前写过的寄存器会被洗掉变回0，这是一个很奇怪的现象，知道我看了讨论区，才知道要将DMX的three-state设置为yes.这背后的原因是什么呢？\n​\t在logisim官方文档中，three-state作了如下解释：Specifies whether the unselected outputs should be floating (Yes) or zero (No).即处理没有选择的引脚的输入状态，选择yes即为floating状态，这是一个悬空状态，即不对寄存器输入数据，寄存器中原有的内容不会改变，选择no则会造成zero,即没有被选择的引脚都会输入0,这就会发生原来写入的数据被冲掉的现象。\n3.一个坑点 ​\t其实DMX的three-state已经可以算作一个坑点，这一点自己动手实验可以发现上一周期存入数据在存入新数据时被洗掉的问题，但可能不知道是three-state出了问题，但是接下来这个坑点可能更不容易被发现，那就是0号寄存器要始终输出0，这一点很容易被忽视，这一点的处理上我选择不使用统一的tunnel处理0号寄存器的使能端，而是将其直接常量化为0，这样可以保证0号寄存器的值始终为寄存器初值0.\n3. Moore与Mealy ​\t对于有限自动机类型的题型，在状态较少的情况下，最常见的情况是利用真值表进行自动绘图，当状态数特别多时，如Pre 上机的俄罗斯方块题目，就不能使用真值表，但是值得庆幸的是，本次作业的两道题目都可以通过真值表完成绘制。\n​\t对于两种自动机的辨析，我很喜欢肖利民老师上课时提到的一句话，Moore 型自动机在画真值表时，需要画两张表，下一状态逻辑和输出逻辑分开画，而 Mealy型自动机在画真值表时只需要一张表就可以解决，这是为什么呢？因为Mealy型自动机的两个逻辑模块输入是相同的， Moore型自动机两个逻辑模块的输入不同。但是实际上，当我们选择使用真值表解决问题时，由于分层次绘制的思想，我们总喜欢将下一状态逻辑和输出逻辑封装为不同的子模块，因此在实际绘制时还是相当于两张真值表。因此作业中的两道状态机题目不再给出具体电路，毕竟顶层是模板，底层是真值表。\n​\t在绘制有限自动机电路时，熟悉的流水线作业：\n绘制该种自动机的main模块（模板） 绘制status circuit 绘制output circuit ​\t从顶层电路中可以看出，Mealy与Moore的主要区别为输出上的区别。当输入后，两种状态机都会next state logic更新次态，但是对于输出，一般采用Mealy型自动机的题目会选择在时钟周期内输入，而不一定在时钟上升沿输入。\n​\t简单来说，无论在何种状态机中，一个时钟周期只有一个状态。 但是Moore机我在时钟周期内改变输入，输出不会变，因为输出只与状态有关。Mealy机在周期内改变输入，输出会变，且输出由临时输入与当前状态共同决定。状态只在时钟上升沿（一个周期开始的瞬间）发生改变。\n4.logisim导航 ​\t这题目一开始我的理解是Mealy型自动机，因为我的理解是hit信号应当是实时更新的，而arrive信号不是。这其实是很扭曲的，你说我设计的是哪一种状态机呢？hit输出信号实时更新,arrive信号等到时钟上升沿到来更新。这不是四不像吗！最关键是我还真设计出来了，hit信号直接从status逻辑中输出，arrive信号从output逻辑中输出。顶层电路实际上不满足任何一种有限自动机。这提醒我不要自己设计新种类自动机QWQ。\n​\t实际上，这题虽然没有明说请设计Moore型自动机，却已经给到了充足的暗示，撞到墙壁并将hit信号置高一周期，到达信号需要置位并保持一周期。我们知道，输出信号按照周期更新的是Moore型自动机。\n​\t这道题目为了实现hit的按照周期更新，我选择将hit看作一种状态(毕竟是否撞墙确实是一种状态)，加入到status的编码中，并作为最高位，这样就是四位状态编码(五个位置对应五个状态)。在output逻辑中对hit进行读取输出。画完状态转移图之后，对应的两个子电路真值表完成信手拈来。\n5.正则表达式匹配 ​\t此题涉及到同步复位与异步复位的概念:\n同步复位：与时钟上升沿同步复位，即时钟上升沿到来时进行复位 异步复位：复位信号到来即进行复位，常见的异步复位信号为寄存器的复位信号。 ​\t此题目中要求设计Mealy型状态机并实现同步复位，要将复位信号直接接到寄存器上这显然是不对的。我的选择是将复位信号接入到下一状态逻辑中，在复位信号为1时产生的下一状态为00，这样同样可以实现同步复位。但却不太巧妙。\n​\t讨论区中介绍了一种通过MUX选择下一状态输入到寄存器的方法，虽然两种办法本质上是相同的，但是明显这种做法更节省电路。\n​\t讨论区中还有一种做法如下：这种做法显然是不对的，这种做法中在时钟高电平时均会使复位信号有效。\n6.foti 1.主体思路 ​\t题目要求输入一个16位的单精度浮点数，输出浮点数的整数部分（有符号），用32位补码表示，超出32位则保留低位。16位单精度浮点数的编码形式为1+5+10.这种固定位数的编码很好处理，有一点像上课讲过的定点浮点数。此题中的定点即为第十位，也就是我们压根不用管移位后的结果，第十位左边的就是整数部分，右边的一律为小数部分。\n2.实现细节 1.移位 ​\t我们现在知道这就是一个移位+取位的问题。根据给出的公式，我们知道需要判断向左还是向右移位。向左还是向右可以通过comparator实现，比较exponent部分与01111的大小。\n2.补码 ​\t电路的实现很朴实，我们知道：正数的补码为原码，负数的补码为符号位不变、对应正数的原码取反再加1。在电路里即可按照定义实现：先对符号位进行判断\u0026hellip;\u0026hellip;.\n3.对于不同输入状态的判断 ​\t这个判断让我很快联想起pre上机中的俄罗斯方块题目，这种判断五位01状态可以使用与门、或门实现，再用MUX选择输出\u0026hellip;\u0026hellip;\n3.一个坑点 ​\t比较器要选择无符号比较，而不是2的补码比较！\n4.电路图 7.结语 ​\t两天的搭建过程乐趣无穷，思考电路的架构，细细查找错误\u0026hellip;\u0026hellip;.最现实的是希望下周上机顺利通过！QAQ\n","permalink":"https://coder0xe.github.io/posts/p0kexia/","summary":"\u003ch3 id=\"p0课下提交\"\u003e\u003ccode\u003eP0\u003c/code\u003e课下提交\u003c/h3\u003e\n\u003cp\u003e​\t本次\u003ccode\u003eP0\u003c/code\u003e课下提交部分全部为\u003ccode\u003elogisim\u003c/code\u003e有关内容，五个电路题目我没有一题是一遍过的\u003ccode\u003eQAQ\u003c/code\u003e,在做每个题目的过程中或多或少都会发现一些疏漏点，本篇笔记的初衷是记录一下做题思路(毕竟\u003ccode\u003e.circ\u003c/code\u003e文件不支持添加笔记)以及在做题过程中遇到的一些坑点。\u003c/p\u003e\n\u003ch4 id=\"1crc校验码的生成\"\u003e1.\u003ccode\u003eCRC\u003c/code\u003e校验码的生成\u003c/h4\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e名称\u003c/th\u003e\n          \u003cth\u003e方向\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eA[7 : 0]\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e8位原数据帧\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eB[3 : 0]\u003c/td\u003e\n          \u003ctd\u003eI\u003c/td\u003e\n          \u003ctd\u003e除数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eC[10 : 0]\u003c/td\u003e\n          \u003ctd\u003eO\u003c/td\u003e\n          \u003ctd\u003e8位原数据帧+3位余数\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch5 id=\"1被除数的生成\"\u003e1.被除数的生成\u003c/h5\u003e\n\u003cp\u003e​\t被除数为8位原数据帧 + (除数位数-1)位0，在题目中具体下来即补全为11位被除数。这时我们发现，按照题目中的提示，按照4位除法来搭建电路，而一个11位数应当可以进行8次4位补位除法(同样参考商的位数是8位可以得到答案，\u003cstrong\u003e不要被竖式计算过程中似乎计算除法模块小于8次迷惑，做出难以名状的事情\u003c/strong\u003e)。\u003c/p\u003e\n\u003ch5 id=\"2模二除法\"\u003e2.模二除法\u003c/h5\u003e\n\u003cimg src=\"/img/除法.png\" alt=\"除法\" style=\"zoom:67%;\" /\u003e\r\n​\t在此题目中涉及到模二除法的使用，这是一个新概念，模二除法在结果上等于两位进行异或的答案，但是进行模二除法的前提是最高位需要为1(已经保证除数的最高位为1)，即保证被除数与除数的最高位相同。这样我们可以知道，能进行除法的四位数为```1xxx```,这样得到的余数为```0xxx```，型为```0xxx```的数字不满足进行模二除法的条件，需要进行借位，直到最高位变为1才进行计算，这是根据题目中给出的样例得到的。\r\n\u003cimg src=\"/img/除法.png\" alt=\"除法\" style=\"zoom:67%;\" /\u003e\r\n\u003ch5 id=\"3电路设计\"\u003e3.电路设计\u003c/h5\u003e\n\u003cimg src=\"/img/四位除法.png\" alt=\"四位除法\" style=\"zoom:67%;\" /\u003e\r\n\u003cp\u003e​\t通过以上分析我们知道，当前补全的四位能否进行模二除法的关键在于它的最高位，如果当前四位数字的最高位为1则进行模二除法，并传递余数到下一级，如果当前最高位为0则将数字左移一位，传递给下一级，如此传递直到最高位为1满足进行除法的条件。由于我们知道余数一定是三位且在进行下一级除法前需要拼接被除数的下一位，因此在四位除法中输出设计为3位。下面给出电路。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231003004732125\" loading=\"lazy\" src=\"/img/P0%E4%B8%BB%E7%94%B5%E8%B7%AF.png\"\u003e\u003c/p\u003e\n\u003ch6 id=\"2主电路搭建\"\u003e2.主电路搭建\u003c/h6\u003e\n\u003cp\u003e​\t主电路主要实现8级除法的连接(传入下一位)，这里需要注意的是在进行输出输出时都需要进行处理，输入时在原数据后补加3位0，输出时在原数据后补加3位余数。此题用到许多的\u003ccode\u003esplitter\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20231003004732125\" loading=\"lazy\" src=\"/img/P0%E4%B8%BB%E7%94%B5%E8%B7%AF.png\"\u003e\u003c/p\u003e\n\u003ch4 id=\"2实现grf\"\u003e2.实现\u003ccode\u003eGRF\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e​\t这一题主体上的功能比较单一，即对寄存器进行简单的读写操作，但是这个题目中却有很多的细节值得细细品味。而且此题的电路图过于复杂且重复，因此只展示部分电路连接。\u003c/p\u003e\n\u003ch5 id=\"1一个弱智问题mux与dmx\"\u003e1.一个弱智问题\u003ccode\u003eMUX\u003c/code\u003e与\u003ccode\u003eDMX\u003c/code\u003e\u003c/h5\u003e\n\u003cp\u003e​\t对于\u003ccode\u003eMUX\u003c/code\u003e与\u003ccode\u003eDMX\u003c/code\u003e我要好好品味，毕竟\u003ccode\u003ePpre\u003c/code\u003e挂掉就是因为对多路选择器的功能不够熟悉\u003ccode\u003eQAQ\u003c/code\u003e!。\u003c/p\u003e\n\u003ch6 id=\"1dmx\"\u003e1.\u003ccode\u003eDMX\u003c/code\u003e\u003c/h6\u003e\n\u003cp\u003e​\t\u003ccode\u003eDMX\u003c/code\u003e通常用于输入端选择输入到哪里的情况，短边连接输入信号，长边连接多个可以被选择的输入到的位置。\u003c/p\u003e\n\u003cp\u003e端口说明:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e短边连接输入信号(data)\u003c/li\u003e\n\u003cli\u003e长边连接多个输入路径选择\u003c/li\u003e\n\u003cli\u003e腰上一个使能端口(include enable)，一个选择输入到第几个路径的输入信号(select),这里需要注意的是一些情况下可以不选择启用使能端口，在启用使能端口时，腰上会出现两个接口点，如何去区分功能？端口上有一个灰色点的是select!\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"/img/DMX.png\" alt=\"DMX\" style=\"zoom:50%;\" /\u003e\r\n\u003ch6 id=\"2mux\"\u003e2.\u003ccode\u003eMUX\u003c/code\u003e\u003c/h6\u003e\n\u003cp\u003e​\t\u003ccode\u003eMUX\u003c/code\u003e通常用于选择多方数据中的一个来进行输出，长边连接多个可以进行输出的信号，短边进行输出。\u003c/p\u003e\n\u003cp\u003e端口说明:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e短边进行输出(output)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e长边上连接多个可供进行输出的信号\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e腰上一个使能端口(include enable)，一个选择输出第几路数据的信号(select)，同样，上面标记有灰色点的为选择信号。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"/img/MUX.png\" alt=\"MUX\" style=\"zoom:50%;\" /\u003e\r\n\u003ch6 id=\"3总结\"\u003e3.总结\u003c/h6\u003e\n\u003cp\u003e​\t\u003ccode\u003eDMX\u003c/code\u003e用于输入到哪里的选择，\u003ccode\u003eMUX\u003c/code\u003e用于输出哪个的选择。选择信号为腰上标记灰色点的端口。\u003ccode\u003eDMX\u003c/code\u003e与\u003ccode\u003eMUX\u003c/code\u003e在此题中配对放置。\u003c/p\u003e\n\u003cp\u003e使能端的勾选视情况而定。\u003c/p\u003e\n\u003ch5 id=\"2dmx的three-state\"\u003e2.\u003ccode\u003eDMX\u003c/code\u003e的three-state\u003c/h5\u003e\n\u003cp\u003e​\t在我进行电路搭建的过程中，我习惯性的将\u003ccode\u003ethree-state\u003c/code\u003e设置为\u003ccode\u003eno\u003c/code\u003e,在此次搭建过程中，由于需要向32个不同的寄存器中写入数据，我发现在写入数据时每当我向新的寄存器写入数据，之前写过的寄存器会被洗掉变回0，这是一个很奇怪的现象，知道我看了讨论区，才知道要将\u003ccode\u003eDMX\u003c/code\u003e的\u003ccode\u003ethree-state\u003c/code\u003e设置为\u003ccode\u003eyes\u003c/code\u003e.这背后的原因是什么呢？\u003c/p\u003e","title":"P0课下提交"},{"content":"Pre上机logisim部分\u0026mdash;\u0026mdash;俄罗斯方块 一.题目的回忆 1.关于输入输出 name width input 8 reset 1 clk 1 output 2 2.题意 ​\t我们利用mealy型状态机实现俄罗斯方块的模拟。假设我们有一个1行8列的空间，在每个时钟周期进行一个8位的输入，这个输入以独热码形式，如00000001表示在第一块空间放入方块，对于放置方块的输出有如下要求：\n若尝试放置处已有方块，则当前想要放入的方块被阻挡，输出01. 若尝试放置处无方块且其他位置处至少有一处无方块，则成功放入方块，输出10。 若尝试放置处无方块，此外每个位置都有方块，则清空所有方块，输出得分 11。 3.电路模块外观 ​\t这部分对于题意倒是无关紧要 后续题解补充，唯一的坑点在于我们搭建好的电路可能与标准要求的电路外观不同，涉及到修改子电路外观。\n二.题意理解 ​\t对于这道题目，由于要求搭建状态机，我的思路被局限在pre教程中提示过的利用真值表的解法。事实上，mealy状态机的下一状态逻辑和输出逻辑的输入是相同的，即电路的上一状态和当前输入。我们粗略的考虑一下打表的复杂度，输入为独热码，共八种状态，可能的状态有2^8-1种，即除去满方块的状态，这样打表的复杂度是2^11显然是不合理的。\n所以我们应当摒弃打表这种想法，进一步思考题目的要求。 ​\t题目中只涉及到三种状态的判断，一是放置位置处已经有方块，这时放置失败，输出01,并将原来的状态更新为只有将要放置的这一块地方有方块（即相当于输入的一行把原来的状态顶替掉），二是想要放置的位置没有方块，且其他位置至少还有一个空块，这时输出10,三是想要放置的地方没有方块，且放置后刚好满一行，清空这一行，输出得分11。\n​\t我们考虑如何判断放置位置处有没有方块呢？我们知道输入为8位独热码，只有表示方块的那一位为1，如果此时状态中那一位已经有方块，我们知道，这两位的与运算为1。经过分析我们知道，判断放置位置处是否为空可以用与运算，而且当前输入与状态的与运算八位中最多只会有一位出现1。\n​\t我们考虑如何更新状态呢？我们想要的更新状态是在可以放入方块的情况下，而这“放入”的操作是可以通过位运算“或”来实现的，注意，在填入方块后，我们还需要考虑是不是每一位都是1，如果都是1，则说明满足情况3，需要清除所有方块。\n​\t在大体明白的情况下，考虑一下细节。如何判断与运算中是否有1？将与运算的结果的8位进行或运算。如何判断或运算是否已经填满？使用与运算。\n​\t在大致逻辑明白的情况下，我们可以进行搭建电路。\n三.电路搭建 ​\t这里我附上mealy状态机的原型图\n​\t我们可以知道下方的或门是用来更新状态，或门之后的与门用来判断是否清空。clk与reset信号则直接控制寄存器。这里只有一个状态更新是由上面部分的电路提供的，即放置位置已有方块，这时更新为input的状态。多路选择器选择1引脚输出，大部分情况下(2,3)都是选择0引脚输出，即下方电路产生的下一状态。同时我们可以发现，电路的输出是控制选择常量输出。\n四.编辑子电路外观 在我们搭建好的电路中，默认的外观为\n​\t题目要求的外观为输出锚点在右上角，这就需要我们修改子电路外观。\n​\t如上即可正确测评。\n","permalink":"https://coder0xe.github.io/posts/pre/","summary":"\u003ch3 id=\"pre上机logisim部分俄罗斯方块\"\u003ePre上机logisim部分\u0026mdash;\u0026mdash;俄罗斯方块\u003c/h3\u003e\n\u003ch4 id=\"一题目的回忆\"\u003e一.题目的回忆\u003c/h4\u003e\n\u003ch5 id=\"1关于输入输出\"\u003e1.关于输入输出\u003c/h5\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003ename\u003c/th\u003e\n          \u003cth\u003ewidth\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003einput\u003c/td\u003e\n          \u003ctd\u003e8\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ereset\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eclk\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eoutput\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch5 id=\"2题意\"\u003e2.题意\u003c/h5\u003e\n\u003cp\u003e​\t我们利用mealy型状态机实现俄罗斯方块的模拟。假设我们有一个1行8列的空间，在每个时钟周期进行一个8位的输入，这个输入以独热码形式，如00000001表示在第一块空间放入方块，对于放置方块的输出有如下要求：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e若尝试放置处已有方块，则当前想要放入的方块被阻挡，输出\u003ccode\u003e01\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e若尝试放置处无方块且其他位置处至少有一处无方块，则成功放入方块，输出\u003ccode\u003e10\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e若尝试放置处无方块，此外每个位置都有方块，则清空所有方块，输出得分 \u003ccode\u003e11\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"3电路模块外观\"\u003e3.电路模块外观\u003c/h5\u003e\n\u003cp\u003e​\t这部分对于题意倒是无关紧要 后续题解补充，唯一的坑点在于我们搭建好的电路可能与标准要求的电路外观不同，涉及到修改子电路外观。\u003c/p\u003e\n\u003ch4 id=\"二题意理解\"\u003e二.题意理解\u003c/h4\u003e\n\u003cp\u003e​\t对于这道题目，由于要求搭建状态机，我的思路被局限在pre教程中提示过的利用真值表的解法。事实上，mealy状态机的下一状态逻辑和输出逻辑的输入是相同的，即电路的上一状态和当前输入。\u003cstrong\u003e我们粗略的考虑一下打表的复杂度，输入为独热码，共八种状态，可能的状态有2^8-1种，即除去满方块的状态，这样打表的复杂度是\u003ccode\u003e2^11\u003c/code\u003e显然是不合理的。\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e所以我们应当摒弃打表这种想法，进一步思考题目的要求。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e​\t题目中只涉及到三种状态的判断，一是放置位置处已经有方块，这时放置失败，输出\u003ccode\u003e01\u003c/code\u003e,并将原来的状态更新为只有将要放置的这一块地方有方块（即相当于输入的一行把原来的状态顶替掉），二是想要放置的位置没有方块，且其他位置至少还有一个空块，这时输出\u003ccode\u003e10\u003c/code\u003e,三是想要放置的地方没有方块，且放置后刚好满一行，清空这一行，输出得分\u003ccode\u003e11\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e​\t我们考虑如何判断放置位置处有没有方块呢？我们知道输入为8位独热码，只有表示方块的那一位为1，如果此时状态中那一位已经有方块，我们知道，这两位的与运算为1。经过分析我们知道，判断放置位置处是否为空可以用与运算，而且当前输入与状态的与运算八位中最多只会有一位出现1。\u003c/p\u003e\n\u003cp\u003e​\t我们考虑如何更新状态呢？我们想要的更新状态是在可以放入方块的情况下，而这“放入”的操作是可以通过位运算“或”来实现的，注意，在填入方块后，我们还需要考虑是不是每一位都是1，如果都是1，则说明满足情况3，需要清除所有方块。\u003c/p\u003e\n\u003cp\u003e​\t在大体明白的情况下，考虑一下细节。如何判断与运算中是否有1？将与运算的结果的8位进行或运算。如何判断或运算是否已经填满？使用与运算。\u003c/p\u003e\n\u003cp\u003e​\t在大致逻辑明白的情况下，我们可以进行搭建电路。\u003c/p\u003e\n\u003ch4 id=\"三电路搭建\"\u003e三.电路搭建\u003c/h4\u003e\n\u003cp\u003e\u003cimg alt=\"俄罗斯方块电路\" loading=\"lazy\" src=\"/img/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E7%94%B5%E8%B7%AF.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t这里我附上mealy状态机的原型图\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"mealy\" loading=\"lazy\" src=\"/img/mealy.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t我们可以知道下方的或门是用来更新状态，或门之后的与门用来判断是否清空。clk与reset信号则直接控制寄存器。这里只有一个状态更新是由上面部分的电路提供的，即放置位置已有方块，这时更新为input的状态。多路选择器选择1引脚输出，大部分情况下(2,3)都是选择0引脚输出，即下方电路产生的下一状态。同时我们可以发现，电路的输出是控制选择常量输出。\u003c/p\u003e\n\u003ch4 id=\"四编辑子电路外观\"\u003e四.编辑子电路外观\u003c/h4\u003e\n\u003cp\u003e在我们搭建好的电路中，默认的外观为\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"原电路外观\" loading=\"lazy\" src=\"/img/%E5%8E%9F%E7%94%B5%E8%B7%AF%E5%A4%96%E8%A7%82.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t题目要求的外观为输出锚点在右上角，这就需要我们修改子电路外观。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"编辑后外观\" loading=\"lazy\" src=\"/img/%E7%BC%96%E8%BE%91%E5%90%8E%E5%A4%96%E8%A7%82.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t如上即可正确测评。\u003c/p\u003e","title":"Pre上机logisim部分——俄罗斯方块"},{"content":"OOpre_HW3 and JUnit 一.关于OO_checkstyle的新发现 只能采用驼峰命名法命名变量 方法行数不超过60行(后续重构代码将操作与处理输入分离的主要原理，虽然只有两分) 每行字数不超过100（方法传参时发现） 其余关于空格的问题省略 二.增量开发的思路 在此次作业中，新增了“食物”、“背包”等概念。food作为与equipment和bottle同级物品，背包则负责容纳这些物品。 新增操作： 尝试携带（放入背包）某物品（保证尝试携带的物品冒险者已经拥有） 尝试使用某物品（该物品必须被携带才能够使用） ​\t实现逻辑：我们需要明白“携带”与“使用”的业务逻辑。\n我的第一版代码实现思路 ​\t我第一版代码中，按照题目描述，将food与package作为新建类处理，冒险者与背包之间的关系使用哈希表处理，建立起\u0026lt;advid,package\u0026gt;的映射，在背包中建立三个容器分别存储瓶子，装备和食物。对于加入背包，我的理解是，为冒险者增加物品是将物品放在冒险者对应的类adventure.java中对应的总库三个容器中，加入背包需要将物品从总库移动到与冒险者对应的背包，从物理角度来看是对物品进行了移动。这导致实现起来非常麻烦，例如统计数量等都需要考虑两个部分。这与题意不符，具体体现在中测最后一个数据点不过。\n第二版代码 ​\t经过与助教的沟通，我理解到：\n放入背包是一个概念的问题，而不是一个物理上的问题。放入背包并不需要将物品从总库中删除，只需要加入背包。\n一开始处理中建立冒险者与背包对应哈希表的想法并不符合面向对象的逻辑，这是面向过程的思路，如果想要具体实现背包应该建立在冒险者类中\n既然放入背包是一个概念问题，那么我们完全可以不去实现背包实体，而只需要进行概念上的判断。例如给每个物品增加一个属性\n1 private boolean becarried ; 初始时设置为false即不在背包中，放入背包即建立方法将属性设置为true.这个思路在实现代码上是十分简便的，具体体验到的优势如下：\n不需要新建数据结构存储放在背包中的物品 判断该物品是否在背包中只需要获取属性becarried 删除物品只需要在adventure类中的总库删除，实现简洁 获取物品数量是需要获取总库中的数量 三.代码架构与重构 ​\t经过checkstyle与JUnit对于代码架构的步步限制，我经历了三次代码重构，第一次是在编写过程中发现方法的行数不能超过60行，第二次是在传参时受到限制，选择将定义的静态方法从operation.java移动到inputhandler.java,第三次是编写JUnit过程中由于不能进行输入输出重定向等测评机认为的违法操作，这样只能将输入集中到一个类中，后续在方法中进行读取已经存储好的输入。\n​\t对于输入的类，原码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.Arrays; import java.util.Scanner; import java.util.ArrayList; public class Main { public static void main(String [] args) { ArrayList\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt; inputInfo = new ArrayList\u0026lt;\u0026gt;(); // 解析后的输入将会存进该容器中, 类似于c语言的二维数组 Scanner scanner = new Scanner(System.in); int n = Integer.parseInt(scanner.nextLine().trim()); // 读取行数 for (int i = 0; i \u0026lt; n; ++i) { String nextLine = scanner.nextLine(); // 读取本行指令 String[] strings = nextLine.trim().split(\u0026#34; +\u0026#34;); // 按空格对行进行分割 inputInfo.add(new ArrayList\u0026lt;\u0026gt;(Arrays.asList(strings))); // 将指令分割后的各个部分存进容器中 } InputHandler inputHandler = new InputHandler(inputInfo); inputHandler.solve(n); } } ​\t这样所有的操作指令被以分割的字符串的方式存入inputinfo,后续将inputinfo传入inputhandler类进行处理，所有的变量从这个形式上的二维数组中读取。这样可以避免在编写JUnit时无法控制台输入导致无法测试方法导致覆盖率不够，第二部分任务寄掉的问题。\n​\t详解输入解析\n1 2 3 4 5 6 7 8 9 10 11 12 //定义的数组类型为 ArrayList\u0026lt;Arraylist\u0026lt;String\u0026gt;\u0026gt; 处理完每一行输入后的示意图如下 //行数 0 \u0026#34;1\u0026#34; \u0026#34;123456\u0026#34; \u0026#34;dqr\u0026#34; 1 \u0026#34;2\u0026#34; \u0026#34;123456\u0026#34; \u0026#34;111\u0026#34; \u0026#34;ok\u0026#34; \u0026#34;50\u0026#34; //需要注意的是排列近似于二维数组，里面的每一个元素以字符串的形式存储 //读取二维数组中的元素 String name = inputinfo.get(0).get(0);//读取第一行中的第一个元素 int id = Integer.parseInt(inputinfo.get(0).get(1));//将字符串类型转化为整数类型 //存入方式 我这里选择模仿 String nextLine = \u0026#34;1 123456 dqr\u0026#34;; // 本行指令 String[] strings = nextLine.trim().split(\u0026#34; +\u0026#34;); // 按空格对行进行分割 inputInfo.add(new ArrayList\u0026lt;\u0026gt;(Arrays.asList(strings))); // 将指令分割后的各个部分存进容器中 四.JUnit 编写JUnit时由于导入头文件错误，且测试方法前没有写@Test导致测评机无法识别，此处提供JUnit模板 1 2 3 4 5 6 7 8 9 10 11 //只需要导入这两个头文件 import org.junit.Test; import static org.junit.Assert.*; public class FoodTest { @Test //每个测试方法前必须要有 public void test() { } } 编写时常用到的JUnit4标准断言 方法 介绍 assertEquals(expected, actual) 检查两个值是否相等 assertTrue(condition) 检查条件是否为真 assertFalse(condition) 检查条件是否为假 assertNotNull(object) 检查是否不为空 assertNull(object) 检查是否为空 assertNotSame(expected, actual) 检查两个相关对象是否不指向同一个对象 assertSame(expected, actual) 检查两个相关对象是否指向同一个对象 assertArrayEquals(expectedArray, resultArray) 检查两个数组是否相等 注：使用assert()断言是测评机不识别的，会导致本地覆盖率与测评结果差距较大\n运行测试代码报错空指针\n​\t编写inputhandler.java中的测试方法时，由于有删除，携带等操作，前提是必须有对应的冒险者，对应的物品，所以想要测试这个方法需要连带调用前提方法，如果不建立前提就会出现空指针。这里的测评方法同样是采用建ArrayList\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt;类型并进行赋值。相对来说对inputhandler的测试是最为复杂的。\n五.特别致谢助教 ","permalink":"https://coder0xe.github.io/posts/oopre-hw3/","summary":"\u003ch3 id=\"oopre_hw3-and-junit\"\u003e\u003ccode\u003eOOpre_HW3 and JUnit\u003c/code\u003e\u003c/h3\u003e\n\u003ch4 id=\"一关于oo_checkstyle的新发现\"\u003e一.关于\u003ccode\u003eOO_checkstyle\u003c/code\u003e的新发现\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e只能采用驼峰命名法命名变量\u003c/li\u003e\n\u003cli\u003e方法行数不超过60行(后续重构代码将操作与处理输入分离的主要原理，虽然只有两分)\u003c/li\u003e\n\u003cli\u003e每行字数不超过100（方法传参时发现）\u003c/li\u003e\n\u003cli\u003e其余关于空格的问题省略\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"二增量开发的思路\"\u003e二.增量开发的思路\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在此次作业中，新增了“食物”、“背包”等概念。\u003ccode\u003efood\u003c/code\u003e作为与\u003ccode\u003eequipment\u003c/code\u003e和\u003ccode\u003ebottle\u003c/code\u003e同级物品，背包则负责容纳这些物品。\u003c/li\u003e\n\u003cli\u003e新增操作：\n\u003col\u003e\n\u003cli\u003e尝试携带（放入背包）某物品（保证尝试携带的物品冒险者已经拥有）\u003c/li\u003e\n\u003cli\u003e尝试使用某物品（该物品必须被携带才能够使用）\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t\u003cstrong\u003e实现逻辑\u003c/strong\u003e：我们需要明白“携带”与“使用”的业务逻辑。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e我的第一版代码实现思路\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\t我第一版代码中，按照题目描述，将\u003ccode\u003efood\u003c/code\u003e与\u003ccode\u003epackage\u003c/code\u003e作为新建类处理，冒险者与背包之间的关系使用哈希表处理，建立起\u003ccode\u003e\u0026lt;advid,package\u0026gt;\u003c/code\u003e的映射，在背包中建立三个容器分别存储瓶子，装备和食物。对于加入背包，我的理解是，为冒险者增加物品是将物品放在冒险者对应的类\u003ccode\u003eadventure.java\u003c/code\u003e中对应的总库三个容器中，加入背包需要将物品从总库移动到与冒险者对应的背包，从物理角度来看是对物品进行了移动。这导致实现起来非常麻烦，例如统计数量等都需要考虑两个部分。这与题意不符，具体体现在中测最后一个数据点不过。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e第二版代码\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\t\t经过与助教的沟通，我理解到：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e放入背包是一个概念的问题，而不是一个物理上的问题\u003c/strong\u003e。放入背包并不需要将物品从总库中删除，只需要加入背包。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e一开始处理中建立冒险者与背包对应哈希表的想法并不符合面向对象的逻辑，这是面向过程的思路，如果想要具体实现背包应该建立在冒险者类中\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e既然放入背包是一个概念问题，那么我们完全可以不去实现背包实体，而只需要进行概念上的判断。例如给每个物品增加一个属性\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eboolean\u003c/span\u003e becarried ;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e初始时设置为\u003ccode\u003efalse\u003c/code\u003e即不在背包中，放入背包即建立方法将属性设置为\u003ccode\u003etrue\u003c/code\u003e.这个思路在实现代码上是十分简便的，具体体验到的优势如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e不需要新建数据结构存储放在背包中的物品\u003c/li\u003e\n\u003cli\u003e判断该物品是否在背包中只需要获取属性\u003ccode\u003ebecarried\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e删除物品只需要在\u003ccode\u003eadventure\u003c/code\u003e类中的总库删除，实现简洁\u003c/li\u003e\n\u003cli\u003e获取物品数量是需要获取总库中的数量\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"三代码架构与重构\"\u003e三.代码架构与重构\u003c/h4\u003e\n\u003cp\u003e​\t经过\u003ccode\u003echeckstyle\u003c/code\u003e与\u003ccode\u003eJUnit\u003c/code\u003e对于代码架构的步步限制，我经历了三次代码重构，第一次是在编写过程中发现方法的行数不能超过60行，第二次是在传参时受到限制，选择将定义的静态方法从\u003ccode\u003eoperation.java\u003c/code\u003e移动到\u003ccode\u003einputhandler.java\u003c/code\u003e,第三次是编写\u003ccode\u003eJUnit\u003c/code\u003e过程中由于不能进行输入输出重定向等测评机认为的违法操作，这样只能将输入集中到一个类中，后续在方法中进行读取已经存储好的输入。\u003c/p\u003e\n\u003cp\u003e​\t对于输入的类，原码如下\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eimport\u003c/span\u003e java.util.Arrays;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eimport\u003c/span\u003e java.util.Scanner;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eimport\u003c/span\u003e java.util.ArrayList;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eMain\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003emain\u003c/span\u003e(String \u003cspan style=\"color:#ff79c6\"\u003e[]\u003c/span\u003e args) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ArrayList\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eArrayList\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003eString\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e inputInfo \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e ArrayList\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e(); \u003cspan style=\"color:#6272a4\"\u003e// 解析后的输入将会存进该容器中, 类似于c语言的二维数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Scanner scanner \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e Scanner(System.\u003cspan style=\"color:#50fa7b\"\u003ein\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e n \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e Integer.\u003cspan style=\"color:#50fa7b\"\u003eparseInt\u003c/span\u003e(scanner.\u003cspan style=\"color:#50fa7b\"\u003enextLine\u003c/span\u003e().\u003cspan style=\"color:#50fa7b\"\u003etrim\u003c/span\u003e()); \u003cspan style=\"color:#6272a4\"\u003e// 读取行数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e 0; i \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e n; \u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003ei) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            String nextLine \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e scanner.\u003cspan style=\"color:#50fa7b\"\u003enextLine\u003c/span\u003e(); \u003cspan style=\"color:#6272a4\"\u003e// 读取本行指令\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            String\u003cspan style=\"color:#ff79c6\"\u003e[]\u003c/span\u003e strings \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e nextLine.\u003cspan style=\"color:#50fa7b\"\u003etrim\u003c/span\u003e().\u003cspan style=\"color:#50fa7b\"\u003esplit\u003c/span\u003e(\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; +\u0026#34;\u003c/span\u003e); \u003cspan style=\"color:#6272a4\"\u003e// 按空格对行进行分割\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            inputInfo.\u003cspan style=\"color:#50fa7b\"\u003eadd\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e ArrayList\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e(Arrays.\u003cspan style=\"color:#50fa7b\"\u003easList\u003c/span\u003e(strings))); \u003cspan style=\"color:#6272a4\"\u003e// 将指令分割后的各个部分存进容器中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        InputHandler inputHandler \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e InputHandler(inputInfo);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        inputHandler.\u003cspan style=\"color:#50fa7b\"\u003esolve\u003c/span\u003e(n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t这样所有的操作指令被以分割的字符串的方式存入\u003ccode\u003einputinfo\u003c/code\u003e,后续将\u003ccode\u003einputinfo\u003c/code\u003e传入\u003ccode\u003einputhandler\u003c/code\u003e类进行处理，所有的变量从这个形式上的二维数组中读取。这样可以避免在编写\u003ccode\u003eJUnit\u003c/code\u003e时无法控制台输入导致无法测试方法导致覆盖率不够，第二部分任务寄掉的问题。\u003c/p\u003e","title":"OOpre_HW3"},{"content":"OOpre_HW2 第一次进行类的编写（冒险者故事的开端） 1.什么是面向对象(Object Oriented) ​\t对象能够直接反映现实生活中的事物，例如人、车、小鸟等，将其表示为程序中的对象，每个对象都有各自的状态特征（属性）以及行为特征（方法），除了可以存储数据外还可以对自身进行操作，相当于结构体与函数的封装。\n​\t面向对象就是把构成问题的事物分解成一个一个的对象，建立对象不是为了实现一个步骤，而是描述某个事物在解决问题中的行为。\n​\t类是面向对象中的一个很重要的概念，类是很多个具有相同属性和行为特征的对象所抽象出来的，对象是类的一个实例。\n2. OO三大特征 封装 继承 多态 3.类与对象 ​\t类表示一个共性的产物，是一个综合的产物，而对象是一个个性的产物，类必须通过对象才可以使用，对象的所有操作都在类中定义\n类由属性和方法组成 属性：特征 方法：行为 ​\t一个类想真正地进行操作则必须依靠对象\n1 2 3 4 5 //对象的定义 classname objectname = new classname();//所有类的对象都是通过new关键字创建 //访问类中的属性或方法 objectname.id //访问属性 objectname.func(parameter1,parameter2)//调用方法 类的编写规则 类必须编写在.java文件中 一个.java文件中可以存在多个类，但只能存在一个public修饰的类 .java文件名必须与public修饰的类名相同 同一个包中不能有重名的类 4.构造方法 ​\t在创建对象时，调用构造方法，所有的JAVA类中都至少存在一个构造方法（除了主类），如果一个类中没有明确的编写构造方法，编译器会自动生成一个无参的构造方法，构造方法中没有任何的代码！如果自行编写了构造方法，则编译器不会生成无参的构造方法。\n构造方法的定义格式 构造方法名称必须与类名相同 没有返回值类型的声明 1 2 3 4 5 6 7 //创建一个对象就要调用构造方法 //一个自定义构造方法的例子 public person(String name, int age) { this.name = name; this.age = age; } this关键字 this指当前对象 程序中非静态方法可以使用this关键字 指向当前代码运行时所处于的对象空间 引用当前对象的实例变量 目前只在构造方法中接触this关键字 static关键字 static修饰变量为静态变量，也成称为类变量，静态变量属于类本身，而不是属于对象实例。该类的所有对象共享同一个静态变量的值，不会开辟出多块内存空间，可以通过\u0026lt;类名\u0026gt;.\u0026lt;变量名\u0026gt;来访问静态变量，但此时的变量需要被public修饰而不是private\n1 2 public static int variablename; classname.variablename 静态变量在程序运行期间只会被初始化一次，在内存中常驻不被销毁\nstatic修饰的成员方法是静态方法，也成为类方法。静态方法属于类本身，不依赖于对应的对象实例。可以通过\u0026lt;类名\u0026gt;.\u0026lt;方法名\u0026gt;来调用静态方法,方法需要被public修饰\n1 2 3 4 public static int method{ //? } className.methodName 静态方法只能访问静态属性，非静态方法可以访问静态属性和非静态属性\n静态方法不能调用非静态方法，非静态方法可以调用静态方法\n5.类成员的可见性 public:任意外部对象都能访问 protected:本类或子类对象可以访问 private:只有本类对象才能访问 注意：所有的作业中对于类中属性的定义都应为private!\n第一次作业内容，增量开发的基础 背景 在接下来的若干次作业中，同学们将进行以本次作业为基础的迭代开发，因此在具体的代码实现中，希望同学们可以考虑到每一次所写代码的可扩展性和可维护性，从而减少下一次的工作量。\n在接下来的几次作业中，请想象你是一个穿越到魔法大陆上的冒险者，在旅途中，你需要收集各种道具，使用各种装备，招募其他冒险者加入队伍，提升自己的等级并体验各种战斗。\n在本次作业中，你要做的是：\n实现冒险者类 Adventurer 、药水瓶类 Bottle 、装备类 Equipment\n利用容器，管理所有冒险者，并管理每一个冒险者所拥有的药水瓶和装备\n你可能需要实现的类和它们要拥有的属性\nAdventure ：ID，名字，药水瓶和装备各自的容器 Bottle：ID，名字，容量(capacity) Equipment：ID，名字，星级(star) 请注意，在作业中，可能会存在ID不同但名字相同的情况，请同学们在设计代码的时候考虑这一点\n其中，Bottle的容量属性在本次作业中不会被测试，但是却是后续作业的重要部分，请同学们不要忽略。\n在本次作业中，初始时，你没有需要管理的冒险者，我们通过若干条操作指令来修改当前的状态：\n加入一个需要管理的冒险者（新加入的冒险者不携带任何药水瓶和装备）\n给某个冒险者增加一个药水瓶\n删除某个冒险者的某个药水瓶\n给某个冒险者增加一个装备\n删除某个冒险者的某个装备\n给某个冒险者的某个装备提升一个星级\n其中，提升星级的意思是，新星级=原有星级+1\n输入格式 第一行一个整数 n，表示操作的个数。\n接下来的 n 行，每行一个形如 {type} {attribute} 的操作，{type} 和 {attribute} 间、若干个 {attribute} 间使用若干个空格分割，操作输入形式及其含义如下。同时，为了方便测评，我们需要在需要执行一些指令后进行相关输出。具体要求也在下面的表中列出：\ntype attribute 意义 输出格式（每条对应的占一行） 1 {adv_id} {name} 加入一个 ID 为 {adv_id}、名字为 {name} 的冒险者 无 2 {adv_id} {bot_id} {name} {capacity} 给 ID 为 {adv_id} 的冒险者增加一个药水瓶，药水瓶的 ID、名字、容量分别为 {bot_id}、{name}、{capacity} 无 3 {adv_id} {bot_id} 将 ID 为 {adv_id} 的冒险者的 id 为 {bot_id} 的药水瓶删除 {一个整数} {一个字符串}（解释：整数为删除后冒险者药水瓶数目，字符串为删除的药水瓶的name） 4 {adv_id} {equ_id} {name} {star} 给 ID 为 {adv_id} 的冒险者增加一个装备，装备的 ID、名字、星级分别为 {equ_id}、{name}、{star} 无 5 {adv_id} {equ_id} 将 ID 为 {adv_id} 的冒险者的 id 为 {equ_id} 的装备删除 {一个整数} {一个字符串}（解释：整数为删除后冒险者装备数目，字符串为删除的装备的name） 6 {adv_id} {equ_id} 将 ID 为 {adv_id} 的冒险者的 id 为 {equ_id} 的装备提升一个星级 {一个字符串} {一个整数}（解释：字符串为装备的name，整数为装备升星后的星级） 输出数值时，你的输出数值需要和正确数值相等。\n输入输出样例 输入1 4 1 700917 i$KdS=1n 4 700917 829431 ?TE/G1 3 6 700917 829431 5 700917 829431 输出1 ?TE/G1 4 0 ?TE/G1 输入2 3 1 700917 i$KdS=1n 2 700917 829431 ?TE/G1 3 3 700917 829431 输出2 0 ?TE/G1 数据限制 变量约束 变量 类型 说明 id 整数 取值范围：0 - 2147483647 name 字符串 保证不会出现空白字符，长度区间: (0,40) capacity 整数 取值范围：0 - 2147483647 star 整数 取值范围：0 - 2147483647 操作约束 保证所有的冒险者、药水瓶、装备 id 均不相同 保证删除了的药水瓶/装备的 id 不会再次出现 2-6保证所有冒险者均已存在 3/5/6保证该冒险者拥有操作中提到 id 的药水瓶/装备 保证增加的装备和药水瓶原本不存在 操作数满足1≤n≤2000 ArrayList,HashMap与容器 ​\t容器是一种用于存储和管理数据的类或接口的集合，最常用的容器包括集合框架与映射框架\n集合框架：\nList:用于存储有序的元素集合，例如ArrayList与LinkedList Set:用于存储独一无二的元素集合，例如HashSet与TreeSET Queue:用于存储按照特定顺序进行哈如何访问的元素集合 映射框架：\nMap:用于存储\u0026lt;键-值\u0026gt;对的集合，其中每个键都是唯一的，例如HashMap和TreeMap ArrayList ArrayList是一个可以动态修改的数组，但是他没有固定大小的限制，其中数组下标即为存入顺序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //ArrayList类位于java.util包中，使用前需要进行引入 import java.util.ArrayList; public class ArrayListSample { public void sample()//创建ArrayList { ArrayList\u0026lt;Bottles\u0026gt; bottles = new ArrayList\u0026lt;\u0026gt;(); //ArrayList\u0026lt;className\u0026gt; ArrayName = new ArrayList\u0026lt;\u0026gt;(); //可以看出数组中的元素为类的实例化对象 Bottle bottle1 = new Bottle(/*parameters*/); Bottle bottle2 = new Bottle(/*parameters*/); //增加一个元素 数组名.add(对象名) bottles.add(bottle1); bottles.add(bottle2); //访问数组中下标为i的元素 ArrayName.get(i) Bottle bottle = bottles.get(0);//取出第一个元素 //判断元素是否在容器中 if(bottles.contains(bottle)){ System.out.println(\u0026#34;yep\u0026#34;); } //数组大小 int size = bottles.size(); //遍历元素 for(Bottle item : bottles) { System.out.println(item.getName()); } //或者是 for(int i=0;i\u0026lt;bottles.size();i++) { System.out.println(bottles.get(i).getName()); } //删除元素 bottles.remove(bottle1);//对象名 bottles.remove(0);//按照下标 } } HashMap 散列表不会记录存入的顺序，存储内容是键值对(key-value)的映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import java.util.HashMap; public class HasnMapSample { public void sample() { //创建散列表 bottle.id -\u0026gt; bottle HashMap\u0026lt;Integer,Bottle\u0026gt; bottles = new HashMap\u0026lt;\u0026gt;(); Bottle bottle1 = new Bottle(/*parameters*/); Bottle bottle2 = new Bottle(/*parameters*/); //散列表中加入元素 mapname.put(key,value) bottles.put(12345,botttle1); bottles.put(bottle2.getID(),bottle2); //访问key值对应的value Bottle bottle = bottles.get(12345); //检查是否存在指定的key对应的映射关系 if(bottles.containsKey(12345)) { System.out.println(\u0026#34;yep\u0026#34;); } //检测是否存在指定的value对应的映射关系 if(bottles.containsValue(bottle2)) { System.out.println(\u0026#34;yep\u0026#34;); } //散列表大小 int size = bottles.size(); //遍历所有元素 for(int key : bottles.keySet()) { System.out.println(bottles.get(key).getName()); } for(Bottle value : bottles.values()) { System.out.println(value.getName()); } //删除一个映射关系 name.remove(key) // bottles.containsKey(12345) == true bottles.remove(12345); // bottles.containsKey(12345) == false //删除一个键值对 bottles.remove(bottle2.getID(),bottle2); } } 代码实现 main.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import java.util.Scanner; import java.util.HashMap; public class Main { public static void main(String [] args) { Scanner scanner = new Scanner(System.in); //读取指令条数 int opCount = Integer.parseInt(scanner.nextLine()); HashMap\u0026lt;Integer,Adventure\u0026gt; adventurers = new HashMap\u0026lt;\u0026gt;(); //构造id与对应adventure的映射 for (int i = 0;i \u0026lt; opCount;i++) { String opLine = scanner.nextLine();//整行读取字符串 Scanner opLineScannner = new Scanner(opLine); int op = opLineScannner.nextInt();//nextInt()方法读取字符串中第一个整数 int id = opLineScannner.nextInt();//读取第二个整数 if (op == 1) { //增加冒险者 String name = opLineScannner.next();//读取名字 Adventure adventurer = new Adventure(id,name); adventurers.put(id,adventurer); } else if (op == 2) { //增加药水瓶 int botId = opLineScannner.nextInt(); String botName = opLineScannner.next(); int botCapacity = opLineScannner.nextInt(); Bottle bottle = new Bottle(botId,botName,botCapacity); Adventure man = adventurers.get(id); man.addBottle(bottle); } else if (op == 3) { //删除药水瓶 int botid = opLineScannner.nextInt(); Adventure man = adventurers.get(id); Bottle bottle = man.getBottle(botid); String bottlename = bottle.getName(bottle); man.removeBottle(bottle); int bottlesnum = man.BottlesNumber(man); System.out.println(bottlesnum + \u0026#34; \u0026#34; + bottlename); } else if (op == 4) { //增加装备 int equId = opLineScannner.nextInt(); String equName = opLineScannner.next(); int equStar = opLineScannner.nextInt(); Adventure man = adventurers.get(id); Equipment equipment = new Equipment(equId,equName,equStar); man.addEquipment(equipment); } else if (op == 5) { //删除装备 int equId = opLineScannner.nextInt(); Adventure man = adventurers.get(id); Equipment equipment = man.getEquipment(equId); String equipmentName = equipment.getName(equipment); man.removeEquipment(equipment); int equipmentNumber = man.EquipmentNumber(man); System.out.println(equipmentNumber + \u0026#34; \u0026#34; + equipmentName); } else if (op == 6) { //装备升级 int equId = opLineScannner.nextInt(); Adventure man = adventurers.get(id); Equipment equipment = man.getEquipment(equId); equipment.setStar(equipment.getStar() + 1); String equipmentName = equipment.getName(equipment); int star = equipment.getStar(); System.out.println(equipmentName + \u0026#34; \u0026#34; + star); } } } } Adventure.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.util.ArrayList; public class Adventure { private int id; private String name; private ArrayList\u0026lt;Bottle\u0026gt; bottles; private ArrayList\u0026lt;Equipment\u0026gt; equipments; public Adventure(int id,String name)//构造方法 { this.id = id; this.name = name; this.bottles = new ArrayList\u0026lt;\u0026gt;(); this.equipments = new ArrayList\u0026lt;\u0026gt;(); } public void addBottle(Bottle bottle) { bottles.add(bottle); } public Bottle getBottle(int id) { for (Bottle item : bottles) { if (item.getID(item) == id) { return item; } } return null; } public void removeBottle(Bottle bottle) { bottles.remove(bottle); } public void addEquipment(Equipment equipment) { equipments.add(equipment); } public void removeEquipment(Equipment equipment) { equipments.remove(equipment); } public void addStar(Equipment equipment) { if (equipment != null) { equipment.setStar(equipment.getStar() + 1); } } public int BottlesNumber(Adventure adventure) { return adventure.bottles.size(); } public Equipment getEquipment(int id) { for (Equipment item : equipments) { if (item.getID(item) == id) { return item; } } return null; } public int EquipmentNumber(Adventure adventure) { return adventure.equipments.size(); } } Bottle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Bottle { private int id; private String name; private int capacity; public Bottle(int id,String name,int capacity)//构造方法 { this.id = id; this.name = name; this.capacity = capacity; } public int getID(Bottle bottle) { return bottle.id; } public String getName(Bottle bottle) { return bottle.name; } } Equipment.class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Equipment { private int id; private String name; private int star; public Equipment(int id,String name,int star)//构造方法 { this.id = id; this.name = name; this.star = star; } public int getStar() { return star; } public void setStar(int star) { this.star = star; } public int getID(Equipment equipment) { return equipment.id; } public String getName(Equipment equipment) { return equipment.name; } } ","permalink":"https://coder0xe.github.io/posts/oopre-hw2/","summary":"\u003ch3 id=\"oopre_hw2-第一次进行类的编写冒险者故事的开端\"\u003eOOpre_HW2 第一次进行类的编写（冒险者故事的开端）\u003c/h3\u003e\n\u003ch4 id=\"1什么是面向对象object-oriented\"\u003e1.什么是面向对象(Object Oriented)\u003c/h4\u003e\n\u003cp\u003e​\t对象能够直接反映现实生活中的事物，例如人、车、小鸟等，将其表示为程序中的对象，每个对象都有各自的状态特征（属性）以及行为特征（方法），除了可以存储数据外还可以对自身进行操作，相当于结构体与函数的封装。\u003c/p\u003e\n\u003cp\u003e​\t面向对象就是把构成问题的事物分解成一个一个的对象，建立对象不是为了实现一个步骤，而是描述某个事物在解决问题中的行为。\u003c/p\u003e\n\u003cp\u003e​\t类是面向对象中的一个很重要的概念，类是很多个具有相同属性和行为特征的对象所抽象出来的，\u003cstrong\u003e对象是类的一个实例\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4 id=\"2-oo三大特征\"\u003e2. OO三大特征\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e封装\u003c/li\u003e\n\u003cli\u003e继承\u003c/li\u003e\n\u003cli\u003e多态\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3类与对象\"\u003e3.类与对象\u003c/h4\u003e\n\u003cp\u003e​\t类表示一个共性的产物，是一个综合的产物，而对象是一个个性的产物，\u003cstrong\u003e类必须通过对象才可以使用，对象的所有操作都在类中定义\u003c/strong\u003e\u003c/p\u003e\n\u003ch5 id=\"类由属性和方法组成\"\u003e类由属性和方法组成\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e属性：特征\u003c/li\u003e\n\u003cli\u003e方法：行为\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t一个类想真正地进行操作则必须依靠对象\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//对象的定义\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclassname objectname \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003enew\u003c/span\u003e classname();\u003cspan style=\"color:#6272a4\"\u003e//所有类的对象都是通过new关键字创建\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//访问类中的属性或方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eobjectname.\u003cspan style=\"color:#50fa7b\"\u003eid\u003c/span\u003e \u003cspan style=\"color:#6272a4\"\u003e//访问属性\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eobjectname.\u003cspan style=\"color:#50fa7b\"\u003efunc\u003c/span\u003e(parameter1,parameter2)\u003cspan style=\"color:#6272a4\"\u003e//调用方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"类的编写规则\"\u003e类的编写规则\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e类必须编写在.java文件中\u003c/li\u003e\n\u003cli\u003e一个.java文件中可以存在多个类，但只能存在一个public修饰的类\u003c/li\u003e\n\u003cli\u003e.java文件名必须与public修饰的类名相同\u003c/li\u003e\n\u003cli\u003e同一个包中不能有重名的类\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"4构造方法\"\u003e4.构造方法\u003c/h4\u003e\n\u003cp\u003e​\t\u003cstrong\u003e在创建对象时，调用构造方法，所有的JAVA类中都至少存在一个构造方法（除了主类）\u003c/strong\u003e，如果一个类中没有明确的编写构造方法，编译器会自动生成一个无参的构造方法，构造方法中没有任何的代码！如果自行编写了构造方法，则编译器不会生成无参的构造方法。\u003c/p\u003e\n\u003ch5 id=\"构造方法的定义格式\"\u003e构造方法的定义格式\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e构造方法名称必须与类名相同\u003c/li\u003e\n\u003cli\u003e没有返回值类型的声明\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//创建一个对象就要调用构造方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//一个自定义构造方法的例子\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eperson\u003c/span\u003e(String name, \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e age)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#50fa7b\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e name;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ethis\u003c/span\u003e.\u003cspan style=\"color:#50fa7b\"\u003eage\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e age;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"this关键字\"\u003ethis关键字\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003ethis指当前对象\u003c/li\u003e\n\u003cli\u003e程序中非静态方法可以使用this关键字\u003c/li\u003e\n\u003cli\u003e指向当前代码运行时所处于的对象空间\u003c/li\u003e\n\u003cli\u003e引用当前对象的实例变量\u003c/li\u003e\n\u003cli\u003e目前只在构造方法中接触this关键字\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"static关键字\"\u003estatic关键字\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003estatic修饰变量为静态变量，也成称为类变量，静态变量属于类本身，而不是属于对象实例。该类的所有对象共享同一个静态变量的值，不会开辟出多块内存空间，可以通过\u0026lt;类名\u0026gt;.\u0026lt;变量名\u0026gt;来访问静态变量，但此时的变量需要被public修饰而不是private\u003c/p\u003e","title":"OOpre_HW2"},{"content":"向$ra寄存器中自动存入地址的指令 ​\t在进行编写MIPS部分矩阵转化一题时，我误以为beq等分支指令也会将下一条指令的地址存入$ra寄存器,这导致出现访存bug.\n​\t在MIPS架构的汇编指令中，只有\njal: 会将当前指令的地址存入$ra中，并跳转到目标地址执行 jalr:会将要跳转的地址存入目标寄存器，并将当前指令的地址存入$ra. beq与bne等条件分支指令则不会有将当前地址存入$ra寄存器的行为。 4560 ","permalink":"https://coder0xe.github.io/posts/mipsaddress/","summary":"\u003ch3 id=\"向ra寄存器中自动存入地址的指令\"\u003e向\u003ccode\u003e$ra\u003c/code\u003e寄存器中自动存入地址的指令\u003c/h3\u003e\n\u003cp\u003e​\t\u003cstrong\u003e在进行编写MIPS部分矩阵转化一题时，我误以为\u003ccode\u003ebeq\u003c/code\u003e等分支指令也会将下一条指令的地址存入\u003ccode\u003e$ra\u003c/code\u003e寄存器\u003c/strong\u003e,这导致出现访存bug.\u003c/p\u003e\n\u003cp\u003e​\t在MIPS架构的汇编指令中，只有\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ejal\u003c/code\u003e\u003c/strong\u003e: 会将当前指令的地址存入\u003ccode\u003e$ra\u003c/code\u003e中，并跳转到目标地址执行\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejalr\u003c/code\u003e:\u003cstrong\u003e会将要跳转的地址存入目标寄存器\u003c/strong\u003e，\u003cstrong\u003e并将当前指令的地址存入\u003ccode\u003e$ra\u003c/code\u003e\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebeq\u003c/code\u003e与\u003ccode\u003ebne\u003c/code\u003e等条件分支指令则不会有将当前地址存入\u003ccode\u003e$ra\u003c/code\u003e寄存器的行为。\u003c/li\u003e\n\u003cli\u003e4560\u003c/li\u003e\n\u003c/ul\u003e","title":"MIPS中自动存入地址的指令"},{"content":"函数调用 一.调用初印象 ​\t最早接触到函数调用是在选择排序程序中，教学视频中代码块来换回拼接导致我看了好几遍视频！ 下面附上源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 .data array: .space 400 // 申请数组空间 message_input_n: .asciiz \u0026#34;please input an integer as the length of the sequence\\n\u0026#34; message_input_array: .asciiz \u0026#34;please input an integer followed with a line breaker\\n\u0026#34; message_output_array: .asciiz \u0026#34;the sorted sequence is:\\n\u0026#34; space: .asciiz \u0026#34; \u0026#34; stack: .space 100 // 申请栈空间 .globl main // 在代码段起始位置声明main为全局符号 .text input: la $a0,message_input_n li $v0,4 syscall li $v0,5 // number of integers to be sorted syscall // the number is stored in $v0 move $t0, $v0 // set $t0 to the contents of $v0 li $t1, 0 // 循环变量 for_1_begin: slt $t2, $t1, $t0 // t2=1 if t1 \u0026lt; t0 beq $t2, $zero, for_1_end nop // 目标指令紧跟分支指令 增加延时槽防止并行性引起错误 //下面这段代码实际上是在计算存入地址 // 存入地址 = 首地址 + 循环变量 * 4 la $t2, array / 将数组首地址存入t2 li $t3, 4 mult $t3, $t1 // t3 * t1 高位存入 hi，低位存入lo 事实上一般的乘法，只要结果不超过32位，lo中的值就是完整的答案 mflo $t3 // 将lo寄存器中移动到t3（所有的move指令都相当于赋值语句，复制后原值不会改变，而不是“移动”） addu $t2, $t2, $t3 //在首地址t2基础上加上偏移量t3 la $a0,message_input_array //输出前导字符串 li $v0,4 syscall li $v0, 5 //输入数字 syscall sw $v0, 0($t2) // 从寄存器存入数组中对应的地址 这里的t2就是刚刚计算过的地址 addi $t1, $t1, 1\t// 循环变量++ j for_1_begin nop for_1_end: move $v0, $t0 jr $ra //跳回到主程序，跳转语句的下一条语句 nop //与input同理 无需多言！ output: move $t0, $a0 li $t1,0 la $a0,message_output_array li $v0,4 syscall for_2_begin: slt $t2, $t1, $t0 beq $t2, $zero, for_2_end nop la $t2, array li $t3, 4 mult $t3, $t1 mflo $t3 addu $t2, $t2, $t3 lw $a0,0($t2) li $v0,1 syscall la $a0,space li $v0,4 syscall addi $t1, $t1, 1\tj for_2_begin nop for_2_end: jr $ra nop sort: addiu $sp,$sp,-32 //向低地址移动32字节 move $t0,$a0 //此时a0值即为元素个数 li $t1,0 //循环变量 for_4_begin: slt $t2, $t1, $t0 //选择排序外层循环n-1趟 beq $t2, $zero, for_4_end nop //计算地址 la $t2, array li $t3, 4 mult $t1, $t3 mflo $t3 addu $t2, $t2, $t3 move $a0, $t0 move $a1, $t1 //父函数维护t寄存器 入栈 需要注意的是多层调用时$ra的维护 sw $t2, 28($sp) sw $t1, 24($sp) sw $t0, 20($sp) sw $ra, 16($sp) //这时的ra值需要保存 这里的ra值记录的是返回到主函数的指令地址 经过调用findmin后会变为返回到sort的地址! jal findmin //调用子函数 nop //出栈 lw $ra, 16($sp) lw $t0, 20($sp) lw $t1, 24($sp) lw $t2, 28($sp) //交换值 v0地址与t2地址处存储的值,两个寄存器分别存储 lw $t3, 0($v0) lw $t4, 0($t2) sw $t3, 0($t2) sw $t4, 0($v0) addi $t1,$t1,1 //更新循环变量 j for_4_begin nop for_4_end: addiu $sp,$sp,32 //将申请的栈空间退回，栈指针回到高地址 jr $ra //回到主程序 nop findmin: //从sort中传入 a0值为n, a1值为外层循环变量i la $t0,array sll $a0,$a0,2 subi $a0,$a0,4 //需要注意的是在 * 4的基础上需要减去4， addu $t0,$t0,$a0 //当前的地址是数组中最后一个元素的地址 lw $t1, 0($t0) // t1=a[n-1] move $t2,$t0 move $t3,$t0 // t3 = t2 = t0 = 最后一个元素地址 // a[i+1] la $t0,array sll $a1,$a1,2 addu $t0,$t0,$a1// t0此时为a[i+1]地址 for_3_begin: sge $t4,$t3,$t0 // t4 = 1 if t3 \u0026gt;= t0 beq $t4,$zero,for_3_end nop lw $t5,0($t3) // t5=a[n-1] // 进入查找时 t3为最后一个元素地址 ,t0为a[i+1]地址 //这里寻找最小值的操作实际上是从末尾开始的，先记t1=a[n-1]为最小值，之后由哨兵 t5=遍历到的值 从n-1逐步向前遍历直到 i+1 //不断更新t1的值作为新的最小值，并在t2中保存最小值地址 t3 //这里t1被设置为保存最小值 如果当前遍历的元素小于t1最小值则进入下方更新最小值操作，否则进入if_1_else,顺序进入if_1_end遍历 //下一个元素 slt $t6,$t5,$t1 // t6 = 1 if t5 \u0026lt; t1 第一次运行时 t5 = t1 直接跳转到 if_1_else beq $t6,$zero,if_1_else nop move $t1,$t5 //更新最小值 move $t2,$t3 //保存最小值在数组中的的地址 j if_1_end nop if_1_else:// if_1_else后误操作则直接执行 if_1_end 在标签之间无跳转时按照顺序执行 if_1_end: subi $t3,$t3,4 //t3从末尾向前移动一个元素，更新遍历元素 j for_3_begin nop for_3_end: move $v0,$t2 jr $ra //回到主程序 nop main: la $sp, stack addiu $sp,$sp,100 //此处sp+100是将指针向高地址移动 addiu $sp,$sp,-20 //-20向低地址移动 jal input //跳转到input nop move $t0,$v0 //回到位置 move $a0,$t0 sw $t0, 16($sp) //向高地址偏移量为16 调用者维护t寄存器，将t0入栈 jal sort nop lw $t0,16($sp) // t0出栈 move $a0,$t0 jal output nop addiu $sp,$sp,20 li $v0,10 //程序结束 syscall ​\t上述选择排序算法较为复杂，主体结构为main调用input,sort,output函数，在sort中又调用findmin子函数\n在MARS中的运行配置：\ndelayed branching initial program counter to global \u0026ldquo;main\u0026rdquo; if defined address configuration: compact ,data at address 0 ​\t需要注意的是多层函数调用时除了经典的父函数维护t寄存器，子函数维护s寄存器，还要对ra寄存器进行维护,经典的例子是在sort调用findmin过程中，$ra一开始存储的值是sort函数返回到主函数main下一条指令的地址，经过调用findmin,寄存器$ra中的值会被自动更新为findmin跳回到sort的指令地址，故需要保存跳回到main的指令地址，对$ra进行维护！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //选择排序的C语言实现 void selectSort(int k[],int n) { int i,j,d; int temp; for(i=0;i\u0026lt;n-1;i++){ d=i; for(j=i+1;j\u0026lt;n;j++){//从后n-i+1中选取 if(k[j]\u0026lt;k[d])d=j; //找到后面最小的元素 } if(d!=i)//放在排好队的序列最后面 { temp=k[d]; k[d]=k[i]; k[i]=temp; } } } 二.函数调用 ​\t对于函数调用，可以看成在函数调用的这条语句，程序跳转到函数的内容处开始执行，执行完整个函数后再跳转回到调用处向下执行，这个跳转过程可以用汇编语言中的跳转指令和标签实现。\n# function call jal function_name # function function_name: \u0026lt;function-content\u0026gt; jr $ra ​\t在这里我们的跳转指令选择jal而非j, jal = jump and link,相比j指令，jal多了将PC+4 写入$ra的过程,即记录跳转语句下一条语句的地址。当函数结束时，会返回到之前调用它的位置，并执行下一条指令。故我们常常搭配使用jal和j.\n​ 例如简单的C语言代码，计算两数相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int sum(int a, int b) { int tmp = a + b; return tmp; } int main() { int a = 2; int b = 3; int ans = sum(a, b); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ​ 翻译成汇编语言\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 .macro end li $v0,10 syscall .end_macro .text main: li $s0, 2 li $s1, 3 jal sum move $a0, $s2 li $v0,1 syscall end //marco sum: add $s2,$s0,$s1 jr $ra 三.复用代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int sum(int a, int b) { int tmp = a + b; return tmp; } int main() { int a = 2; int b = 3; int c = 4; int d = 5; int sum1 = sum(a, b); printf(\u0026#34;%d\u0026#34;, sum1); sum2 = sum(c, d); printf(\u0026#34;%d\u0026#34;, sum2); return 0; } ​\t上面的C程序，sum代码是可以进行复用的，但是在我们原来的汇编代码中，操作的寄存器是固定的，即$s0,$s1,$s2,为了复用代码（可以对其他寄存器进行操作），就必须要让一些特定寄存器作为“接收器”，对于不同的参数，都采用同一组寄存器来存储它们的值，也就是我们说的函数传参寄存器$a0.$a1,$a2,$a3,同样，对于返回值，也需要指定特定的寄存器。\n//利用宏进行代码复用 .macro end li $v0,10 syscall .end_macro .macro printStr(%Str) la $a0,%Str li $v0,4 syscall .end_macro .data space: .asciiz \u0026#34; \u0026#34; .text li $t0,1 li $t1,2 li $t2,3 li $t3,4 #传参 $a0,$a1作为桥梁作用 move $a0,$s0 move $a1,$s1 jal sum move $s4,$v0 li $v0,1 move $a0,$s4 syscall printStr(space) move $a0,$s2 move $a1,$s3 jal sum move $s5,$v0 li $v0,1 move $a0,$s5 syscall end sum: #传参 move $t0,$a0 move $t1,$a1 add $v0,$t0,$t1 jr $ra ​\t如果传参过程中$a0,$a1,$a2,$a3不够用（参数超过四个），可以利用栈$sp,将多余的参数存入内存中。\n四.避免对外界造成影响 ​\t函数还有一个重要的功能是不对函数体外的变量造成不必要的影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int sum(int a, int b) { int tmp = a + b; return tmp; } int main() { int a = 2; int b = 3; int c = 4; int sum1 = sum(a, b); int sum2 = sum(sum1, c); printf(\u0026#34;%d\u0026#34;, sum2); return 0; } ​\t汇编\n.macro end li $v0, 10 syscall .end_macro .text li $s0, 2 li $s1, 3 li $t0, 4 move $a0, $s0 #传参 move $a1, $s1 jal sum move $s4, $v0 #获得返回值 move $a0, $s4 move $a1, $t0 jal sum move $s5, $v0 li $v0, 1 move $a0, $s5 syscall end sum: #传参过程 move $t0, $a0 #t0被修改了 move $t1, $a1 #函数过程 add $v0 $t0, $t1 jr $ra ​\t这里的问题在于，$t0在主函数中存储变量值,而在sum函数中用于接受参数，改变了原来的变量值，即函数对外部产生了影响！\n​\t所以我们需要保证函数不会对外部造成影响，方法就是应用栈，利用栈来保存和恢复函数中所使用的寄存器。\n在哪里维护寄存器：\nt寄存器：在调用者中进行维护‘ s寄存器：在被调用者中进行维护 1.在调用者中进行维护 .macro end li $v0, 10 syscall .end_macro .text li $s0, 2 li $s1, 3 li $t0, 4 move $a0, $s0 #传参 move $a1, $s1 #进行维护 入栈 sw $t0, 0($sp) addi $sp, $sp, -4 jal sum #出栈 addi $sp, $sp, 4 lw $t0, 0($sp) move $s4, $v0 #获得返回值 move $a0, $s4 move $a1, $t0 sw $t0, 0($sp) #入栈 addi $sp, $sp, -4 jal sum addi $sp, $sp, 4 #出栈 lw $t0, 0($sp) move $s5, $v0 li $v0, 1 move $a0, $s5 syscall end sum: #传参过程 move $t0, $a0 move $t1, $a1 #函数过程 add $v0 $t0, $t1 jr $ra ​\t**在以上代码中，只涉及到对t寄存器的维护，故只需要在主函数中使用栈，在子函数中无需使用栈，**在发觉这一点之前，我对于主函数中对于栈指针$sp移动的操作表示迷惑，认为完全可以删去这两行代码。事实上，如果在一个参数的入栈与出栈之间没有对$sp进行任何操作，确实可以不移动$sp,但事实上，考虑到我们习惯上第一个参数入栈表达为 lw $s0 0($sp),即相对于栈指针地址没有偏移，而如果我们在子函数中这样存入，在主函数中又没有移动$sp,无疑会覆盖掉我们在那个位置上保存的参数，从而发生bug,(杠精当然可以说我会写lw $s0, 4($sp)），但这样写在主函数中维护寄存器数量很多时很费笔墨，不如移动栈指针来的简洁。当然，我们在子函数中同样需要注意栈指针的移动，在子函数结束时即使释放栈空间，防止覆写主函数中维护的参数。\n2.在被调用者中维护 .macro end li $v0, 10 syscall .end_macro .text li $s0, 2 li $s1, 3 li $t0, 4 move $a0, $s0 #传参 move $a1, $s1 jal sum move $s4, $v0 #获得返回值 move $a0, $s4 move $a1, $t0 jal sum move $s5, $v0 li $v0, 1 move $a0, $s5 syscall end sum: #入栈过程 sw $t0, 0($sp) addi $sp, $sp, -4 #传参过程 move $t0, $a0 move $t1, $a1 #函数过程 add $v0 $t0, $t1 #出栈过程 addi $sp, $sp, 4 lw $t0, 0($sp) #return jr $ra 五.嵌套函数调用 ​\t嵌套函数调用的重要意识是用栈保存$ra，以保存向外层函数的跳转，这一点我在sort程序中就有发现，还是有一定理解能力(bushi).\n​\t嵌套函数的C语言例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int sum(int a, int b) { return a + b; } int cal(int a, int b) { return a - sum(b, a); } int main() { int a = 2; int b = 3; int ans = cal(2, 3); printf(\u0026#34;%d\u0026#34;, ans); } ​\t其中cal函数嵌套调用sum函数。\n.macro end li $v0, 10 syscall .end_macro .text li $s0, 2 li $s1, 3 move $a0, $s0 move $a1, $s1 jal cal move $s5, $v0 li $v0, 1 move $a0, $s5 syscall end sum: #传参过程 move $t0, $a0 move $t1, $a1 #函数过程 add $v0, $t0, $t1 #return jr $ra cal: #传参过程 move $t0, $a0 move $t1, $a1 #调用sum的过程 move $a0, $t1 move $a1, $t0 jal sum move $t2, $v0 #运算a-sum(b, a) sub $v0, $t0, $t2 #return jr $ra #错误的地址值 造成死循环 ​\t这段代码会陷入死循环！在cal调用sum时，$ra中的值由cal跳回主函数的地址由jal指令更改为sum跳回cal的地址，因此会陷入死循环。\n​\t所以我们可以总结出：在嵌套函数调用中，一旦一个函数不是叶子函数（调用逻辑的最低端），就需要保存和恢复$ra,以能够正常一层一层向上返回。\n​\t以下为在父一级函数中对$ra进行维护的正确代码\n.macro end li $v0, 10 syscall .end_macro .text li $s0, 2 li $s1, 3 move $a0, $s0 move $a1, $s1 jal cal move $s5, $v0 li $v0, 1 move $a0, $s5 syscall end sum: #将 $t0 和 $t1 入栈 sw $t0, 0($sp) addi $sp, $sp, -4 sw $t1, 0($sp) addi $sp, $sp, -4 #传参过程 move $t0, $a0 move $t1, $a1 #函数过程 add $v0 $t0, $t1 #将 $t0 和 $t1 出栈 addi $sp, $sp, 4 lw $t1, 0($sp) addi $sp, $sp, 4 lw $t0, 0($sp) #return jr $ra cal: #将 $ra 入栈 sw $ra, 0($sp) addi $sp, $sp, -4 #传参过程 move $t0, $a0 move $t1, $a1 #调用 sum 的过程 move $a0, $t1 move $a1, $t0 jal sum move $t2, $v0 #运算a-sum(b, a) sub $v0, $t0, $t2 #将ra出栈 addi $sp, $sp, 4 lw $ra, 0($sp) #return jr $ra 六.递归函数调用 ​\t最后的部分：递归函数的汇编翻译，递归函数的本质是一个在函数体内调用自身的嵌套函数。\n​\tC语言阶乘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int factorial(int n) { if (n == 1) { return 1; } else { return n * factorial(n - 1); } } int main() { printf(\u0026#34;%d\\n\u0026#34;, factorial(5)); return 0; } ​\t汇编版本\n# 程序结束 .macro end li $v0, 10 syscall .end_macro # 从标准输入处得到一个整型变量，并存储到 %des 寄存器中 .macro getInt(%des) li $v0, 5 syscall move %des, $v0 .end_macro # 向标准输出中写入一个数据，这个数据保存在 %src 寄存器中 .macro printInt(%src) move $a0, %src li $v0, 1 syscall .end_macro # 将寄存器 %src 中的数据入栈 .macro push(%src) sw %src, 0($sp) subi $sp, $sp, 4 #入栈栈指针向低地址移动 .end_macro # 将栈顶数据出栈，并保存在 %des 寄存器中 .macro pop(%des) addi $sp, $sp, 4 # 出栈栈指针向高地址移动 lw %des, 0($sp) .end_macro .text main: getInt($s0) move $a0, $s0 jal factorial #最终结果存储在$v0中 move $s1, $v0 printInt($s1) end factorial: # 入栈 push($ra) push($t0) # 传参 move $t0, $a0 #函数过程 bne $t0, 1, else # 基准情况 if: li $v0, 1 j if_end # 递归情况 else: subi $t1, $t0, 1 move $a0, $t1 jal factorial mult $t0, $v0 mflo $v0 if_end: # 出栈 pop($t0) pop($ra) # 返回 jr $ra ​\t我们可以预想到，调用过递归函数的栈中，一定是整整齐齐的存储了一排$ra值\n","permalink":"https://coder0xe.github.io/posts/mipsfunc/","summary":"\u003ch3 id=\"函数调用\"\u003e函数调用\u003c/h3\u003e\n\u003ch4 id=\"一调用初印象\"\u003e一.调用初印象\u003c/h4\u003e\n\u003cp\u003e​\t最早接触到函数调用是在选择排序程序中，\u003cstrong\u003e教学视频中代码块来换回拼接导致我看了好几遍视频！\u003c/strong\u003e 下面附上源码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e  9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 46\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 47\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 48\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 49\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 50\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 51\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 52\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 53\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 54\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 55\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 56\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 57\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 58\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 59\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 60\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 61\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 62\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 63\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 64\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 65\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 66\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 67\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 68\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 69\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 70\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 71\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 72\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 73\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 74\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 75\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 76\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 77\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 78\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 79\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 80\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 81\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 82\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 83\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 84\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 85\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 86\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 87\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 88\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 89\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 90\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 91\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 92\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 93\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 94\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 95\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 96\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 97\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 98\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 99\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e100\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e101\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e102\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e103\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e104\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e105\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e106\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e107\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e108\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e109\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e110\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e111\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e112\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e113\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e114\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e115\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e116\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e117\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e118\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e119\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e120\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e121\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e122\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e123\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e124\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e125\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e126\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e127\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e128\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e129\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e130\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e131\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e132\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e133\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e134\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e135\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e136\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e137\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e138\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e139\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e140\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e141\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e142\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e143\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e144\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e145\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e146\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e147\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e148\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e149\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e150\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e151\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e152\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e153\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e154\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e155\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e156\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e157\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e158\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e159\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e160\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e161\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e162\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e163\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e164\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e165\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e166\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e167\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e168\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e169\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e170\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e171\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e172\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e173\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e174\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e175\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e176\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e177\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e178\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e179\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e180\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e181\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e182\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e183\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e184\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e185\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e186\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e187\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e188\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e189\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e190\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e191\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e192\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e193\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e194\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e195\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e196\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e197\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e198\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e199\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e200\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e201\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e202\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e203\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e204\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e205\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e206\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e207\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e208\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e209\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e210\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e211\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e212\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e213\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.data \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003earray\u003c/span\u003e: .space \u003cspan style=\"color:#bd93f9\"\u003e400\u003c/span\u003e \u003cspan style=\"color:#6272a4\"\u003e// 申请数组空间\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003emessage_input_n\u003c/span\u003e: .asciiz \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;please input an integer as the length of the sequence\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003emessage_input_array\u003c/span\u003e: .asciiz \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;please input an integer followed with a line breaker\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003emessage_output_array\u003c/span\u003e: .asciiz \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;the sorted sequence is:\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003espace\u003c/span\u003e: .asciiz \u003cspan style=\"color:#f1fa8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003estack\u003c/span\u003e: .space \u003cspan style=\"color:#bd93f9\"\u003e100\u003c/span\u003e \u003cspan style=\"color:#6272a4\"\u003e// 申请栈空间\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.globl main  \u003cspan style=\"color:#6272a4\"\u003e// 在代码段起始位置声明main为全局符号\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.text \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003einput\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $a0,message_input_n\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0,\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0,\u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e   \u003cspan style=\"color:#6272a4\"\u003e// number of integers to be sorted  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall    \u003cspan style=\"color:#6272a4\"\u003e// the number is stored in $v0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t0, $v0 \u003cspan style=\"color:#6272a4\"\u003e// set $t0 to the contents of $v0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $t1, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e// 循环变量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_1_begin\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    slt $t2, $t1, $t0  \u003cspan style=\"color:#6272a4\"\u003e// t2=1 if t1 \u0026lt; t0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    beq $t2, $zero, for_1_end\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop                \u003cspan style=\"color:#6272a4\"\u003e// 目标指令紧跟分支指令 增加延时槽防止并行性引起错误\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#6272a4\"\u003e//下面这段代码实际上是在计算存入地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#6272a4\"\u003e// 存入地址 = 首地址 + 循环变量 * 4\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $t2, array  \u003cspan style=\"color:#ff79c6\"\u003e/\u003c/span\u003e 将数组首地址存入t2\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $t3, \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mult $t3, $t1  \u003cspan style=\"color:#6272a4\"\u003e// t3 * t1 高位存入 hi，低位存入lo 事实上一般的乘法，只要结果不超过32位，lo中的值就是完整的答案\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mflo $t3       \u003cspan style=\"color:#6272a4\"\u003e// 将lo寄存器中移动到t3（所有的move指令都相当于赋值语句，复制后原值不会改变，而不是“移动”）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addu $t2, $t2, $t3  \u003cspan style=\"color:#6272a4\"\u003e//在首地址t2基础上加上偏移量t3\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $a0,message_input_array \u003cspan style=\"color:#6272a4\"\u003e//输出前导字符串\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0,\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0, \u003cspan style=\"color:#bd93f9\"\u003e5\u003c/span\u003e          \u003cspan style=\"color:#6272a4\"\u003e//输入数字\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $v0, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($t2)     \u003cspan style=\"color:#6272a4\"\u003e// 从寄存器存入数组中对应的地址 这里的t2就是刚刚计算过的地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addi $t1, $t1, \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\t\u003cspan style=\"color:#6272a4\"\u003e// 循环变量++\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    j for_1_begin\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_1_end\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $v0, $t0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jr $ra             \u003cspan style=\"color:#6272a4\"\u003e//跳回到主程序，跳转语句的下一条语句\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//与input同理 无需多言！\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eoutput\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t0, $a0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $t1,\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $a0,message_output_array\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0,\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_2_begin\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    slt $t2, $t1, $t0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    beq $t2, $zero, for_2_end\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $t2, array\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $t3, \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mult $t3, $t1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mflo $t3\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addu $t2, $t2, $t3\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $a0,\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($t2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0,\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $a0,space\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0,\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addi $t1, $t1, \u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    j for_2_begin\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_2_end\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jr $ra\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003esort\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addiu $sp,$sp,\u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e \u003cspan style=\"color:#6272a4\"\u003e//向低地址移动32字节\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t0,$a0   \u003cspan style=\"color:#6272a4\"\u003e//此时a0值即为元素个数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $t1,\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e//循环变量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_4_begin\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    slt $t2, $t1, $t0   \u003cspan style=\"color:#6272a4\"\u003e//选择排序外层循环n-1趟\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    beq $t2, $zero, for_4_end\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//计算地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $t2, array\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $t3, \u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mult $t1, $t3\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mflo $t3\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addu $t2, $t2, $t3\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $a0, $t0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $a1, $t1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//父函数维护t寄存器 入栈  需要注意的是多层调用时$ra的维护\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $t2, \u003cspan style=\"color:#bd93f9\"\u003e28\u003c/span\u003e($sp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $t1, \u003cspan style=\"color:#bd93f9\"\u003e24\u003c/span\u003e($sp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $t0, \u003cspan style=\"color:#bd93f9\"\u003e20\u003c/span\u003e($sp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $ra, \u003cspan style=\"color:#bd93f9\"\u003e16\u003c/span\u003e($sp) \u003cspan style=\"color:#6272a4\"\u003e//这时的ra值需要保存 这里的ra值记录的是返回到主函数的指令地址 经过调用findmin后会变为返回到sort的地址!\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jal findmin   \u003cspan style=\"color:#6272a4\"\u003e//调用子函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//出栈\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $ra, \u003cspan style=\"color:#bd93f9\"\u003e16\u003c/span\u003e($sp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t0, \u003cspan style=\"color:#bd93f9\"\u003e20\u003c/span\u003e($sp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t1, \u003cspan style=\"color:#bd93f9\"\u003e24\u003c/span\u003e($sp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t2, \u003cspan style=\"color:#bd93f9\"\u003e28\u003c/span\u003e($sp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#6272a4\"\u003e//交换值   v0地址与t2地址处存储的值,两个寄存器分别存储\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t3, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($v0)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t4, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($t2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $t3, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($t2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $t4, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($v0)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addi $t1,$t1,\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#6272a4\"\u003e//更新循环变量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    j for_4_begin\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_4_end\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addiu $sp,$sp,\u003cspan style=\"color:#bd93f9\"\u003e32\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e//将申请的栈空间退回，栈指针回到高地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jr $ra  \u003cspan style=\"color:#6272a4\"\u003e//回到主程序\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efindmin\u003c/span\u003e:  \u003cspan style=\"color:#6272a4\"\u003e//从sort中传入 a0值为n, a1值为外层循环变量i\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $t0,array\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sll $a0,$a0,\u003cspan style=\"color:#bd93f9\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    subi $a0,$a0,\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e   \u003cspan style=\"color:#6272a4\"\u003e//需要注意的是在 * 4的基础上需要减去4，\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addu $t0,$t0,$a0  \u003cspan style=\"color:#6272a4\"\u003e//当前的地址是数组中最后一个元素的地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t1, \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($t0)    \u003cspan style=\"color:#6272a4\"\u003e// t1=a[n-1]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t2,$t0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t3,$t0      \u003cspan style=\"color:#6272a4\"\u003e// t3 = t2 = t0 = 最后一个元素地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// a[i+1]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $t0,array\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sll $a1,$a1,\u003cspan style=\"color:#bd93f9\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addu $t0,$t0,$a1\u003cspan style=\"color:#6272a4\"\u003e// t0此时为a[i+1]地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_3_begin\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sge $t4,$t3,$t0 \u003cspan style=\"color:#6272a4\"\u003e// t4 = 1 if t3 \u0026gt;= t0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    beq $t4,$zero,for_3_end\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t5,\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e($t3)  \u003cspan style=\"color:#6272a4\"\u003e// t5=a[n-1]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// 进入查找时 t3为最后一个元素地址 ,t0为a[i+1]地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//这里寻找最小值的操作实际上是从末尾开始的，先记t1=a[n-1]为最小值，之后由哨兵 t5=遍历到的值 从n-1逐步向前遍历直到 i+1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//不断更新t1的值作为新的最小值，并在t2中保存最小值地址 t3\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e//这里t1被设置为保存最小值 如果当前遍历的元素小于t1最小值则进入下方更新最小值操作，否则进入if_1_else,顺序进入if_1_end遍历     //下一个元素\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    slt $t6,$t5,$t1   \u003cspan style=\"color:#6272a4\"\u003e// t6 = 1 if t5 \u0026lt; t1   第一次运行时 t5 = t1 直接跳转到 if_1_else\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    beq $t6,$zero,if_1_else\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t1,$t5   \u003cspan style=\"color:#6272a4\"\u003e//更新最小值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t2,$t3   \u003cspan style=\"color:#6272a4\"\u003e//保存最小值在数组中的的地址\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    j if_1_end\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eif_1_else\u003c/span\u003e:\u003cspan style=\"color:#6272a4\"\u003e// if_1_else后误操作则直接执行 if_1_end  在标签之间无跳转时按照顺序执行\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eif_1_end\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    subi $t3,$t3,\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e \u003cspan style=\"color:#6272a4\"\u003e//t3从末尾向前移动一个元素，更新遍历元素\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    j for_3_begin\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efor_3_end\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $v0,$t2\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jr $ra \u003cspan style=\"color:#6272a4\"\u003e//回到主程序\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003emain\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    la $sp, stack   \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addiu $sp,$sp,\u003cspan style=\"color:#bd93f9\"\u003e100\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e//此处sp+100是将指针向高地址移动\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addiu $sp,$sp,\u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e20\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e//-20向低地址移动\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jal input   \u003cspan style=\"color:#6272a4\"\u003e//跳转到input\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $t0,$v0 \u003cspan style=\"color:#6272a4\"\u003e//回到位置\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $a0,$t0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    sw $t0, \u003cspan style=\"color:#bd93f9\"\u003e16\u003c/span\u003e($sp) \u003cspan style=\"color:#6272a4\"\u003e//向高地址偏移量为16  调用者维护t寄存器，将t0入栈\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jal sort\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    lw $t0,\u003cspan style=\"color:#bd93f9\"\u003e16\u003c/span\u003e($sp) \u003cspan style=\"color:#6272a4\"\u003e// t0出栈\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    move $a0,$t0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    jal output\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    nop\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    addiu $sp,$sp,\u003cspan style=\"color:#bd93f9\"\u003e20\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    li $v0,\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e  \u003cspan style=\"color:#6272a4\"\u003e//程序结束\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    syscall\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t\u003cstrong\u003e上述选择排序算法较为复杂，主体结构为\u003ccode\u003emain\u003c/code\u003e调用\u003ccode\u003einput\u003c/code\u003e,\u003ccode\u003esort\u003c/code\u003e,\u003ccode\u003eoutput\u003c/code\u003e函数，在\u003ccode\u003esort\u003c/code\u003e中又调用\u003ccode\u003efindmin\u003c/code\u003e子函数\u003c/strong\u003e\u003c/p\u003e","title":"MIPS中的函数调用"},{"content":"MIPS编程 1.各部分寄存器的功能 $t0 ~ $t9: 临时变量 (调用者保存，否则容易丢失) $s0 ~ $s7: 保存变量(被调用者保存) $0 ：常量0，存不了数据 $at : 保留给汇编器（不可以随便用） $v0 ~ $v1 : 函数调用返回值 $a0 ~ $a3 : 函数调用参数 $sp : 栈指针 $ra : 返回地址，用于子程序的调用 2.调用子过程时对于s,t寄存器的操作 1.被调用者维护s寄存器 ​\t对于s寄存器而言，被调用者需要保证s寄存器中的值在调用前后不能发生改变， 实际操作中，如果想要编写一个子函数，那么在这个子函数中使用的所有s寄存器，都必须要在函数的开头入栈、在函数的结尾出栈，确保s寄存器的值在函数调用前后不会发生变化。\n2.调用者维护t寄存器 ​\t对于t寄存器，编写子函数中用到t寄存器的地方无需做任何保存，维护t寄存器是上层函数(调用者维护)，调用者将t寄存器压入栈中，函数调用结束之后再弹回来，只需要借助$sp指针。\n需要注意的是，对于s,t寄存器的维护都要通过在数据区开辟栈空间来实现！\n3.调用关键字 jal:跳转到子过程\njr:跳转到父过程\n4.栈的使用 过程自身需要满足栈的结构 过程调用子过程时需满足栈的结构 子过程执行前后移动栈指针 $sp MIPS中栈由高地址向低地址延申，即优先使用高地址，父过程栈帧高，子过程栈帧低 子过程的栈帧图 高地址 临时变量 ​ 返回地址 ​ 需要保存的寄存器 ​ 其他变量 低地址 参数0~3,传给子子过程($a0~$a3) 叶子函数：可以省去参数和返回地址（无子子函数）\n栈的具体使用 计算好栈帧大小 即保存这些变量需要的字节大小 栈指针减少表示向低地址移动，栈指针增加表示向高地址移动 栈指针始终指向栈顶，栈指针初始时在高地址 过程开始时分配栈空间 addiu $sp,$sp,-32（需要32字节，将栈指针向低地址移动32字节） 过程结束时回收栈空间 addiu $sp,$sp,32 以栈指针为基址进行存取 sw $t0,24($sp) ,偏移量的单位是字节 偏移量为正向高地址偏移，偏移量为负向低地址偏移 5.nop延时槽 ​\t在MIPS编程中，延时槽是指指令执行的时间间隔。当某个条件分支指令（如条件跳转、函数调用等）的目标指令紧跟在该分支指令后面时，需要插入一个延时槽指令，以免出现错误的指令结果，常用```nop```.\n​ 细说：条件分支指令的目标指令紧跟在该分支指令后面：意味着这个目标指令会在条件分支指令执行之后立即执行。\nbeq $t0, $t1, label #条件分支指令 add $t2, $t3, $t4 #目标指令紧跟在条件分支指令之后 ​\t增加nop\nbeq $t0, $t1, label nop add $t2, $t3, $t4 ​ 延迟槽的作用是保持流水线的同步，当条件分支指令的目标指令紧跟在该分支指令后面时，由于流水线执行的并行性，目标指令可能会在分支指令判断之前就开始执行。为了避免这种错误的发生，增加延迟槽指令来保证分支指令正确判断。\n6.流水线执行 ​\t流水线执行是指一种通过将指令的执行过程拆分为多个阶段并以并行的方式执行，从而提高指令执行效率，每一个阶段处理特定的任务，指令每次在不同阶段执行。我们使用的MIPS架构是一种采用了流水线执行的指令集架构。\n​\tMIPS架构中，一般将指令的执行过程划分为取指令、译码、执行、访存、写回等阶段。每条指令都会经过上述过程最后完成执行，MIPS流水线中，多条指令可以处于不同的阶段，这样就可以利用处理器的并行性提高执行速度。\n​\t延迟槽是在流水线执行中为了解决指令间可能产生的数据冲突或分支预测错误等问题而引入的技术。延迟槽是指在分支指令之后执行的一条指令，它位于分支指令之后但在实际分支发生之前。延迟槽的作用是填充流水线中由于分支发生而产生的空槽，使流水线保持正确的执行状态。在延迟槽中可以插入与分支指令无关的指令，以充分利用流水线的吞吐能力。\n7.分支-循环模板 1.分支模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .text li $t1, 100 #t1 = 100 li $t2, 200 #t2 = 200 slt $t3, $t1, $t2 #if(t1 \u0026lt; t2) t3 = 1 beq $t3, $0, if_1_else nop #do something j if_1_end #jump to end nop if_1_else: #do something else if_1_end: li $v0, 10 syscall 2.循环模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .text li $t1, 100 #n = 100 li $t2, 0 #i for_begin1: #for (int i = 0; i \u0026lt; n; i++) slt $t3, $t2, $t1 #{ beq $t3, $0, for_end1 nop #do something addi $t2, $t2, 1 #i++ j for_begin1 nop #} for_end1: li $v0, 10 syscall ","permalink":"https://coder0xe.github.io/posts/mipcoding/","summary":"\u003ch3 id=\"mips编程\"\u003eMIPS编程\u003c/h3\u003e\n\u003ch4 id=\"1各部分寄存器的功能\"\u003e1.各部分寄存器的功能\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e$t0 ~ $t9\u003c/code\u003e: 临时变量 (调用者保存，否则容易丢失)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$s0 ~ $s7\u003c/code\u003e: 保存变量(被调用者保存)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$0\u003c/code\u003e ：常量0，存不了数据\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$at\u003c/code\u003e : 保留给汇编器（不可以随便用）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$v0 ~ $v1\u003c/code\u003e : 函数调用返回值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$a0 ~ $a3\u003c/code\u003e : 函数调用参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$sp\u003c/code\u003e : 栈指针\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$ra\u003c/code\u003e : 返回地址，用于子程序的调用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2调用子过程时对于st寄存器的操作\"\u003e2.调用子过程时对于s,t寄存器的操作\u003c/h4\u003e\n\u003ch5 id=\"1被调用者维护s寄存器\"\u003e1.被调用者维护s寄存器\u003c/h5\u003e\n\u003cp\u003e​\t 对于s寄存器而言，被调用者需要保证s寄存器中的值在调用前后不能发生改变， 实际操作中，如果想要编写一个子函数，那么在这个子函数中使用的所有s寄存器，都必须要在函数的开头入栈、在函数的结尾出栈，确保s寄存器的值在函数调用前后不会发生变化。\u003c/p\u003e\n\u003ch5 id=\"2调用者维护t寄存器\"\u003e2.调用者维护t寄存器\u003c/h5\u003e\n\u003cp\u003e​\t 对于t寄存器，编写子函数中用到t寄存器的地方无需做任何保存，维护t寄存器是上层函数(调用者维护)，调用者将t寄存器压入栈中，函数调用结束之后再弹回来，只需要借助\u003ccode\u003e$sp\u003c/code\u003e指针。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e需要注意的是，对于s,t寄存器的维护都要通过在数据区开辟栈空间来实现！\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"3调用关键字\"\u003e3.调用关键字\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ejal\u003c/code\u003e:跳转到子过程\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ejr\u003c/code\u003e:跳转到父过程\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"4栈的使用\"\u003e4.栈的使用\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e过程自身需要满足栈的结构\u003c/li\u003e\n\u003cli\u003e过程调用子过程时需满足栈的结构\u003c/li\u003e\n\u003cli\u003e子过程执行前后移动栈指针 \u003ccode\u003e$sp\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eMIPS中栈由高地址向低地址延申，即优先使用高地址，父过程栈帧高，子过程栈帧低\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"子过程的栈帧图\"\u003e子过程的栈帧图\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e高地址       临时变量\u003c/li\u003e\n\u003cli\u003e​                   返回地址\u003c/li\u003e\n\u003cli\u003e​                   需要保存的寄存器\u003c/li\u003e\n\u003cli\u003e​                   其他变量\u003c/li\u003e\n\u003cli\u003e低地址     参数0~3,传给子子过程\u003ccode\u003e($a0~$a3)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e叶子函数：可以省去参数和返回地址（无子子函数）\u003c/strong\u003e\u003c/p\u003e\n\u003ch5 id=\"栈的具体使用\"\u003e栈的具体使用\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e计算好栈帧大小 即保存这些变量需要的字节大小\u003c/li\u003e\n\u003cli\u003e栈指针减少表示向低地址移动，栈指针增加表示向高地址移动\u003c/li\u003e\n\u003cli\u003e栈指针始终指向栈顶，栈指针初始时在高地址\u003c/li\u003e\n\u003cli\u003e过程开始时分配栈空间 \u003ccode\u003eaddiu $sp,$sp,-32\u003c/code\u003e（需要32字节，将栈指针向低地址移动32字节）\u003c/li\u003e\n\u003cli\u003e过程结束时回收栈空间 \u003ccode\u003eaddiu $sp,$sp,32\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e以栈指针为基址进行存取\u003ccode\u003e sw $t0,24($sp)\u003c/code\u003e ,偏移量的单位是字节 偏移量为正向高地址偏移，偏移量为负向低地址偏移\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"5nop延时槽\"\u003e5.\u003ccode\u003enop\u003c/code\u003e延时槽\u003c/h4\u003e\n\u003cp\u003e​\t\u003cstrong\u003e在MIPS编程中，延时槽是指指令执行的时间间隔。当某个条件分支指令（如条件跳转、函数调用等）的目标指令紧跟在该分支指令后面时，需要插入一个延时槽指令，以免出现错误的指令结果，常用```nop``\u003c/strong\u003e`.\u003c/p\u003e","title":"MIPS基础编程"},{"content":"COpre——MIPS汇编指令与机器码、内存 ​\t在笔者进行COpre中MIPS部分的学习时，对于MIPS指令及其机器码转换，MIPS对应的内存计算等等感到十分头痛，这一篇文章主要目的是零碎的记录一些知识。\n一. 数制 ​\t在计组学习中最常用到的数值即为二进制(binary/BIN)和十六进制(hexadecimal/HEX),例如MIPS汇编指令机器码用二进制表示，而计算机内存的表示通常为十六进制。一位十六进制数相当于四位二进制数。一位二进制数通常又称为比特位(bit),关联出计算机系统中经典的换算关系。\n​ 在32位系统中：\n1字节(byte)=8比特位(bit) 计算机中最小的寻址单位即为字节/B 1个字(word)=4字节(byte)=32bits 即一个字就是32位，同样64位系统中一个字是64位 1KB=1024B 计算机中K的概念是2^10即1024 1MB=1024KB 1G=1024MB 二. 浅析MIPS架构 ​\tMIPS是一种经典的RISC架构，具有精简的指令集，32位定长指令，五级流水线，延迟槽，32个通用寄存器等特点。这里我们主要谈及32位定长指令、32个通用寄存器、指令集等内容，其他的部分会在日后涉及。这里需要特殊说明的是我们的MIPS是32位系统\n1.32位定长编码 ​\t定长指令的优点是简化指令解析，减少解析时间。但同样的，由于指令为定长32位，这对于内存是不友好的。我们在写MIPS汇编程序时，编写的每一行指令代码均为32位，四个字节，一个字。这里指令具体的分为R型、I型、J型指令\nR型指令(register type)\nR型指令用于寄存器之间的操作，常用于算术运算、逻辑操作和寄存器之间的数据传输，如add,sub.and.or等。\nI型指令(immediate type)\n​\tI型指令用于立即数(常数)与寄存器之间的操作，通常用于家在常熟、内存读写、分支跳转等操作。例如,addi,lw,sw,beq等指令\nJ型指令(jump type)\n​\tJ型指令用于无条件跳转到目标地址，常用于函数调用、循环跳转等控制流程的修改。例如,j,jar指令。\n对于以上指令，我们只需要记住他们都占32位，4个字节，其他的具体用法详见《MIPS-C指令集》。\n​\n2.32个通用寄存器 ​\tMIPS寄存器是32位寄存器，每个部分的功能如图所示\n​\t需要注意的是，每个寄存器既可以用名字表示，也可以用编号表示，如**$to\u0026lt;==\u0026gt;$8**。\n3.特殊寄存器 1. HI(high)与LO(low) ​\tHI与LO是MIPS中用于处理乘除法的特殊寄存器，在MIPS汇编指令中，乘除法指令的结果最多为64位，夫需要设置特殊寄存器进行保存。在乘法中，HI保存高32位，LO保存低32位;在除法中HI保存余数，LO保存商。\n2.PC程序计数器 ​\tPC(program counter)程序计数器，是计算机系统中的一个寄存器，用于存储下一条指令的地址。程序计数器指向执行中的指令的内存地址，当处理器执行完当前指令后会自动将程序计数器的值增加，使其指向下一条指令的地址。具体地，在MIPS汇编指令中，每执行完一条指令 PC=PC+4,这是由于在MIPS中每一条指令所占的内存空间都是4个字节。程序计数器的初始值一般为程序的入口地址（首条指令的地址 最常见的为0x0000_3000)。同时分支指令也可以使程序计数器进行跳转。总的来说，PC相当于程序运行中的内存监控，通过PC可以了解程序的流程。\n1 2 3 4 5 6 7 8 9 //在我翻阅 MIPS-C指令集时，发现了如下出场率极高的代码 //BEQ: beq rs,rt,offset //描述：if rs==rt then 转移 //以BEQ：相等时转移为例，功能的C语言描述为 if(GPR[rs]==GPR[rt]) PC=PC+4+sign_extend(offset||0^2);//代表在offset后补两位0 即乘四 else PC=PC+4; //我们可以发现，该指令至少会进行一条语句的跳转(四个字节),这也是我查询PC的起始 三.COpre中提供的部分题目具体分析 1.下列指令中需要在立即数后拼接两位0的是 1 答案： beq $s2,$s3,4 在立即数后拼接两位0，即将原立即数向左移动两位，立即数4，代表着按4对齐。在beq中，立即数n的意义是跳转到第n条指令，而实际操作中，一条指令占用四字节，地址访存的话需要跳转4n字节，所以需要拼接两位0。\n2.与上一题类似的beq计算next立即数 1 2 3 4 5 ori $t0,$0,4 bne $t0,$t1,next nop//no operation 占位符指令，不执行任何内容 next: sw $t0, 4($t1) ​\t功能分析：beq:相等时跳转，bne:不相等时跳转,在此题目中，当$t0与$t1不相等时跳转到next标签，我们之前在《MIPS-C》中发现了bne的C代码\n1 2 3 4 if(GRF[rs]!=GRF[rt]) PC=PC+4+sign_extend(nest|0^2); else PC=PC+4; 可以知道，无论如何PC计数器都会+4,即向前迈出一条指令，这里next可以增加移动的指令数，在此题目中，可以发现，跳转到next标签需要跳两条语句，故next==1.此题的原型为表示16进制的八位机器码(32位二进制==8位十六进制，用电脑内置的计算器即可将首先得到的32位机器码转换为8位十六进制)。关于机器码只需要进行查表即可。\n3.下列操作过程中，需要将立即数进行符号扩展的是 1 2 3 4 5 1. beq $s2, $s3, 4 2. lw $s2, 4($s3) 3. addi $s2, $s3, 4 //拓展说明：temp\u0026lt;- (GPR[rs]||GPR[rs]31..0)+ sign_extend(immediate) 符号扩展 4. sltiu $s1, $s2, 0x8888 ​\t**通过R,I,J指令的结构可知，立即数通常是没有32位的，在有些指令中为26位，在有些指令中为16位。**而在ALU运算及读写存储等等操作都需要32位，所以需要将立即数拓展到32位，MIPS指令手册规定了每条指令的拓展方式(符号扩展/0扩展)。\n4.下列操作过程中，需要将立即数无符号扩展的是 1 2 ori $s2, $s3, 4 //拓展说明： GPR[rt]\u0026lt;-GPR[rs] or zero_extend(immediate) 无符号扩展 以上两题均可以通过查英文版MIPS指令解决（MIPS-C过于简略），只需要查看Operation一栏\n5.下列指令中属于R型的是 1 2 sub $s2, $s2, $s2 jarl $s0, $a0 需要注意的是：不是所有j开头的指令都是J型，jarl为R型指令，最好分辨的是I型指令，在指令当中有立即数\n查表时分表R、I、J型指令的方法：看32位数据分割，\nR：6+5+5+5++5+6 I：6+5+5+16 J: 6+26 6.汇编代码流程分析 1.例一jal-jr 程序结束时 a2=0x00003001\njal指令用于跳转到目标地址，并将jal指令的下一条指令的地址存储到ra中，jr用于跳转到一个寄存器中存储的目标地址\n1 2 3 4 5 6 7 8 9 10 11 12 //程序的第一条指令的地址为0x0000_3000 ori $a0, $0, 1 jal loop //跳转到loop标签处，这里loop在编译时转换为立即数 add $a2, $a2, $a0 // 地址为0x0000_3008 即ra=0x0000_3008 li $v0, 10 syscall//最后两行为程序结束 loop: sll $a1, $a0, 3// a1=a0\u0026lt;\u0026lt;3 (a0*8) sub $a2, $ra,$a1// a2=ra-a1 jr $ra //在执行jar跳转时，会将jal的下一条语句地址存入ra,此时跳回add一行 add $a2, $a1, $a0//未被执行 2.例二bne指令 程序结束时 a2=2\n1 2 3 4 5 6 7 8 9 10 ori $a0,$0,1 ori $a1,$0,10 ori $a2,$0,20 loop: addi $a0,$a0,1 addi $a2,$a2,-2 bne $a0,$a1,loop //循环条件 a0!=a1 继续跳回标签为loop处 nop li $v0,10 syscall 7.load-store指令功能测试 1 2 3 4 5 6 7 8 9 10 11 12 13 //在一个小端存储CPU中执行以下指令 t0 t1 t2寄存器中的值为多少 li $a0, 0x12345678 li $s0, 0x00001000 sw $a0, 0($s0)//向以s0中存储的数为基地址(0x1000)偏移量为0的地址,store word,即存储四个字节，将a0全部存入(0x1000为起始地址，低地址)，$a0中的数为4byte。对应内存中也需要4byte. // 0x1000 存储 0x78 // 0x1001 存储 0x56 // 0x1002 存储 0x34 // 0x1003 存储 0x12 lb $t0, 1($s0)//t0=0x56 sb $a0, 2($s0)// s0偏移两个字节-\u0026gt;0x1002地址上sb(store byte) 0x34-\u0026gt;0x78 lw $t1, 0($s0)// load word 存储一个字 即为s0后4byte的值 t1=0x12785678 sh $a0, 2($s0)// sh(store halfword) 0x1002存储两个byte a0后两个byte存储到 0x1002 0x1003 lw $t2, 0($s0)// load word 经过以上操作 s0处开始存储的完整数为0x56785678 即为t2值 小端存储：数据的低位放在低地址，高位放在高地址；大端存储相反，这里面第一离谱的事情是li是MIPS扩展指令，而不是汇编指令，这导致我在MIPS指令集中查无此人。li扩展指令的含义为为寄存器赋值\n1 li $a0,100//将100赋给a0寄存器 内存中每个单元只能存储一个字节，这导致初始时的a0被分成四个部分存储。\n易混淆点：物理地址与内存地址\n内存地址是对内存单元的编号（可以理解为门牌号），计算机中最小的寻址单位即内存单元为1byte，物理地址是真实的物理内存的地址\n我们以上提及的0x1000与0x1001都是指内存地址（计算机中常用16进制表示内存地址），每两个内存地址之间的物理地址差异为一个字节。将以上内存地址与物理地址可以用图画联系起来,在每一个门牌号下都有一个大小为1byte的空间。\n1 2 3 4 0x1000 : 0000_0000 0x1001 : 0000_0000 0x1002 : 0000_0000 0x1003 : 0000_0000 8.跳转指令范围 j指令只有26位用于存储到跳转的地址，那么j指令能够跳转到的代码范围有多大？ 1 2 3 2^26=64M 但是J指令有低位补00的拓展（即表示的是64M条指令，而不是64MB），所以应当表示256MB大小的代码 j 指令是 PC 相关的转移指令。当把 4GB 划分为 16 个 256MB 区域，j 指令可以在当前PC 所在的 256MB 区域内任意跳转。 jr指令可以跳转的代码范围有多大？ 1 2 jr跳转到的是寄存器(32位)中的值(jump to register)，如之前的例子中 jr ra 4 * 2^10 * 2^10 * 2^10 但是没有低位拓展，所以表示4GB代码大小。 beq指令可以跳转的代码范围有多大？ 1 beq地址立即数为16位，2^16=64k条指令，即256KB大小 (2^10=1k) 由此可以知道 在operation部分出现|0^2意味着左移位两位，代表的是指令\n9.数据溢出 1 addi $a0, $0, 0x8165 addi指令中，immediate是一个有符号的16位数，即原数最多15位，但是0x8165是16位数。\n","permalink":"https://coder0xe.github.io/posts/mipwithmemory/","summary":"\u003ch2 id=\"copremips汇编指令与机器码内存\"\u003eCOpre——MIPS汇编指令与机器码、内存\u003c/h2\u003e\n\u003cp\u003e​\t\u003cstrong\u003e在笔者进行COpre中MIPS部分的学习时，对于MIPS指令及其机器码转换，MIPS对应的内存计算等等感到十分头痛\u003c/strong\u003e，这一篇文章主要目的是零碎的记录一些知识。\u003c/p\u003e\n\u003ch3 id=\"一-数制\"\u003e一. 数制\u003c/h3\u003e\n\u003cp\u003e​\t在计组学习中最常用到的数值即为二进制(binary/BIN)和十六进制(hexadecimal/HEX),例如MIPS汇编指令机器码用二进制表示，而计算机内存的表示通常为十六进制。一位十六进制数相当于四位二进制数。一位二进制数通常又称为比特位(bit),关联出计算机系统中经典的换算关系。\u003c/p\u003e\n\u003cp\u003e​    在32位系统中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1字节(byte)=8比特位(bit) \u003cstrong\u003e计算机中最小的寻址单位即为字节/B\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e1个字(word)=4字节(byte)=32bits \u003cstrong\u003e即一个字就是32位，同样64位系统中一个字是64位\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e1KB=1024B\u003c/strong\u003e 计算机中K的概念是2^10即1024\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e1MB=1024KB\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e1G=1024MB\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"二-浅析mips架构\"\u003e二. 浅析MIPS架构\u003c/h3\u003e\n\u003cp\u003e​\tMIPS是一种经典的RISC架构，具有精简的指令集，32位定长指令，五级流水线，延迟槽，32个通用寄存器等特点。这里我们主要谈及32位定长指令、32个通用寄存器、指令集等内容，其他的部分会在日后涉及。\u003cstrong\u003e这里需要特殊说明的是我们的MIPS是32位系统\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"132位定长编码\"\u003e1.32位定长编码\u003c/h4\u003e\n\u003cp\u003e​\t定长指令的优点是简化指令解析，减少解析时间。但同样的，由于指令为定长32位，这对于内存是不友好的。我们在写MIPS汇编程序时，编写的每一行指令代码均为32位，四个字节，一个字。\u003cstrong\u003e这里指令具体的分为R型、I型、J型指令\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"RIJ\" loading=\"lazy\" src=\"/img/RIJ.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eR型指令(register type)\u003c/p\u003e\n\u003cp\u003eR型指令用于寄存器之间的操作，常用于算术运算、逻辑操作和寄存器之间的数据传输，如add,sub.and.or等。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eI型指令(immediate type)\u003c/p\u003e\n\u003cp\u003e​\tI型指令用于立即数(常数)与寄存器之间的操作，通常用于家在常熟、内存读写、分支跳转等操作。例如,addi,lw,sw,beq等指令\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eJ型指令(jump type)\u003c/p\u003e\n\u003cp\u003e​\tJ型指令用于无条件跳转到目标地址，常用于函数调用、循环跳转等控制流程的修改。例如,j,jar指令。\u003c/p\u003e\n\u003cp\u003e对于以上指令，\u003cstrong\u003e我们只需要记住他们都占32位，4个字节\u003c/strong\u003e，其他的具体用法详见《MIPS-C指令集》。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\u003c/p\u003e\n\u003ch4 id=\"232个通用寄存器\"\u003e2.32个通用寄存器\u003c/h4\u003e\n\u003cp\u003e​\tMIPS寄存器是32位寄存器，每个部分的功能如图所示\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"通用寄存器\" loading=\"lazy\" src=\"/img/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8.png\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t需要注意的是，\u003cstrong\u003e每个寄存器既可以用名字表示，也可以用编号表示\u003c/strong\u003e，如**$to\u0026lt;==\u0026gt;$8**。\u003c/p\u003e\n\u003ch4 id=\"3特殊寄存器\"\u003e3.特殊寄存器\u003c/h4\u003e\n\u003ch5 id=\"1-hihigh与lolow\"\u003e1. HI(high)与LO(low)\u003c/h5\u003e\n\u003cp\u003e​\tHI与LO是MIPS中用于处理乘除法的特殊寄存器，在MIPS汇编指令中，乘除法指令的结果最多为64位，夫需要设置特殊寄存器进行保存。\u003cstrong\u003e在乘法中，HI保存高32位，LO保存低32位;在除法中HI保存余数，LO保存商。\u003c/strong\u003e\u003c/p\u003e\n\u003ch5 id=\"2pc程序计数器\"\u003e2.PC程序计数器\u003c/h5\u003e\n\u003cp\u003e​\tPC(program counter)程序计数器，是计算机系统中的一个寄存器，用于存储下一条指令的地址。程序计数器指向执行中的指令的内存地址，当处理器执行完当前指令后会自动将程序计数器的值增加，使其指向下一条指令的地址。\u003cstrong\u003e具体地，在MIPS汇编指令中，每执行完一条指令 PC=PC+4\u003c/strong\u003e,这是由于在MIPS中每一条指令所占的内存空间都是4个字节。\u003cstrong\u003e程序计数器的初始值一般为程序的入口地址\u003c/strong\u003e（首条指令的地址 最常见的为0x0000_3000)。同时分支指令也可以使程序计数器进行跳转。\u003cstrong\u003e总的来说，PC相当于程序运行中的内存监控，通过PC可以了解程序的流程\u003c/strong\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//在我翻阅 MIPS-C指令集时，发现了如下出场率极高的代码\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//BEQ: beq rs,rt,offset\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//描述：if rs==rt then 转移\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//以BEQ：相等时转移为例，功能的C语言描述为\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(GPR[rs]\u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003eGPR[rt])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PC\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ePC\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#50fa7b\"\u003esign_extend\u003c/span\u003e(offset\u003cspan style=\"color:#ff79c6\"\u003e||\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e^\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e2\u003c/span\u003e);\u003cspan style=\"color:#6272a4\"\u003e//代表在offset后补两位0 即乘四\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    PC\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ePC\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//我们可以发现，该指令至少会进行一条语句的跳转(四个字节),这也是我查询PC的起始\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"三copre中提供的部分题目具体分析\"\u003e三.COpre中提供的部分题目具体分析\u003c/h3\u003e\n\u003ch4 id=\"1下列指令中需要在立即数后拼接两位0的是\"\u003e1.下列指令中需要在立即数后拼接两位0的是\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e答案： beq $s2,$s3,\u003cspan style=\"color:#bd93f9\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e在立即数后拼接两位0，即将原立即数向左移动两位，立即数\u003cem\u003e4，代表着按4对齐。在beq中，\u003cstrong\u003e立即数n的意义是跳转到第n条指令\u003c/strong\u003e，而实际操作中，一条指令占用四字节，地址访存的话需要跳转4\u003c/em\u003en字节，所以需要拼接两位0。\u003c/p\u003e","title":"MIPS与计算机内存"},{"content":"MIPS代码的基本语法 1. .data数据段 1 2 3 .data fibs: .space 48 size: .word 12 ​\t在数据段进行变量的定义,\u0026lt;变量名\u0026gt; : .\u0026lt;伪指令\u0026gt; \u0026lt;变量内容\u0026gt;\n2. .test代码段 ​\t定义程序的代码段，指令后为代码\n1 2 .test add $t0,\u0026amp;t1,$t2 3. .macro ​\t使用宏可以避免相同代码多次复用\n不带参数定义的宏 macro \u0026lt;macro_name\u0026gt; # # # .end_macro 常用的场景是可以替换程序结束的两行代码\n1 2 li $v0,10 syscall 如果我们定义出代表这两行定义的宏\n1 2 3 4 macro DONE li $v0,10 syscall .end_macro 这样我们在需要调用这两行代码的时候只需一行\nDONE #而且这样对于代码的含义理解还更加清晰 带参数定义的宏 这样的宏适用于一段结构相似的代码，只有变量名需要变动的情形,其中参数的形式为 %\u0026lt;parameter_name\u0026gt;.例如斐波那契中的例子\n1 2 3 4 5 .macro \u0026lt;macro_name\u0026gt; (%parameter1, %parameter2, ...) # # # .end_macro 例如矩阵乘法\n1 2 3 4 5 .macro getindex(%ans, %i, %j) sll %ans, %i, 3 add %ans, %ans, %j sll %ans, %ans, 2 .end_macro 4. .eqv 用于定义常量数字\n1 .eqv \u0026lt;name\u0026gt; \u0026lt;value\u0026gt; ","permalink":"https://coder0xe.github.io/posts/mipssyn/","summary":"\u003ch2 id=\"mips代码的基本语法\"\u003eMIPS代码的基本语法\u003c/h2\u003e\n\u003ch4 id=\"1-data数据段\"\u003e1. .data数据段\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.data\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003efibs\u003c/span\u003e: .space \u003cspan style=\"color:#bd93f9\"\u003e48\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd;font-style:italic\"\u003esize\u003c/span\u003e: .word \u003cspan style=\"color:#bd93f9\"\u003e12\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​\t\u003cstrong\u003e在数据段进行变量的定义,\u0026lt;变量名\u0026gt; :  .\u0026lt;伪指令\u0026gt;  \u0026lt;变量内容\u0026gt;\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"2-test代码段\"\u003e2. .test代码段\u003c/h4\u003e\n\u003cp\u003e​\t\u003cstrong\u003e定义程序的代码段，指令后为代码\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.test\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e add $t0,\u003cspan style=\"color:#ff79c6\"\u003e\u0026amp;\u003c/span\u003et1,$t2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"3-macro\"\u003e3. .macro\u003c/h4\u003e\n\u003cp\u003e​\t\u003cstrong\u003e使用宏可以避免相同代码多次复用\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e不带参数定义的宏\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emacro  \u0026lt;macro_name\u0026gt;\n#\n#\n#\n.end_macro\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e常用的场景是可以替换程序结束的两行代码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eli $v0,\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esyscall\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果我们定义出代表这两行定义的宏\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emacro DONE\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eli $v0,\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esyscall\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e.end_macro\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这样我们在需要调用这两行代码的时候只需一行\u003c/p\u003e","title":"MIPS基本语法"},{"content":"MIPS中使用数组 1.一维数组 ​\t数组存储需要申请内存空间\n.data array: .space 40 # 存储这些数需要用到数组，数组需要使用 10 * 4 = 40 字节 # 一个 int 整数需要占用 4 个字节，需要存储 10 个 int 整数 # 因此，array[0] 的地址为 0x00，array[1] 的地址为 0x04 # array[2] 的地址为 0x08，以此类推。 str: .asciiz \u0026#34;The numbers are:\\n\u0026#34; space: .asciiz \u0026#34; \u0026#34; .text li $v0,5 syscall # 输入一个整数 move $s0, $v0 # $s0 is n li $t0, 0 # $t0 循环变量 loop_in: beq $t0, $s0, loop_in_end # $t0 == $s0 的时候跳出循环 li $v0, 5 syscall # 输入一个整数 sll $t1, $t0, 2 # $t1 = $t0 \u0026lt;\u0026lt; 2，即 $t1 = $t0 * 4 sw $v0, array($t1) # 把输入的数存入地址为 array + $t1 的内存中 addi $t0, $t0, 1 # $t0 = $t0 + 1 j loop_in # 跳转到 loop_in loop_in_end: la $a0, str li $v0, 4 syscall # 输出提示信息 li $t0, 0 loop_out: beq $t0, $s0, loop_out_end sll $t1, $t0, 2 # $t1 = $t0 \u0026lt;\u0026lt; 2，即 $t1 = $t0 * 4 lw $a0, array($t1) # 把内存中地址为 array + $t1 的数取出到 $a0 中 li $v0, 1 syscall # 输出 $a0 la $a0, space li $v0, 4 syscall # 输出一个空格 addi $t0, $t0, 1 j loop_out loop_out_end: li $v0, 10 syscall # 结束程序 2.二维数组 .data matrix: .space 256 # int matrix[8][8] 8*8*4 字节 # matrix[0][0] 的地址为 0x00，matrix[0][1] 的地址为 0x04，…… # matrix[1][0] 的地址为 0x20，matrix[1][1] 的地址为 0x24，…… # …… str_enter: .asciiz \u0026#34;\\n\u0026#34; str_space: .asciiz \u0026#34; \u0026#34; # 这里使用了宏，%i 为存储当前行数的寄存器，%j 为存储当前列数的寄存器 # 把 (%i * 8 + %j) * 4 存入 %ans 寄存器中 .macro getindex(%ans, %i, %j) sll %ans, %i, 3 # %ans = %i * 8 add %ans, %ans, %j # %ans = %ans + %j sll %ans, %ans, 2 # %ans = %ans * 4 .end_macro .text li $v0, 5 syscall move $s0, $v0 # 行数 li $v0, 5 syscall move $s1, $v0 # 列数 # 这里使用了循环嵌套 li $t0, 0 # $t0 是一个循环变量 in_i: # 这是外层循环 beq $t0, $s0, in_i_end li $t1, 0 # $t1 是另一个循环变量 in_j: # 这是内层循环 beq $t1, $s1, in_j_end li $v0, 5 syscall # 注意一下下面几行，在 Execute 页面中 Basic 列变成了什么 getindex($t2, $t0, $t1) # 这里使用了宏，就不用写那么多行来算 ($t0 * 8 + $t1) * 4 了 sw $v0, matrix($t2) # matrix[$t0][$t1] = $v0 addi $t1, $t1, 1 j in_j in_j_end: addi $t0, $t0, 1 j in_i in_i_end: # 这里使用了循环嵌套，和输入的时候同理 li $t0, 0 out_i: beq $t0, $s0, out_i_end li $t1, 0 out_j: beq $t1, $s1, out_j_end getindex($t2, $t0, $t1) lw $a0, matrix($t2) # $a0 = matrix[$t0][$t1] li $v0, 1 syscall la $a0, str_space li $v0, 4 syscall # 输出一个空格 addi $t1, $t1, 1 j out_j out_j_end: la $a0, str_enter li $v0, 4 syscall # 输出一个回车 addi $t0, $t0, 1 j out_i out_i_end: li $v0, 10 syscall 事实上，在做矩阵转化一题时，我用了利用一维数组模拟二维数组\n.data array: .space 10000 space: .asciiz \u0026#34; \u0026#34; enter: .asciiz \u0026#34;\\n\u0026#34; .text li $v0,5 # n syscall move $t0,$v0 addu $a1,$t0,$zero # a1 is row_counter li $v0,5 # m syscall move $t1,$v0 addu $a2,$t1,$zero # a2 is col_counter add $a3,$a2,$zero # calcultate row and col li $t2,0 # i mult $t0, $t1 mflo $t3 # m*n input: beq $t2, $t3, output li $v0,5 syscall sll $t4, $t2, 2 sw $v0, array($t4) addi $t2, $t2, 1 j input output: beq $t3, $zero, output_end beq $a3,$zero,if_1_else # equals to 1 col ; row-- sll $t4,$t3,2 subi $t4,$t4,4 lw $t5, array($t4) beq $t5,$zero,if_2_else add $a0,$a1,$zero li $v0,1 syscall la $a0,space li $v0,4 syscall add $a0,$a3,$zero li $v0,1 syscall la $a0,space li $v0,4 syscall add $a0,$t5,$zero li $v0,1 syscall la $a0,enter li $v0,4 syscall subi $a3,$a3,1 subi $t3,$t3,1 j output if_1_else: # row-- col_reset subi $a1,$a1,1 add $a3,$zero,$a2 j output if_2_else: subi $a3,$a3,1 subi $t3,$t3,1 j output output_end: li $v0,10 syscall ","permalink":"https://coder0xe.github.io/posts/mipsarray/","summary":"\u003ch3 id=\"mips中使用数组\"\u003eMIPS中使用数组\u003c/h3\u003e\n\u003ch4 id=\"1一维数组\"\u003e1.一维数组\u003c/h4\u003e\n\u003cp\u003e​\t\u003cstrong\u003e数组存储需要申请内存空间\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.data\narray: .space 40           # 存储这些数需要用到数组，数组需要使用 10 * 4 = 40 字节\n                           # 一个 int 整数需要占用 4 个字节，需要存储 10 个 int 整数\n                           # 因此，array[0] 的地址为 0x00，array[1] 的地址为 0x04\n                           # array[2] 的地址为 0x08，以此类推。\n\nstr:   .asciiz \u0026#34;The numbers are:\\n\u0026#34;\nspace: .asciiz \u0026#34; \u0026#34;\n\n.text\nli $v0,5\nsyscall                    # 输入一个整数\nmove $s0, $v0              # $s0 is n\nli $t0, 0                  # $t0 循环变量\n\nloop_in:\nbeq $t0, $s0, loop_in_end  # $t0 == $s0 的时候跳出循环\nli $v0, 5\nsyscall                    # 输入一个整数\nsll $t1, $t0, 2            # $t1 = $t0 \u0026lt;\u0026lt; 2，即 $t1 = $t0 * 4\nsw $v0, array($t1)         # 把输入的数存入地址为 array + $t1 的内存中\naddi $t0, $t0, 1           # $t0 = $t0 + 1\nj loop_in                  # 跳转到 loop_in\n\nloop_in_end:\nla $a0, str\nli $v0, 4\nsyscall                    # 输出提示信息\nli $t0, 0\nloop_out:\nbeq $t0, $s0, loop_out_end\nsll $t1, $t0, 2            # $t1 = $t0 \u0026lt;\u0026lt; 2，即 $t1 = $t0 * 4\nlw $a0, array($t1)         # 把内存中地址为 array + $t1 的数取出到 $a0 中\nli $v0, 1\nsyscall                    # 输出 $a0\nla $a0, space\nli $v0, 4\nsyscall                    # 输出一个空格\naddi $t0, $t0, 1\nj loop_out\n\nloop_out_end:\nli $v0, 10\nsyscall                    # 结束程序\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"2二维数组\"\u003e2.二维数组\u003c/h4\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-MIPS\" data-lang=\"MIPS\"\u003e.data\nmatrix: .space  256             # int matrix[8][8]   8*8*4 字节\n                                # matrix[0][0] 的地址为 0x00，matrix[0][1] 的地址为 0x04，……\n                                # matrix[1][0] 的地址为 0x20，matrix[1][1] 的地址为 0x24，……\n                                # ……\nstr_enter:  .asciiz \u0026#34;\\n\u0026#34;\nstr_space:  .asciiz \u0026#34; \u0026#34;\n\n# 这里使用了宏，%i 为存储当前行数的寄存器，%j 为存储当前列数的寄存器\n# 把 (%i * 8 + %j) * 4 存入 %ans 寄存器中\n.macro  getindex(%ans, %i, %j)\n    sll %ans, %i, 3             # %ans = %i * 8\n    add %ans, %ans, %j          # %ans = %ans + %j\n    sll %ans, %ans, 2           # %ans = %ans * 4\n.end_macro\n\n.text\nli  $v0, 5\nsyscall\nmove $s0, $v0                   # 行数\nli  $v0, 5\nsyscall\nmove $s1, $v0                   # 列数\n# 这里使用了循环嵌套\nli  $t0, 0                      # $t0 是一个循环变量\n\nin_i:                           # 这是外层循环\nbeq $t0, $s0, in_i_end\nli  $t1, 0                      # $t1 是另一个循环变量\nin_j:                           # 这是内层循环\nbeq $t1, $s1, in_j_end\nli  $v0, 5\nsyscall                         # 注意一下下面几行，在 Execute 页面中 Basic 列变成了什么\ngetindex($t2, $t0, $t1)         # 这里使用了宏，就不用写那么多行来算 ($t0 * 8 + $t1) * 4 了\nsw  $v0, matrix($t2)            # matrix[$t0][$t1] = $v0\naddi $t1, $t1, 1\nj   in_j\nin_j_end:\naddi $t0, $t0, 1\nj   in_i\nin_i_end:\n# 这里使用了循环嵌套，和输入的时候同理\nli  $t0, 0\n\nout_i:\nbeq $t0, $s0, out_i_end\nli  $t1, 0\nout_j:\nbeq $t1, $s1, out_j_end\ngetindex($t2, $t0, $t1)\nlw  $a0, matrix($t2)            # $a0 = matrix[$t0][$t1]\nli  $v0, 1\nsyscall\nla  $a0, str_space\nli  $v0, 4\nsyscall                         # 输出一个空格\naddi $t1, $t1, 1\nj   out_j\nout_j_end:\nla  $a0, str_enter\nli  $v0, 4\nsyscall                         # 输出一个回车\naddi $t0, $t0, 1\nj   out_i\n\nout_i_end:\nli  $v0, 10\nsyscall\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e事实上\u003c/strong\u003e，在做矩阵转化一题时，我用了利用一维数组模拟二维数组\u003c/p\u003e","title":"MIPS中的一维数组和二维数组"},{"content":"面向OO的git指令 ​\t在秋季学期开设的OOpre课程中，我首次接触到使用Gitlab对代码进行版本管理，在第一次OOpre作业中我就受到了提交库的拷打，现在是2023年9月10日晚上22:46,开始编写面向OO的git指令\nwindows命令行操作经典指令\ncd:change dictionary cd D: #只有转移磁盘需要加冒号: cd OO #进一步转移到目录下文件夹 cd .. #回退一层目录 ​ 2.pwd:print working dictionary 打印当前工作目录\n​ 3. git 指令 git是一个终端\n提交注意\n​ 在每一次作业的发布中，分为作业发布区和个人仓库区，常见的操作是从作业发布区进行repository的clone,在本地完成作业后push到个人仓库区，需要注意的是公共发布区是没有push权限的，下面以第一次作业为例\n完成作业的常见步骤\n从公共发布区clone\n​\t需要注意的是这里的每一个步骤都可以通过IDEA编译器操作或是通过git终端操作，这里我们主要介绍通过git的操作方式(我更加喜欢)。\n​ 进行源的clone,通过以下代码实现\n1 git clone url path ​ 其中url代表远程仓库的地址如SSH密钥，path代表路径，绝对路径或相对路径均可以，如果指定的路径不存在则会创建该目录，笔者经过验证，在路径不存在的情况下，确实会进行生成。\n需要注意的是在clone后已经存在.git文件\n对代码进行修改后的一系列\n常用指令git init\ngit init指令用于生成本地的.git跟踪版本文件，是万恶的开端\ngit status\ngit status用于查看当前文件的情况，是否被跟踪(tracked 用于代码管理)，是否有修改等等\ngit add\ngit add 指令是很常用的操作，用于将文件添加到tracked,常见的有这几种用法\n1 2 3 4 //将.git目录下全体文件加入tracked git add . //添加单个文件进行版本管理 git add \u0026lt;filename\u0026gt;//其中如果filename中包含空格的话需要对文件名进行双引号处理 \u0026#34;filename\u0026#34; 通常对文件进行修改后或新建文件后需要进行git add 这时可以通过git status 进行文件状态的查询\n这时可以通过git add 对改变的文件进行track。\ngit commit\ngit commit用于将代码提交到本地代码库，常用的命令行有:\n1 2 git commit -m \u0026#34;message\u0026#34; //参数-m代表提交的同时进行消息说明 在\u0026#34;message\u0026#34;中写出对于此次提交的注释，便于以后git log查看 git commit -am \u0026#34;message\u0026#34; //与之前相比多了参数-a 这表示进行了add操作，这一条指令就相当于git add+commit git log\n​\tgit log可以查看commit记录，查看每一次commit会发现每一次commit都对应着一个编号，这个编号用于版本的回退，后面会提及。\ngit push\ngit push是第一次需要联网进行的操作，用于将代码推送到远端服务器,在push之前可以查看已存在的SSH路径。\n1 2 git remote//显示出所有SSH git remote -v//显示出当前使用SSH的地址 可以发现我们当前已经存在命名过的SSH origin，并且知晓了他的地址。也就是说我们当前进行的push操作是将代码推送到origin对应的远程仓库，但是我们知道，此时进行push会push到课程公共发布区，而这是不被允许且没有权限的。这时就涉及到新建推送地址SSH(个人代码库)\n1 2 git remote add \u0026lt;name\u0026gt; \u0026lt;url\u0026gt;//其中\u0026lt;name\u0026gt;的名字应当与想要推送到的仓库一致，不可以乱起名，url为对应仓库的SSH git remote remove \u0026lt;name\u0026gt;//删除SSH源，比如这里当我们只需要提交代码时就可以删除公共发布区的SSH 这时，我们距离push还有很多的细节，\n课程组提供的个人代码库默认为master分支，需要观察我们的代码分支是否为master,这一点在命令行的蓝色部分有显示\n若我们的代码在master分支，则无许进行修改，否则需要进行分支的修改，因为我们的提交是需要分支对应的，我们本地库的master分支对应提交到远程代码库的master分支。具体步骤如下:\n1 2 3 4 5 git branch//查看现有的分支 在测验环境下只有main git branch \u0026lt;newname\u0026gt;//新建一个分支，这里我们一般是将name设置为master,顺应作业提交规则 git branch master //这时就可以进行代码分支的切换 git checkout master//切换到master分支 检查目标库中是否有本地没有的文件\n很多代码托管平台如github,gitee在创建仓库的时候会询问是否添加README.md文档(在OO课程组提供的个人代码库中初始时为空的)，这时如果push会进行报错，因为远程仓库中包含本地不存在的工作(README.md),有几种解决方法\n1 2 3 4 5 6 7 8 9 10 //1.同步 git pull origin master git add . git commit git push origin master //2.如果只是因为README.md原因，可以选择在本地生成 git pull --rebase origin master git push origin master //强推，用本地代码强制覆盖git仓库内内容，在仓库为空时可以使用 git push -f origin master//-f force git push是我们上传作业最重要的工作，我们应当使用以下代码\n1 2 3 4 git push \u0026lt;sshname\u0026gt; \u0026lt;branch\u0026gt;//仓库名+分支名 //例如 git push homework_1 master //需要注意的是 这里的branch如果原仓库中没有，此行指令会在仓库中新建branch并将代码提交到branch当中 希望我们都可以顺利PUSH!!!\ngit revert\n版本回退是一个非常好用的功能，可以调出前几次的commit.这里我们需要先使用git log查看git commit记录,在提交记录中有提交的HASH值和指定标签,这种方式是进行一个新的提交来表示撤销操作，而不会抹除历史记录。需要使用git push重新推送到远程仓库中。\n1 2 3 git revert \u0026lt;commit-hash\u0026gt;//回退到指定hash git revert \u0026lt;tag-name\u0026gt;//回退到指定标签 git revert HEAD~n//回退到前N个提交 还有一些版本管理上的内容需要补充\n","permalink":"https://coder0xe.github.io/posts/gitlines/","summary":"\u003ch3 id=\"面向oo的git指令\"\u003e面向OO的git指令\u003c/h3\u003e\n\u003cp\u003e​\t\t\u003cstrong\u003e在秋季学期开设的OOpre课程中，我首次接触到使用Gitlab对代码进行版本管理，在第一次OOpre作业中我就受到了提交库的拷打，现在是2023年9月10日晚上22:46,开始编写面向OO的git指令\u003c/strong\u003e\u003c/p\u003e\n\u003col start=\"0\"\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ewindows命令行操作经典指令\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecd:change dictionary\n\u003cul\u003e\n\u003cli\u003ecd D:    #只有转移磁盘需要加冒号:\u003c/li\u003e\n\u003cli\u003ecd OO #进一步转移到目录下文件夹\u003c/li\u003e\n\u003cli\u003ecd ..     #回退一层目录\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​     2.pwd:print working dictionary 打印当前工作目录\u003c/p\u003e\n\u003cp\u003e​     3. git 指令 git是一个终端\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e提交注意\u003c/p\u003e\n\u003cp\u003e​     在每一次作业的发布中，分为作业发布区和个人仓库区，常见的操作是从作业发布区进行repository的clone,在本地完成作业后push到个人仓库区，需要注意的是公共发布区是没有push权限的，下面以第一次作业为例\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e完成作业的常见步骤\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e从公共发布区clone\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e​\t\t\u003cstrong\u003e需要注意的是这里的每一个步骤都可以通过IDEA编译器操作或是通过git终端操作，这里我们主要介绍通过git的操作方式(我更加喜欢)。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e​       进行源的clone,通过以下代码实现\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit clone url path\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​       其中url代表远程仓库的地址如SSH密钥，path代表路径，绝对路径或相对路径均可以，如果指定的路径不存在则会创建该目录，笔者经过验证，在路径不存在的情况下，确实会进行生成。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e需要注意的是在clone后已经存在.git文件\u003c/strong\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e对代码进行修改后的一系列\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e常用指令git init\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003egit init指令用于生成本地的.git跟踪版本文件，是万恶的开端\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003egit status\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003egit status用于查看当前文件的情况，是否被跟踪(tracked 用于代码管理)，是否有修改等等\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003egit add\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003egit add 指令是很常用的操作，用于将文件添加到tracked,常见的有这几种用法\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//将.git目录下全体文件加入tracked\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//添加单个文件进行版本管理\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit add \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003efilename\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#6272a4\"\u003e//其中如果filename中包含空格的话需要对文件名进行双引号处理 \u0026#34;filename\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e通常对文件进行修改后或新建文件后需要进行git add 这时可以通过git status 进行文件状态的查询\u003c/p\u003e","title":"git指令的初步学习"},{"content":"利用malloc分配二维数组 先利用malloc分配出连续的行，再分别对每行分配内存\n1 2 3 4 5 int row,col;//二维数组的行数和列数 int** a=(int**)malloc(sizeof(int)*row);//分配出连续的行头 for(int i=0;i\u0026lt;row;i++){ a[i]=(int* )malloc(sizeof(int)*col);//分配每一行的内存 } 注：每一行的内存是连续的，相邻两行的内存不一定连续\n","permalink":"https://coder0xe.github.io/posts/malloc%E5%88%86%E9%85%8D%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"\u003ch2 id=\"利用malloc分配二维数组\"\u003e利用malloc分配二维数组\u003c/h2\u003e\n\u003cp\u003e先利用malloc分配出连续的行，再分别对每行分配内存\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e row,col;\u003cspan style=\"color:#6272a4\"\u003e//二维数组的行数和列数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e**\u003c/span\u003e a\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e**\u003c/span\u003e)\u003cspan style=\"color:#50fa7b\"\u003emalloc\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003esizeof\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e)\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003erow);\u003cspan style=\"color:#6272a4\"\u003e//分配出连续的行头\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e i\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;i\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003erow;i\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    a[i]\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e )\u003cspan style=\"color:#50fa7b\"\u003emalloc\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003esizeof\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e)\u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ecol);\u003cspan style=\"color:#6272a4\"\u003e//分配每一行的内存\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e注：每一行的内存是连续的，相邻两行的内存不一定连续\u003c/p\u003e","title":"malloc分配二维数组"},{"content":"用hash解决leetcode01两数之和 题意分析：在一个数组中找到和为target的两个元素，并返回下标数组\n1. 做法一：双层暴力循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int *twoSum(int *nums,int numsSize,int target,int *returnSize) { static int ret[10]={0}; for(int i=0;i\u0026lt;numsSize;i++){ for(int j=i+1;j\u0026lt;numsSize;j++){ if(nums[i]+nums[j]==target){ //int* ret=(int *)malloc(sizeof(int)*10); ret[0]=i,ret[1]=j; *returnSize=2; return ret; } } } *returnSize=0; return NULL; } 2. 做法二：hash ​ **利用hash的做法即为涉及到查找，我们设置一个集合，初始状态为空，在遍历原数组的过程中，就在这个集合中查找target-a[i],如果有则停止查找，如果没有则将该元素加入集合** ```c //leetcode支持ut_hash函数库 typedef struct { int key; int value; UT_hash_handle hh;//make this structure hashable }map; map* hashMAP=NULL; void hashMapAdd(int key,int value) { map*s; HASH_FIND_INT(hashMap,\u0026amp;key,s); if(s==NULL){ s=(map*)malloc(sizeof(map)); s-\u0026gt;key=key; HASH_ADD_INT(hashMap,key,s); } s-\u0026gt;value=value; } map* hashMapFind(int key) { map*s; HASH_FIND_INT(hashMap,\u0026amp;key,s); return s; } void hashMapCleanup() { map*cur,*tmp; HASH_ITER(hh,hashMap,cur,tmp){ HASH_DEL(hashMap,cur); free(cur); } } void hashPrint(){ map*s; for(s=hashMap;s!=NULL;s=(map*)(s-\u0026gt;hh.next)) { print(\u0026quot;key %d ,value %d\\n\u0026quot;,s-\u0026gt;key,s-\u0026gt;value); } } int *twoSum(int *nums,int numsSize,int target,int *returnSize) { int i,*ans; map* hashMapRes; hashMap=NULL; ans=(int*)malloc(sizeof(int)*2); for(i=0;i\u0026lt;numsSize;i++){ hashMapAdd(nums[i],i); } hashPrint();//经典打印检查 for(i=0;i\u0026lt;numsSize;i++){ hashMapRes=hashMapFind(target-nums[i]); if(hashMapRes\u0026amp;\u0026amp;hashMapRes-\u0026gt;value!=i){ ans[0]=i; ans[1]=hashMapRes-\u0026gt;value; *returnSize=2; return ans; } } hashMapCleanup(); *returnSize=0; return NULL; } ``` ​ 此种做法中涉及到很多使用头文件函数库uthash.h中的用法，当然我们也可以将这些封装好的函数进行手搓，关于函数库uthash.h会在下一篇中介绍 **手搓hash** ```c //每个元素的关键是值和下标 struct node{ int key; int value; struct node*link; }; struct node *hash[10000]={NULL}; //这里的整数值都比较小，可以考虑直接取余法(质数)，但是会处理一些冲突 int HASH(int key) { return key%13; } int *twoSum(int *nums,int numsSize,int target,int *returnSize) { int*a=(int*)malloc(sizeof(int)*2); for(int i=0;i\u0026lt;numsSize;i++){ //以下代码为target\u0026gt;nums[i] if(hash[HASH(target-nums[i])]==NULL){ struct node *p=(struct node*)malloc(sizeof(struct node)); p-\u0026gt;key=nums[i];p-\u0026gt;value=i;p-\u0026gt;link=NULL; hash[HASH(nums[i])]=p; }else{ struct node *q=hash[HASH(target-nums[i])]; while(q!=NULL){ if(q-\u0026gt;value!=i)//不同下标 { a[0]=q-\u0026gt;value,a[1]=i; *returnSize=2; return a; } q=q-\u0026gt;link; } } } *returnSize=0; return NULL; } ``` ​ **但是测试用例中会出现target\u0026lt;nums[i]的情况，即可能出现hash数组下标为负数的情况，以上版本不能通过** ","permalink":"https://coder0xe.github.io/posts/hash--leetcode01/","summary":"\u003ch1 id=\"用hash解决leetcode01两数之和\"\u003e用hash解决leetcode01两数之和\u003c/h1\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e题意分析：在一个数组中找到和为target的两个元素，并返回下标数组\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"1-做法一双层暴力循环\"\u003e1. 做法一：双层暴力循环\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#50fa7b\"\u003etwoSum\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003enums,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e numsSize,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e target,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ereturnSize)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003estatic\u003c/span\u003e \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e ret[\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e]\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e i\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;i\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003enumsSize;i\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e j\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ei\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;j\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003enumsSize;j\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(nums[i]\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003enums[j]\u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003etarget){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             \u003cspan style=\"color:#6272a4\"\u003e//int* ret=(int *)malloc(sizeof(int)*10);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              ret[\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e]\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ei,ret[\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e]\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ej;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ereturnSize\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e ret;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ereturnSize\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eNULL\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2-做法二hash\"\u003e2. 做法二：hash\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e  ​       **利用hash的做法即为涉及到查找，我们设置一个集合，初始状态为空，在遍历原数组的过程中，就在这个集合中查找target-a[i],如果有则停止查找，如果没有则将该元素加入集合**\n\n  ```c\n  //leetcode支持ut_hash函数库\n  typedef struct {\n      int key;\n      int value;\n      UT_hash_handle hh;//make this structure hashable\n  }map;\n  map* hashMAP=NULL;\n  void hashMapAdd(int key,int value)\n  {\n      map*s;\n      HASH_FIND_INT(hashMap,\u0026amp;key,s);\n      if(s==NULL){\n          s=(map*)malloc(sizeof(map));\n          s-\u0026gt;key=key;\n          HASH_ADD_INT(hashMap,key,s);\n      }\n      s-\u0026gt;value=value;\n  }\n  map* hashMapFind(int key)\n  {\n      map*s;\n     HASH_FIND_INT(hashMap,\u0026amp;key,s);\n      return s;\n  }\n  void hashMapCleanup()\n  {\n      map*cur,*tmp;\n      HASH_ITER(hh,hashMap,cur,tmp){\n          HASH_DEL(hashMap,cur);\n          free(cur);\n      }\n  }\n  void hashPrint(){\n      map*s;\n      for(s=hashMap;s!=NULL;s=(map*)(s-\u0026gt;hh.next))\n      {\n          print(\u0026quot;key %d ,value %d\\n\u0026quot;,s-\u0026gt;key,s-\u0026gt;value);\n      }\n  }\n  int *twoSum(int *nums,int numsSize,int target,int *returnSize)\n  {\n      int i,*ans;\n      map* hashMapRes;\n      hashMap=NULL;\n      ans=(int*)malloc(sizeof(int)*2);\n      for(i=0;i\u0026lt;numsSize;i++){\n          hashMapAdd(nums[i],i);\n      }\n      hashPrint();//经典打印检查\n      for(i=0;i\u0026lt;numsSize;i++){\n          hashMapRes=hashMapFind(target-nums[i]);\n          if(hashMapRes\u0026amp;\u0026amp;hashMapRes-\u0026gt;value!=i){\n              ans[0]=i;\n              ans[1]=hashMapRes-\u0026gt;value;\n              *returnSize=2;\n              return ans;\n          }\n      }\n      hashMapCleanup();\n      *returnSize=0;\n      return NULL;\n  }\n  ```\n\n  ​     此种做法中涉及到很多使用头文件函数库uthash.h中的用法，当然我们也可以将这些封装好的函数进行手搓，关于函数库uthash.h会在下一篇中介绍\n\n  **手搓hash**\n\n  ```c\n  //每个元素的关键是值和下标\n  struct node{\n      int key;\n      int value;\n      struct node*link;\n  };\n  struct node *hash[10000]={NULL};\n  //这里的整数值都比较小，可以考虑直接取余法(质数)，但是会处理一些冲突\n  int HASH(int key)\n  {\n     return key%13;\n  }\n  int *twoSum(int *nums,int numsSize,int target,int *returnSize)\n  {\n      int*a=(int*)malloc(sizeof(int)*2);\n      for(int i=0;i\u0026lt;numsSize;i++){\n          //以下代码为target\u0026gt;nums[i]\n          if(hash[HASH(target-nums[i])]==NULL){\n              struct node *p=(struct node*)malloc(sizeof(struct node));  \n              p-\u0026gt;key=nums[i];p-\u0026gt;value=i;p-\u0026gt;link=NULL;\n              hash[HASH(nums[i])]=p;                                                                                                                          \n          }else{\n              struct node *q=hash[HASH(target-nums[i])];\n              while(q!=NULL){\n                  if(q-\u0026gt;value!=i)//不同下标\n                  {\n                      a[0]=q-\u0026gt;value,a[1]=i;\n                      *returnSize=2;\n                      return a;\n                  }\n                  q=q-\u0026gt;link;\n              }\n          }\n      }\n      *returnSize=0;\n      return NULL;\n  }\n  ```\n\n  ​      **但是测试用例中会出现target\u0026lt;nums[i]的情况，即可能出现hash数组下标为负数的情况，以上版本不能通过**\n\u003c/code\u003e\u003c/pre\u003e","title":"Leetcode01"},{"content":"C语言内存分区 5大分区\n栈区\n向下生长 编译器自动分配释放 存储：局部变量 形参 返回值 堆区\n向上生长 程序员调用和分配 malloc free 全局（静态）区\n全局变量 静态变量 常量区\n字符串 数字 代码区\n程序代码 下面来看一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int *twoSum(int *nums,int numsSize,int target,int *returnSize) { int ret[10]={0}; for(int i=0;i\u0026lt;numsSize;i++){ for(int j=i+1;j\u0026lt;numsSize;j++){ if(nums[i]+nums[j]==target){ ret[0]=i,ret[1]=j; *returnSize=2; return ret; } } } *returnSize=0; return NULL; } ​ 这是leetcode第一题 ，函数要求返回存储原数组下标的新数组，出现过错误在于在函数中去建立临时变量数组，再返回数组地址，\nret的内存被分配在栈区，然而栈区的内存会随着函数运行结束而被释放 ，因此返回的是无意义的地址，产生报错。\n​ 解决方法有两种\n用malloc在堆区申请空间\nmalloc在堆区申请空间并不会随着函数运行结束而被释放\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int *twoSum(int *nums,int numsSize,int target,int *returnSize) { for(int i=0;i\u0026lt;numsSize;i++){ for(int j=i+1;j\u0026lt;numsSize;j++){ if(nums[i]+nums[j]==target){ int* ret=(int *)malloc(sizeof(int)*10);//malloc申请空间 ret[0]=i,ret[1]=j; *returnSize=2; return ret; } } } *returnSize=0; return NULL; } 改变为静态变量 全局区\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int *twoSum(int *nums,int numsSize,int target,int *returnSize) { static int ret[10]={0};//改为静态变量 全局区 for(int i=0;i\u0026lt;numsSize;i++){ for(int j=i+1;j\u0026lt;numsSize;j++){ if(nums[i]+nums[j]==target){ ret[0]=i,ret[1]=j; *returnSize=2; return ret; } } } *returnSize=0; return NULL; } ","permalink":"https://coder0xe.github.io/posts/c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/","summary":"\u003ch2 id=\"c语言内存分区\"\u003eC语言内存分区\u003c/h2\u003e\n\u003cp\u003e5大分区\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e栈区\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e向下生长\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e编译器自动分配释放\u003c/li\u003e\n\u003cli\u003e存储：局部变量 形参 返回值\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e堆区\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e向上生长\u003c/li\u003e\n\u003cli\u003e程序员调用和分配\u003c/li\u003e\n\u003cli\u003emalloc free\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e全局（静态）区\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e全局变量 静态变量\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e常量区\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e字符串 数字\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e代码区\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e程序代码\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下面来看一段代码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#50fa7b\"\u003etwoSum\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003enums,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e numsSize,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e target,\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ereturnSize)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e ret[\u003cspan style=\"color:#bd93f9\"\u003e10\u003c/span\u003e]\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e i\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;i\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003enumsSize;i\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003eint\u003c/span\u003e j\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ei\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e;j\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003enumsSize;j\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#ff79c6\"\u003eif\u003c/span\u003e(nums[i]\u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003enums[j]\u003cspan style=\"color:#ff79c6\"\u003e==\u003c/span\u003etarget){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              ret[\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e]\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ei,ret[\u003cspan style=\"color:#bd93f9\"\u003e1\u003c/span\u003e]\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003ej;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ereturnSize\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e ret;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003ereturnSize\u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#8be9fd;font-style:italic\"\u003eNULL\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e​       这是leetcode第一题 ，函数要求返回存储原数组下标的新数组，出现过错误在于在函数中去建立临时变量数组，再返回数组地址，\u003c/p\u003e","title":"C语言内存分区"}]