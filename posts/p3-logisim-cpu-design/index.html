<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>支持40条指令P3_logisim_CPU | coder0xe's blog</title><meta name=keywords content="计组"><meta name=description content="使用logisim搭建CPU"><meta name=author content="sudo"><link rel=canonical href=https://coder0xe.github.io/posts/p3-logisim-cpu-design/><link crossorigin=anonymous href=/assets/css/stylesheet.e4a36188e2c44563c1cc5ed1a2d0b8451a4f68c685114d738b97609f82dae050.css integrity="sha256-5KNhiOLERWPBzF7RotC4RRpPaMaFEU1zi5dgn4La4FA=" rel="preload stylesheet" as=style><link rel=icon href=https://coder0xe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://coder0xe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://coder0xe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://coder0xe.github.io/apple-touch-icon.png><link rel=mask-icon href=https://coder0xe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://coder0xe.github.io/posts/p3-logisim-cpu-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://coder0xe.github.io/posts/p3-logisim-cpu-design/"><meta property="og:site_name" content="coder0xe's blog"><meta property="og:title" content="支持40条指令P3_logisim_CPU"><meta property="og:description" content="使用logisim搭建CPU"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-06T12:42:31+08:00"><meta property="article:modified_time" content="2023-11-06T12:42:31+08:00"><meta property="article:tag" content="Nov"><meta name=twitter:card content="summary"><meta name=twitter:title content="支持40条指令P3_logisim_CPU"><meta name=twitter:description content="使用logisim搭建CPU"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://coder0xe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"支持40条指令P3_logisim_CPU","item":"https://coder0xe.github.io/posts/p3-logisim-cpu-design/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"支持40条指令P3_logisim_CPU","name":"支持40条指令P3_logisim_CPU","description":"使用logisim搭建CPU","keywords":["计组"],"articleBody":"CPU Design Document 1. CPU Design 1.总体设计 ​\t通过对于《计算机组成与设计》一书的阅读，对于P3的CPU设计我有如下思考，设计MIPS架构的CPU的本质在于从指令存储器中读出32位MIPS指令，并对MIPS指令进行解析进而完成指令中要求的操作。在本次实验中，要求实现的指令有add,sub,ori,lw,sw,beq,lui,nop其中，R型指令有add,sub,I型指令有ori,lw,sw,beq,lui，特殊的有nop指令，32位全为0。\nRIJ类型指令图:\n此次实验中要求实现的基本指令：\nR型 Operation Op-Code rs rt rd shamt(移位) func add 000000 00000 100000 sub 000000 00000 100010 I型 Operation Op-Code rs rt 16-bit-immediate-value ori 001101 lw 100011 sw 101011 beq 000100 lui 001111 nop ​\t32’b0\n​\t将我们要实现的CPU分为几个模块：IFU（取指令单元），GRF（寄存器堆），ALU（算术逻辑单元），DM（数据存储器），EXT（扩展单元），Controller（控制器）。\n下面给出设计电路模块图：\n1. IFU取指令单元 ​\t由于题目中要求寄存器的0x00003000对应ROM的0地址，即第一条指令的地址，且寄存器异步复位到初值0x00003000，这里涉及到类似于为寄存器赋初值的操作，可以对寄存器进行地址映射，利用寄存器当前值完成“赋初值”，当寄存器值为0时加上0x00003000进行下一个地址NPC的计算，而在计算取ROM中指令地址时再减去0x00003000。注意寄存器中保存的为以字节为单位的偏移量，ROM中一条指令为4个字节，需要将pc寄存器中的值右移两位后才对应到ROM中对应的行地址。\n2.NPC计算下一条指令地址 ​\t利用PCSrc信号选择取出PC+4地址的指令还是进行beq跳转得到的地址，应当注意的是beq中跳转为以字为单位，要先对移位量shift左移两位得到对应的字节偏移量。\n3.ALU计算单元 ALUOp 运算 是否判断溢出 0000 and no 0001 or no 0010 addu no 0011 subu no 0010 add yes（结合控制信号judge-overflow选择是否进行判断溢出问题） 0011 sub yes 0100 lui no 0101 xor no 0110 nor no 0111 logical-left no 1000 logical-right no 1001 Arth-right no 1010 sign-compare no 1011 unsigned-compare no 注：由于教程中要求对于add sub不实现溢出判断 即把add sub当作addu subu用，而在指令中不具体实现addu subu\n4. GRF寄存器堆 ​\t寄存器中有32个通用寄存器，\n注意0号寄存器的值只能为0，故将使能端WE设置为常量0 在写入端的解复用器DMX需要设置为三态，否则在写入一个值的时候其他值会被清零 5.Controller总控制器 ​\tController的输入为读取出指令的Op-Code,即[31:26]位，输出为八个控制信号，其中输送给ALU Controller的控制信号ALUOp为2位，下面对不同指令需要哪些控制信号进行分析，对不同指令按照其Op-Code进行分类.\n1. R型指令 1. 数据通路 2.输出信号 Op-Code:000000，对R型指令对应的Controller输出情况列表\n信号名称 取值情况 RegDst 1 ALUSrc 0 MemtoReg 0 RegWrite 1 MemRead 0 MemWrite 0 Branch 0 EXTOp 0 2.lw指令 1.数据通路 2.输出信号 Op-Code:100011，对应的输出情况列表\n信号名称 取值情况 RegDst 0 ALUSrc 1 MemtoReg 1 RegWrite 1 MemRead 1 MemWrite 0 Branch 0 EXTOp 1 3.sw指令 1.数据通路 2.输出信号 Op-Code:101011\n信号名称 取值情况 RegDst x ALUSrc 1 MemtoReg x RegWrite 0 MemRead 0 MemWrite 1 Branch 0 EXTOp 1 4.beq指令 1.数据通路 2.输出信号 Op-Code: 000100\n信号名称 取值情况 RegDst x ALUSrc 0 MemtoReg x RegWrite 0 MemRead 0 MemWrite 0 Branch 1 EXTOp 1 注：由于sw与beq指令中都不需要向寄存器中存储数字，即RegWrite=0,此时RegDst与MemtoReg可以为不定值x因为无论为多少都不会写入\n5.lui指令 1.数据通路 ​\t将原16位imm后拼接16位0，存入目标寄存器，位拼接操作在ALU中实现，对应操作编码为1000。此处rs寄存器为$0。\n2.输出信号 Op-Code:001111，对应的输出情况列表\n信号名称 取值情况 RegDst 0 ALUSrc 1 MemtoReg 0 RegWrite 1 MemRead 0 MemWrite 0 Branch 0 EXTOp 0 6.ori指令 1.数据通路 2.输出信号 Op-Code:001101\n需要注意的是ori指令中16位立即数的范围是:0~65535,如果位数超出16位则会发生截断保留低位\n信号名称 取值情况 RegDst 0 ALUSrc 1 MemtoReg 0 RegWrite 1 MemRead 0 MemWrite 0 Branch 0 EXTOp 0 注：不需要向DM中进行读或写操作，MemRead=MemWrite=0\n指令操作码 操作 func ALU动作 ALU控制信号 lw 取字 xxxxxx 加 0010 sw 存字 xxxxxx 加 0010 beq 相等跳转 xxxxxx 减 0110 add 加 100000 加 0010 sub 减 100010 减 0110 and 与 100100 与 0000 or 或 100101 或 0001 ori 或立即数 xxxxxx 或 0001 lui 存半字 xxxxxx 低位拼接0 1000 7.利用与或门阵列实现对指令的识别和产生相应的控制信号 1.指令识别 ​\t对于指令的识别主要用到32位指令中的opcode字段([31-26]位)与funct字段([5:0]位)，只有R型指令会利用funct字段进行指令的识别，其他类型指令只需要opcode字段即可。思路是，先利用opcode进行识别，识别出除R型指令之外的其他类型具体指令后，再利用funct字段对R型指令进行识别。\n2.产生控制信号 ​\t我将理论课中介绍的Controller与ALU Controller合并为一个整体，Controller产生的控制信号直接控制ALU进行运算，运用或阵列进行操作，只将输出信号表中为1的接到对应的信号或门上，对于0或x值均无连接，连接时有一个小技巧为将opcode与funct点为该指令的码，之后只需要将亮色的线连接到与门上。\n8.对补充的指令的实现思路进行总结 1.补充的R型指令 运算指令\n通过在ALU中传递不同的ALUOp实现，如add,sub,and,or,nor,xor\n移位指令\n如sll,srl,sllv,srlv,sra,srav,在ALU中通过Shifter实现逻辑左移，逻辑右移，算术右移。其中sll,srl,sra是将rt中的数值移动s([4:0]位立即数)位存储到rd中，在ALU的传入移位量端口控制信号shiftvar=0，sllv,srlv,srav将rt中的值移动rs位后存储入rd，需要注意的是rs只取低五位，相当于s\u003c——GPR[rs]4...0，控制信号shiftvar=1。\n置位指令\nslt,sltu(set if less than)，同样在在ALU中实现，slt对两个操作数进行符号比较，sltu对两个操作数进行无符号比较，比较结果进行0扩展至32位赋值到rd\n跳转指令\njr,jalr.跳转指令需要着重进行分析，\njr :跳转到寄存器rs中存储的地址，在电路中对应GRF中读取的数据RD1，在NPC模块中实现跳转。 jalr: PC跳转到GPR[rs]中保存的地址，并将当前PC+4保存在GPR[rd]中，相比jr多了将PC+4存入GPR[RD]的功能。在NPC模块中输出PC+4，在寄存器堆写入数据端口，控制信号PC+4=1，(控制信号PC+4只有jal和halr指令会涉及到将当前PC+4存入寄存器)选择写入寄存器信号RegDst=1，ralink=0（控制信号ralink=1时写入31号寄存器,jal指令专属） 2.补充的J型指令 ​\t跳转指令在NPC中实现。\nj ，j跳转指令默认的地址为26位，需要在NPC模块中进行补全，形式为(PC+4)31...28 | j-address |00 jal指令与j指令计算地址的方式相同，同时将PC+4存入31号寄存器即ra寄存器，给出重要的控制信号:ralink=1,pc+4=1,jump=1 3.补充的I型指令 运算指令\n凡是带立即数运算的如addi,subi,ori,andi等都需要在ALU控制信号ALUSrc=1，选择符号扩展后的32位立即数，运算控制信号ALUOp与R类运算相同\nB类跳转指令\n注意：B类跳转指令对16位地址偏移量都是进行符号扩展，Control Unit输出branch，branchOp,完成对具体指令的识别，对于是否满足条件进行跳转的判断则在sel-B模块中实现，尤其要注意在sel-B模块中由于是要进行大于0小于0的判断，比较器应该选择为有符号的。其中beq和bne指令由ALU中输出信号equal判定。\n置位指令\nslti,sltiu，比较时对第二个操作数ALUSrc=1\n访存指令\nsw,sh,sb,lw,lh,lb,lbu,lhu等指令的具体实现已经在HorB模块中有了比较详细的叙述，利用address[1:0]进行判断并进行\"插入\"操作\n6.DM数据存储 ​\t一定要注意DM需要时钟信号控制！DM在时钟上升沿写入数据，一开始没有给DM加时钟信号导致数据没有及时存入QAQ。\n​\t**补充指令sb,lb,sh,lh,lbu,lhu，在DM模块中增加新模块HorB，根据控制信号b or h选择按照byte进行操作还是按照half word进行操作。**首先分析传入地址，传入地址是以字节为单位的，我们可以在已知对字/半字/字节操作的的情况下，分析出具体的半字/字节。记传入地址最后两位address[1:0]\n操作单位 address[1:0] 操作对象 word 00 字 half word 00 第一个半字节 half word 10 第二个半字节 byte 00 第一个字节 byte 01 第二个字节 byte 10 第三个字节 byte 11 第四个字节 ​\t思路：当操作类型为load(读取)：先读取出来一个字，再从中选择部分进行load，当操作类型为save(存入)：先读取出来对应地址上的一个字，再在相应位置上插入想要存入的内容，这就要求sb,lb,sh,lh,lbu,lhu进行操作前需要先从对应地址上读取，即MemRead = 1.\n电路图如下：\n7.EXT位扩展 ​\t位扩展单元由EXTOp信号控制，选择进行符号扩展还是0扩展，其中sw,lw,beq均为符号扩展，ori为0扩展。\n8.sel-B具体判断B指令 ​\t实现的B类型跳转指令有,beq,bne,bgez,bgtz,blez,bltz。可以大致分为两类。第一类为beq,bne，这两个指令是对于两个操作数进行比较然后进行跳转（比较在ALU中完成），第二类中都是进行与0的比较（在sel-B中完成）。branchOp列表如下:\nbranchOp 指令 000 beq 001 bltz 001 bgez 010 bgtz 011 blez 100 bne ​\t其中beq指令与bne指令都由equal信号判断，故对于beq\\bne的选择通过最高位选择。在001编码中，对bltz和bgez进行了合并，因为这两种指令的opcode一致为000001，故在control unit中无法实现对这两种指令的识别，需要利用这两种指令的[20:16]进行分辨，即judge信号，bltz:00000,bgez:00001，这样实际上需要选择的只有四个信号，利用branchOp的低两位进行判断，电路图如下：\n尤其需要注意的是：在sel-B模块中比较器应当选择有符号的而不是unsigned，因为他们都是与0进行比较，而在ALU模块中slt指令需要进行符号比较，sltu指令需要进行无符号比较.\n2. test scheme ​\t课下测试利用课程组提供的jar包进行测试，从MARS中导出16进制文件load到我的单周期CPU中，运行CPU，将存储在寄存器中的数据与MARS运行结果进行比对。\n1.基本指令测试 1. ori-test ​\tori指令中的立即数为无符号扩展，不存在复数的情况，测试指令\nori $a0,$0,123 ori $a1,$a0,456 2. lui-test lui $a2,123 #符号位为0 lui $a3,0xffff #符号位为1 3. add-test lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 4.sw-test ori $a0,$0,1 ori $a1,$0,2 ori $a2,$0,3 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) 5.lw-test ori $a0,$0,1 ori $a1,$0,2 ori $a2,$0,3 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) 6.beq-test ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) 7.将以上指令综合测试 ori $a0, $0, 123 ori $a1, $a0, 456 lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) sw $a3, 12($t0) sw $s0, 16($t0) sw $s1, 20($t0) sw $s2, 24($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) ​\t需要注意的是MARS设置中不应当开启delayed branching，否则会运行跳转指令如beq的下一条指令，与本地CPU不符\n2.补充指令后计算指令综合测试 3.补充指令后访存指令综合测试 .text li\t$s0, 0xABCF1234 li\t$s1, 0x1234ABCD li\t$s2, 0xa1b2c3d4 li\t$s3, 0x7fff0000 sb\t$s1, 100($0) sb\t$s2, 103($0) sb\t$s3, 105($0) sb\t$s4, 107($0) sh\t$s4, 108($0) sh\t$s3, 110($0) sh\t$s2, 112($0) sh\t$s1, 114($0) sw\t$s0, 0($0) sw\t$s1, 4($0) sw\t$s2, 8($0) sw\t$s3, 12($0) lw\t$t0, 0($0) lw\t$t1, 4($0) lw\t$t2, 8($0) lw\t$t3, 12($0) sw\t$t0, 16($0) sw\t$t1, 20($0) sw\t$t2, 24($0) sw\t$t3, 28($0) lb\t$t0, 3($0) lb\t$t1, 7($0) lb\t$t2, 11($0) lb\t$t3, 13($0) sw\t$t0, 32($0) sw\t$t1, 36($0) sw\t$t2, 40($0) sw\t$t3, 44($0) lbu\t$t0, 3($0) lbu\t$t1, 7($0) lbu\t$t2, 11($0) lbu\t$t3, 13($0) sw\t$t0, 48($0) sw\t$t1, 52($0) sw\t$t2, 56($0) sw\t$t3, 60($0) lh\t$t0, 2($0) lh\t$t0, 4($0) lh\t$t0, 8($0) lh\t$t0, 12($0) sw\t$t0, 64($0) sw\t$t1, 68($0) sw\t$t2, 72($0) sw\t$t3, 76($0) lhu\t$t0, 2($0) lhu\t$t0, 6($0) lhu\t$t0, 8($0) lhu\t$t0, 12($0) sw\t$t0, 80($0) sw\t$t1, 84($0) sw\t$t2, 88($0) sw\t$t3, 92($0) li\t$v0, 10 syscall 4.补充指令后跳转指令综合测试 .text main:\tli\t$s0, 0 li\t$s1, -1000 li\t$s2, 1000 lui\t$s3, 0x8000\t#s3 is -2147483648 lui\t$s4, 0x8000 ori\t$s4, 0x0001\t#s4 is -2147483647 lui\t$s5, 0x7fff ori\t$s5, 0xffff\t#s5 is 2147483647 lui\t$s6, 0x7fff ori\t$s6, 0xfffe\t#s6 is 2147483646 beq_1:\tbeq\t$s0, $s0, beq_1_test beq_10: beq\t$s5, $s6, beq_10_test beq_end: bne_1:\tbne\t$s0, $s1, bne_1_test bne_10:\tbne\t$s3, $s3, bne_10_test bne_end: blez_1: blez\t$s0, blez_1_test blez_10: blez\t$s6, blez_10_test blez_end: bgtz_1:\tbgtz\t$s2,bgtz_1_test bgtz_10: bgtz\t$s1,bgtz_10_test bgtz_end: jal_1:\tjal\tjal_1_test jal_5:\tjal\tjal_5_test jal_end: jalr_1:\tor\t$v0, $0, 12916 jalr\t$v1, $v0 jalr_5:\tor\t$v0, $0, 12948 jalr\t$v1, $v0 sw\t$t0, 0($s0) sw\t$t1, 0($s0) sw\t$t2, 0($s0) sw\t$t3, 0($s0) sw\t$t4, 0($s0) sw\t$t5, 0($s0) li\t$v0, 10 syscall beq_1_test: addi\t$t0,$t0, 1 j\tbeq_10 beq_10_test: addi\t$t0,$t0, 1 j\tbeq_end bne_1_test: addi\t$t1,$t1, 1 j\tbne_10 bne_10_test:addi\t$t1,$t1, 1 j\tbne_end blez_1_test:\taddi\t$t2,$t2, 1 j\tblez_10 blez_10_test:\taddi\t$t2,$t2, 1 j\tblez_end bgtz_1_test:\taddi\t$t3,$t3 1 j\tbgtz_10 bgtz_10_test:\taddi\t$t3,$t3 1 j\tbgtz_end jal_1_test:\taddi\t$t4, $4, 1 jr\t$ra jal_5_test:\taddi\t$t4, $4, 1 jr\t$ra jalr_1_test:\taddi\t$t5, $t5, 1 jr\t$v1 jalr_5_test:\taddi\t$t5, $t5, 1 jr\t$v1 2.编写python脚本完成自动化测试 ​\t利用正则表达式替换，对ROM中内容进行改写，并生成新的电路。\n1 2 3 4 5 6 7 8 9 10 11 12 import os import re #generate ROM-File command=\"java -jar MARS_mod.jar CPUtest.asm nc mc CompactTextAtZero a dump .text HexText rom.txt\" os.system(command) content = open(\"rom.txt\").read() #write ROM-File to Circle—File cur = open(\"CPU.circ\", encoding=\"utf-8\").read() cur = re.sub(r'addr/data: 12 32([\\s\\S]*)',\"addr/data: 12 32\\n\" + content + \"\", cur) with open(\"cpu_remake.circ\",\"w\", encoding=\"utf-8\") as file: file.write(cur) ​\t注意：cpu_remake是根据原CPU新生成的文件，若有改动应该在原CPU中完成，若在cpu_remake中进行改动，改动会发生“丢失”，因为cpu_remake的每一次生成都是根据CPU生成\n3.思考题 1.单周期CPU的模块中哪些发挥状态存储功能，哪些发挥状态转移功能？ ​\t答：在单周期CPU中，我们以splitter为界可以将CPU分为一个Moore机与一个Mealy机，两个状态机各有一个状态存储模块与一个状态转移模块。状态存储：IM,GRF,DM，状态转移：NPC,ALU\n2.IM使用ROM，DM使用RAM，GRF使用Register合理吗 ​\t合理，Information Memory用来存储运行的程序指令，要保证程序不会被更改，使用ROM（Read Only Memory）， Data Memory是数据存储区，需要进行写入和读取，使用RAM。\n3.额外实现的单元 ​\t我将IFU中的取指令功能与计算下一指令地址的逻辑分开，计算下一指令地址的功能单独由NPC模块实现，包括对B型和J型指令的跳转。具体细分判断B类型跳转指令的sel-B模块，HorB，存储或读取时对字节和半字进行操作的模块。\n4.nop空指令不需要加入信号真值表 ​\t实际上nop指令会被识别为sll指令，具体形式为sll $0,$0,0，即将0号寄存器左移0位，确实不会发生影响。\n5.评价MIPS指令及汇编语言一节中测试样例的强度 ​\t测试样例的覆盖是不全面的，有些寄存器没有用到，有些负数的特殊情况没有涉及，跳转的指令没有涉及等。\n","wordCount":"1142","inLanguage":"en","datePublished":"2023-11-06T12:42:31+08:00","dateModified":"2023-11-06T12:42:31+08:00","author":{"@type":"Person","name":"sudo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://coder0xe.github.io/posts/p3-logisim-cpu-design/"},"publisher":{"@type":"Organization","name":"coder0xe's blog","logo":{"@type":"ImageObject","url":"https://coder0xe.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://coder0xe.github.io/ accesskey=h title="coder0xe's blog (Alt + H)">coder0xe's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://coder0xe.github.io/ title=首页><span>首页</span></a></li><li><a href=https://coder0xe.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://coder0xe.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://coder0xe.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://coder0xe.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://coder0xe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://coder0xe.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">支持40条指令P3_logisim_CPU</h1><div class=post-description>使用logisim搭建CPU</div><div class=post-meta><span title='2023-11-06 12:42:31 +0800 +0800'>November 6, 2023</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>sudo</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#cpu-design-document aria-label="CPU Design Document">CPU Design Document</a><ul><li><a href=#1-cpu-design aria-label="1. CPU Design">1. CPU Design</a><ul><li><a href=#1%e6%80%bb%e4%bd%93%e8%ae%be%e8%ae%a1 aria-label=1.总体设计>1.总体设计</a></li><li><a href=#1-ifu%e5%8f%96%e6%8c%87%e4%bb%a4%e5%8d%95%e5%85%83 aria-label="1. IFU取指令单元">1. IFU取指令单元</a></li><li><a href=#2npc%e8%ae%a1%e7%ae%97%e4%b8%8b%e4%b8%80%e6%9d%a1%e6%8c%87%e4%bb%a4%e5%9c%b0%e5%9d%80 aria-label=2.NPC计算下一条指令地址>2.NPC计算下一条指令地址</a></li><li><a href=#3alu%e8%ae%a1%e7%ae%97%e5%8d%95%e5%85%83 aria-label=3.ALU计算单元>3.ALU计算单元</a></li><li><a href=#4-grf%e5%af%84%e5%ad%98%e5%99%a8%e5%a0%86 aria-label="4. GRF寄存器堆">4. GRF寄存器堆</a></li><li><a href=#5controller%e6%80%bb%e6%8e%a7%e5%88%b6%e5%99%a8 aria-label=5.Controller总控制器>5.Controller总控制器</a><ul><li><a href=#1-r%e5%9e%8b%e6%8c%87%e4%bb%a4 aria-label="1. R型指令">1. R型指令</a><ul><li><a href=#1-%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af aria-label="1. 数据通路">1. 数据通路</a></li><li><a href=#2%e8%be%93%e5%87%ba%e4%bf%a1%e5%8f%b7 aria-label=2.输出信号>2.输出信号</a></li></ul></li><li><a href=#2lw%e6%8c%87%e4%bb%a4 aria-label=2.lw指令>2.lw指令</a><ul><li><a href=#1%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af aria-label=1.数据通路>1.数据通路</a></li><li><a href=#2%e8%be%93%e5%87%ba%e4%bf%a1%e5%8f%b7-1 aria-label=2.输出信号>2.输出信号</a></li></ul></li><li><a href=#3sw%e6%8c%87%e4%bb%a4 aria-label=3.sw指令>3.sw指令</a><ul><li><a href=#1%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af-1 aria-label=1.数据通路>1.数据通路</a></li><li><a href=#2%e8%be%93%e5%87%ba%e4%bf%a1%e5%8f%b7-2 aria-label=2.输出信号>2.输出信号</a></li></ul></li><li><a href=#4beq%e6%8c%87%e4%bb%a4 aria-label=4.beq指令>4.beq指令</a><ul><li><a href=#1%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af-2 aria-label=1.数据通路>1.数据通路</a></li><li><a href=#2%e8%be%93%e5%87%ba%e4%bf%a1%e5%8f%b7-3 aria-label=2.输出信号>2.输出信号</a></li></ul></li><li><a href=#5lui%e6%8c%87%e4%bb%a4 aria-label=5.lui指令>5.lui指令</a><ul><li><a href=#1%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af-3 aria-label=1.数据通路>1.数据通路</a></li><li><a href=#2%e8%be%93%e5%87%ba%e4%bf%a1%e5%8f%b7-4 aria-label=2.输出信号>2.输出信号</a></li></ul></li><li><a href=#6ori%e6%8c%87%e4%bb%a4 aria-label=6.ori指令>6.ori指令</a><ul><li><a href=#1%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af-4 aria-label=1.数据通路>1.数据通路</a></li><li><a href=#2%e8%be%93%e5%87%ba%e4%bf%a1%e5%8f%b7-5 aria-label=2.输出信号>2.输出信号</a></li></ul></li><li><a href=#7%e5%88%a9%e7%94%a8%e4%b8%8e%e6%88%96%e9%97%a8%e9%98%b5%e5%88%97%e5%ae%9e%e7%8e%b0%e5%af%b9%e6%8c%87%e4%bb%a4%e7%9a%84%e8%af%86%e5%88%ab%e5%92%8c%e4%ba%a7%e7%94%9f%e7%9b%b8%e5%ba%94%e7%9a%84%e6%8e%a7%e5%88%b6%e4%bf%a1%e5%8f%b7 aria-label=7.利用与或门阵列实现对指令的识别和产生相应的控制信号>7.利用与或门阵列实现对指令的识别和产生相应的控制信号</a><ul><li><a href=#1%e6%8c%87%e4%bb%a4%e8%af%86%e5%88%ab aria-label=1.指令识别>1.指令识别</a></li><li><a href=#2%e4%ba%a7%e7%94%9f%e6%8e%a7%e5%88%b6%e4%bf%a1%e5%8f%b7 aria-label=2.产生控制信号>2.产生控制信号</a></li></ul></li><li><a href=#8%e5%af%b9%e8%a1%a5%e5%85%85%e7%9a%84%e6%8c%87%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af%e8%bf%9b%e8%a1%8c%e6%80%bb%e7%bb%93 aria-label=8.对补充的指令的实现思路进行总结>8.对补充的指令的实现思路进行总结</a><ul><li><a href=#1%e8%a1%a5%e5%85%85%e7%9a%84r%e5%9e%8b%e6%8c%87%e4%bb%a4 aria-label=1.补充的R型指令>1.补充的R型指令</a></li><li><a href=#2%e8%a1%a5%e5%85%85%e7%9a%84j%e5%9e%8b%e6%8c%87%e4%bb%a4 aria-label=2.补充的J型指令>2.补充的J型指令</a></li><li><a href=#3%e8%a1%a5%e5%85%85%e7%9a%84i%e5%9e%8b%e6%8c%87%e4%bb%a4 aria-label=3.补充的I型指令>3.补充的I型指令</a></li></ul></li></ul></li><li><a href=#6dm%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8 aria-label=6.DM数据存储>6.DM数据存储</a></li><li><a href=#7ext%e4%bd%8d%e6%89%a9%e5%b1%95 aria-label=7.EXT位扩展>7.EXT位扩展</a></li><li><a href=#8sel-b%e5%85%b7%e4%bd%93%e5%88%a4%e6%96%adb%e6%8c%87%e4%bb%a4 aria-label=8.sel-B具体判断B指令>8.sel-B具体判断B指令</a></li></ul></li><li><a href=#2-test-scheme aria-label="2. test scheme">2. test scheme</a><ul><ul><li><a href=#1%e5%9f%ba%e6%9c%ac%e6%8c%87%e4%bb%a4%e6%b5%8b%e8%af%95 aria-label=1.基本指令测试>1.基本指令测试</a><ul><li><a href=#1-ori-test aria-label="1. ori-test">1. ori-test</a></li><li><a href=#2-lui-test aria-label="2. lui-test">2. lui-test</a></li><li><a href=#3-add-test aria-label="3. add-test">3. add-test</a></li><li><a href=#4sw-test aria-label=4.sw-test>4.sw-test</a></li><li><a href=#5lw-test aria-label=5.lw-test>5.lw-test</a></li><li><a href=#6beq-test aria-label=6.beq-test>6.beq-test</a></li><li><a href=#7%e5%b0%86%e4%bb%a5%e4%b8%8a%e6%8c%87%e4%bb%a4%e7%bb%bc%e5%90%88%e6%b5%8b%e8%af%95 aria-label=7.将以上指令综合测试>7.将以上指令综合测试</a></li></ul></li><li><a href=#2%e8%a1%a5%e5%85%85%e6%8c%87%e4%bb%a4%e5%90%8e%e8%ae%a1%e7%ae%97%e6%8c%87%e4%bb%a4%e7%bb%bc%e5%90%88%e6%b5%8b%e8%af%95 aria-label=2.补充指令后计算指令综合测试>2.补充指令后计算指令综合测试</a></li><li><a href=#3%e8%a1%a5%e5%85%85%e6%8c%87%e4%bb%a4%e5%90%8e%e8%ae%bf%e5%ad%98%e6%8c%87%e4%bb%a4%e7%bb%bc%e5%90%88%e6%b5%8b%e8%af%95 aria-label=3.补充指令后访存指令综合测试>3.补充指令后访存指令综合测试</a></li><li><a href=#4%e8%a1%a5%e5%85%85%e6%8c%87%e4%bb%a4%e5%90%8e%e8%b7%b3%e8%bd%ac%e6%8c%87%e4%bb%a4%e7%bb%bc%e5%90%88%e6%b5%8b%e8%af%95 aria-label=4.补充指令后跳转指令综合测试>4.补充指令后跳转指令综合测试</a></li></ul><li><a href=#2%e7%bc%96%e5%86%99python%e8%84%9a%e6%9c%ac%e5%ae%8c%e6%88%90%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95 aria-label=2.编写python脚本完成自动化测试>2.编写python脚本完成自动化测试</a></li></ul></li><li><a href=#3%e6%80%9d%e8%80%83%e9%a2%98 aria-label=3.思考题>3.思考题</a><ul><li><a href=#1%e5%8d%95%e5%91%a8%e6%9c%9fcpu%e7%9a%84%e6%a8%a1%e5%9d%97%e4%b8%ad%e5%93%aa%e4%ba%9b%e5%8f%91%e6%8c%a5%e7%8a%b6%e6%80%81%e5%ad%98%e5%82%a8%e5%8a%9f%e8%83%bd%e5%93%aa%e4%ba%9b%e5%8f%91%e6%8c%a5%e7%8a%b6%e6%80%81%e8%bd%ac%e7%a7%bb%e5%8a%9f%e8%83%bd aria-label=1.单周期CPU的模块中哪些发挥状态存储功能，哪些发挥状态转移功能？>1.单周期CPU的模块中哪些发挥状态存储功能，哪些发挥状态转移功能？</a></li><li><a href=#2im%e4%bd%bf%e7%94%a8romdm%e4%bd%bf%e7%94%a8ramgrf%e4%bd%bf%e7%94%a8register%e5%90%88%e7%90%86%e5%90%97 aria-label=2.IM使用ROM，DM使用RAM，GRF使用Register合理吗>2.IM使用ROM，DM使用RAM，GRF使用Register合理吗</a></li><li><a href=#3%e9%a2%9d%e5%a4%96%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%8d%95%e5%85%83 aria-label=3.额外实现的单元>3.额外实现的单元</a></li><li><a href=#4nop%e7%a9%ba%e6%8c%87%e4%bb%a4%e4%b8%8d%e9%9c%80%e8%a6%81%e5%8a%a0%e5%85%a5%e4%bf%a1%e5%8f%b7%e7%9c%9f%e5%80%bc%e8%a1%a8 aria-label=4.nop空指令不需要加入信号真值表>4.nop空指令不需要加入信号真值表</a></li><li><a href=#5%e8%af%84%e4%bb%b7mips%e6%8c%87%e4%bb%a4%e5%8f%8a%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e4%b8%80%e8%8a%82%e4%b8%ad%e6%b5%8b%e8%af%95%e6%a0%b7%e4%be%8b%e7%9a%84%e5%bc%ba%e5%ba%a6 aria-label=5.评价MIPS指令及汇编语言一节中测试样例的强度>5.评价MIPS指令及汇编语言一节中测试样例的强度</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=cpu-design-document><center>CPU Design Document</center><a hidden class=anchor aria-hidden=true href=#cpu-design-document>#</a></h2><h3 id=1-cpu-design>1. CPU Design<a hidden class=anchor aria-hidden=true href=#1-cpu-design>#</a></h3><h4 id=1总体设计>1.总体设计<a hidden class=anchor aria-hidden=true href=#1总体设计>#</a></h4><p>​ 通过对于《计算机组成与设计》一书的阅读，对于<code>P3</code>的CPU设计我有如下思考，设计MIPS架构的CPU的本质在于从指令存储器中读出32位MIPS指令，并对MIPS指令进行解析进而完成指令中要求的操作。在本次实验中，要求实现的指令有<code>add</code>,<code>sub</code>,<code>ori</code>,<code>lw</code>,<code>sw</code>,<code>beq</code>,<code>lui</code>,<code>nop</code>其中，R型指令有<code>add,sub</code>,I型指令有<code>ori,lw,sw,beq,lui</code>，特殊的有<code>nop</code>指令，32位全为0。</p><p>RIJ类型指令图:</p><p><img alt=image-20231029210509165 loading=lazy src=/img/image-20231029210509165.png></p><p>此次实验中要求实现的基本指令：</p><ol><li>R型</li></ol><table><thead><tr><th style=text-align:center>Operation</th><th style=text-align:center>Op-Code</th><th style=text-align:center>rs</th><th style=text-align:center>rt</th><th style=text-align:center>rd</th><th style=text-align:center>shamt(移位)</th><th style=text-align:center>func</th></tr></thead><tbody><tr><td style=text-align:center>add</td><td style=text-align:center>000000</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>00000</td><td style=text-align:center>100000</td></tr><tr><td style=text-align:center>sub</td><td style=text-align:center>000000</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>00000</td><td style=text-align:center>100010</td></tr></tbody></table><ol start=2><li>I型</li></ol><table><thead><tr><th style=text-align:center>Operation</th><th style=text-align:center>Op-Code</th><th style=text-align:center>rs</th><th style=text-align:center>rt</th><th style=text-align:center>16-bit-immediate-value</th></tr></thead><tbody><tr><td style=text-align:center>ori</td><td style=text-align:center>001101</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>lw</td><td style=text-align:center>100011</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>sw</td><td style=text-align:center>101011</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>beq</td><td style=text-align:center>000100</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>lui</td><td style=text-align:center>001111</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><ol start=3><li>nop</li></ol><p>​ 32&rsquo;b0</p><p>​ 将我们要实现的CPU分为几个模块：IFU（取指令单元），GRF（寄存器堆），ALU（算术逻辑单元），DM（数据存储器），EXT（扩展单元），Controller（控制器）。</p><p>下面给出设计电路模块图：</p><p><img alt=image-20231026201931449 loading=lazy src=/img/image-20231026201931449.png></p><h4 id=1-ifu取指令单元>1. IFU取指令单元<a hidden class=anchor aria-hidden=true href=#1-ifu取指令单元>#</a></h4><p>​ 由于题目中要求寄存器的<code>0x00003000</code>对应ROM的0地址，即第一条指令的地址，且寄存器异步复位到初值<code>0x00003000</code>，这里涉及到类似于为寄存器赋初值的操作，可以对寄存器进行地址映射，利用寄存器当前值完成“赋初值”，当寄存器值为0时加上0x00003000进行下一个地址NPC的计算，而在计算取ROM中指令地址时再减去0x00003000。注意寄存器中保存的为以字节为单位的偏移量，ROM中一条指令为4个字节，需要将pc寄存器中的值右移两位后才对应到ROM中对应的行地址。</p><h4 id=2npc计算下一条指令地址>2.NPC计算下一条指令地址<a hidden class=anchor aria-hidden=true href=#2npc计算下一条指令地址>#</a></h4><p>​ 利用PCSrc信号选择取出PC+4地址的指令还是进行beq跳转得到的地址，应当注意的是beq中跳转为以字为单位，要先对移位量shift左移两位得到对应的字节偏移量。</p><h4 id=3alu计算单元>3.ALU计算单元<a hidden class=anchor aria-hidden=true href=#3alu计算单元>#</a></h4><table><thead><tr><th>ALUOp</th><th>运算</th><th>是否判断溢出</th></tr></thead><tbody><tr><td>0000</td><td>and</td><td>no</td></tr><tr><td>0001</td><td>or</td><td>no</td></tr><tr><td>0010</td><td>addu</td><td>no</td></tr><tr><td>0011</td><td>subu</td><td>no</td></tr><tr><td>0010</td><td>add</td><td>yes（结合控制信号judge-overflow选择是否进行判断溢出问题）</td></tr><tr><td>0011</td><td>sub</td><td>yes</td></tr><tr><td>0100</td><td>lui</td><td>no</td></tr><tr><td>0101</td><td>xor</td><td>no</td></tr><tr><td>0110</td><td>nor</td><td>no</td></tr><tr><td>0111</td><td>logical-left</td><td>no</td></tr><tr><td>1000</td><td>logical-right</td><td>no</td></tr><tr><td>1001</td><td>Arth-right</td><td>no</td></tr><tr><td>1010</td><td>sign-compare</td><td>no</td></tr><tr><td>1011</td><td>unsigned-compare</td><td>no</td></tr></tbody></table><p><strong>注：由于教程中要求对于add sub不实现溢出判断 即把add sub当作addu subu用，而在指令中不具体实现addu subu</strong></p><h4 id=4-grf寄存器堆>4. GRF寄存器堆<a hidden class=anchor aria-hidden=true href=#4-grf寄存器堆>#</a></h4><p>​ 寄存器中有32个通用寄存器，</p><ul><li>注意0号寄存器的值只能为0，故将使能端WE设置为常量0</li><li>在写入端的解复用器DMX需要设置为三态，否则在写入一个值的时候其他值会被清零</li></ul><h4 id=5controller总控制器>5.Controller总控制器<a hidden class=anchor aria-hidden=true href=#5controller总控制器>#</a></h4><p>​ Controller的输入为读取出指令的Op-Code,即[31:26]位，输出为八个控制信号，其中输送给ALU Controller的控制信号ALUOp为2位，下面对不同指令需要哪些控制信号进行分析，对不同指令按照其<code>Op-Code</code>进行分类.</p><h5 id=1-r型指令>1. R型指令<a hidden class=anchor aria-hidden=true href=#1-r型指令>#</a></h5><h6 id=1-数据通路>1. 数据通路<a hidden class=anchor aria-hidden=true href=#1-数据通路>#</a></h6><p><img alt=image-20231029210536844 loading=lazy src=/img/image-20231029210536844.png></p><h6 id=2输出信号>2.输出信号<a hidden class=anchor aria-hidden=true href=#2输出信号>#</a></h6><p>Op-Code:000000，对R型指令对应的Controller输出情况列表</p><table><thead><tr><th>信号名称</th><th>取值情况</th></tr></thead><tbody><tr><td>RegDst</td><td>1</td></tr><tr><td>ALUSrc</td><td>0</td></tr><tr><td>MemtoReg</td><td>0</td></tr><tr><td>RegWrite</td><td>1</td></tr><tr><td>MemRead</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td></tr><tr><td>Branch</td><td>0</td></tr><tr><td>EXTOp</td><td>0</td></tr></tbody></table><h5 id=2lw指令>2.lw指令<a hidden class=anchor aria-hidden=true href=#2lw指令>#</a></h5><h6 id=1数据通路>1.数据通路<a hidden class=anchor aria-hidden=true href=#1数据通路>#</a></h6><p><img alt=image-20231029210547206 loading=lazy src=/img/image-20231029210547206.png></p><h6 id=2输出信号-1>2.输出信号<a hidden class=anchor aria-hidden=true href=#2输出信号-1>#</a></h6><p>Op-Code:100011，对应的输出情况列表</p><table><thead><tr><th>信号名称</th><th>取值情况</th></tr></thead><tbody><tr><td>RegDst</td><td>0</td></tr><tr><td>ALUSrc</td><td>1</td></tr><tr><td>MemtoReg</td><td>1</td></tr><tr><td>RegWrite</td><td>1</td></tr><tr><td>MemRead</td><td>1</td></tr><tr><td>MemWrite</td><td>0</td></tr><tr><td>Branch</td><td>0</td></tr><tr><td>EXTOp</td><td>1</td></tr></tbody></table><h5 id=3sw指令>3.sw指令<a hidden class=anchor aria-hidden=true href=#3sw指令>#</a></h5><h6 id=1数据通路-1>1.数据通路<a hidden class=anchor aria-hidden=true href=#1数据通路-1>#</a></h6><p><img alt=image-20231029210600170 loading=lazy src=/img/image-20231029210600170.png></p><h6 id=2输出信号-2>2.输出信号<a hidden class=anchor aria-hidden=true href=#2输出信号-2>#</a></h6><p>Op-Code:101011</p><table><thead><tr><th>信号名称</th><th>取值情况</th></tr></thead><tbody><tr><td>RegDst</td><td>x</td></tr><tr><td>ALUSrc</td><td>1</td></tr><tr><td>MemtoReg</td><td>x</td></tr><tr><td>RegWrite</td><td>0</td></tr><tr><td>MemRead</td><td>0</td></tr><tr><td>MemWrite</td><td>1</td></tr><tr><td>Branch</td><td>0</td></tr><tr><td>EXTOp</td><td>1</td></tr></tbody></table><h5 id=4beq指令>4.beq指令<a hidden class=anchor aria-hidden=true href=#4beq指令>#</a></h5><h6 id=1数据通路-2>1.数据通路<a hidden class=anchor aria-hidden=true href=#1数据通路-2>#</a></h6><p><img alt=image-20231029210611308 loading=lazy src=/img/image-20231029210611308.png></p><h6 id=2输出信号-3>2.输出信号<a hidden class=anchor aria-hidden=true href=#2输出信号-3>#</a></h6><p>Op-Code: 000100</p><table><thead><tr><th>信号名称</th><th>取值情况</th></tr></thead><tbody><tr><td>RegDst</td><td>x</td></tr><tr><td>ALUSrc</td><td>0</td></tr><tr><td>MemtoReg</td><td>x</td></tr><tr><td>RegWrite</td><td>0</td></tr><tr><td>MemRead</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td></tr><tr><td>Branch</td><td>1</td></tr><tr><td>EXTOp</td><td>1</td></tr></tbody></table><p><strong>注：由于sw与beq指令中都不需要向寄存器中存储数字，即RegWrite=0,此时RegDst与MemtoReg可以为不定值x因为无论为多少都不会写入</strong></p><h5 id=5lui指令>5.lui指令<a hidden class=anchor aria-hidden=true href=#5lui指令>#</a></h5><h6 id=1数据通路-3>1.数据通路<a hidden class=anchor aria-hidden=true href=#1数据通路-3>#</a></h6><p>​ 将原16位imm后拼接16位0，存入目标寄存器，位拼接操作在ALU中实现，对应操作编码为1000。此处rs寄存器为$0。</p><p><img alt=image-20231106124946845 loading=lazy src=/img/image-20231106124946845.png></p><h6 id=2输出信号-4>2.输出信号<a hidden class=anchor aria-hidden=true href=#2输出信号-4>#</a></h6><p>Op-Code:001111，对应的输出情况列表</p><table><thead><tr><th>信号名称</th><th>取值情况</th></tr></thead><tbody><tr><td>RegDst</td><td>0</td></tr><tr><td>ALUSrc</td><td>1</td></tr><tr><td>MemtoReg</td><td>0</td></tr><tr><td>RegWrite</td><td>1</td></tr><tr><td>MemRead</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td></tr><tr><td>Branch</td><td>0</td></tr><tr><td>EXTOp</td><td>0</td></tr></tbody></table><h5 id=6ori指令>6.ori指令<a hidden class=anchor aria-hidden=true href=#6ori指令>#</a></h5><h6 id=1数据通路-4>1.数据通路<a hidden class=anchor aria-hidden=true href=#1数据通路-4>#</a></h6><p><img alt=image-20231029210637470 loading=lazy src=/img/image-20231029210637470.png></p><h6 id=2输出信号-5>2.输出信号<a hidden class=anchor aria-hidden=true href=#2输出信号-5>#</a></h6><p>Op-Code:001101</p><p><strong>需要注意的是ori指令中16位立即数的范围是:0~65535,如果位数超出16位则会发生截断保留低位</strong></p><table><thead><tr><th>信号名称</th><th>取值情况</th></tr></thead><tbody><tr><td>RegDst</td><td>0</td></tr><tr><td>ALUSrc</td><td>1</td></tr><tr><td>MemtoReg</td><td>0</td></tr><tr><td>RegWrite</td><td>1</td></tr><tr><td>MemRead</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td></tr><tr><td>Branch</td><td>0</td></tr><tr><td>EXTOp</td><td>0</td></tr></tbody></table><p><strong>注：不需要向DM中进行读或写操作，MemRead=MemWrite=0</strong></p><table><thead><tr><th>指令操作码</th><th>操作</th><th>func</th><th>ALU动作</th><th>ALU控制信号</th></tr></thead><tbody><tr><td>lw</td><td>取字</td><td>xxxxxx</td><td>加</td><td>0010</td></tr><tr><td>sw</td><td>存字</td><td>xxxxxx</td><td>加</td><td>0010</td></tr><tr><td>beq</td><td>相等跳转</td><td>xxxxxx</td><td>减</td><td>0110</td></tr><tr><td>add</td><td>加</td><td>100000</td><td>加</td><td>0010</td></tr><tr><td>sub</td><td>减</td><td>100010</td><td>减</td><td>0110</td></tr><tr><td>and</td><td>与</td><td>100100</td><td>与</td><td>0000</td></tr><tr><td>or</td><td>或</td><td>100101</td><td>或</td><td>0001</td></tr><tr><td>ori</td><td>或立即数</td><td>xxxxxx</td><td>或</td><td>0001</td></tr><tr><td>lui</td><td>存半字</td><td>xxxxxx</td><td>低位拼接0</td><td>1000</td></tr></tbody></table><h5 id=7利用与或门阵列实现对指令的识别和产生相应的控制信号>7.利用与或门阵列实现对指令的识别和产生相应的控制信号<a hidden class=anchor aria-hidden=true href=#7利用与或门阵列实现对指令的识别和产生相应的控制信号>#</a></h5><h6 id=1指令识别>1.指令识别<a hidden class=anchor aria-hidden=true href=#1指令识别>#</a></h6><p>​ 对于指令的识别主要用到32位指令中的opcode字段([31-26]位)与funct字段([5:0]位)，只有R型指令会利用funct字段进行指令的识别，其他类型指令只需要opcode字段即可。思路是，先利用opcode进行识别，识别出除R型指令之外的其他类型具体指令后，再利用funct字段对R型指令进行识别。</p><h6 id=2产生控制信号>2.产生控制信号<a hidden class=anchor aria-hidden=true href=#2产生控制信号>#</a></h6><p>​ 我将理论课中介绍的Controller与ALU Controller合并为一个整体，Controller产生的控制信号直接控制ALU进行运算，运用或阵列进行操作，只将输出信号表中为1的接到对应的信号或门上，对于0或x值均无连接，<strong>连接时有一个小技巧为将opcode与funct点为该指令的码，之后只需要将亮色的线连接到与门上。</strong></p><h5 id=8对补充的指令的实现思路进行总结>8.对补充的指令的实现思路进行总结<a hidden class=anchor aria-hidden=true href=#8对补充的指令的实现思路进行总结>#</a></h5><h6 id=1补充的r型指令>1.补充的R型指令<a hidden class=anchor aria-hidden=true href=#1补充的r型指令>#</a></h6><ol><li><p>运算指令</p><p>通过在ALU中传递不同的ALUOp实现，如add,sub,and,or,nor,xor</p></li><li><p>移位指令</p><p>如sll,srl,sllv,srlv,sra,srav,在ALU中通过Shifter实现逻辑左移，逻辑右移，算术右移。其中sll,srl,sra是将rt中的数值移动s([4:0]位立即数)位存储到rd中，在ALU的传入移位量端口控制信号<code>shiftvar=0</code>，sllv,srlv,srav将rt中的值移动rs位后存储入rd，需要注意的是rs只取低五位，相当于<code>s&lt;——GPR[rs]4...0</code>，控制信号<code>shiftvar=1</code>。</p></li><li><p>置位指令</p><p>slt,sltu(set if less than)，同样在在ALU中实现，slt对两个操作数进行符号比较，sltu对两个操作数进行无符号比较，比较结果进行0扩展至32位赋值到rd</p></li><li><p>跳转指令</p><p>jr,jalr.跳转指令需要着重进行分析，</p><ol><li>jr :跳转到寄存器rs中存储的地址，在电路中对应GRF中读取的数据RD1，在NPC模块中实现跳转。</li><li>jalr: PC跳转到GPR[rs]中保存的地址，并将当前PC+4保存在GPR[rd]中，相比jr多了将PC+4存入GPR[RD]的功能。在NPC模块中输出PC+4，在寄存器堆写入数据端口，控制信号<code>PC+4=1</code>，(<strong>控制信号PC+4只有jal和halr指令会涉及到将当前PC+4存入寄存器</strong>)选择写入寄存器信号<code>RegDst=1</code>，<code>ralink=0</code>（<strong>控制信号ralink=1时写入31号寄存器,jal指令专属</strong>）</li></ol></li></ol><h6 id=2补充的j型指令>2.补充的J型指令<a hidden class=anchor aria-hidden=true href=#2补充的j型指令>#</a></h6><p>​ 跳转指令在NPC中实现。</p><ol><li>j ，j跳转指令默认的地址为26位，需要在NPC模块中进行补全，形式为<code>(PC+4)31...28 | j-address |00</code></li><li>jal指令与j指令计算地址的方式相同，同时将PC+4存入31号寄存器即ra寄存器，给出重要的控制信号:<code>ralink=1</code>,<code>pc+4=1</code>,<code>jump=1</code></li></ol><h6 id=3补充的i型指令>3.补充的I型指令<a hidden class=anchor aria-hidden=true href=#3补充的i型指令>#</a></h6><ol><li><p>运算指令</p><p>凡是带立即数运算的如addi,subi,ori,andi等都需要在ALU控制信号<code>ALUSrc=1</code>，选择符号扩展后的32位立即数，运算控制信号ALUOp与R类运算相同</p></li><li><p>B类跳转指令</p><p><strong>注意：B类跳转指令对16位地址偏移量都是进行符号扩展</strong>，Control Unit输出branch，branchOp,完成对具体指令的识别，对于是否满足条件进行跳转的判断则在sel-B模块中实现，尤其要注意在sel-B模块中由于是要进行大于0小于0的判断，比较器应该选择为有符号的。其中beq和bne指令由ALU中输出信号equal判定。</p></li><li><p>置位指令</p><p>slti,sltiu，比较时对第二个操作数<code>ALUSrc=1</code></p></li><li><p>访存指令</p><p>sw,sh,sb,lw,lh,lb,lbu,lhu等指令的具体实现已经在HorB模块中有了比较详细的叙述，利用address[1:0]进行判断并进行"插入"操作</p></li></ol><h4 id=6dm数据存储>6.DM数据存储<a hidden class=anchor aria-hidden=true href=#6dm数据存储>#</a></h4><p>​ 一定要注意DM需要时钟信号控制！DM在时钟上升沿写入数据，一开始没有给DM加时钟信号导致数据没有及时存入<code>QAQ</code>。</p><p>​ **补充指令sb,lb,sh,lh,lbu,lhu，在DM模块中增加新模块HorB，根据控制信号b or h选择按照byte进行操作还是按照half word进行操作。**首先分析传入地址，传入地址是以字节为单位的，我们可以在已知对字/半字/字节操作的的情况下，分析出具体的半字/字节。记传入地址最后两位<code>address[1:0]</code></p><table><thead><tr><th>操作单位</th><th>address[1:0]</th><th>操作对象</th></tr></thead><tbody><tr><td>word</td><td>00</td><td>字</td></tr><tr><td>half word</td><td>00</td><td>第一个半字节</td></tr><tr><td>half word</td><td>10</td><td>第二个半字节</td></tr><tr><td>byte</td><td>00</td><td>第一个字节</td></tr><tr><td>byte</td><td>01</td><td>第二个字节</td></tr><tr><td>byte</td><td>10</td><td>第三个字节</td></tr><tr><td>byte</td><td>11</td><td>第四个字节</td></tr></tbody></table><p>​ <strong>思路：当操作类型为load(读取)：先读取出来一个字，再从中选择部分进行load，当操作类型为save(存入)：先读取出来对应地址上的一个字，再在相应位置上插入想要存入的内容，这就要求sb,lb,sh,lh,lbu,lhu进行操作前需要先从对应地址上读取，即MemRead = 1</strong>.</p><p>电路图如下：</p><p><img alt=image-20231106120304715 loading=lazy src=/img/image-20231106120304715.png></p><h4 id=7ext位扩展>7.EXT位扩展<a hidden class=anchor aria-hidden=true href=#7ext位扩展>#</a></h4><p>​ 位扩展单元由EXTOp信号控制，选择进行符号扩展还是0扩展，其中sw,lw,beq均为符号扩展，ori为0扩展。</p><h4 id=8sel-b具体判断b指令>8.sel-B具体判断B指令<a hidden class=anchor aria-hidden=true href=#8sel-b具体判断b指令>#</a></h4><p>​ 实现的B类型跳转指令有,beq,bne,bgez,bgtz,blez,bltz。可以大致分为两类。第一类为beq,bne，这两个指令是对于两个操作数进行比较然后进行跳转（比较在ALU中完成），第二类中都是进行与0的比较（在sel-B中完成）。branchOp列表如下:</p><table><thead><tr><th>branchOp</th><th>指令</th></tr></thead><tbody><tr><td>000</td><td>beq</td></tr><tr><td>001</td><td>bltz</td></tr><tr><td>001</td><td>bgez</td></tr><tr><td>010</td><td>bgtz</td></tr><tr><td>011</td><td>blez</td></tr><tr><td>100</td><td>bne</td></tr></tbody></table><p>​ 其中beq指令与bne指令都由equal信号判断，故对于beq\bne的选择通过最高位选择。在001编码中，对bltz和bgez进行了合并，因为这两种指令的opcode一致为000001，故在control unit中无法实现对这两种指令的识别，<strong>需要利用这两种指令的[20:16]进行分辨，即judge信号，bltz:00000,bgez:00001</strong>，这样实际上需要选择的只有四个信号，利用branchOp的低两位进行判断，电路图如下：</p><p><img alt=image-20231106123917609 loading=lazy src=/img/image-20231106123917609.png></p><p><strong>尤其需要注意的是：在sel-B模块中比较器应当选择有符号的而不是unsigned，因为他们都是与0进行比较，而在ALU模块中slt指令需要进行符号比较，sltu指令需要进行无符号比较.</strong></p><h3 id=2-test-scheme>2. test scheme<a hidden class=anchor aria-hidden=true href=#2-test-scheme>#</a></h3><p>​ 课下测试利用课程组提供的jar包进行测试，从MARS中导出16进制文件load到我的单周期CPU中，运行CPU，将存储在寄存器中的数据与MARS运行结果进行比对。</p><h5 id=1基本指令测试>1.基本指令测试<a hidden class=anchor aria-hidden=true href=#1基本指令测试>#</a></h5><h6 id=1-ori-test>1. ori-test<a hidden class=anchor aria-hidden=true href=#1-ori-test>#</a></h6><p>​ <strong>ori指令中的立即数为无符号扩展，不存在复数的情况</strong>，测试指令</p><pre tabindex=0><code class=language-MIPS data-lang=MIPS>ori $a0,$0,123
ori $a1,$a0,456
</code></pre><h6 id=2-lui-test>2. lui-test<a hidden class=anchor aria-hidden=true href=#2-lui-test>#</a></h6><pre tabindex=0><code class=language-MIPS data-lang=MIPS>lui $a2,123 #符号位为0
lui $a3,0xffff #符号位为1
</code></pre><h6 id=3-add-test>3. add-test<a hidden class=anchor aria-hidden=true href=#3-add-test>#</a></h6><pre tabindex=0><code class=language-MIPS data-lang=MIPS>lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
</code></pre><h6 id=4sw-test>4.sw-test<a hidden class=anchor aria-hidden=true href=#4sw-test>#</a></h6><pre tabindex=0><code class=language-MIPS data-lang=MIPS>ori $a0,$0,1
ori $a1,$0,2
ori $a2,$0,3
ori $t0, $0, 0x0000
sw $a0, 0($t0)
sw $a1, 4($t0)
sw $a2, 8($t0)
</code></pre><h6 id=5lw-test>5.lw-test<a hidden class=anchor aria-hidden=true href=#5lw-test>#</a></h6><pre tabindex=0><code class=language-MIPS data-lang=MIPS>ori $a0,$0,1
ori $a1,$0,2
ori $a2,$0,3
ori $t0, $0, 0x0000
sw $a0, 0($t0)
sw $a1, 4($t0)
sw $a2, 8($t0)
lw $a0, 0($t0)
lw $a1, 12($t0)
sw $a0, 28($t0)
sw $a1, 32($t0)
</code></pre><h6 id=6beq-test>6.beq-test<a hidden class=anchor aria-hidden=true href=#6beq-test>#</a></h6><pre tabindex=0><code class=language-MIPS data-lang=MIPS>ori $a0, $0, 1
ori $a1, $0, 2
ori $a2, $0, 1
beq $a0, $a1, loop1     # 不相等
beq $a0, $a2, loop2     # 相等
loop1:sw $a0, 36($t0)
loop2:sw $a1, 40($t0)
</code></pre><h6 id=7将以上指令综合测试>7.将以上指令综合测试<a hidden class=anchor aria-hidden=true href=#7将以上指令综合测试>#</a></h6><pre tabindex=0><code class=language-MIPS data-lang=MIPS>ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
add $s0, $a0, $a2      # 正正
add $s1, $a0, $a3      # 正负
add $s2, $a3, $a3      # 负负
ori $t0, $0, 0x0000
sw $a0, 0($t0)
sw $a1, 4($t0)
sw $a2, 8($t0)
sw $a3, 12($t0)
sw $s0, 16($t0)
sw $s1, 20($t0)
sw $s2, 24($t0)
lw $a0, 0($t0)
lw $a1, 12($t0)
sw $a0, 28($t0)
sw $a1, 32($t0)
ori $a0, $0, 1
ori $a1, $0, 2
ori $a2, $0, 1
beq $a0, $a1, loop1     # 不相等
beq $a0, $a2, loop2     # 相等
loop1:sw $a0, 36($t0)
loop2:sw $a1, 40($t0)
</code></pre><p>​ <strong>需要注意的是MARS设置中不应当开启delayed branching，否则会运行跳转指令如beq的下一条指令，与本地CPU不符</strong></p><h5 id=2补充指令后计算指令综合测试>2.补充指令后计算指令综合测试<a hidden class=anchor aria-hidden=true href=#2补充指令后计算指令综合测试>#</a></h5><pre tabindex=0><code class=language-MIPS data-lang=MIPS></code></pre><h5 id=3补充指令后访存指令综合测试>3.补充指令后访存指令综合测试<a hidden class=anchor aria-hidden=true href=#3补充指令后访存指令综合测试>#</a></h5><pre tabindex=0><code class=language-MIPS data-lang=MIPS>.text

li	$s0, 0xABCF1234
li	$s1, 0x1234ABCD
li	$s2, 0xa1b2c3d4
li	$s3, 0x7fff0000

sb	$s1, 100($0)
sb	$s2, 103($0)
sb	$s3, 105($0)
sb	$s4, 107($0)
sh	$s4, 108($0)
sh	$s3, 110($0)
sh	$s2, 112($0)
sh	$s1, 114($0)
sw	$s0, 0($0)
sw	$s1, 4($0)
sw	$s2, 8($0)
sw	$s3, 12($0)
lw	$t0, 0($0)
lw	$t1, 4($0)
lw	$t2, 8($0)
lw	$t3, 12($0)
sw	$t0, 16($0)
sw	$t1, 20($0)
sw	$t2, 24($0)
sw	$t3, 28($0)
lb	$t0, 3($0)
lb	$t1, 7($0)
lb	$t2, 11($0)
lb	$t3, 13($0)
sw	$t0, 32($0)
sw	$t1, 36($0)
sw	$t2, 40($0)
sw	$t3, 44($0)
lbu	$t0, 3($0)
lbu	$t1, 7($0)
lbu	$t2, 11($0)
lbu	$t3, 13($0)
sw	$t0, 48($0)
sw	$t1, 52($0)
sw	$t2, 56($0)
sw	$t3, 60($0)
lh	$t0, 2($0)
lh	$t0, 4($0)
lh	$t0, 8($0)
lh	$t0, 12($0)
sw	$t0, 64($0)
sw	$t1, 68($0)
sw	$t2, 72($0)
sw	$t3, 76($0)
lhu	$t0, 2($0)
lhu	$t0, 6($0)
lhu	$t0, 8($0)
lhu	$t0, 12($0)
sw	$t0, 80($0)
sw	$t1, 84($0)
sw	$t2, 88($0)
sw	$t3, 92($0)
li	$v0, 10
syscall
</code></pre><h5 id=4补充指令后跳转指令综合测试>4.补充指令后跳转指令综合测试<a hidden class=anchor aria-hidden=true href=#4补充指令后跳转指令综合测试>#</a></h5><pre tabindex=0><code class=language-MIPS data-lang=MIPS>.text
main:	
li	$s0, 0
li	$s1, -1000
li	$s2, 1000
lui	$s3, 0x8000	#s3 is  -2147483648
lui	$s4, 0x8000
ori	$s4, 0x0001	#s4 is  -2147483647
lui	$s5, 0x7fff
ori	$s5, 0xffff	#s5 is  2147483647
lui	$s6, 0x7fff
ori	$s6, 0xfffe	#s6 is 2147483646


beq_1:	beq	$s0, $s0, beq_1_test
beq_10:  beq	$s5, $s6, beq_10_test
beq_end:

bne_1:	bne	$s0, $s1, bne_1_test
bne_10:	bne	$s3, $s3, bne_10_test
bne_end:

blez_1: blez	$s0, blez_1_test
blez_10: blez	$s6, blez_10_test
blez_end:

bgtz_1:	 bgtz	$s2,bgtz_1_test
bgtz_10: bgtz	$s1,bgtz_10_test
bgtz_end:

jal_1:	jal	jal_1_test
jal_5:	jal	jal_5_test
jal_end:

jalr_1:	or	$v0, $0, 12916
	jalr	$v1, $v0
jalr_5:	or	$v0, $0, 12948
	jalr	$v1, $v0

sw	$t0, 0($s0)
sw	$t1, 0($s0)
sw	$t2, 0($s0)
sw	$t3, 0($s0)
sw	$t4, 0($s0)
sw	$t5, 0($s0)
li	$v0, 10
syscall
	
beq_1_test: addi	$t0,$t0, 1
	   j	beq_10
beq_10_test: addi	$t0,$t0, 1
	   j	beq_end

bne_1_test: addi	$t1,$t1, 1
	   j	bne_10
bne_10_test:addi	$t1,$t1, 1
	   j	bne_end  	      	      	   

blez_1_test:	addi	$t2,$t2, 1
		j	blez_10
blez_10_test:	addi	$t2,$t2, 1
		j	blez_end

bgtz_1_test:	addi	$t3,$t3 1
		j	bgtz_10
bgtz_10_test:	addi	$t3,$t3 1
		j	bgtz_end
		
jal_1_test:	addi	$t4, $4, 1
		jr	$ra
jal_5_test:	addi	$t4, $4, 1
		jr	$ra

jalr_1_test:	addi	$t5, $t5, 1
		jr	$v1
jalr_5_test:	addi	$t5, $t5, 1
		jr	$v1
</code></pre><h4 id=2编写python脚本完成自动化测试>2.编写python脚本完成自动化测试<a hidden class=anchor aria-hidden=true href=#2编写python脚本完成自动化测试>#</a></h4><p>​ 利用正则表达式替换，对ROM中内容进行改写，并生成新的电路。</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> os
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> re
</span></span><span style=display:flex><span><span style=color:#6272a4>#generate ROM-File</span>
</span></span><span style=display:flex><span>command<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;java -jar MARS_mod.jar CPUtest.asm nc mc CompactTextAtZero a dump .text HexText rom.txt&#34;</span>
</span></span><span style=display:flex><span>os<span style=color:#ff79c6>.</span>system(command)
</span></span><span style=display:flex><span>content <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>open</span>(<span style=color:#f1fa8c>&#34;rom.txt&#34;</span>)<span style=color:#ff79c6>.</span>read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#write ROM-File to Circle—File</span>
</span></span><span style=display:flex><span>cur <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>open</span>(<span style=color:#f1fa8c>&#34;CPU.circ&#34;</span>, encoding<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;utf-8&#34;</span>)<span style=color:#ff79c6>.</span>read()
</span></span><span style=display:flex><span>cur <span style=color:#ff79c6>=</span> re<span style=color:#ff79c6>.</span>sub(<span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>&#39;addr/data: 12 32([\s\S]*)&lt;/a&gt;&#39;</span>,<span style=color:#f1fa8c>&#34;addr/data: 12 32</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span> <span style=color:#ff79c6>+</span> content <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34;&lt;/a&gt;&#34;</span>, cur)
</span></span><span style=display:flex><span><span style=color:#ff79c6>with</span> <span style=color:#8be9fd;font-style:italic>open</span>(<span style=color:#f1fa8c>&#34;cpu_remake.circ&#34;</span>,<span style=color:#f1fa8c>&#34;w&#34;</span>, encoding<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;utf-8&#34;</span>) <span style=color:#ff79c6>as</span> file:
</span></span><span style=display:flex><span> file<span style=color:#ff79c6>.</span>write(cur)
</span></span></code></pre></td></tr></table></div></div><p>​ <strong>注意：cpu_remake是根据原CPU新生成的文件，若有改动应该在原CPU中完成，若在cpu_remake中进行改动，改动会发生“丢失”，因为cpu_remake的每一次生成都是根据CPU生成</strong></p><h3 id=3思考题>3.思考题<a hidden class=anchor aria-hidden=true href=#3思考题>#</a></h3><h4 id=1单周期cpu的模块中哪些发挥状态存储功能哪些发挥状态转移功能>1.单周期CPU的模块中哪些发挥状态存储功能，哪些发挥状态转移功能？<a hidden class=anchor aria-hidden=true href=#1单周期cpu的模块中哪些发挥状态存储功能哪些发挥状态转移功能>#</a></h4><p>​ 答：在单周期CPU中，我们以<code>splitter</code>为界可以将CPU分为一个Moore机与一个Mealy机，两个状态机各有一个状态存储模块与一个状态转移模块。状态存储：IM,GRF,DM，状态转移：NPC,ALU</p><h4 id=2im使用romdm使用ramgrf使用register合理吗>2.IM使用ROM，DM使用RAM，GRF使用Register合理吗<a hidden class=anchor aria-hidden=true href=#2im使用romdm使用ramgrf使用register合理吗>#</a></h4><p>​ 合理，Information Memory用来存储运行的程序指令，要保证程序不会被更改，使用ROM（Read Only Memory）， Data Memory是数据存储区，需要进行写入和读取，使用RAM。</p><h4 id=3额外实现的单元>3.额外实现的单元<a hidden class=anchor aria-hidden=true href=#3额外实现的单元>#</a></h4><p>​ 我将IFU中的取指令功能与计算下一指令地址的逻辑分开，计算下一指令地址的功能单独由NPC模块实现，包括对B型和J型指令的跳转。具体细分判断B类型跳转指令的sel-B模块，HorB，存储或读取时对字节和半字进行操作的模块。</p><h4 id=4nop空指令不需要加入信号真值表>4.nop空指令不需要加入信号真值表<a hidden class=anchor aria-hidden=true href=#4nop空指令不需要加入信号真值表>#</a></h4><p>​ 实际上nop指令会被识别为sll指令，具体形式为<code>sll $0,$0,0</code>，即将0号寄存器左移0位，确实不会发生影响。</p><h4 id=5评价mips指令及汇编语言一节中测试样例的强度>5.评价MIPS指令及汇编语言一节中测试样例的强度<a hidden class=anchor aria-hidden=true href=#5评价mips指令及汇编语言一节中测试样例的强度>#</a></h4><p>​ 测试样例的覆盖是不全面的，有些寄存器没有用到，有些负数的特殊情况没有涉及，跳转的指令没有涉及等。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://coder0xe.github.io/tags/nov/>Nov</a></li></ul><nav class=paginav><a class=prev href=https://coder0xe.github.io/posts/p4-verilog-cpu/><span class=title>« Prev</span><br><span>支持40条指令P4_Verilog_CPU</span>
</a><a class=next href=https://coder0xe.github.io/posts/oopre%E6%80%BB%E7%BB%93/><span class=title>Next »</span><br><span>OOpre总结</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 支持40条指令P3_logisim_CPU on x" href="https://x.com/intent/tweet/?text=%e6%94%af%e6%8c%8140%e6%9d%a1%e6%8c%87%e4%bb%a4P3_logisim_CPU&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f&amp;hashtags=Nov"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 支持40条指令P3_logisim_CPU on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f&amp;title=%e6%94%af%e6%8c%8140%e6%9d%a1%e6%8c%87%e4%bb%a4P3_logisim_CPU&amp;summary=%e6%94%af%e6%8c%8140%e6%9d%a1%e6%8c%87%e4%bb%a4P3_logisim_CPU&amp;source=https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 支持40条指令P3_logisim_CPU on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f&title=%e6%94%af%e6%8c%8140%e6%9d%a1%e6%8c%87%e4%bb%a4P3_logisim_CPU"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 支持40条指令P3_logisim_CPU on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 支持40条指令P3_logisim_CPU on whatsapp" href="https://api.whatsapp.com/send?text=%e6%94%af%e6%8c%8140%e6%9d%a1%e6%8c%87%e4%bb%a4P3_logisim_CPU%20-%20https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 支持40条指令P3_logisim_CPU on telegram" href="https://telegram.me/share/url?text=%e6%94%af%e6%8c%8140%e6%9d%a1%e6%8c%87%e4%bb%a4P3_logisim_CPU&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 支持40条指令P3_logisim_CPU on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e6%94%af%e6%8c%8140%e6%9d%a1%e6%8c%87%e4%bb%a4P3_logisim_CPU&u=https%3a%2f%2fcoder0xe.github.io%2fposts%2fp3-logisim-cpu-design%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://coder0xe.github.io/>coder0xe's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>