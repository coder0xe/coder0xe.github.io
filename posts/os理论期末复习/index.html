<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OS理论期末复习 | coder0xe's blog</title><meta name=keywords content="OS期末复习"><meta name=description content="OS理论期末复习"><meta name=author content="sudo"><link rel=canonical href=https://coder0xe.github.io/posts/os%E7%90%86%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/><link crossorigin=anonymous href=/assets/css/stylesheet.e4a36188e2c44563c1cc5ed1a2d0b8451a4f68c685114d738b97609f82dae050.css integrity="sha256-5KNhiOLERWPBzF7RotC4RRpPaMaFEU1zi5dgn4La4FA=" rel="preload stylesheet" as=style><link rel=icon href=https://coder0xe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://coder0xe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://coder0xe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://coder0xe.github.io/apple-touch-icon.png><link rel=mask-icon href=https://coder0xe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://coder0xe.github.io/posts/os%E7%90%86%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://coder0xe.github.io/posts/os%E7%90%86%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><meta property="og:site_name" content="coder0xe's blog"><meta property="og:title" content="OS理论期末复习"><meta property="og:description" content="OS理论期末复习"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-03T19:55:42+08:00"><meta property="article:modified_time" content="2024-06-03T19:55:42+08:00"><meta property="article:tag" content="June"><meta name=twitter:card content="summary"><meta name=twitter:title content="OS理论期末复习"><meta name=twitter:description content="OS理论期末复习"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://coder0xe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OS理论期末复习","item":"https://coder0xe.github.io/posts/os%E7%90%86%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OS理论期末复习","name":"OS理论期末复习","description":"OS理论期末复习","keywords":["OS期末复习"],"articleBody":"OS理论期末复习 一. 引论 ==1. 批处理系统== 把用户提交的作业成批送入计算机 由作业调度程序自动选择作业运行 目的 缩短作业之间的交接时间 减少处理机的空闲等待，提高系统效率 1.1 联机批处理系统 作业的输入输出由CPU处理 **优点：**监督程序不停地处理各个作业，实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间 不足：在作业输入和结果输出时，主机的高速CPU仍然处于空闲状态，等待慢速的输入输出设备完成工作 1.2 脱机批处理系统 作业的输入输出脱离CPU处理\n**优点：**主机不与慢速的输入输出设备打交道，而是与速度相对较快的磁带机发生关系，缓解了主机与设备的矛盾\n**缺点：**每次主机内存中仅存放一道作业，每当它运行期间发出I/O请求后，高速的CPU处于等待低速的I/O完成状态，CPU空闲\n2. 多道程序系统 **多道程序设计技术：**允许多个程序同时进入内存并运行\n当一道程序因I/O请求暂停时，CPU便立即转去运行另一道程序\n宏观上并行，微观上串行\n**优点：**使CPU得到充分利用，同时也改善I/O设备和内存的利用率，提高了整个系统的资源利用率和系统吞吐量\n单道程序系统：I/O时CPU空闲\n多道程序系统：交替使用CPU\n3. 多道批处理系统 优点： 系统吞吐量大 资源利用率高 缺点： 平均周转时间长 ==不能提供交互能力== 4. 分时系统 多个用户分享使用同一台计算机，多个程序分时共享硬件和软件资源\n多路性：多路连接，宏观上用户共享，微观上分时\n独立性：用户相互不干扰\n及时性：响应时间\n交互性：人机对话\n分时技术：处理机的运行时间分成很短的时间片，轮流分配给各联机作业使用\n5. 实时系统 及时响应\n高可靠性和安全性\n实时信息处理、实时控制\n6. 异常、陷阱和中断 同步异常：执行指令的过程中发生\n系统调用为一种同步异常:自陷指令(trap)\n二.引导 加载BIOS 读取MBR BootLoader 加载内核 … 三. 内存管理 地址空间：逻辑地址空间\n存储空间：物理地址空间\n1.单道程序的内存管理 静态地址翻译：在程序运行之前就计算出所有物理地址\n优点：\n最简单，单用户、单任务的OS 执行过程中无需进行地址翻译，程序运行速度快 缺点：\n比物理内存大的程序无法加载 资源浪费 2.多道程序的存储管理 分区式分配：把内存分为一些大小相等或不等的分区，每个应用程序占用一个或几个分区\n2.1 固定式分区 当系统初始化时，把存储空间划分为若干个任意大小的区域，然后把这些区域分配给每个用户作业\n**优点：**易于实现，开销小\n缺点：\n内碎片造成浪费 分区总数固定，限制了并发执行的程序数目 数据结构：分区表\n分配方式\n单一队列：大分区小程序 多队列：按程序大小对应分区块排队\n2.2 可变式分区 分区的边界可以移动，分区的大小可变\n优点：没有内碎片\n缺点：产生外碎片\n==外部碎片是造成内存系统性能下降的主要原因==\n消除外碎片：紧凑技术\n内碎片已经被分配给程序，外碎片是没被分配给程序的碎片\n2.3 闲置空间的管理 跟踪内存的使用：位图表示法/链表表示法 2.3.1 位图表示法 为每个分配单元赋予一个字位，用来记录单元是否闲置\n优点\n空间成本固定：不依赖于内存中程序数量 时间成本低 缺点\n没有容错能力 2.3.2 链表表示法 空闲链表\n优点\n有一定容错能力 缺点\n时间成本：链表扫描较慢 空间成本：取决于程序的数量 2.4 回收内存 尽可能合并回收分区上下的空闲分区 2.5 基于顺序搜索的内存分配 首次适应(Fisrt Fit)：从空闲链表的始端开始查找，选择第一个满足请求的空白块 下次适应(Next Fit)：总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去 最佳适应(Best Fit)：找到大小最接近于作业要求的分区 最坏适应(Worst Fit)：为作业选择存储区域时，总是寻找最大的空白区 2.6 基于索引搜索的内存分配 较大系统遍历空闲链表比较慢\n快速适应算法(分类搜索法)：把空闲分区按照容量大小进行分类，经常用到长度的空闲区设立单独的空闲区链表，系统为多个空闲链表设立一张管理索引表。 优点 查找效率高，依据长度寻找能容纳他的最小空闲区链表取下第一块进行分配 缺点 分区归还主存时算法复杂，系统开销大 伙伴系统(二进制伙伴系统)：在分配存储块时将一个大的存储块分裂成两个大小相等的小块 大小为$2^k$ 分配给进程大于或等于所申请尺寸的最小的2的幂次的空闲块 内存释放时，首先考虑将被释放块与其伙伴合并成一个大的空闲块，然后继续合并下去，直到不能合并为止 ==2.7 程序编译和程序段== 编译(compile)：由编译程序将用户源程序编译为若干个目标模块\n链接(linking)：由链接程序将目标模块和对应的库函数连接成可装载模块\n装入(loading)：由装载程序将可装载模块装入内存\n==程序段==\nbss段：存放程序中未初始化的全局变量或静态变量 data段：存放程序中已初始化的全局变量静态变量 text段：存放程序执行代码 ==栈(stack)==\n存放程序局部变量 保存/恢复调用现场 向下生长 ==堆(heap)==\nmalloc/free 向下生长 2.8 ELF可执行文件 2.9 链接 2.10 装载 对于每一个段，根据其在内存中的大小，分配足够的物理页并映射到指定的虚地址上 若ELF中记录的段在内存中大小大于在文件中大小，多出来部分用0填充 未初始化全局变量为0 2.11 页式内存管理 程序：程序是静止的，是存放在磁盘上的可执行文件\n进程：进程是动态的，进程包括程序和程序处理对象，是一个程序对某个数据集的执行过程\n作业：作业是用户需要计算机完成的某项任务\n分页地址结构：页号P+位移量W\n逻辑地址：虚拟页号+页内偏移量\n物理地址：物理页号+页内偏移量\n虚拟页面大小与物理页面大小相等\n地址转换机构：MMU\n一级页表\n逻辑地址空间大，划分的页面多，页表占用的存储空间大\n虚拟页号转换到对应的物理页号 需要访存两次(页表一次，访问数据一次) 两级页表\n给一级页表设置页表 一级页表(页目录) 地址结构：p1 | p2 | offset 二级页表访存次数：三次 2.12 快表TLB 解决页表的访存性能下降问题，建立快表(页表的Cache)\nMMU首先在TLB中查找，若没有则到外部页表查询，然后置换进TLB\n访存：TLB命中情况下：一次Cache+一次内存\n多个进程的标识符：ASID\n2.13 改进页表 2.13.1 哈希页表 建立虚拟页号与物理页号的哈希表，提高查找速度 2.13.2 反置页表 反置页表不是根据进程的逻辑页号来组织，而是依据该进程在内存中的物理页号来组织\n按照进程在内存中的物理页面号来组织，表项的内容是逻辑页号P及隶属进程标志符pid\n反置页表的大小只与物理内存的大小有关\n可以使用哈希表进行优化\n2.14 页共享与保护 页共享：物理页面出现在A和B两个进程的地址空间\n页保护：地址越界保护，在页表中设置保护位\n2.15 分段存储管理 一个段可以定义为一组逻辑信息，每个作业的地址空间是由一些分段构成的，例如代码段、数据段等。\n优点：\n方便编程 信息共享 信息保护 动态增长 动态链接 地址结构：段号+位移量\n==分页的地址空间为一维的，分段的地址空间为二维的==\n对比\n页是信息的物理单位，大小固定 段是信息的逻辑单位，长度不固定 分页活动用户看不见，分段是用户可见的 段页式：先分段，再分页\n2.16 虚拟存储管理 2.16.1 覆盖 节约，时间上扩展\n把一个大的程序划分为一系列的覆盖，每个覆盖是一个独立的程序单位，程序执行时并不要求同时装入主存的覆盖组成一组 缺点：编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度。 2.16.2 交换 借用，空间上扩展\n把暂时不用的某个程序及其数据的部分或全部从主存移到辅存中去，腾出必要的存储空间，接着把指定程序或数据从辅存读到相应的主存中。 2.16.3 ==局部性原理== 程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址局限于一定区域 ==时间局部性==：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内 ==空间局部性==：当前指令和临近的几条指令，当前访问的数据和临近的数据都集中在一个较小区域内 2.16.4 虚拟存储 所有进程一致的地址空间，每个进程都认为自己在独占使用单机系统的存储资源 隔离进程地址访问 缺页中断：进程执行过程中需访问的页面不在物理存储器中，发生缺页中断 ==页面置换算法== ==2.16.5 页面置换策略== 最佳策略(OPT)：从主存中移出永远不再需要的页面，如无这样的页面存在，应选择最长时间不需要访问的页面(理论参考，==无法被实现==)\n先进先出(FIFO)：总选择作业在主存中驻留时间最长的一页淘汰\n最近最久不用的页面置换算法(LRUR)：选择在最近一段时间内最久不用的页面予以淘汰\n改进的FIFO算法：二次机会算法(Second Chance)：如果被淘汰的数据之前被访问过，则给其第二次机会\n每个页面增加一个访问标志位，标识此数据放入缓存队列后是否再次被访问过\n对于队列中最旧的页面\n若其放入队列后没有被再次访问，则立即被淘汰 如果放入队列后被访问过，则移动到FIFO队列头，并清除访问标志位 若所有页面都被访问过，按照FIFO淘汰 改进的FIFO算法：Clock(最近未使用算法NRU，Not Recently Used)，环形队列\n==FIFO类算法命中率比其他算法要低，实际中很少使用==\n==最近最少使用(LRU:Least Recently Used)：局部性原理的合理近似，性能接近最优算法==\n硬件开销比较大 近似实现：设置栈保存当前使用的各个页面的页面号，当进程访问某页面时压入栈顶 老化算法(Aging)：LRU的简化\n为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入\n选择寄存器值小的移出\n2.16.6 Belady现象(期中考过) 在使用FIFO算法作为缺页置换算法时，分配的页面增多，缺页率反而提高\n理想的情况：缺页率随页框数增加而下降\nBelady现象\n2.16.7 工作集与驻留集 进程的==工作集(Working Set)==：当前正在使用的页面的集合\n进程的==驻留集==：每个进程驻留在内存的页面集合(分配的物理页)\n工作集策略：依据进程在过去的一段时间内访问的页面来调整常驻集大小\n工作集可以用一个二元函数$WS(k,t)$表示 $k$表示窗口尺寸 $t$表示执行时刻 工作集为$[t-k,t]$时间段内访问的页面的集合 驻留集的管理：系统应当为每个活跃进程分配多少个页框\n分配给每个活跃进程的页框数越少，同时驻留内存的活跃进程数就越多，进程调度就绪进程的概率就越大，但是将导致缺页中断率增大 全局置换算法：程序无法控制自己的缺页率，在内存中的页面不仅取决于该进程的页面走向，也取决于其他进程\n可变分配策略+局部置换：可增加或减少分配给每个活跃进程的页框数，当进程的页框全部用完，而需要装入一个新的页面，==系统在该进程的当前驻留集中选择一个页面换出内存==\n==抖动问题(期中考过)==\n随着驻留内存的进程数目增加，处理器利用率先是上升，然后下降 原因是：每个进程的常驻集不断减小，缺页率不断上升，频繁发生缺页中断 选择适当的进程数目，平衡并发水平和缺页率 ==消除抖动==： 局部置换策略 工作集算法 预留部分页面 挂起若干进程 2.16.8 写时复制技术 实验中的理解已经足够 ==2.17 页目录自映射== 一个进程的4GB地址空间被划分为4GB/4KB=1M页，即需要1M个页表项来记录逻辑-物理关系\n每个页表项需要4B，1M个页表项需要4MB，即整个页表占用的地址空间大小为4MB\n4MB页表需要1024个页面存储，每一页中存储1024个页表项\n一个页表项对应4KB内存，则个页表页对应4MB内存\n页目录占一页空间，有1024项，每一项指向一个页表页，==则必有一项指向自己，即页目录也是上述4MB页表中的一页==\n一个页目录项指向一个页表页，映射到4MB物理内存\n假设进程页表的基地址为$PT_{base}$，几个经典计算\n==页目录基地址$PD_{base}$​：页目录中第一项映射第一个页表页==\n$PD_{n} : 10bits | PT_n : 10bits | offset:12bits$\n$PD_{base}=PT_{base}+(PT_{base} » 12)*4=PT_{base}+PT_{base}»10$\n解释：映射第一个页表页的页表项编号为PT_base » 12，也就是页目录项的编号，每个PDE大小为4B，基地址+偏移量\n==映射页目录自身的页目录项==\n$页目录基地址PD_{base}=PT_{base}+PT_{base}»10$\n$PDE_{self-mapping}=PT_{base}+(PD_{base}»12)*4=PT_{base}|PT_{base}»10|PT_{base}»20$\n==根本思想：计算出映射到该页表页的是第几个页表项==\n四.进程管理 1. 进程与线程 并发：有两个活动a1,a2，如果在某一指定的时间t，无论a1和a2是在同一处理机上还是在不同的处理机上执行，只要a1和a2都处在各自的起点和终点之间的某一处，即称为并发的\n并行：两个程序在同一时间度量下运行在不同的处理机上\n竞争：多个进程在读写一个共享数据时，结果依赖于他们执行的相对时间，这种情形叫竞争\n==1.1 Bernstein条件== $R(S_{i})$：Si的读子集 $W(S_i)$：Si的写子集 两个进程可并发的条件为 R(S1)^W(S2)=null W(S1)^R(S2)=null W(S1)^W(S2)=null ==或者说可并发条件为除了读读之外交集都为空== 1.2 进程 进程是一个程序及其数据在处理机上顺序执行所发生的活动\n==进程是系统进行资源分配和调度的一个基本单位==\n动态性：==程序是静态实体，进程具有生命周期==\n并发性：多个进程在内存中同时运行\n独立性：==传统OS中==，进程是独立运行的基本单位\n异步性\n进程的结构\n程序段、数据段、进程控制块PCB 1.3 进程控制 ==由内核来实现==\n进程控制的实现——原语：由若干条指令所组成的指令序列，来实现某个特定的操作功能，连续不可被分割，必须在内核态执行\nfork()执行一次，父子进程两个返回值\n==进程的状态(期中考过)==\n就绪状态：已经获得所需资源，分配CPU就可运行 执行状态：占用CPU运行，进程数小于等于CPU数目 阻塞状态：正在执行的进程，由于发生某种事件而无法执行，放弃CPU处于暂停状态 ==状态转换==\n就绪-\u003e运行：调度程序选择进程运行 运行-\u003e就绪：运行进程用完了时间片，或因为高优先级进程处于就绪状态而中断 运行-\u003e阻塞：当进程需要的资源必须等待 阻塞-\u003e就绪：所等待的事件发生 进程控制块PCB\n进程标识符：每个进程唯一的标识符 程序和数据地址 现行状态 现场保留区：trapframe寄存器等等 优先级 父进程 同步互斥机制 … ==进程上下文切换vs陷入内核：陷入内核开销更小==\n进程上下文切换：\n调度器执行 保存进程执行断点 保存执行现场 切换内存映射 陷入内核\n中断/异常/trap 保存执行现场 ==用户态到内核态的切换(mode switch)消耗要比进程上下文切换(Process Context Switch)消耗小得多==\n1.4 线程 进程：资源拥有者+可执行单元\n线程：可执行单元\n优点\n减小进程切换开销 提高进程内的并发程度 共享资源 ==基本上不拥有资源，和同进程的线程共享进程拥有的所有资源==\n==进程是资源分配的基本单位，线程是处理机调度的基本单位==\n用户级线程：线程在用户空间，通过用户库模拟thread\n优点 上下文切换快 ==线程切换与内核无关== ==线程调度由应用决定，容易进行优化== 缺点： 系统调用会引起阻塞，因为内核只能看到一个进程，所以会阻塞所有相关的线程 内核只能将处理器分配给进程，即使有多个处理器也无法实现多线程并行执行 内核级线程：kernel有好几个分身，一个分身处理一件事\n优点 阻塞发生在线程级别 内核可以在多个处理器上调度一个进程的多个线程 缺点 线程切换需要内核参与 ==切换效率较低== 线程安全：对象\n多个线程访问同一个对象时，如果不用考虑线程的调度和交替执行，也不需要进行额外的同步，或者调用方进行任何操作，行为都可以获得正确的结果 可重入：代码\n即当该副程序正在运作时，执行线程可以再次进入并执行它，仍然可得到符合设计时所预期的结果 ==可重入不一定线程安全，线程安全不一定可重入==\n1.5 同步与互斥 wty课件例题\n**临界资源：**我们将一次仅允许一个进程访问的资源称为临界资源\n**临界区：**访问临界资源的代码\n互斥：某一资源同时只允许一个访问者对其进行访问，无法限制访问顺序，无序访问\n同步：在互斥的基础上通过其他机制实现对资源的有序访问\n==基于忙等待的互斥方法（暂时跳过，期中考过）==\n浪费CPU时间 1.6 信号量机制 必须置一次且只能置一次初值\n只能由P、V操作改变\nP操作分配资源\n无法分配则阻塞(wait)：避免忙等 V操作释放资源\n有等待进程则唤醒(signal) S.value为正表示资源个数\nS.value为负表示等待进程个数\n信号量实现互斥：S=1\n1 2 3 P(S) // 临界区 V(S) 信号量实现同步：S=0\n1 2 3 4 5 6 7 8 9 process1(){ P(s) // code } process2(){ //code V(s) } 前驱关系\n有限并发：S=n\n多进程同步原语(Barriers)\ncount到达汇合点的线程数 信号量集：同时需要多个资源时的信号量操作\nAND型信号量集：将进程需要的所有共享资源一次分配给他，使用完后一起释放(每种资源分配一个) SP(S1,S2,…,Sn) 一般信号量集：Si的测试值为ti，低于ti不进行分配，占用值为di SP(S1,t1,d1,…,Sn,tn,dn) 1.7 基于管程的同步互斥 把分散的临界区集中起来，为每个可共享资源设计一个专门机构来统一管理各进程对该资源的访问\n==管程是高级同步原语==\n互斥：任意时刻，管程中只能有一个活跃进程\n管程中的特殊类型变量：条件变量\n每个条件变量表示一种等待原因，==并不取具体数值== 条件变量与信号量的区别\n条件变量的值不可增减，信号量可增减\nwait操作一定会阻塞当前进程，P操作只有当信号量值小于0才会阻塞\n没有wait线程则signal会丢失，V操作不会丢失\n当一个进入管程的进程执行等待操作时，应当释放管程的互斥权，后面进入的进程执行唤醒，则管程中有两个同时处于活动状态的进程\nsignal(x)时如何避免管程中有两个活跃进程 Hoare：执行signal的进程等待，直到被释放进程退出管程 Mesa：被释放进程等待，直到执行signal的进程退出管程 Hansen：执行signal的进程立即退出管程 1.8 进程间通信 IPC 低级通信：传递状态和整数值\n==高级通信：管道，共享内存，消息系统==\n1.8.1 无名管道 半双工：==数据只能向一个方向流动==，双方通信建立两个管道\n==只能用于父子进程或兄弟进程之间==\n单独构成独立的文件系统，管道对于管道两端的进程而言是一个文件\n数据读出和写入：从末尾写入，从头部读出(数据单向流动的原因)\n1.8.2 有名管道(FIFO) ==名字打破了无名管道只能在有亲缘关系的进程间通信的限制，不相关进程可以交换数据== FIFO提供了路径名与之关联，访问路径通过FIFO通信 以FIFO文件的形式存在于文件系统中 从末尾写入，从开始读出 1.8.3 消息传递 系统调用send/receive 阻塞调用/非阻塞调用 ==内核消息缓冲区== 1.8.4 共享内存 ==最有效的进程间通信机制，最快== 同一块物理内存被映射到A,B各自的进程地址空间 2.经典同步互斥问题 课件\u0026作业 3. 进程调度 高级调度：作业调度，从工作流程角度对每个作业进行调度\n中级调度：从存储器资源的角度将进程的部分或全部换出到外存上\n==低级调度：从CPU资源的角度对进程/线程进行调度==\n抢占式 非抢占式 何时进行切换 用户调用 陷阱 中断 ==进程切换的步骤== 保存处理器上下文，程序计数器和其他寄存器 用新状态和其他相关信息更新正在运行进程的PCB 把进程移到合适的队列：就绪/阻塞 选择另一个要执行的进程 更新被选中进程的PCB 从被选中进程中重装入CPU上下文 ==3.1 调度性能准则== ==周转时间：作业从提交到完成所经历的时间== 响应时间：用户输入一个请求到系统给出首次响应的时间(分时系统) 截止时间：开始截止时间和完成截止时间(实时系统) 优先级 公平性 ==吞吐量：单位时间内完成的作业数(批处理系统)== 作业/小时 ==平均周转时间不是吞吐量的倒数，并发执行的作业在时间上可以重叠== 处理机利用率：忙碌时间/总时间 各种资源的均衡利用 ==3.2 批处理系统中常用的调度算法== 有关指标\n==$吞吐量=\\frac {作业数} {总执行时间}$ 即单位CPU时间完成的作业量==\n==$周转时间=完成时刻-提交时刻(小时为单位)$==\n$平均周转时间=\\frac {作业周转时间之和} {作业数}$\n==$带权周转时间=\\frac {周转时间} {执行时间}$==\n$平均带权周转时间=\\frac {作业带权周转时间之和} {作业数}$\n有关调度方式\n抢占式：就绪队列中有优先级高于当前运行进程优先级的进程，立即进行进程调度\n非抢占式：一个进程一直占用处理器知道时间片用完或I/O等原因进入阻塞状态才让出处理器\n3.2.1 FCFS 先来先服务 按照作业提交或进程变为就绪状态的先后次序分派CPU ==非抢占式== 有利于长作业，不利于短作业 有利于CPU繁忙的作业，不利于I/O繁忙的作业 3.2.2 SJF 短作业优先 对预计执行时间短的作业优先分派处理机 通常后来的短作业==不抢占==正在执行的作业 优点 ==改善平均周转时间和平均带权周转时间==，缩短作业等待时间 提高系统吞吐量 缺点 对长作业不友好，饥饿现象 没有优先级划分 3.2.3 SRTF 最短剩余时间优先 ==抢占式== 一个新就绪的进程如果比当前运行进程具有更短的完成时间，则系统抢占当前进程，选择新就绪的进程运行 长任务饥饿现象 3.2.4 HRRF 最高响应比优先 ==非抢占式==\n每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP，然后选择最大的投入运行\n$RP=\\frac {已等待时间+要求运行时间} {要求运行时间}$\n==3.3 交互式系统调度算法== 3.3.1 RR 时间片轮转算法 ==抢占式==\n所有进程按照FCFS原则排成队列，每次调度将CPU分派给队首进程，让其执行一个时间片，一个时间片执行完后，发生时钟中断，将当前进程送到就绪队列末尾\n系统的响应时间\n$T=N(进程数目)*q(时间片)$\n数目越多时间片越小\n3.3.2 PS 优先级算法 平衡进程对响应时间的要求\n静态优先级：创建进程时就确定，直到进程终止前都不改变\n动态优先级：创建进程时赋予的优先级，在进程运行过程中可以自动改变，获得更好的调度性能\n3.3.3 MLQ 多级队列算法 引入多个就绪队列，通过对各队列的区别对待，到达综合的调度目标 不同队列有不同的优先级，时间片长度，调度策略 优先执行高优先级，高优先级队列为空再执行低优先级 3.3.4 RRMF 多级反馈队列算法 设置多个就绪队列，分别赋予不同的优先级，每个队列执行时间片的长度也不同，优先级越低时间片越长\n新进程进入内存后，先投入队列1的末尾，按时间片轮转算法调度，若按队列1的一个时间片未能执行完，则降低优先级投入到队列2的末尾，同样按时间片轮转算法调度…降低到最后的队列，则按照FCFS算法调度直到完成。\n当较高优先级的队列为空，才调度较低优先级队列中的进程执行，若进程执行时有新进程进入较高优先级的队列，则==抢先==执行新进程，并把被抢先的进程投入到原队列末尾\n3.3.5 优先级倒置 问题背景：有三个进程 taskA taskB taskC 优先级依次降低\ntaskA和taskC共享临界资源，但是由于taskB优先级比taskC高，taskB抢占处理机，这样C得不到处理，优先级最高的A也被阻塞\n==解决关键：提高C优先级，不允许B抢占CPU==\n优先级置顶：给C最高的优先级，A也抢不过来 缺点：如果临界区较长，则A仍会等待很长的时间 优先级继承：C继承A的优先级 3.4 实时系统调度算法 实时系统是一种时间起主导作用的系统，计算机必须在一个确定的时间范围内做出反应 ==抢先式调度== 快速中断响应：中断处理时间尽量短 实时系统问题描述：\n假设一任务集S={t1,t2,…tn}，周期分别为T1,T2,…,Tn，执行时间分别为C1,C2,..Cn\n截止周期为D1,D2,…,Dn通常Di=Ti\n所有的任务都是周期性的(Ti)，必须在时限Di内完成\n==$CPU利用率 U= \\Sigma {\\frac {C_i} {T_i}}$​==\n3.4.1 静态表调度算法 对所有周期性任务进行分析预测，==事先确定一个固定的调度方案== 无任何计算，无灵活性 3.4.2 RMS 单调速率调度 (2106被拷打过) 优先级静态固定分配：优先级与周期成反比，周期越短优先级越高，优先级越高的任务先被调度，优先级相同随机调度\n==抢占式，静态优先级：最优静态优先级调度算法==\n3.4.3 EDF 最早截止期优先 任务的绝对截止时间越早优先级越高，优先级越高先被调度(动态优先级)\n3.5 多处理机调度(略) 4. 死锁 一组进程中，每个进程都无限等待被该组进程中其他进程所占有的资源 ==4.1 死锁发生的四个必要条件== 互斥条件：进程对分配到的资源进排他性使用\n请求且占有条件：进程已经占有至少一个资源，但又提出新的请求，但该资源已经被其他进程占有，此时进程阻塞，且对已获得的资源保持不放\n不可剥夺条件：进程已经获得的资源在使用完之前不能被剥夺\n==环路等待条件==：发生死锁时，必定存在一个“进程-资源”的环形链，或者说循环等待条件\n{P0,P1,..Pn}中P0等待P1的资源，P1等待P2…\n4.2 死锁预防 ==排除死锁的静态策略==\n打破互斥条件：有些资源不允许被同时访问\n打破申请且占有条件：实行资源预先分配策略，只有系统能够满足当前全部资源请求时，才一次性将所申请的资源分配给该进程，否则不分配\n打破不可剥夺条件：允许进程从占有者处强行夺取\n打破循环等待条件：实行资源有序分配策略，资源事先分类编号，按号分配，进程占用了小号资源才申请大号资源，例如多层锁的顺序性\n1 2 3 P(mutex1); P(mutex2); //... 4.3 死锁避免 ==排除死锁的动态策略==\n安全序列：一个进程序列是安全的，是指对于每一个进程Pi，他需要的附加资源可以被系统中当前可用资源加上所有进程Pj(j","wordCount":"912","inLanguage":"en","datePublished":"2024-06-03T19:55:42+08:00","dateModified":"2024-06-03T19:55:42+08:00","author":{"@type":"Person","name":"sudo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://coder0xe.github.io/posts/os%E7%90%86%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},"publisher":{"@type":"Organization","name":"coder0xe's blog","logo":{"@type":"ImageObject","url":"https://coder0xe.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://coder0xe.github.io/ accesskey=h title="coder0xe's blog (Alt + H)">coder0xe's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://coder0xe.github.io/ title=首页><span>首页</span></a></li><li><a href=https://coder0xe.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://coder0xe.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://coder0xe.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://coder0xe.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://coder0xe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://coder0xe.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">OS理论期末复习</h1><div class=post-description>OS理论期末复习</div><div class=post-meta><span title='2024-06-03 19:55:42 +0800 +0800'>June 3, 2024</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>sudo</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#os%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0 aria-label=OS理论期末复习>OS理论期末复习</a><ul><li><a href=#%e4%b8%80-%e5%bc%95%e8%ae%ba aria-label="一. 引论">一. 引论</a><ul><li><a href=#1-%e6%89%b9%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f aria-label="==1. 批处理系统==">==1. 批处理系统==</a><ul><li><a href=#11-%e8%81%94%e6%9c%ba%e6%89%b9%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f aria-label="1.1 联机批处理系统">1.1 联机批处理系统</a></li><li><a href=#12-%e8%84%b1%e6%9c%ba%e6%89%b9%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f aria-label="1.2 脱机批处理系统">1.2 脱机批处理系统</a></li></ul></li><li><a href=#2-%e5%a4%9a%e9%81%93%e7%a8%8b%e5%ba%8f%e7%b3%bb%e7%bb%9f aria-label="2. 多道程序系统">2. 多道程序系统</a></li><li><a href=#3-%e5%a4%9a%e9%81%93%e6%89%b9%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f aria-label="3. 多道批处理系统">3. 多道批处理系统</a></li><li><a href=#4-%e5%88%86%e6%97%b6%e7%b3%bb%e7%bb%9f aria-label="4. 分时系统">4. 分时系统</a></li><li><a href=#5-%e5%ae%9e%e6%97%b6%e7%b3%bb%e7%bb%9f aria-label="5. 实时系统">5. 实时系统</a></li><li><a href=#6-%e5%bc%82%e5%b8%b8%e9%99%b7%e9%98%b1%e5%92%8c%e4%b8%ad%e6%96%ad aria-label="6. 异常、陷阱和中断">6. 异常、陷阱和中断</a></li></ul></li><li><a href=#%e4%ba%8c%e5%bc%95%e5%af%bc aria-label=二.引导>二.引导</a></li><li><a href=#%e4%b8%89-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-label="三. 内存管理">三. 内存管理</a><ul><li><a href=#1%e5%8d%95%e9%81%93%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-label=1.单道程序的内存管理>1.单道程序的内存管理</a></li><li><a href=#2%e5%a4%9a%e9%81%93%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=2.多道程序的存储管理>2.多道程序的存储管理</a><ul><li><a href=#21-%e5%9b%ba%e5%ae%9a%e5%bc%8f%e5%88%86%e5%8c%ba aria-label="2.1 固定式分区">2.1 固定式分区</a></li><li><a href=#22-%e5%8f%af%e5%8f%98%e5%bc%8f%e5%88%86%e5%8c%ba aria-label="2.2 可变式分区">2.2 可变式分区</a></li><li><a href=#23-%e9%97%b2%e7%bd%ae%e7%a9%ba%e9%97%b4%e7%9a%84%e7%ae%a1%e7%90%86 aria-label="2.3 闲置空间的管理">2.3 闲置空间的管理</a><ul><li><a href=#231-%e4%bd%8d%e5%9b%be%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label="2.3.1 位图表示法">2.3.1 位图表示法</a></li><li><a href=#232-%e9%93%be%e8%a1%a8%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label="2.3.2 链表表示法">2.3.2 链表表示法</a></li></ul></li><li><a href=#24-%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98 aria-label="2.4 回收内存">2.4 回收内存</a></li><li><a href=#25-%e5%9f%ba%e4%ba%8e%e9%a1%ba%e5%ba%8f%e6%90%9c%e7%b4%a2%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d aria-label="2.5 基于顺序搜索的内存分配">2.5 基于顺序搜索的内存分配</a></li><li><a href=#26-%e5%9f%ba%e4%ba%8e%e7%b4%a2%e5%bc%95%e6%90%9c%e7%b4%a2%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d aria-label="2.6 基于索引搜索的内存分配">2.6 基于索引搜索的内存分配</a></li><li><a href=#27-%e7%a8%8b%e5%ba%8f%e7%bc%96%e8%af%91%e5%92%8c%e7%a8%8b%e5%ba%8f%e6%ae%b5 aria-label="==2.7 程序编译和程序段==">==2.7 程序编译和程序段==</a></li><li><a href=#28-elf%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6 aria-label="2.8 ELF可执行文件">2.8 ELF可执行文件</a></li><li><a href=#29-%e9%93%be%e6%8e%a5 aria-label="2.9 链接">2.9 链接</a></li><li><a href=#210-%e8%a3%85%e8%bd%bd aria-label="2.10 装载">2.10 装载</a></li><li><a href=#211-%e9%a1%b5%e5%bc%8f%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-label="2.11 页式内存管理">2.11 页式内存管理</a></li><li><a href=#212-%e5%bf%ab%e8%a1%a8tlb aria-label="2.12 快表TLB">2.12 快表TLB</a></li><li><a href=#213-%e6%94%b9%e8%bf%9b%e9%a1%b5%e8%a1%a8 aria-label="2.13 改进页表">2.13 改进页表</a><ul><li><a href=#2131-%e5%93%88%e5%b8%8c%e9%a1%b5%e8%a1%a8 aria-label="2.13.1 哈希页表">2.13.1 哈希页表</a></li><li><a href=#2132-%e5%8f%8d%e7%bd%ae%e9%a1%b5%e8%a1%a8 aria-label="2.13.2 反置页表">2.13.2 反置页表</a></li></ul></li><li><a href=#214-%e9%a1%b5%e5%85%b1%e4%ba%ab%e4%b8%8e%e4%bf%9d%e6%8a%a4 aria-label="2.14 页共享与保护">2.14 页共享与保护</a></li><li><a href=#215-%e5%88%86%e6%ae%b5%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label="2.15 分段存储管理">2.15 分段存储管理</a></li><li><a href=#216-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label="2.16 虚拟存储管理">2.16 虚拟存储管理</a><ul><li><a href=#2161-%e8%a6%86%e7%9b%96 aria-label="2.16.1 覆盖">2.16.1 覆盖</a></li><li><a href=#2162-%e4%ba%a4%e6%8d%a2 aria-label="2.16.2 交换">2.16.2 交换</a></li><li><a href=#2163-%e5%b1%80%e9%83%a8%e6%80%a7%e5%8e%9f%e7%90%86 aria-label="2.16.3 ==局部性原理==">2.16.3 ==局部性原理==</a></li><li><a href=#2164-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8 aria-label="2.16.4 虚拟存储">2.16.4 虚拟存储</a></li><li><a href=#2165-%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ad%96%e7%95%a5 aria-label="==2.16.5 页面置换策略==">==2.16.5 页面置换策略==</a></li><li><a href=#2166-belady%e7%8e%b0%e8%b1%a1%e6%9c%9f%e4%b8%ad%e8%80%83%e8%bf%87 aria-label="2.16.6 Belady现象(期中考过)">2.16.6 Belady现象(期中考过)</a></li><li><a href=#2167-%e5%b7%a5%e4%bd%9c%e9%9b%86%e4%b8%8e%e9%a9%bb%e7%95%99%e9%9b%86 aria-label="2.16.7 工作集与驻留集">2.16.7 工作集与驻留集</a></li><li><a href=#2168-%e5%86%99%e6%97%b6%e5%a4%8d%e5%88%b6%e6%8a%80%e6%9c%af aria-label="2.16.8 写时复制技术">2.16.8 写时复制技术</a></li></ul></li><li><a href=#217-%e9%a1%b5%e7%9b%ae%e5%bd%95%e8%87%aa%e6%98%a0%e5%b0%84 aria-label="==2.17 页目录自映射==">==2.17 页目录自映射==</a></li></ul></li></ul></li><li><a href=#%e5%9b%9b%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86 aria-label=四.进程管理>四.进程管理</a><ul><li><a href=#1-%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b aria-label="1. 进程与线程">1. 进程与线程</a><ul><li><a href=#11-bernstein%e6%9d%a1%e4%bb%b6 aria-label="==1.1 Bernstein条件==">==1.1 Bernstein条件==</a></li><li><a href=#12-%e8%bf%9b%e7%a8%8b aria-label="1.2 进程">1.2 进程</a></li><li><a href=#13-%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6 aria-label="1.3 进程控制">1.3 进程控制</a></li><li><a href=#14-%e7%ba%bf%e7%a8%8b aria-label="1.4 线程">1.4 线程</a></li><li><a href=#15-%e5%90%8c%e6%ad%a5%e4%b8%8e%e4%ba%92%e6%96%a5 aria-label="1.5 同步与互斥">1.5 同步与互斥</a></li><li><a href=#16-%e4%bf%a1%e5%8f%b7%e9%87%8f%e6%9c%ba%e5%88%b6 aria-label="1.6 信号量机制">1.6 信号量机制</a></li><li><a href=#17-%e5%9f%ba%e4%ba%8e%e7%ae%a1%e7%a8%8b%e7%9a%84%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5 aria-label="1.7 基于管程的同步互斥">1.7 基于管程的同步互斥</a></li><li><a href=#18-%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1-ipc aria-label="1.8 进程间通信 IPC">1.8 进程间通信 IPC</a><ul><li><a href=#181-%e6%97%a0%e5%90%8d%e7%ae%a1%e9%81%93 aria-label="1.8.1 无名管道">1.8.1 无名管道</a></li><li><a href=#182-%e6%9c%89%e5%90%8d%e7%ae%a1%e9%81%93fifo aria-label="1.8.2 有名管道(FIFO)">1.8.2 有名管道(FIFO)</a></li><li><a href=#183-%e6%b6%88%e6%81%af%e4%bc%a0%e9%80%92 aria-label="1.8.3 消息传递">1.8.3 消息传递</a></li><li><a href=#184-%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98 aria-label="1.8.4 共享内存">1.8.4 共享内存</a></li></ul></li></ul></li><li><a href=#2%e7%bb%8f%e5%85%b8%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e9%97%ae%e9%a2%98 aria-label=2.经典同步互斥问题>2.经典同步互斥问题</a></li><li><a href=#3-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6 aria-label="3. 进程调度">3. 进程调度</a><ul><li><a href=#31-%e8%b0%83%e5%ba%a6%e6%80%a7%e8%83%bd%e5%87%86%e5%88%99 aria-label="==3.1 调度性能准则==">==3.1 调度性能准则==</a></li><li><a href=#32-%e6%89%b9%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f%e4%b8%ad%e5%b8%b8%e7%94%a8%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label="==3.2 批处理系统中常用的调度算法==">==3.2 批处理系统中常用的调度算法==</a><ul><li><a href=#321-fcfs-%e5%85%88%e6%9d%a5%e5%85%88%e6%9c%8d%e5%8a%a1 aria-label="3.2.1 FCFS 先来先服务">3.2.1 FCFS 先来先服务</a></li><li><a href=#322-sjf-%e7%9f%ad%e4%bd%9c%e4%b8%9a%e4%bc%98%e5%85%88 aria-label="3.2.2 SJF 短作业优先">3.2.2 SJF 短作业优先</a></li><li><a href=#323-srtf-%e6%9c%80%e7%9f%ad%e5%89%a9%e4%bd%99%e6%97%b6%e9%97%b4%e4%bc%98%e5%85%88 aria-label="3.2.3 SRTF 最短剩余时间优先">3.2.3 SRTF 最短剩余时间优先</a></li><li><a href=#324-hrrf-%e6%9c%80%e9%ab%98%e5%93%8d%e5%ba%94%e6%af%94%e4%bc%98%e5%85%88 aria-label="3.2.4 HRRF 最高响应比优先">3.2.4 HRRF 最高响应比优先</a></li></ul></li><li><a href=#33-%e4%ba%a4%e4%ba%92%e5%bc%8f%e7%b3%bb%e7%bb%9f%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label="==3.3 交互式系统调度算法==">==3.3 交互式系统调度算法==</a><ul><li><a href=#331-rr-%e6%97%b6%e9%97%b4%e7%89%87%e8%bd%ae%e8%bd%ac%e7%ae%97%e6%b3%95 aria-label="3.3.1 RR 时间片轮转算法">3.3.1 RR 时间片轮转算法</a></li><li><a href=#332-ps-%e4%bc%98%e5%85%88%e7%ba%a7%e7%ae%97%e6%b3%95 aria-label="3.3.2 PS 优先级算法">3.3.2 PS 优先级算法</a></li><li><a href=#333-mlq-%e5%a4%9a%e7%ba%a7%e9%98%9f%e5%88%97%e7%ae%97%e6%b3%95 aria-label="3.3.3 MLQ 多级队列算法">3.3.3 MLQ 多级队列算法</a></li><li><a href=#334-rrmf-%e5%a4%9a%e7%ba%a7%e5%8f%8d%e9%a6%88%e9%98%9f%e5%88%97%e7%ae%97%e6%b3%95 aria-label="3.3.4 RRMF 多级反馈队列算法">3.3.4 RRMF 多级反馈队列算法</a></li><li><a href=#335-%e4%bc%98%e5%85%88%e7%ba%a7%e5%80%92%e7%bd%ae aria-label="3.3.5 优先级倒置">3.3.5 优先级倒置</a></li></ul></li><li><a href=#34-%e5%ae%9e%e6%97%b6%e7%b3%bb%e7%bb%9f%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label="3.4 实时系统调度算法">3.4 实时系统调度算法</a><ul><li><a href=#341-%e9%9d%99%e6%80%81%e8%a1%a8%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label="3.4.1 静态表调度算法">3.4.1 静态表调度算法</a></li><li><a href=#342-rms-%e5%8d%95%e8%b0%83%e9%80%9f%e7%8e%87%e8%b0%83%e5%ba%a6-2106%e8%a2%ab%e6%8b%b7%e6%89%93%e8%bf%87 aria-label="3.4.2 RMS 单调速率调度 (2106被拷打过)">3.4.2 RMS 单调速率调度 (2106被拷打过)</a></li><li><a href=#343-edf-%e6%9c%80%e6%97%a9%e6%88%aa%e6%ad%a2%e6%9c%9f%e4%bc%98%e5%85%88 aria-label="3.4.3 EDF 最早截止期优先">3.4.3 EDF 最早截止期优先</a></li></ul></li><li><a href=#35-%e5%a4%9a%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6%e7%95%a5 aria-label="3.5 多处理机调度(略)">3.5 多处理机调度(略)</a></li></ul></li><li><a href=#4-%e6%ad%bb%e9%94%81 aria-label="4. 死锁">4. 死锁</a><ul><li><a href=#41-%e6%ad%bb%e9%94%81%e5%8f%91%e7%94%9f%e7%9a%84%e5%9b%9b%e4%b8%aa%e5%bf%85%e8%a6%81%e6%9d%a1%e4%bb%b6 aria-label="==4.1 死锁发生的四个必要条件==">==4.1 死锁发生的四个必要条件==</a></li><li><a href=#42-%e6%ad%bb%e9%94%81%e9%a2%84%e9%98%b2 aria-label="4.2 死锁预防">4.2 死锁预防</a></li><li><a href=#43-%e6%ad%bb%e9%94%81%e9%81%bf%e5%85%8d aria-label="4.3 死锁避免">4.3 死锁避免</a><ul><li><a href=#431-%e9%93%b6%e8%a1%8c%e5%ae%b6%e7%ae%97%e6%b3%95 aria-label="==4.3.1 银行家算法==">==4.3.1 银行家算法==</a></li><li><a href=#432-%e5%ae%89%e5%85%a8%e6%80%a7%e7%ae%97%e6%b3%95 aria-label="==4.3.2 安全性算法==">==4.3.2 安全性算法==</a></li></ul></li><li><a href=#44-%e6%ad%bb%e9%94%81%e6%a3%80%e6%b5%8b aria-label="4.4 死锁检测">4.4 死锁检测</a><ul><li><a href=#441-%e8%b5%84%e6%ba%90%e5%88%86%e9%85%8d%e5%9b%be aria-label="==4.4.1 资源分配图==">==4.4.1 资源分配图==</a></li><li><a href=#442-%e6%a3%80%e6%b5%8b%e6%ad%bb%e9%94%81 aria-label="4.4.2 检测死锁">4.4.2 检测死锁</a></li></ul></li><li><a href=#45-%e6%ad%bb%e9%94%81%e8%a7%a3%e9%99%a4 aria-label="4.5 死锁解除">4.5 死锁解除</a></li></ul></li></ul></li><li><a href=#%e4%ba%94%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e7%b3%bb%e7%bb%9f aria-label=五.输入输出系统>五.输入输出系统</a><ul><li><a href=#1-io%e8%ae%be%e5%a4%87%e5%88%86%e7%b1%bb aria-label="1. I/O设备分类">1. I/O设备分类</a></li><li><a href=#2-io%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f aria-label="2 .I/O控制方式">2 .I/O控制方式</a><ul><li><a href=#21-%e8%bd%ae%e8%af%a2%e6%96%b9%e5%bc%8f aria-label="2.1 轮询方式">2.1 轮询方式</a></li><li><a href=#22-%e4%b8%ad%e6%96%ad%e9%a9%b1%e5%8a%a8%e6%96%b9%e5%bc%8f aria-label="2.2 中断驱动方式">2.2 中断驱动方式</a></li><li><a href=#23-%e7%9b%b4%e6%8e%a5%e5%ad%98%e5%82%a8%e8%ae%bf%e9%97%ae%e6%96%b9%e5%bc%8fdma aria-label="2.3 直接存储访问方式(DMA)">2.3 直接存储访问方式(DMA)</a></li><li><a href=#24-io%e9%80%9a%e9%81%93%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f aria-label="2.4 I/O通道控制方式">2.4 I/O通道控制方式</a></li></ul></li><li><a href=#3-%e7%bc%93%e5%86%b2%e6%8a%80%e6%9c%af aria-label="3. 缓冲技术">3. 缓冲技术</a><ul><li><a href=#31-%e5%8d%95%e7%bc%93%e5%86%b2 aria-label="3.1 单缓冲">3.1 单缓冲</a></li><li><a href=#32-%e5%8f%8c%e7%bc%93%e5%86%b2 aria-label="3.2 双缓冲">3.2 双缓冲</a></li><li><a href=#34-%e7%8e%af%e5%bd%a2%e7%bc%93%e5%86%b2 aria-label="3.4 环形缓冲">3.4 环形缓冲</a></li><li><a href=#35-%e7%bc%93%e5%86%b2%e6%b1%a0 aria-label="3.5 缓冲池">3.5 缓冲池</a></li></ul></li></ul></li><li><a href=#%e5%85%ad%e7%a3%81%e7%9b%98%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=六.磁盘存储管理>六.磁盘存储管理</a><ul><li><a href=#1%e7%a3%81%e7%9b%98%e7%bb%93%e6%9e%84 aria-label=1.磁盘结构>1.磁盘结构</a></li><li><a href=#2%e7%a3%81%e7%9b%98%e8%ae%bf%e9%97%ae%e6%97%b6%e9%97%b4 aria-label="==2.磁盘访问时间==">==2.磁盘访问时间==</a><ul><li><a href=#21-%e5%af%bb%e9%81%93%e6%97%b6%e9%97%b4 aria-label="2.1 寻道时间">2.1 寻道时间</a></li><li><a href=#22-%e6%97%8b%e8%bd%ac%e5%bb%b6%e8%bf%9f%e6%97%b6%e9%97%b4 aria-label="2.2 旋转延迟时间">2.2 旋转延迟时间</a></li><li><a href=#23-%e4%bc%a0%e8%be%93%e6%97%b6%e9%97%b4 aria-label="2.3 传输时间">2.3 传输时间</a></li><li><a href=#24-%e6%80%bb%e8%ae%bf%e9%97%ae%e6%97%b6%e9%97%b4 aria-label="2.4 总访问时间">2.4 总访问时间</a></li></ul></li><li><a href=#3-%e7%a3%81%e7%9b%98%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label="==3. 磁盘调度算法==">==3. 磁盘调度算法==</a><ul><li><a href=#31-fcfs aria-label="3.1 FCFS">3.1 FCFS</a></li><li><a href=#32-sstf-%e6%9c%80%e7%9f%ad%e5%af%bb%e9%81%93%e6%97%b6%e9%97%b4%e4%bc%98%e5%85%88 aria-label="3.2 SSTF 最短寻道时间优先">3.2 SSTF 最短寻道时间优先</a></li><li><a href=#33-scan%e6%89%ab%e6%8f%8f%e7%ae%97%e6%b3%95 aria-label="3.3 SCAN扫描算法">3.3 SCAN扫描算法</a></li><li><a href=#34-c-scan-%e5%be%aa%e7%8e%af%e6%89%ab%e6%8f%8f%e7%ae%97%e6%b3%95 aria-label="3.4 C-SCAN 循环扫描算法">3.4 C-SCAN 循环扫描算法</a></li></ul></li><li><a href=#4-raid aria-label="4. RAID">4. RAID</a></li></ul></li><li><a href=#%e4%b8%83%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-label=七.文件系统>七.文件系统</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=os理论期末复习>OS理论期末复习<a hidden class=anchor aria-hidden=true href=#os理论期末复习>#</a></h1><h2 id=一-引论>一. 引论<a hidden class=anchor aria-hidden=true href=#一-引论>#</a></h2><h3 id=1-批处理系统>==1. 批处理系统==<a hidden class=anchor aria-hidden=true href=#1-批处理系统>#</a></h3><ul><li>把用户提交的作业<strong>成批</strong>送入计算机</li><li>由作业调度程序自动选择作业运行</li><li><strong>目的</strong><ul><li>缩短作业之间的交接时间</li><li>减少处理机的空闲等待，提高系统效率</li></ul></li></ul><h4 id=11-联机批处理系统>1.1 联机批处理系统<a hidden class=anchor aria-hidden=true href=#11-联机批处理系统>#</a></h4><ul><li>作业的输入输出由CPU处理</li><li><img alt=image-20240603200219167 loading=lazy src=/img/image-20240603200219167.png></li><li>**优点：**监督程序不停地处理各个作业，实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间</li><li><strong>不足</strong>：在作业输入和结果输出时，主机的高速CPU仍然处于空闲状态，等待慢速的输入输出设备完成工作</li></ul><h4 id=12-脱机批处理系统>1.2 脱机批处理系统<a hidden class=anchor aria-hidden=true href=#12-脱机批处理系统>#</a></h4><ul><li><p>作业的输入输出脱离CPU处理</p></li><li><p><img alt=image-20240603200518486 loading=lazy src=/img/image-20240603200518486.png></p><p><img alt=image-20240603201014462 loading=lazy src=/img/image-20240603201014462.png></p></li><li><p>**优点：**主机不与慢速的输入输出设备打交道，而是与速度相对较快的磁带机发生关系，缓解了主机与设备的矛盾</p></li><li><p>**缺点：**每次主机内存中仅存放一道作业，每当它运行期间发出I/O请求后，高速的CPU处于等待低速的I/O完成状态，CPU空闲</p></li></ul><h3 id=2-多道程序系统>2. 多道程序系统<a hidden class=anchor aria-hidden=true href=#2-多道程序系统>#</a></h3><ul><li><p>**多道程序设计技术：**允许多个程序同时进入内存并运行</p></li><li><p>当一道程序因I/O请求暂停时，CPU便立即转去运行另一道程序</p></li><li><p><strong>宏观上并行，微观上串行</strong></p></li><li><p>**优点：**使CPU得到充分利用，同时也改善I/O设备和内存的利用率，<strong>提高了整个系统的资源利用率和系统吞吐量</strong></p></li><li><p>单道程序系统：I/O时CPU空闲</p><p><img alt=image-20240603201620364 loading=lazy src=/img/image-20240603201620364.png></p></li><li><p>多道程序系统：交替使用CPU</p><p><img alt=image-20240603201647414 loading=lazy src=/img/image-20240603201647414.png></p></li></ul><h3 id=3-多道批处理系统>3. 多道批处理系统<a hidden class=anchor aria-hidden=true href=#3-多道批处理系统>#</a></h3><ul><li><strong>优点：</strong><ul><li>系统吞吐量大</li><li>资源利用率高</li></ul></li><li><strong>缺点：</strong><ul><li>平均周转时间长</li><li>==<strong>不能提供交互能力</strong>==</li></ul></li></ul><h3 id=4-分时系统>4. 分时系统<a hidden class=anchor aria-hidden=true href=#4-分时系统>#</a></h3><ul><li><p>多个用户分享使用同一台计算机，多个程序分时共享硬件和软件资源</p><p><img alt=image-20240603202224263 loading=lazy src=/img/image-20240603202224263.png></p></li><li><p><strong>多路性：多路连接，宏观上用户共享，微观上分时</strong></p></li><li><p><strong>独立性：用户相互不干扰</strong></p></li><li><p><strong>及时性：响应时间</strong></p></li><li><p><strong>交互性：人机对话</strong></p></li><li><p>分时技术：处理机的运行时间分成很短的时间片，轮流分配给各联机作业使用</p></li></ul><h3 id=5-实时系统>5. 实时系统<a hidden class=anchor aria-hidden=true href=#5-实时系统>#</a></h3><ul><li><p>及时响应</p></li><li><p>高可靠性和安全性</p></li><li><p>实时信息处理、实时控制</p></li></ul><h3 id=6-异常陷阱和中断>6. 异常、陷阱和中断<a hidden class=anchor aria-hidden=true href=#6-异常陷阱和中断>#</a></h3><p><img alt=image-20240603203445951 loading=lazy src=/img/image-20240603203445951.png></p><ul><li><p><strong>同步异常：执行指令的过程中发生</strong></p></li><li><p><strong>系统调用为一种同步异常:自陷指令(trap)</strong></p></li></ul><h2 id=二引导>二.引导<a hidden class=anchor aria-hidden=true href=#二引导>#</a></h2><ul><li>加载BIOS</li><li>读取MBR</li><li>BootLoader</li><li>加载内核</li><li>&mldr;</li></ul><h2 id=三-内存管理>三. 内存管理<a hidden class=anchor aria-hidden=true href=#三-内存管理>#</a></h2><blockquote><p>地址空间：逻辑地址空间</p><p>存储空间：物理地址空间</p></blockquote><h3 id=1单道程序的内存管理>1.单道程序的内存管理<a hidden class=anchor aria-hidden=true href=#1单道程序的内存管理>#</a></h3><ul><li><p><strong>静态地址翻译：在程序运行之前就计算出所有物理地址</strong></p></li><li><p><strong>优点：</strong></p><ul><li>最简单，单用户、单任务的OS</li><li>执行过程中无需进行地址翻译，<strong>程序运行速度快</strong></li></ul></li><li><p><strong>缺点：</strong></p><ul><li>比物理内存大的程序无法加载</li><li>资源浪费</li></ul></li></ul><h3 id=2多道程序的存储管理>2.多道程序的存储管理<a hidden class=anchor aria-hidden=true href=#2多道程序的存储管理>#</a></h3><blockquote><p>分区式分配：把内存分为一些大小相等或不等的分区，每个应用程序占用一个或几个分区</p></blockquote><h4 id=21-固定式分区>2.1 固定式分区<a hidden class=anchor aria-hidden=true href=#21-固定式分区>#</a></h4><ul><li><p>当系统初始化时，把存储空间划分为若干个任意大小的区域，然后把这些区域分配给每个用户作业</p></li><li><p>**优点：**易于实现，开销小</p></li><li><p><strong>缺点：</strong></p><ul><li><strong>内碎片</strong>造成浪费</li><li><strong>分区总数固定</strong>，限制了并发执行的程序数目</li></ul></li><li><p>数据结构：分区表</p></li><li><p>分配方式</p><ul><li><p>单一队列：大分区小程序
<img alt=image-20240603210700655 loading=lazy src=/img/image-20240603210700655.png></p></li><li><p>多队列：按程序大小对应分区块排队</p><p><img alt=image-20240603210711276 loading=lazy src=/img/image-20240603210711276.png></p></li></ul></li></ul><h4 id=22-可变式分区>2.2 可变式分区<a hidden class=anchor aria-hidden=true href=#22-可变式分区>#</a></h4><ul><li><p>分区的边界可以移动，<strong>分区的大小可变</strong></p></li><li><p><strong>优点：没有内碎片</strong></p></li><li><p><strong>缺点：产生外碎片</strong></p></li><li><p>==外部碎片是造成内存系统性能下降的主要原因==</p></li><li><p>消除外碎片：<strong>紧凑技术</strong></p></li><li><p>内碎片已经被分配给程序，外碎片是没被分配给程序的碎片</p></li></ul><h4 id=23-闲置空间的管理>2.3 闲置空间的管理<a hidden class=anchor aria-hidden=true href=#23-闲置空间的管理>#</a></h4><ul><li>跟踪内存的使用：位图表示法/链表表示法</li></ul><h5 id=231-位图表示法>2.3.1 位图表示法<a hidden class=anchor aria-hidden=true href=#231-位图表示法>#</a></h5><ul><li><p>为每个<strong>分配单元</strong>赋予一个字位，用来记录单元是否闲置</p><p><img alt=image-20240603211225934 loading=lazy src=/img/image-20240603211225934.png></p></li><li><p><strong>优点</strong></p><ul><li>空间成本固定：不依赖于内存中程序数量</li><li>时间成本低</li></ul></li><li><p><strong>缺点</strong></p><ul><li>没有容错能力</li></ul></li></ul><h5 id=232-链表表示法>2.3.2 链表表示法<a hidden class=anchor aria-hidden=true href=#232-链表表示法>#</a></h5><ul><li><p>空闲链表</p></li><li><p><strong>优点</strong></p><ul><li>有一定容错能力</li></ul></li><li><p><strong>缺点</strong></p><ul><li>时间成本：链表扫描较慢</li><li>空间成本：取决于程序的数量</li></ul></li></ul><h4 id=24-回收内存>2.4 回收内存<a hidden class=anchor aria-hidden=true href=#24-回收内存>#</a></h4><ul><li>尽可能合并回收分区上下的空闲分区</li></ul><p><img alt=image-20240603211807300 loading=lazy src=/img/image-20240603211807300.png></p><h4 id=25-基于顺序搜索的内存分配>2.5 基于顺序搜索的内存分配<a hidden class=anchor aria-hidden=true href=#25-基于顺序搜索的内存分配>#</a></h4><ul><li>首次适应(<code>Fisrt Fit</code>)：从空闲链表的始端开始查找，选择第一个满足请求的空白块</li><li>下次适应(<code>Next Fit</code>)：总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去</li><li>最佳适应(<code>Best Fit</code>)：找到大小最接近于作业要求的分区</li><li>最坏适应(<code>Worst Fit</code>)：为作业选择存储区域时，总是寻找最大的空白区</li></ul><h4 id=26-基于索引搜索的内存分配>2.6 基于索引搜索的内存分配<a hidden class=anchor aria-hidden=true href=#26-基于索引搜索的内存分配>#</a></h4><blockquote><p>较大系统遍历空闲链表比较慢</p></blockquote><ul><li>快速适应算法(分类搜索法)：<strong>把空闲分区按照容量大小进行分类</strong>，经常用到长度的空闲区设立单独的空闲区链表，系统为多个空闲链表设立一张管理索引表。<ul><li><strong>优点</strong><ul><li>查找效率高，依据长度寻找能容纳他的最小空闲区链表取下第一块进行分配</li></ul></li><li><strong>缺点</strong><ul><li>分区归还主存时算法复杂，系统开销大</li></ul></li></ul></li><li><strong>伙伴系统(二进制伙伴系统)</strong>：在分配存储块时将一个大的存储块分裂成两个<strong>大小相等</strong>的小块<ul><li>大小为$2^k$</li><li>分配给进程大于或等于所申请尺寸的<strong>最小的</strong>2的幂次的空闲块</li><li>内存释放时，<strong>首先考虑将被释放块与其伙伴合并成一个大的空闲块，然后继续合并下去，直到不能合并为止</strong></li><li></li></ul></li></ul><h4 id=27-程序编译和程序段>==2.7 程序编译和程序段==<a hidden class=anchor aria-hidden=true href=#27-程序编译和程序段>#</a></h4><ul><li><p>编译(<code>compile</code>)：由编译程序将用户源程序编译为若干个目标模块</p></li><li><p>链接(<code>linking</code>)：由链接程序将目标模块和对应的库函数连接成可装载模块</p></li><li><p>装入(<code>loading</code>)：由装载程序将可装载模块装入内存</p></li><li><p>==<strong>程序段</strong>==</p><ul><li><code>bss</code>段：存放程序中<strong>未初始化的全局变量或静态变量</strong></li><li><code>data</code>段：存放程序中<strong>已初始化的全局变量静态变量</strong></li><li><code>text</code>段：存放<strong>程序执行代码</strong></li></ul></li><li><p>==栈(stack)==</p><ul><li><strong>存放程序局部变量</strong></li><li>保存/恢复调用现场</li><li><strong>向下生长</strong></li></ul></li><li><p>==堆(heap)==</p><ul><li><strong>malloc/free</strong></li><li><strong>向下生长</strong></li></ul></li></ul><h4 id=28-elf可执行文件>2.8 ELF可执行文件<a hidden class=anchor aria-hidden=true href=#28-elf可执行文件>#</a></h4><p><img alt=image-20240603214717686 loading=lazy src=/img/image-20240603214717686.png></p><h4 id=29-链接>2.9 链接<a hidden class=anchor aria-hidden=true href=#29-链接>#</a></h4><p><img alt=image-20240603214749335 loading=lazy src=/img/image-20240603214749335.png></p><h4 id=210-装载>2.10 装载<a hidden class=anchor aria-hidden=true href=#210-装载>#</a></h4><ul><li>对于每一个段，根据其在内存中的大小，分配足够的物理页并映射到指定的虚地址上</li><li><strong>若ELF中记录的段在内存中大小大于在文件中大小，多出来部分用0填充</strong><ul><li>未初始化全局变量为0</li></ul></li></ul><h4 id=211-页式内存管理>2.11 页式内存管理<a hidden class=anchor aria-hidden=true href=#211-页式内存管理>#</a></h4><blockquote><p>程序：<strong>程序是静止的</strong>，是存放在磁盘上的可执行文件</p><p>进程：<strong>进程是动态的</strong>，进程包括程序和程序处理对象，是一个程序对某个数据集的执行过程</p><p>作业：作业是用户需要计算机完成的某项任务</p></blockquote><ul><li><p>分页地址结构：<strong>页号P+位移量W</strong></p></li><li><p>逻辑地址：<strong>虚拟页号+页内偏移量</strong></p></li><li><p>物理地址：<strong>物理页号+页内偏移量</strong></p></li><li><p><strong>虚拟页面大小与物理页面大小相等</strong></p></li><li><p>地址转换机构：MMU</p></li><li><p>一级页表</p><blockquote><p>逻辑地址空间大，划分的页面多，页表占用的存储空间大</p></blockquote><p><img alt=image-20240603222903264 loading=lazy src=/img/image-20240603222903264.png></p><ul><li>虚拟页号转换到对应的物理页号</li><li>需要访存两次(页表一次，访问数据一次)</li></ul></li><li><p>两级页表</p><ul><li>给一级页表设置页表</li><li>一级页表(页目录)</li><li>地址结构：<code>p1 | p2 | offset</code></li><li><img alt=image-20240603223300908 loading=lazy src=/img/image-20240603223300908.png></li><li><strong>二级页表访存次数：三次</strong></li></ul></li></ul><h4 id=212-快表tlb>2.12 快表TLB<a hidden class=anchor aria-hidden=true href=#212-快表tlb>#</a></h4><blockquote><p>解决页表的访存性能下降问题，建立快表(页表的<strong>Cache</strong>)</p></blockquote><ul><li><p>MMU首先在TLB中查找，若没有则到外部页表查询，然后置换进TLB</p><p><img alt=image-20240603223749932 loading=lazy src=/img/image-20240603223749932.png></p></li><li><p><strong>访存：TLB命中情况下：一次Cache+一次内存</strong></p></li><li><p>多个进程的标识符：<code>ASID</code></p></li></ul><h4 id=213-改进页表>2.13 改进页表<a hidden class=anchor aria-hidden=true href=#213-改进页表>#</a></h4><h5 id=2131-哈希页表>2.13.1 哈希页表<a hidden class=anchor aria-hidden=true href=#2131-哈希页表>#</a></h5><ul><li>建立虚拟页号与物理页号的哈希表，提高查找速度</li></ul><p><img alt=image-20240603224146959 loading=lazy src=/img/image-20240603224146959.png></p><h5 id=2132-反置页表>2.13.2 反置页表<a hidden class=anchor aria-hidden=true href=#2132-反置页表>#</a></h5><ul><li><p><strong>反置页表不是根据进程的逻辑页号来组织，而是依据该进程在内存中的物理页号来组织</strong></p></li><li><p>按照进程在内存中的物理页面号来组织，表项的内容是逻辑页号P及隶属进程标志符<code>pid</code></p><p><img alt=image-20240603224516100 loading=lazy src=/img/image-20240603224516100.png></p></li><li><p>反置页表的大小只与<strong>物理内存</strong>的大小有关</p></li><li><p><img alt=image-20240603224821509 loading=lazy src=/img/image-20240603224821509.png></p></li><li><p>可以使用哈希表进行优化</p></li></ul><h4 id=214-页共享与保护>2.14 页共享与保护<a hidden class=anchor aria-hidden=true href=#214-页共享与保护>#</a></h4><ul><li><p>页共享：<strong>物理页面出现在A和B两个进程的地址空间</strong></p></li><li><p>页保护：地址越界保护，在页表中设置保护位</p></li></ul><h4 id=215-分段存储管理>2.15 分段存储管理<a hidden class=anchor aria-hidden=true href=#215-分段存储管理>#</a></h4><ul><li><p>一个段可以定义为一组<strong>逻辑信息</strong>，每个作业的地址空间是由一些分段构成的，例如代码段、数据段等。</p></li><li><p>优点：</p><ul><li>方便编程</li><li>信息共享</li><li>信息保护</li><li><strong>动态增长</strong></li><li><strong>动态链接</strong></li></ul></li><li><p><strong>地址结构</strong>：段号+位移量</p><p><img alt=image-20240603225709874 loading=lazy src=/img/image-20240603225709874.png></p></li><li><p>==分页的地址空间为一维的，分段的地址空间为二维的==</p></li><li><p>对比</p><ul><li>页是信息的<strong>物理单位</strong>，大小固定</li><li>段是信息的<strong>逻辑单位</strong>，长度不固定</li><li>分页活动用户看不见，分段是用户可见的</li></ul></li><li><p>段页式：先分段，再分页</p></li></ul><h4 id=216-虚拟存储管理>2.16 虚拟存储管理<a hidden class=anchor aria-hidden=true href=#216-虚拟存储管理>#</a></h4><h5 id=2161-覆盖>2.16.1 覆盖<a hidden class=anchor aria-hidden=true href=#2161-覆盖>#</a></h5><blockquote><p>节约，时间上扩展</p></blockquote><ul><li>把一个大的程序划分为一系列的覆盖，每个覆盖是一个独立的程序单位，程序执行时并不要求同时装入主存的覆盖组成一组</li><li><strong>缺点</strong>：编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度。</li></ul><h5 id=2162-交换>2.16.2 交换<a hidden class=anchor aria-hidden=true href=#2162-交换>#</a></h5><blockquote><p>借用，空间上扩展</p></blockquote><ul><li>把暂时不用的某个程序及其数据的部分或全部<strong>从主存移到辅存中去</strong>，腾出必要的存储空间，接着把指定程序或数据<strong>从辅存读到相应的主存</strong>中。</li></ul><h5 id=2163-局部性原理>2.16.3 ==局部性原理==<a hidden class=anchor aria-hidden=true href=#2163-局部性原理>#</a></h5><ul><li>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址局限于一定区域</li><li>==时间局部性==：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</li><li>==空间局部性==：当前指令和临近的几条指令，当前访问的数据和临近的数据都集中在一个较小区域内</li></ul><h5 id=2164-虚拟存储>2.16.4 虚拟存储<a hidden class=anchor aria-hidden=true href=#2164-虚拟存储>#</a></h5><ul><li>所有进程一致的地址空间，每个进程都认为自己在独占使用单机系统的存储资源</li><li>隔离进程地址访问</li><li><strong>缺页中断</strong>：<strong>进程执行过程中需访问的页面不在物理存储器中，发生缺页中断</strong><ul><li>==页面置换算法==</li></ul></li><li><img alt=image-20240603232434624 loading=lazy src=/img/image-20240603232434624.png></li></ul><h5 id=2165-页面置换策略>==2.16.5 页面置换策略==<a hidden class=anchor aria-hidden=true href=#2165-页面置换策略>#</a></h5><ul><li><p>最佳策略(OPT)：从主存中移出永远不再需要的页面，如无这样的页面存在，应选择最长时间不需要访问的页面(理论参考，==无法被实现==)</p></li><li><p>先进先出(FIFO)：总选择作业在主存中驻留时间最长的一页淘汰</p></li><li><p>最近最久不用的页面置换算法(LRUR)：选择在最近一段时间内最久不用的页面予以淘汰</p></li><li><p>改进的FIFO算法：二次机会算法(<code>Second Chance</code>)：如果被淘汰的数据之前被访问过，则给其第二次机会</p><ul><li><p>每个页面增加一个访问标志位，标识此数据放入缓存队列后是否再次被访问过</p><p><img alt=image-20240603234040561 loading=lazy src=/img/image-20240603234040561.png></p></li><li><p>对于队列中最旧的页面</p><ul><li>若其放入队列后没有被再次访问，则立即被淘汰</li><li>如果放入队列后被访问过，则移动到FIFO队列头，并清除访问标志位</li><li>若所有页面都被访问过，按照FIFO淘汰</li></ul></li></ul></li><li><p>改进的FIFO算法：<code>Clock</code>(最近未使用算法NRU，<code>Not Recently Used</code>)，环形队列</p><p><img alt=image-20240603234414566 loading=lazy src=/img/image-20240603234414566.png></p></li><li><p>==FIFO类算法命中率比其他算法要低，实际中很少使用==</p></li><li><p>==最近最少使用(<code>LRU:Least Recently Used</code>)：局部性原理的合理近似，性能接近最优算法==</p><ul><li>硬件开销比较大</li><li>近似实现：设置栈保存当前使用的各个页面的页面号，当进程访问某页面时压入栈顶</li></ul></li><li><p>老化算法(<code>Aging</code>)：LRU的简化</p><ul><li><p>为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入</p></li><li><p>选择寄存器值小的移出</p><p><img alt=image-20240603235447739 loading=lazy src=/img/image-20240603235447739.png></p></li></ul></li></ul><h5 id=2166-belady现象期中考过>2.16.6 Belady现象(期中考过)<a hidden class=anchor aria-hidden=true href=#2166-belady现象期中考过>#</a></h5><blockquote><p>在使用<strong>FIFO算法</strong>作为缺页置换算法时，分配的页面增多，缺页率反而提高</p></blockquote><ul><li><p>理想的情况：缺页率随页框数增加而下降</p><p><img alt=image-20240603233716137 loading=lazy src=/img/image-20240603233716137.png></p></li><li><p>Belady现象</p><p><img alt=image-20240603233748598 loading=lazy src=/img/image-20240603233748598.png></p></li></ul><h5 id=2167-工作集与驻留集>2.16.7 工作集与驻留集<a hidden class=anchor aria-hidden=true href=#2167-工作集与驻留集>#</a></h5><ul><li><p>进程的==工作集(<code>Working Set</code>)==：当前正在使用的页面的集合</p></li><li><p>进程的==驻留集==：每个进程驻留在内存的页面集合(分配的物理页)</p></li><li><p>工作集策略：依据进程在过去的一段时间内访问的页面来调整常驻集大小</p><ul><li>工作集可以用一个二元函数$WS(k,t)$表示<ul><li>$k$表示窗口尺寸</li><li>$t$表示执行时刻</li></ul></li><li>工作集为$[t-k,t]$时间段内访问的页面的集合</li></ul></li><li><p>驻留集的管理：系统应当为每个活跃进程分配多少个页框</p><ul><li>分配给每个活跃进程的页框数越少，同时驻留内存的活跃进程数就越多，进程调度就绪进程的概率就越大，但是将<strong>导致缺页中断率增大</strong></li></ul></li><li><p><strong>全局置换算法：程序无法控制自己的缺页率，在内存中的页面不仅取决于该进程的页面走向，也取决于其他进程</strong></p></li><li><p>可变分配策略+局部置换：可增加或减少分配给每个活跃进程的页框数，当进程的页框全部用完，而需要装入一个新的页面，==<strong>系统在该进程的当前驻留集中选择一个页面换出内存</strong>==</p></li><li><p>==<strong>抖动问题(期中考过)</strong>==</p><ul><li>随着驻留内存的进程数目增加，处理器利用率先是上升，然后下降</li><li><strong>原因是：每个进程的常驻集不断减小，缺页率不断上升，频繁发生缺页中断</strong></li><li>选择适当的进程数目，平衡并发水平和缺页率</li></ul><p><img alt=image-20240604002026550 loading=lazy src=/img/image-20240604002026550.png></p><ul><li>==消除抖动==：<ul><li>局部置换策略</li><li>工作集算法</li><li>预留部分页面</li><li>挂起若干进程</li></ul></li></ul></li></ul><h5 id=2168-写时复制技术>2.16.8 写时复制技术<a hidden class=anchor aria-hidden=true href=#2168-写时复制技术>#</a></h5><ul><li>实验中的理解已经足够</li></ul><h4 id=217-页目录自映射>==2.17 页目录自映射==<a hidden class=anchor aria-hidden=true href=#217-页目录自映射>#</a></h4><ul><li><p>一个进程的4GB地址空间被划分为4GB/4KB=1M页，即需要1M个页表项来记录逻辑-物理关系</p></li><li><p>每个页表项需要4B，1M个页表项需要4MB，<strong>即整个页表占用的地址空间大小为4MB</strong></p></li><li><p>4MB页表需要1024个页面存储，每一页中存储1024个页表项</p></li><li><p>一个页表项对应4KB内存，则个页表页对应4MB内存</p></li><li><p>页目录占一页空间，有1024项，每一项指向一个页表页，==则必有一项指向自己，即页目录也是上述4MB页表中的一页==</p><p><img alt=image-20240604003738528 loading=lazy src=/img/image-20240604003738528.png></p><p><img alt=image-20240604003829655 loading=lazy src=/img/image-20240604003829655.png></p></li><li><p>一个页目录项指向一个页表页，映射到4MB物理内存</p></li><li><p>假设进程页表的基地址为$PT_{base}$，几个经典计算</p><ul><li><p>==页目录基地址$PD_{base}$​：页目录中第一项映射第一个页表页==</p><p>$PD_{n} : 10bits | PT_n : 10bits | offset:12bits$</p><p>$PD_{base}=PT_{base}+(PT_{base} &#187; 12)*4=PT_{base}+PT_{base}&#187;10$</p><p><em>解释：映射第一个页表页的页表项编号为PT_base &#187; 12，也就是页目录项的编号，每个PDE大小为4B，基地址+偏移量</em></p></li><li><p>==映射页目录自身的页目录项==</p><p>$页目录基地址PD_{base}=PT_{base}+PT_{base}&#187;10$</p><p>$PDE_{self-mapping}=PT_{base}+(PD_{base}&#187;12)*4=PT_{base}|PT_{base}&#187;10|PT_{base}&#187;20$</p></li></ul></li><li><p>==根本思想：计算出映射到该页表页的是第几个页表项==</p></li></ul><h2 id=四进程管理>四.进程管理<a hidden class=anchor aria-hidden=true href=#四进程管理>#</a></h2><h3 id=1-进程与线程>1. 进程与线程<a hidden class=anchor aria-hidden=true href=#1-进程与线程>#</a></h3><ul><li><p>并发：有两个活动a1,a2，如果在某一指定的时间t，无论a1和a2是在同一处理机上还是在不同的处理机上执行，只要a1和a2都处在各自的起点和终点之间的某一处，即称为并发的</p></li><li><p>并行：两个程序在同一时间度量下<strong>运行在不同的处理机上</strong></p></li><li><p>竞争：多个进程在读写一个共享数据时，结果依赖于他们执行的相对时间，这种情形叫竞争</p></li></ul><h4 id=11-bernstein条件>==1.1 Bernstein条件==<a hidden class=anchor aria-hidden=true href=#11-bernstein条件>#</a></h4><ul><li>$R(S_{i})$：Si的读子集</li><li>$W(S_i)$：Si的写子集</li><li>两个进程可并发的条件为<ul><li>R(S1)^W(S2)=null</li><li>W(S1)^R(S2)=null</li><li>W(S1)^W(S2)=null</li></ul></li><li>==或者说可并发条件为除了读读之外交集都为空==</li></ul><h4 id=12-进程>1.2 进程<a hidden class=anchor aria-hidden=true href=#12-进程>#</a></h4><ul><li><p>进程是一个程序及其数据在处理机上顺序执行所发生的活动</p></li><li><p>==进程是系统进行资源分配和调度的一个基本单位==</p></li><li><p>动态性：==程序是静态实体，进程具有生命周期==</p></li><li><p>并发性：多个进程在内存中同时运行</p></li><li><p>独立性：==传统OS中==，进程是独立运行的基本单位</p></li><li><p>异步性</p></li><li><p>进程的结构</p><ul><li>程序段、数据段、进程控制块PCB</li></ul></li></ul><h4 id=13-进程控制>1.3 进程控制<a hidden class=anchor aria-hidden=true href=#13-进程控制>#</a></h4><ul><li><p>==由内核来实现==</p></li><li><p>进程控制的实现——<strong>原语：由若干条指令所组成的指令序列，来实现某个特定的操作功能，连续不可被分割，必须在内核态执行</strong></p></li><li><p><code>fork()</code>执行一次，父子进程两个返回值</p></li><li><p>==进程的状态(期中考过)==</p><ul><li><strong>就绪状态</strong>：已经获得所需资源，分配CPU就可运行</li><li><strong>执行状态</strong>：占用CPU运行，进程数小于等于CPU数目</li><li><strong>阻塞状态</strong>：正在执行的进程，由于发生某种事件而无法执行，放弃CPU处于暂停状态</li></ul></li></ul><p><img alt=image-20240604151235284 loading=lazy src=/img/image-20240604151235284.png></p><ul><li><p>==状态转换==</p><ul><li>就绪->运行：调度程序选择进程运行</li><li>运行->就绪：运行进程用完了时间片，或因为高优先级进程处于就绪状态而中断</li><li>运行->阻塞：当进程需要的资源必须等待</li><li>阻塞->就绪：所等待的事件发生</li></ul></li><li><p>进程控制块PCB</p><ul><li><strong>进程标识符</strong>：每个进程唯一的标识符</li><li>程序和数据地址</li><li>现行状态</li><li>现场保留区：<code>trapframe</code>寄存器等等</li><li>优先级</li><li>父进程</li><li>同步互斥机制</li><li>&mldr;</li></ul></li><li><p>==进程上下文切换vs陷入内核：陷入内核开销更小==</p><ul><li><p>进程上下文切换：</p><ul><li><strong>调度器执行</strong></li><li>保存进程执行断点</li><li>保存执行现场</li><li>切换内存映射</li></ul></li><li><p>陷入内核</p><ul><li>中断/异常/trap</li><li>保存执行现场</li></ul></li><li><p>==用户态到内核态的切换(<code>mode switch</code>)消耗要比进程上下文切换(<code>Process Context Switch</code>)消耗小得多==</p></li></ul></li></ul><h4 id=14-线程>1.4 线程<a hidden class=anchor aria-hidden=true href=#14-线程>#</a></h4><ul><li><p>进程：资源拥有者+可执行单元</p></li><li><p>线程：可执行单元</p></li><li><p><strong>优点</strong></p><ul><li>减小进程切换开销</li><li>提高进程内的并发程度</li><li>共享资源</li></ul></li><li><p>==基本上不拥有资源，和同进程的线程共享进程拥有的所有资源==</p></li><li><p>==进程是资源分配的基本单位，线程是处理机调度的基本单位==</p></li><li><p><strong>用户级线程</strong>：线程在用户空间，通过用户库模拟thread</p><p><img alt=image-20240604183613848 loading=lazy src=/img/image-20240604183613848.png></p><ul><li><strong>优点</strong><ul><li>上下文切换快</li><li>==线程切换与内核无关==</li><li>==线程调度由应用决定，容易进行优化==</li></ul></li><li><strong>缺点</strong>：<ul><li>系统调用会引起阻塞，<strong>因为内核只能看到一个进程，所以会阻塞所有相关的线程</strong></li><li><strong>内核只能将处理器分配给进程，即使有多个处理器也无法实现多线程并行执行</strong></li></ul></li></ul></li><li><p><strong>内核级线程</strong>：kernel有好几个分身，一个分身处理一件事</p><p><img alt=image-20240604183910456 loading=lazy src=/img/image-20240604183910456.png></p><ul><li><strong>优点</strong><ul><li>阻塞发生在线程级别</li><li>内核可以在多个处理器上调度一个进程的多个线程</li></ul></li><li><strong>缺点</strong><ul><li>线程切换需要内核参与</li><li>==切换效率较低==</li></ul></li></ul></li><li><p>线程安全：对象</p><ul><li>多个线程访问同一个<strong>对象</strong>时，如果不用考虑线程的调度和交替执行，也不需要进行额外的同步，或者调用方进行任何操作，行为都可以获得正确的结果</li></ul></li><li><p>可重入：代码</p><ul><li>即当该副程序正在运作时，执行线程可以再次进入并执行它，仍然可得到符合设计时所预期的结果</li></ul></li><li><p>==可重入不一定线程安全，线程安全不一定可重入==</p></li></ul><h4 id=15-同步与互斥>1.5 同步与互斥<a hidden class=anchor aria-hidden=true href=#15-同步与互斥>#</a></h4><ul><li><p>wty课件例题</p><p><img alt=image-20240604185313203 loading=lazy src=/img/image-20240604185313203.png></p></li><li><p>**临界资源：**我们将一次仅允许一个进程访问的资源称为临界资源</p></li><li><p>**临界区：**访问临界资源的代码</p></li><li><p>互斥：某一资源同时只允许一个访问者对其进行访问，无法限制访问顺序，<strong>无序访问</strong></p></li><li><p>同步：在互斥的基础上通过其他机制实现对资源的<strong>有序访问</strong></p></li><li><p>==基于忙等待的互斥方法（暂时跳过，期中考过）==</p><ul><li>浪费CPU时间</li></ul></li></ul><h4 id=16-信号量机制>1.6 信号量机制<a hidden class=anchor aria-hidden=true href=#16-信号量机制>#</a></h4><ul><li><p>必须置一次且只能置一次初值</p></li><li><p>只能由P、V操作改变</p></li><li><p>P操作分配资源</p><ul><li>无法分配则<strong>阻塞(wait)</strong>：避免忙等</li></ul></li><li><p>V操作释放资源</p><ul><li>有等待进程则<strong>唤醒(signal)</strong></li></ul></li><li><p><code>S.value</code>为正表示资源个数</p></li><li><p><code>S.value</code>为负表示等待进程个数</p></li><li><p>信号量实现互斥：S=1</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#50fa7b>P</span>(S)
</span></span><span style=display:flex><span><span style=color:#6272a4>// 临界区
</span></span></span><span style=display:flex><span><span style=color:#50fa7b>V</span>(S)    
</span></span></code></pre></td></tr></table></div></div></li><li><p>信号量实现同步：S=0</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#50fa7b>process1</span>(){
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>P</span>(s)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// code
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>process2</span>(){
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//code
</span></span></span><span style=display:flex><span>    <span style=color:#50fa7b>V</span>(s)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></li><li><p>前驱关系</p><p><img alt=image-20240604191427304 loading=lazy src=/img/image-20240604191427304.png></p></li><li><p>有限并发：S=n</p></li><li><p><strong>多进程同步</strong>原语(<code>Barriers</code>)</p><ul><li><code>count</code>到达汇合点的线程数</li></ul></li><li><p>信号量集：同时需要多个资源时的信号量操作</p><ul><li>AND型信号量集：将进程需要的所有共享资源一次分配给他，使用完后一起释放(每种资源分配一个)<ul><li>SP(S1,S2,&mldr;,Sn)</li></ul></li><li>一般信号量集：Si的测试值为ti，低于ti不进行分配，占用值为di<ul><li>SP(S1,t1,d1,&mldr;,Sn,tn,dn)</li></ul></li></ul></li></ul><h4 id=17-基于管程的同步互斥>1.7 基于管程的同步互斥<a hidden class=anchor aria-hidden=true href=#17-基于管程的同步互斥>#</a></h4><ul><li><p>把分散的临界区集中起来，为每个可共享资源设计一个专门机构来统一管理各进程对该资源的访问</p></li><li><p>==管程是高级同步原语==</p></li><li><p><strong>互斥：任意时刻，管程中只能有一个活跃进程</strong></p></li><li><p>管程中的特殊类型变量：<strong>条件变量</strong></p><ul><li>每个条件变量表示一种等待原因，==并不取具体数值==</li></ul></li><li><p>条件变量与信号量的区别</p><ul><li><p>条件变量的值不可增减，信号量可增减</p></li><li><p><code>wait</code>操作一定会阻塞当前进程，P操作只有当信号量值小于0才会阻塞</p></li><li><p>没有<code>wait</code>线程则<code>signal</code>会丢失，V操作不会丢失</p></li></ul></li><li><p>当一个进入管程的进程执行等待操作时，应当释放管程的互斥权，后面进入的进程执行唤醒，则管程中有两个同时处于活动状态的进程</p><ul><li>signal(x)时如何避免管程中有两个活跃进程<ul><li><code>Hoare</code>：<em>执行signal的进程</em>等待，直到<em>被释放进程</em>退出管程</li><li><code>Mesa</code>：<em>被释放进程</em>等待，直到<em>执行signal的进程</em>退出管程</li><li><code>Hansen</code>：执行signal的进程立即退出管程</li></ul></li></ul></li></ul><h4 id=18-进程间通信-ipc>1.8 进程间通信 IPC<a hidden class=anchor aria-hidden=true href=#18-进程间通信-ipc>#</a></h4><blockquote><p>低级通信：传递状态和整数值</p><p>==高级通信：管道，共享内存，消息系统==</p></blockquote><h5 id=181-无名管道>1.8.1 无名管道<a hidden class=anchor aria-hidden=true href=#181-无名管道>#</a></h5><ul><li><p>半双工：==数据只能向一个方向流动==，双方通信建立两个管道</p></li><li><p>==只能用于父子进程或兄弟进程之间==</p></li><li><p>单独构成独立的文件系统，管道对于管道两端的进程而言是一个文件</p></li><li><p>数据读出和写入：从末尾写入，从头部读出(数据单向流动的原因)</p><p><img alt=image-20240604194905764 loading=lazy src=/img/image-20240604194905764.png></p></li></ul><h5 id=182-有名管道fifo>1.8.2 有名管道(FIFO)<a hidden class=anchor aria-hidden=true href=#182-有名管道fifo>#</a></h5><ul><li>==名字打破了无名管道只能在有亲缘关系的进程间通信的限制，不相关进程可以交换数据==</li><li>FIFO提供了路径名与之关联，访问路径通过FIFO通信</li><li>以FIFO文件的形式存在于文件系统中</li><li>从末尾写入，从开始读出</li></ul><h5 id=183-消息传递>1.8.3 消息传递<a hidden class=anchor aria-hidden=true href=#183-消息传递>#</a></h5><ul><li>系统调用send/receive</li><li>阻塞调用/非阻塞调用</li><li>==内核消息缓冲区==</li></ul><p><img alt=image-20240604195559899 loading=lazy src=/img/image-20240604195559899.png></p><h5 id=184-共享内存>1.8.4 共享内存<a hidden class=anchor aria-hidden=true href=#184-共享内存>#</a></h5><ul><li>==最有效的进程间通信机制，最快==</li><li>同一块物理内存被映射到A,B各自的进程地址空间</li></ul><p><img alt=image-20240604195911600 loading=lazy src=/img/image-20240604195911600.png></p><h3 id=2经典同步互斥问题>2.经典同步互斥问题<a hidden class=anchor aria-hidden=true href=#2经典同步互斥问题>#</a></h3><ul><li>课件&作业</li></ul><h3 id=3-进程调度>3. 进程调度<a hidden class=anchor aria-hidden=true href=#3-进程调度>#</a></h3><blockquote><p>高级调度：<strong>作业调度</strong>，从工作流程角度对每个作业进行调度</p><p>中级调度：从<strong>存储器资源的角度</strong>将进程的部分或全部换出到外存上</p><p>==低级调度：从<strong>CPU资源的角度</strong>对进程/线程进行调度==</p><ul><li>抢占式</li><li>非抢占式</li></ul></blockquote><ul><li>何时进行切换<ul><li>用户调用</li><li>陷阱</li><li>中断</li></ul></li><li>==进程切换的步骤==<ul><li>保存处理器上下文，程序计数器和其他寄存器</li><li>用新状态和其他相关信息更新正在运行进程的PCB</li><li>把进程移到合适的队列：就绪/阻塞</li><li>选择另一个要执行的进程</li><li>更新被选中进程的PCB</li><li>从被选中进程中重装入CPU上下文</li></ul></li></ul><h4 id=31-调度性能准则>==3.1 调度性能准则==<a hidden class=anchor aria-hidden=true href=#31-调度性能准则>#</a></h4><ul><li>==<strong>周转时间</strong>：作业从提交到完成所经历的时间==</li><li><strong>响应时间</strong>：用户输入一个请求到系统给出首次响应的时间(分时系统)</li><li><strong>截止时间</strong>：开始截止时间和完成截止时间(实时系统)</li><li>优先级</li><li>公平性</li><li>==<strong>吞吐量</strong>：单位时间内完成的作业数(批处理系统)==<ul><li><strong>作业/小时</strong></li><li>==平均周转时间不是吞吐量的倒数，并发执行的作业在时间上可以重叠==</li></ul></li><li><strong>处理机利用率</strong>：忙碌时间/总时间</li><li><strong>各种资源的均衡利用</strong></li></ul><h4 id=32-批处理系统中常用的调度算法>==3.2 批处理系统中常用的调度算法==<a hidden class=anchor aria-hidden=true href=#32-批处理系统中常用的调度算法>#</a></h4><p>有关指标</p><blockquote><p>==$吞吐量=\frac {作业数} {总执行时间}$ 即单位CPU时间完成的作业量==</p><p>==$周转时间=完成时刻-提交时刻(小时为单位)$==</p><p>$平均周转时间=\frac {作业周转时间之和} {作业数}$</p><p>==$带权周转时间=\frac {周转时间} {执行时间}$==</p><p>$平均带权周转时间=\frac {作业带权周转时间之和} {作业数}$</p></blockquote><p>有关调度方式</p><blockquote><p>抢占式：就绪队列中有优先级高于当前运行进程优先级的进程，立即进行进程调度</p><p>非抢占式：一个进程一直占用处理器知道时间片用完或I/O等原因进入阻塞状态才让出处理器</p></blockquote><h5 id=321-fcfs-先来先服务>3.2.1 FCFS 先来先服务<a hidden class=anchor aria-hidden=true href=#321-fcfs-先来先服务>#</a></h5><ul><li>按照作业提交或进程变为就绪状态的先后次序分派CPU</li><li>==<strong>非抢占式</strong>==</li><li>有利于长作业，不利于短作业</li><li>有利于CPU繁忙的作业，不利于I/O繁忙的作业</li></ul><h5 id=322-sjf-短作业优先>3.2.2 SJF 短作业优先<a hidden class=anchor aria-hidden=true href=#322-sjf-短作业优先>#</a></h5><ul><li>对预计执行时间短的作业优先分派处理机</li><li>通常后来的短作业==不抢占==正在执行的作业</li><li><strong>优点</strong><ul><li>==改善平均周转时间和平均带权周转时间==，缩短作业等待时间</li><li>提高系统吞吐量</li></ul></li><li><strong>缺点</strong><ul><li>对长作业不友好，饥饿现象</li><li>没有优先级划分</li></ul></li></ul><h5 id=323-srtf-最短剩余时间优先>3.2.3 SRTF 最短剩余时间优先<a hidden class=anchor aria-hidden=true href=#323-srtf-最短剩余时间优先>#</a></h5><ul><li>==抢占式==</li><li><strong>一个新就绪的进程如果比当前运行进程具有更短的完成时间</strong>，则系统抢占当前进程，选择新就绪的进程运行</li><li>长任务饥饿现象</li></ul><h5 id=324-hrrf-最高响应比优先>3.2.4 HRRF 最高响应比优先<a hidden class=anchor aria-hidden=true href=#324-hrrf-最高响应比优先>#</a></h5><ul><li><p>==非抢占式==</p></li><li><p>每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP，然后选择最大的投入运行</p><p>$RP=\frac {已等待时间+要求运行时间} {要求运行时间}$</p></li></ul><h4 id=33-交互式系统调度算法>==3.3 交互式系统调度算法==<a hidden class=anchor aria-hidden=true href=#33-交互式系统调度算法>#</a></h4><h5 id=331-rr-时间片轮转算法>3.3.1 RR 时间片轮转算法<a hidden class=anchor aria-hidden=true href=#331-rr-时间片轮转算法>#</a></h5><ul><li><p>==抢占式==</p></li><li><p>所有进程按照FCFS原则排成队列，<strong>每次调度将CPU分派给队首进程</strong>，<strong>让其执行一个时间片</strong>，一个时间片执行完后，发生时钟中断，<strong>将当前进程送到就绪队列末尾</strong></p></li><li><p>系统的响应时间</p><p>$T=N(进程数目)*q(时间片)$</p></li><li><p>数目越多时间片越小</p></li></ul><h5 id=332-ps-优先级算法>3.3.2 PS 优先级算法<a hidden class=anchor aria-hidden=true href=#332-ps-优先级算法>#</a></h5><ul><li><p>平衡进程对响应时间的要求</p><p><img alt=image-20240604230133477 loading=lazy src=/img/image-20240604230133477.png></p></li><li><p><strong>静态优先级</strong>：创建进程时就确定，直到进程终止前都不改变</p></li><li><p><strong>动态优先级</strong>：创建进程时赋予的优先级，<strong>在进程运行过程中可以自动改变</strong>，获得更好的调度性能</p></li></ul><h5 id=333-mlq-多级队列算法>3.3.3 MLQ 多级队列算法<a hidden class=anchor aria-hidden=true href=#333-mlq-多级队列算法>#</a></h5><ul><li>引入多个就绪队列，通过对各队列的区别对待，到达综合的调度目标</li><li>不同队列有不同的优先级，时间片长度，调度策略</li><li><strong>优先执行高优先级，高优先级队列为空再执行低优先级</strong></li></ul><p><img alt=image-20240604230852541 loading=lazy src=/img/image-20240604230852541.png></p><h5 id=334-rrmf-多级反馈队列算法>3.3.4 RRMF 多级反馈队列算法<a hidden class=anchor aria-hidden=true href=#334-rrmf-多级反馈队列算法>#</a></h5><ul><li><p>设置多个就绪队列，分别赋予不同的优先级，<strong>每个队列执行时间片的长度也不同，优先级越低时间片越长</strong></p></li><li><p>新进程进入内存后，先投入队列1的末尾，<strong>按时间片轮转算法调度</strong>，若按队列1的一个时间片未能执行完，则降低优先级投入到队列2的末尾，同样按时间片轮转算法调度&mldr;降低到最后的队列，则<strong>按照FCFS算法调度直到完成</strong>。</p></li><li><p><strong>当较高优先级的队列为空，才调度较低优先级队列中的进程执行，若进程执行时有新进程进入较高优先级的队列，则==抢先==执行新进程，并把被抢先的进程投入到原队列末尾</strong></p><p><img alt=image-20240604231649783 loading=lazy src=/img/image-20240604231649783.png></p></li></ul><h5 id=335-优先级倒置>3.3.5 优先级倒置<a hidden class=anchor aria-hidden=true href=#335-优先级倒置>#</a></h5><blockquote><p>问题背景：有三个进程 <code>taskA taskB taskC</code> 优先级依次降低</p><p><code>taskA</code>和<code>taskC</code>共享临界资源，但是由于<code>taskB</code>优先级比<code>taskC</code>高，<code>taskB</code>抢占处理机，这样C得不到处理，优先级最高的A也被阻塞</p><p>==解决关键：提高C优先级，不允许B抢占CPU==</p></blockquote><ul><li>优先级置顶：给C最高的优先级，A也抢不过来<ul><li>缺点：如果临界区较长，则A仍会等待很长的时间</li></ul></li><li>优先级继承：C继承A的优先级</li></ul><h4 id=34-实时系统调度算法>3.4 实时系统调度算法<a hidden class=anchor aria-hidden=true href=#34-实时系统调度算法>#</a></h4><ul><li>实时系统是一种<strong>时间起主导作用</strong>的系统，计算机必须在<strong>一个确定的时间范围内</strong>做出反应</li><li>==抢先式调度==</li><li>快速中断响应：中断处理时间尽量短</li></ul><blockquote><p>实时系统问题描述：</p><p>假设一任务集S={t1,t2,&mldr;tn}，周期分别为T1,T2,&mldr;,Tn，执行时间分别为C1,C2,..Cn</p><p>截止周期为D1,D2,&mldr;,Dn通常Di=Ti</p><p>所有的任务都是周期性的(Ti)，必须在时限Di内完成</p><p>==$CPU利用率 U= \Sigma {\frac {C_i} {T_i}}$​==</p></blockquote><h5 id=341-静态表调度算法>3.4.1 静态表调度算法<a hidden class=anchor aria-hidden=true href=#341-静态表调度算法>#</a></h5><ul><li>对所有周期性任务进行分析预测，==事先确定一个固定的调度方案==</li><li>无任何计算，无灵活性</li></ul><p><img alt=image-20240604234512038 loading=lazy src=/img/image-20240604234512038.png></p><h5 id=342-rms-单调速率调度-2106被拷打过>3.4.2 RMS 单调速率调度 (2106被拷打过)<a hidden class=anchor aria-hidden=true href=#342-rms-单调速率调度-2106被拷打过>#</a></h5><ul><li><p><strong>优先级静态固定分配</strong>：优先级与周期成反比，周期越短优先级越高，优先级越高的任务先被调度，优先级相同随机调度</p></li><li><p>==抢占式，静态优先级：最优静态优先级调度算法==</p><p><img alt=image-20240604235311590 loading=lazy src=/img/image-20240604235311590.png></p></li></ul><h5 id=343-edf-最早截止期优先>3.4.3 EDF 最早截止期优先<a hidden class=anchor aria-hidden=true href=#343-edf-最早截止期优先>#</a></h5><ul><li><p>任务的绝对截止时间越早优先级越高，优先级越高先被调度(动态优先级)</p><p><img alt=image-20240604235526393 loading=lazy src=/img/image-20240604235526393.png></p></li></ul><h4 id=35-多处理机调度略>3.5 多处理机调度(略)<a hidden class=anchor aria-hidden=true href=#35-多处理机调度略>#</a></h4><h3 id=4-死锁>4. 死锁<a hidden class=anchor aria-hidden=true href=#4-死锁>#</a></h3><ul><li>一组进程中，每个进程都无限等待被该组进程中其他进程所占有的资源</li></ul><h4 id=41-死锁发生的四个必要条件>==4.1 死锁发生的四个必要条件==<a hidden class=anchor aria-hidden=true href=#41-死锁发生的四个必要条件>#</a></h4><ul><li><p><strong>互斥条件</strong>：进程对分配到的资源进排他性使用</p></li><li><p><strong>请求且占有条件</strong>：进程已经占有至少一个资源，但又提出新的请求，但该资源已经被其他进程占有，此时进程阻塞，且对已获得的资源保持不放</p></li><li><p><strong>不可剥夺条件</strong>：进程已经获得的资源在使用完之前不能被剥夺</p></li><li><p>==<strong>环路等待条件</strong>==：发生死锁时，必定存在一个“进程-资源”的环形链，或者说循环等待条件</p><p><code>{P0,P1,..Pn}</code>中P0等待P1的资源，P1等待P2&mldr;</p></li></ul><h4 id=42-死锁预防>4.2 死锁预防<a hidden class=anchor aria-hidden=true href=#42-死锁预防>#</a></h4><blockquote><p>==排除死锁的静态策略==</p></blockquote><ul><li><p>打破互斥条件：有些资源不允许被同时访问</p></li><li><p>打破申请且占有条件：实行资源预先分配策略，<strong>只有系统能够满足当前全部资源请求时，才一次性将所申请的资源分配给该进程，否则不分配</strong></p></li><li><p>打破不可剥夺条件：允许进程从占有者处强行夺取</p></li><li><p>打破循环等待条件：实行资源有序分配策略，资源事先分类编号，按号分配，<strong>进程占用了小号资源才申请大号资源</strong>，例如多层锁的顺序性</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#50fa7b>P</span>(mutex1);
</span></span><span style=display:flex><span><span style=color:#50fa7b>P</span>(mutex2);
</span></span><span style=display:flex><span><span style=color:#6272a4>//...
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=43-死锁避免>4.3 死锁避免<a hidden class=anchor aria-hidden=true href=#43-死锁避免>#</a></h4><blockquote><p>==排除死锁的动态策略==</p></blockquote><ul><li><p>安全序列：一个进程序列<code>&lt;P1,P2,...,Pn></code>是安全的，是指对于每一个进程<code>Pi</code>，他需要的<strong>附加资源</strong>可以被系统中当前可用资源加上所有进程<code>Pj(j&lt;i)</code>当前占有的资源之和满足，则进程序列是一个安全序列</p></li><li><p>安全状态：系统存在一个安全序列(则所有进程均可顺利完成)</p></li><li><p>==系统进入不安全状态也不一定会死锁，死锁一定处于不安全状态==</p><p><img alt=image-20240605090108443 loading=lazy src=/img/image-20240605090108443.png></p></li></ul><h5 id=431-银行家算法>==4.3.1 银行家算法==<a hidden class=anchor aria-hidden=true href=#431-银行家算法>#</a></h5><blockquote><p>n为进程数量，m为资源类型数量</p></blockquote><ul><li><p>可利用资源向量<code>Available</code>：m维向量</p></li><li><p>最大需求矩阵<code>Max</code>：n*m矩阵</p></li><li><p>分配矩阵<code>Allocation</code>：n*m矩阵</p></li><li><p>需求矩阵<code>Need</code>：n*m矩阵</p></li><li><p>进程的请求向量<code>Request</code></p></li><li><p>系统试探部分分配</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>Available <span style=color:#ff79c6>=</span> Available <span style=color:#ff79c6>-</span> Requesti;
</span></span><span style=display:flex><span>Allocation <span style=color:#ff79c6>=</span> Allocation <span style=color:#ff79c6>+</span> Requesti;
</span></span><span style=display:flex><span>Needi <span style=color:#ff79c6>=</span> Needi <span style=color:#ff79c6>-</span> Requesti;
</span></span></code></pre></td></tr></table></div></div></li><li><p>每次分配需要检查安全状态(请求向量不一定等于Need，<strong>部分分配</strong>)，利用安全性算法(核心)，能否找到安全序列</p></li></ul><h5 id=432-安全性算法>==4.3.2 安全性算法==<a hidden class=anchor aria-hidden=true href=#432-安全性算法>#</a></h5><ul><li><p>==保证分配的资源数=Need==</p></li><li><p>工作向量<code>Work</code>：系统可提供给各进程运行继续使用资源数目，初始为<code>Available</code></p></li><li><p>完成向量<code>Finish</code>：表示系统是否有足够的资源分配给进程，<strong>使之运行完成</strong></p><ul><li>初始时<code>Finish[i]=false</code></li><li>有足够的资源分配给进程使之运行完成后<code>Finish[i]=true</code></li></ul></li><li><p>进程获得资源并运行完成后，释放出分配给他的资源</p><ul><li><code>Work += Allocation</code></li><li><code>Finish[i] = true</code></li></ul></li><li><p>再不断寻找下一个能完成分配的进程，<strong>最后如果有所进程的<code>Finish[i]=true</code>则系统处于安全状态，否则处于不安全状态</strong></p></li><li><p>表格模版</p><table><thead><tr><th>Work</th><th>Need</th><th>Allocation</th><th>Finish</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></li></ul><h4 id=44-死锁检测>4.4 死锁检测<a hidden class=anchor aria-hidden=true href=#44-死锁检测>#</a></h4><h5 id=441-资源分配图>==4.4.1 资源分配图==<a hidden class=anchor aria-hidden=true href=#441-资源分配图>#</a></h5><ul><li>圆圈表示进程，矩形表示一类资源，资源中的小圈代表每个资源</li><li>请求边：从进程指向资源</li><li>分配边：从资源指向进程</li></ul><p><img alt=image-20240605102757477 loading=lazy src=/img/image-20240605102757477.png></p><h5 id=442-检测死锁>4.4.2 检测死锁<a hidden class=anchor aria-hidden=true href=#442-检测死锁>#</a></h5><ul><li>资源分配图中有环路不一定存在死锁</li><li>封锁进程：某个进程由于<strong>请求了超过了系统中现有的未分配资源数目的资源</strong>，而被系统封锁的进程</li><li>资源分配图的化简方法：假设图中存在一个进程Pi，Pi为非封锁进程<ul><li>Pi有请求边时，将请求边变为分配边</li><li>一旦所有资源都得到满足，Pi释放所有资源(Pi此时只有分配边)，删去这些分配边</li><li>Pi此时为孤立点</li><li>反复进行</li></ul></li><li>==死锁定理==：资源分配图不可完全化简：不能使所有进程都成为孤立节点</li></ul><h4 id=45-死锁解除>4.5 死锁解除<a hidden class=anchor aria-hidden=true href=#45-死锁解除>#</a></h4><ul><li>撤销进程</li><li>剥夺资源</li></ul><h2 id=五输入输出系统>五.输入输出系统<a hidden class=anchor aria-hidden=true href=#五输入输出系统>#</a></h2><h3 id=1-io设备分类>1. I/O设备分类<a hidden class=anchor aria-hidden=true href=#1-io设备分类>#</a></h3><ul><li>低速、中速、高速</li><li>==块设备、字符设备==</li><li>独占设备、共享设备、虚拟设备</li></ul><h3 id=2-io控制方式>2 .I/O控制方式<a hidden class=anchor aria-hidden=true href=#2-io控制方式>#</a></h3><h4 id=21-轮询方式>2.1 轮询方式<a hidden class=anchor aria-hidden=true href=#21-轮询方式>#</a></h4><ul><li>应用程序提出读数据请求</li><li>驱动程序检查设备状态</li><li>状态正常则发出相应的控制命令</li><li><strong>不断测试设备是否完成了这次执行过程，轮询</strong></li><li>完成操作</li><li><strong>缺点：CPU不断查询设备状态来检查是否完成，浪费CPU时间</strong></li></ul><h4 id=22-中断驱动方式>2.2 中断驱动方式<a hidden class=anchor aria-hidden=true href=#22-中断驱动方式>#</a></h4><p><img alt=image-20240605112343214 loading=lazy src=/img/image-20240605112343214.png></p><ul><li><strong>优点</strong><ul><li>在外设进行数据处理时，CPU不必等待，继续执行其他程序，提高了CPU利用率</li><li>外设准备好数据给CPU发中断，可以将外设和CPU视作并行执行</li><li>==具有异常事件处理能力==</li></ul></li><li><strong>缺点</strong><ul><li>每次输入/输出一个数据都要中断CPU，多次中断浪费CPU时间，==<strong>只适合数据传输率较低的设备</strong>==</li><li>==每个数据传送完成后中断CPU==</li><li>中断处理陷入内核</li></ul></li></ul><h4 id=23-直接存储访问方式dma>2.3 直接存储访问方式(DMA)<a hidden class=anchor aria-hidden=true href=#23-直接存储访问方式dma>#</a></h4><p><img alt=image-20240605113532607 loading=lazy src=/img/image-20240605113532607.png></p><ul><li>程序设置DMA控制器中的若干寄存器值：内存始址、传送字节数</li><li>DMA控制器完成内存与外设的<strong>成批</strong>数据交换</li><li>操作完成后，DMA控制器向CPU发出中断</li><li><strong>优点</strong><ul><li>CPU只干预I/O开始与结束，进行成批数据读写</li><li>==适合传输数据块==</li><li>==适合高速设备==</li></ul></li><li><strong>缺点</strong><ul><li>数据传输方向、地址、长度等由CPU设置占用CPU时间</li><li><strong>每个设备占用一个DMA控制器</strong>，设备增加时新增DMA控制器</li></ul></li></ul><h4 id=24-io通道控制方式>2.4 I/O通道控制方式<a hidden class=anchor aria-hidden=true href=#24-io通道控制方式>#</a></h4><ul><li><strong>I/O通道是专门负责输入输出的处理器，独立于CPU</strong></li><li>执行由通道指令组成的通道程序，进行复杂I/O控制</li><li>优点：<ul><li>执行一个通道程序可以完成几组I/O操作，与DMA相比，减少CPU干预</li><li>同时控制多种设备</li></ul></li></ul><h3 id=3-缓冲技术>3. 缓冲技术<a hidden class=anchor aria-hidden=true href=#3-缓冲技术>#</a></h3><blockquote><p>匹配CPU与外设的不同处理速度，减少CPU中断次数，提高CPU与I/O设备之间的并行性</p></blockquote><h4 id=31-单缓冲>3.1 单缓冲<a hidden class=anchor aria-hidden=true href=#31-单缓冲>#</a></h4><ul><li>一个缓冲区，CPU与外设轮流使用</li></ul><p><img alt=image-20240605120126739 loading=lazy src=/img/image-20240605120126739.png></p><h4 id=32-双缓冲>3.2 双缓冲<a hidden class=anchor aria-hidden=true href=#32-双缓冲>#</a></h4><ul><li>两个缓冲区，CPU和外设都可以连续处理而无需等待对方</li><li>CPU和外设速度相近</li></ul><p><img alt=image-20240605120220206 loading=lazy src=/img/image-20240605120220206.png></p><h4 id=34-环形缓冲>3.4 环形缓冲<a hidden class=anchor aria-hidden=true href=#34-环形缓冲>#</a></h4><ul><li>CPU和外设的处理速度可以相差较大</li></ul><p><img alt=image-20240605120255546 loading=lazy src=/img/image-20240605120255546.png></p><h4 id=35-缓冲池>3.5 缓冲池<a hidden class=anchor aria-hidden=true href=#35-缓冲池>#</a></h4><ul><li>空闲缓冲区、输入缓冲区、输出缓冲区</li></ul><p><img alt=image-20240605120412060 loading=lazy src=/img/image-20240605120412060.png></p><blockquote><p>关于缓冲区计算：采用画条形图的方式解决</p><ul><li><p>完整画出一个执行流程，观察可以并行的部分并在图中进行“遮盖“</p></li><li><p>去除可并行阶段之后的图即为“优化时间”，或者说近似的平均时间</p></li><li><p>可认为每次都按照优化时间运行，最后加上没办法优化的尾巴(最后一次并行部分不能得到优化)</p></li><li><p><strong>关于单缓冲并行部分</strong></p><ul><li>磁盘放到缓冲区，缓冲区放到内存，必须顺序执行</li><li>==CPU计算可以和磁盘放到缓冲区并行，不能和缓冲区放到内存并行(会改变计算数据)==</li></ul></li><li><p><strong>关于双缓冲区并行部分</strong></p><ul><li>CPU计算+内存读入与磁盘读入并行</li></ul></li><li><p>==单缓冲每块数据时间：max(T,C)+M C为并行段==</p></li><li><p>==双缓冲每块数据时间：max(T,C+M) M+C为并行段==</p></li><li><p>==或者说并行部分的最大值+非并行部分==</p></li><li><p>==总时间=n*每块时间+并行部分时间==</p></li></ul></blockquote><h2 id=六磁盘存储管理>六.磁盘存储管理<a hidden class=anchor aria-hidden=true href=#六磁盘存储管理>#</a></h2><h3 id=1磁盘结构>1.磁盘结构<a hidden class=anchor aria-hidden=true href=#1磁盘结构>#</a></h3><ul><li>扇区</li><li>磁道</li><li>柱面</li><li>每个磁盘有两个面，每个面都有一个磁盘</li></ul><h3 id=2磁盘访问时间>==2.磁盘访问时间==<a hidden class=anchor aria-hidden=true href=#2磁盘访问时间>#</a></h3><h4 id=21-寻道时间>2.1 寻道时间<a hidden class=anchor aria-hidden=true href=#21-寻道时间>#</a></h4><ul><li>把磁头从当前位置移动到指定磁道上所经历的时间</li><li>启动磁盘的时间S与磁头移动n条磁道所花费的时间之和</li><li>$T_s=m*n+s$</li></ul><h4 id=22-旋转延迟时间>2.2 旋转延迟时间<a hidden class=anchor aria-hidden=true href=#22-旋转延迟时间>#</a></h4><ul><li><strong>平均旋转延迟时间为旋转一圈周期的一半</strong></li><li>设转速为r(单位为<code>Rounds Per Second</code>)</li><li>平均旋转延迟时间为$T_r=\frac 1 {2r}$</li></ul><h4 id=23-传输时间>2.3 传输时间<a hidden class=anchor aria-hidden=true href=#23-传输时间>#</a></h4><ul><li>传输时间是指把数据从磁盘读出或者向磁盘写入数据所经历的时间</li><li>与每次读写的字节数b，旋转速度r，以及磁道上的字节数N有关</li><li>计算方法为：转的圈数*每圈周期</li><li>$T_t = \frac b n * \frac 1 r = \frac b {rn}$​</li></ul><h4 id=24-总访问时间>2.4 总访问时间<a hidden class=anchor aria-hidden=true href=#24-总访问时间>#</a></h4><ul><li>寻道时间+旋转延迟时间+传输时间</li></ul><h3 id=3-磁盘调度算法>==3. 磁盘调度算法==<a hidden class=anchor aria-hidden=true href=#3-磁盘调度算法>#</a></h3><h4 id=31-fcfs>3.1 FCFS<a hidden class=anchor aria-hidden=true href=#31-fcfs>#</a></h4><ul><li>请求到达先后次序服务</li></ul><h4 id=32-sstf-最短寻道时间优先>3.2 SSTF 最短寻道时间优先<a hidden class=anchor aria-hidden=true href=#32-sstf-最短寻道时间优先>#</a></h4><ul><li>优先选择距当前磁头最近的访问请求进行服务</li></ul><h4 id=33-scan扫描算法>3.3 SCAN扫描算法<a hidden class=anchor aria-hidden=true href=#33-scan扫描算法>#</a></h4><ul><li>按照一个方向移动，移动过程中对遇到的访问请求进行服务</li><li>判断该方向上是否还有访问请求，如果有则继续扫描，否则改变移动方向</li><li>这是课件上的表述，但这实际上是LOOK算法，正常的SCAN是要扫描到头的。。。</li></ul><h4 id=34-c-scan-循环扫描算法>3.4 C-SCAN 循环扫描算法<a hidden class=anchor aria-hidden=true href=#34-c-scan-循环扫描算法>#</a></h4><ul><li>移动到最后一个柱面后，立即带动读写磁头返回0号柱面</li></ul><h3 id=4-raid>4. RAID<a hidden class=anchor aria-hidden=true href=#4-raid>#</a></h3><p><img alt=image-20240605164839668 loading=lazy src=/img/image-20240605164839668.png></p><h2 id=七文件系统>七.文件系统<a hidden class=anchor aria-hidden=true href=#七文件系统>#</a></h2><ul><li>略 重在计算</li><li>文件大小：直接索引+简介索引</li><li>访问磁盘次数：具体问题具体分析 ：文件组织方式有关</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://coder0xe.github.io/tags/june/>June</a></li></ul><nav class=paginav><a class=prev href=https://coder0xe.github.io/posts/os-lab6%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/><span class=title>« Prev</span><br><span>OS:lab6课下基础</span>
</a><a class=next href=https://coder0xe.github.io/posts/os-%E7%AC%AC%E5%85%AD%E6%AC%A1%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/><span class=title>Next »</span><br><span>OS:第六次理论作业</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share OS理论期末复习 on x" href="https://x.com/intent/tweet/?text=OS%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f&amp;hashtags=June"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS理论期末复习 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f&amp;title=OS%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0&amp;summary=OS%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0&amp;source=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS理论期末复习 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f&title=OS%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS理论期末复习 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS理论期末复习 on whatsapp" href="https://api.whatsapp.com/send?text=OS%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0%20-%20https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS理论期末复习 on telegram" href="https://telegram.me/share/url?text=OS%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS理论期末复习 on ycombinator" href="https://news.ycombinator.com/submitlink?t=OS%e7%90%86%e8%ae%ba%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0&u=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos%25E7%2590%2586%25E8%25AE%25BA%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://coder0xe.github.io/>coder0xe's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>