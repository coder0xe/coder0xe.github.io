<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OS:lab3课下基础 | coder0xe's blog</title><meta name=keywords content="操作系统"><meta name=description content="OS-lab3"><meta name=author content="sudo"><link rel=canonical href=https://coder0xe.github.io/posts/os-lab3%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.e4a36188e2c44563c1cc5ed1a2d0b8451a4f68c685114d738b97609f82dae050.css integrity="sha256-5KNhiOLERWPBzF7RotC4RRpPaMaFEU1zi5dgn4La4FA=" rel="preload stylesheet" as=style><link rel=icon href=https://coder0xe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://coder0xe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://coder0xe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://coder0xe.github.io/apple-touch-icon.png><link rel=mask-icon href=https://coder0xe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://coder0xe.github.io/posts/os-lab3%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://coder0xe.github.io/posts/os-lab3%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="coder0xe's blog"><meta property="og:title" content="OS:lab3课下基础"><meta property="og:description" content="OS-lab3"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-08T08:20:28+08:00"><meta property="article:modified_time" content="2024-04-08T08:20:28+08:00"><meta property="article:tag" content="Apr"><meta name=twitter:card content="summary"><meta name=twitter:title content="OS:lab3课下基础"><meta name=twitter:description content="OS-lab3"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://coder0xe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OS:lab3课下基础","item":"https://coder0xe.github.io/posts/os-lab3%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OS:lab3课下基础","name":"OS:lab3课下基础","description":"OS-lab3","keywords":["操作系统"],"articleBody":"OS:lab3课下基础 1.进程 由于没有实现线程，本实验中进程既是基本的分配单元，也是基本的执行单元\n1.1 进程控制块 ​\t进程控制块(Process Control Block)是用来管理进程的数据结构，可以记录进程的变化过程，记录进程的外部特征。PCB是系统感知进程存在的唯一标志，进程与PCB是一一对应的。在MOS中，PCB定义为一个Env结构体\n1 2 3 4 5 6 7 8 9 10 11 struct Env { struct Trapframe env_tf;\t// saved context (registers) before switching LIST_ENTRY(Env) env_link;\t// intrusive entry in 'env_free_list' u_int env_id;\t// unique environment identifier u_int env_asid;\t// ASID of this env u_int env_parent_id;\t// env_id of this env's parent u_int env_status;\t// status of this env Pde *env_pgdir;\t// page directory TAILQ_ENTRY(Env) env_sched_link; // intrusive entry in 'env_sched_list' u_int env_pri;\t// schedule priority }; env_tf : 在发生进程调度，或当陷入内核时，会将当时的进程上下文环境保存在env_tf变量中\ntrap.h中对于Trapframe结构体的定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 struct Trapframe { /* Saved main processor registers. */ unsigned long regs[32]; /* Saved special registers. */ unsigned long cp0_status; unsigned long hi; unsigned long lo; unsigned long cp0_badvaddr; unsigned long cp0_cause; unsigned long cp0_epc; }; 可以知道，当发生进程调度时，对于上下文的保存主要是保存了32个通用寄存器以及协处理器寄存器中的内容，值得注意的是，cp0_epc相当于记录了当前执行到的指令位置\nenv_link：用来构建空闲进程链表env_free_list的链接域\nenv_id：每个进程的id都不一样，是进程独一无二的标识符\nenv_parent_id：本进程的父进程id\nenv_status：该进程的状态，只有如下列举三种情况\nENV_FREE：表示该进程控制块没有被任何进程使用，即该进程控制块处于空闲链表中 ENV_NOT_RUNNABLE：表示该进程处于阻塞状态 ENV_RUNNABLE：表示该进程处于执行状态或就绪状态 env_pgdir：保存了该进程页目录的内核虚拟地址\nenv_sched_link：用来构造调度队列env_sched_list的链接域\nenv_pri：进程的优先级\n1.2 系统启动 env_init ​\t在实验中，存放进程控制块的物理内存在系统启动后就已经分配好，就是envs数组。一开始所有的进程控制块都是空闲的，因此要把他们都串联到env_free_list上。\n进程控制块空闲队列env_free_list使用了LIST结构 进程控制块调度队列env_sched_list使用了TAILQ结构，实现了双端队列，可以在头部或尾部插入和取出 Exercise 3.1 env_init\n将所有进程控制块逆序插入空闲链表，编号更小的进程控制块优先被分配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void env_init(void) { int i; /* Step 1: Initialize 'env_free_list' with 'LIST_INIT' and 'env_sched_list' with * 'TAILQ_INIT'. */ /* Exercise 3.1: Your code here. (1/2) */ LIST_INIT(\u0026env_free_list); TAILQ_INIT(\u0026env_sched_list); /* Step 2: Traverse the elements of 'envs' array, set their status to 'ENV_FREE' and insert * them into the 'env_free_list'. Make sure, after the insertion, the order of envs in the * list should be the same as they are in the 'envs' array. */ /* Exercise 3.1: Your code here. (2/2) */ for (i = NENV - 1; i \u003e= 0;i--) { envs[i].env_status = ENV_FREE; LIST_INSERT_HEAD(\u0026env_free_list,\u0026envs[i],env_link); } /* * We want to map 'UPAGES' and 'UENVS' to *every* user space with PTE_G permission (without * PTE_D), then user programs can read (but cannot write) kernel data structures 'pages' and * 'envs'. * * Here we first map them into the *template* page directory 'base_pgdir'. * Later in 'env_setup_vm', we will copy them into each 'env_pgdir'. */ struct Page *p; panic_on(page_alloc(\u0026p)); p-\u003epp_ref++; base_pgdir = (Pde *)page2kva(p); map_segment(base_pgdir, 0, PADDR(pages), UPAGES, ROUND(npage * sizeof(struct Page), PAGE_SIZE), PTE_G); map_segment(base_pgdir, 0, PADDR(envs), UENVS, ROUND(NENV * sizeof(struct Env), PAGE_SIZE), PTE_G); } 1.3 段地址映射 map_segment ​\tbase_pgdir为模版页表，所谓模版页表就是相当于为之后创建的进程的页表写了个板子，创建页表时先将这个模版复制过去。在env_init函数的最后，使用page_alloc函数为模版页表base_pgdir分配了一页物理内存，将其转换为内核虚拟地址后，使用map_segment函数将内核数组pages和envs映射到用户空间的UPAGES和UENVS处，以供用户程序读取\n关于map_segment：在一级页表基地址pgdir对应的两级页表结构中按页做段地址映射，将虚拟地址段va~va+size映射到物理地址段pa~pa+size\nExercise 3.2 map_segment\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static void map_segment(Pde *pgdir, u_int asid, u_long pa, u_long va, u_int size, u_int perm) { assert(pa % PAGE_SIZE == 0); assert(va % PAGE_SIZE == 0); assert(size % PAGE_SIZE == 0); /* Step 1: Map virtual address space to physical address space. */ for (int i = 0; i \u003c size; i += PAGE_SIZE) { /* * Hint: * Map the virtual page 'va + i' to the physical page 'pa + i' using 'page_insert'. * Use 'pa2page' to get the 'struct Page *' of the physical address. */ /* Exercise 3.2: Your code here. */ page_insert(pgdir,asid,pa2page(pa + i),va + i,perm | PTE_V); } } 1.4 进程的标识ASID ​\t实验中对于不同进程的识别是通过进程标识符env_id实现的，每个进程的id是独一无二的，在进程创建时就被赋予。\n创建新env_id是通过mkenvid实现的\n1 2 3 4 u_int mkenvid(struct Env *e) { static u_int i = 0; return ((++i) \u003c\u003c (1 + LOG2NENV)) | (e - envs); } ​\tenv_id已经可以唯一表示进程，包括进程虚拟地址空间，为什么还需要额外的域来作为虚拟地址空间的标识？\n​\t系统中并发执行多个拥有不同虚拟地址空间的进程，具有不同的页表。CPU的MMU使用TLB缓存虚拟地址映射关系，不同页表拥有不同虚拟地址映射。当CPU切换页表，TLB中仍可能缓存有之前页表的虚拟地址映射关系，这些映射关系可能与当前页表所描述的不一致，即为无效映射关系。\n​\t为了避免TLB缓存的无效映射关系在页表切换后导致错误的地址翻译发生，早期操作系统实现在CPU每次切换页表时无效化所有TLB项，但效率较低，会造成很多TLB Miss\n​\t现代的CPU及操作系统，采用ASID解决上述问题。ASID用于标识虚拟地址空间，同时并发执行的多个进程具有不同ASID以便TLB标识其虚拟地址空间\n​\t在lab2中提到，TLB实质上构建了一个映射 $$ -\u003e $$ ​\tTLB存储进程的ASID，作为key的一部分，用于区别不同地址空间中的映射，相当于每个进程都有自己虚拟地址空间（使用ASID标识）下的一套TLB缓存，每次切换页表不必再清空所有TLB表项。\n经过以上分析，我们知道对于在TLB中进行虚拟地址转换需要进行两步\n首先寻找虚拟地址对应的虚页号(»12) 如果有再检查ASID域，检查是不是一个进程，是否能使用相应的映射关系 ​\t同样ASID也具有唯一标识性，直到进程被销毁或TLB清空时，其ASID才可以被分配给其他进程，MIPS-4Kc中的ASID只有8个bit，即实验中可用的ASID只有256个，我们使用asid_alloc为进程分配ASID码，如果ASID已经耗尽还需要创建进程，内核会发生崩溃(panic)\n1 2 3 4 5 6 7 8 9 10 11 12 static int asid_alloc(u_int *asid) { for (u_int i = 0; i \u003c NASID; ++i) { int index = i \u003e\u003e 5; int inner = i \u0026 31; if ((asid_bitmap[index] \u0026 (1 \u003c\u003c inner)) == 0) { asid_bitmap[index] |= 1 \u003c\u003c inner; *asid = i; return 0; } } return -E_NO_FREE_ENV; } 1.5 设置进程控制块 创建进程的流程如下\n申请一个空闲的PCB：从env_free_list中索取一个空闲PCB块 手工初始化进程控制块 为新进程初始化页目录(env_setup_vm) 将PCB从共享页表摘除 ​\t首先介绍初始化新进程地址空间的函数env_setup_vm\nExercise 3.3 env_setup_vm\n首先为新进程分配一页物理页\n将模版页表base_pgdir的内容(pages/envs数组)复制到新进程对应的地址空间\n复制到对应的地址空间memcpy，这里在虚拟地址空间中pages和envs存储位置在mmu.h中定义，如下图所示\n故只需要从UTOP复制到UVPT\nULIM是kseg0和kuseg的分界线，是系统给用户进程分配的最高地址，kseg0和kseg1的访问不经过TLB，这部分内存由内核管理，所有进程共享，MOS操作系统特意将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问\n这里我们要暴露的是UTOP往上到UVPT之间所有进程共享的只读空间\nUVPT往上到ULIM之间是进程自己的页表\n将UVPT处的页表项设置为只读权限，故用户进程可以通过UVPT读自己的页表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static int env_setup_vm(struct Env *e) { /* Step 1: * Allocate a page for the page directory with 'page_alloc'. * Increase its 'pp_ref' and assign its kernel address to 'e-\u003eenv_pgdir'. * * Hint: * You can get the kernel address of a specified physical page using 'page2kva'. */ struct Page *p; try(page_alloc(\u0026p)); /* Exercise 3.3: Your code here. */ p-\u003epp_ref++; e-\u003eenv_pgdir = (Pde*)page2kva(p); /* Step 2: Copy the template page directory 'base_pgdir' to 'e-\u003eenv_pgdir'. */ /* Hint: * As a result, the address space of all envs is identical in [UTOP, UVPT). * See include/mmu.h for layout. */ memcpy(e-\u003eenv_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP), sizeof(Pde) * (PDX(UVPT) - PDX(UTOP))); /* Step 3: Map its own page table at 'UVPT' with readonly permission. * As a result, user programs can read its page table through 'UVPT' */ e-\u003eenv_pgdir[PDX(UVPT)] = PADDR(e-\u003eenv_pgdir) | PTE_V; return 0; } Exercise 3.4 env_alloc\n拿到一个空闲的进程控制块PCB 为新进程初始化地址空间 初始化env_id/parent_id/分配env_asid 初始化env_tp中的栈指针寄存器sp(通用寄存器第29个)和cp0_status寄存器，对于cp0寄存器中的设置后续说明 从空闲链表中移除PCB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int env_alloc(struct Env **new, u_int parent_id) { int r; struct Env *e; /* Step 1: Get a free Env from 'env_free_list' */ /* Exercise 3.4: Your code here. (1/4) */ if (LIST_EMPTY(\u0026env_free_list)) { return -E_NO_FREE_ENV; } e = LIST_FIRST(\u0026env_free_list); /* Step 2: Call a 'env_setup_vm' to initialize the user address space for this new Env. */ /* Exercise 3.4: Your code here. (2/4) */ try(env_setup_vm(e)); /* Step 3: Initialize these fields for the new Env with appropriate values: * 'env_user_tlb_mod_entry' (lab4), 'env_runs' (lab6), 'env_id' (lab3), 'env_asid' (lab3), * 'env_parent_id' (lab3) * * Hint: * Use 'asid_alloc' to allocate a free asid. * Use 'mkenvid' to allocate a free envid. */ e-\u003eenv_user_tlb_mod_entry = 0; // for lab4 e-\u003eenv_runs = 0;\t// for lab6 /* Exercise 3.4: Your code here. (3/4) */ r = asid_alloc(\u0026(e-\u003eenv_asid)); if (r != 0) { return r; } e-\u003eenv_id = mkenvid(e); e-\u003eenv_parent_id = parent_id; /* Step 4: Initialize the sp and 'cp0_status' in 'e-\u003eenv_tf'. * Set the EXL bit to ensure that the processor remains in kernel mode during context * recovery. Additionally, set UM to 1 so that when ERET unsets EXL, the processor * transitions to user mode. */ e-\u003eenv_tf.cp0_status = STATUS_IM7 | STATUS_IE | STATUS_EXL | STATUS_UM; // Reserve space for 'argc' and 'argv'. e-\u003eenv_tf.regs[29] = USTACKTOP - sizeof(int) - sizeof(char **); /* Step 5: Remove the new Env from env_free_list. */ /* Exercise 3.4: Your code here. (4/4) */ LIST_REMOVE(e,env_link); *new = e; return 0; } ​\t关于寄存器的设置：\ncp0_status：\nIE位表示中断是否开启\nIM7位表示是否响应时钟中断\nEXL以及UM位表示处理器当前的运行状态(当且仅当EXL=0且UM=1是为用户模式，其余均为内核模式)，每当异常发生，EXL被置1，执行eret时EXL被置0。我们知道，每个进程在每一次被调度时，都会执行\nRESTORE_ALL(registers) eret 首先要恢复env_tf中保存的所有寄存器的值，如果不设置EXL位，那么恢复完status寄存器的值后(此时EXL=0,UM=1)即进入用户模式，此时再访问内核地址段（例如恢复其他寄存器的值），执行特权指令，处理器就会立刻陷入异常。如果我们设置了EXL=1，则恢复完status寄存器的值后(EXL=1,UM=1)仍然处于内核态，不会发生错误。而在运行进程前，运行到eret时，就会将EXL设置为0，此时UM=IE=1表示在用户模式下且开启中断，之后进程成功以用户模式运行且操作系统正常响应中断。（实际上设置EXL位的目的就是避免在没有恢复完进程现场前就进入用户模式发生错误，控制住在eret时再回到用户模式）\nsp：设置栈指针，对应第29个通用寄存器，为argc和argv分配空间\n1.6 加载二进制镜像 ​\tELF文件的类型有三种，可重定位文件、可执行文件和可被共享的对象文件。本节中需要将程序(可执行文件)加载到新进程的地址空间中。\n​\t要想正确加载一个ELF文件到内存，只需将ELF文件中所有需要加载的程序段加载到对应的虚拟地址上。\nlab3中还没实现文件系统，无法直接操作磁盘中的ELF文件，这里将ELF文件内容转化为C数组形式，通过编译到内核中完成加载\nload_icode函数负责加载可执行文件binary到进程e的内存中 elf_from函数完成了解析ELF文件头的部分 elf_load_seg函数负责将ELF文件的一个segment加载到内存，它的最后两个参数用于接受一个自定义的回调函数map_page以及以及需要转递给回调函数的额外参数data，并由回调函数(这里为load_icode_mapper)完成单个页面的加载过程。 ​\tload_icode函数会从ELF文件中解析出每个segment的段头ph，以及其在内存中的起始位置bin，再由elf_load_seg函数将参数指定的程序段加载到进程的地址空间中。\nExercise 3.5 load_icode_mapper 回调函数将一页加载到用户内存空间中\n分配一个物理页面p 如果src非空，加载len字节到分配的物理页面p偏移量offset位置 将物理页面p插入到页表中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int load_icode_mapper(void *data, u_long va, size_t offset, u_int perm, const void *src, size_t len) { struct Env *env = (struct Env *)data; struct Page *p; int r; /* Step 1: Allocate a page with 'page_alloc'. */ /* Exercise 3.5: Your code here. (1/2) */ r = page_alloc(\u0026p); if (r != 0) { return r; } /* Step 2: If 'src' is not NULL, copy the 'len' bytes started at 'src' into 'offset' at this * page. */ // Hint: You may want to use 'memcpy'. if (src != NULL) { /* Exercise 3.5: Your code here. (2/2) */ memcpy(page2kva(p) + offset,src,len); } /* Step 3: Insert 'p' into 'env-\u003eenv_pgdir' at 'va' with 'perm'. */ return page_insert(env-\u003eenv_pgdir, env-\u003eenv_asid, p, va, perm); } Exercise 3.6 load_icode 加载ELF到进程\n首先使用elf_form将binary转换为ELF头的形式用于解析 将ELF中的每一段(loadable)加载到内存中，调用elf_load_seg env_tf.cp0_epc字段指示了进程恢复运行时PC应当恢复到的位置，程序入口为e_entry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static void load_icode(struct Env *e, const void *binary, size_t size) { /* Step 1: Use 'elf_from' to parse an ELF header from 'binary'. */ const Elf32_Ehdr *ehdr = elf_from(binary, size); if (!ehdr) { panic(\"bad elf at %x\", binary); } /* Step 2: Load the segments using 'ELF_FOREACH_PHDR_OFF' and 'elf_load_seg'. * As a loader, we just care about loadable segments, so parse only program headers here. */ size_t ph_off; ELF_FOREACH_PHDR_OFF (ph_off, ehdr) { Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off); if (ph-\u003ep_type == PT_LOAD) { // 'elf_load_seg' is defined in lib/elfloader.c // 'load_icode_mapper' defines the way in which a page in this segment // should be mapped. panic_on(elf_load_seg(ph, binary + ph-\u003ep_offset, load_icode_mapper, e)); } } /* Step 3: Set 'e-\u003eenv_tf.cp0_epc' to 'ehdr-\u003ee_entry'. */ /* Exercise 3.6: Your code here. */ e-\u003eenv_tf.cp0_epc = ehdr-\u003ee_entry; } 1.7 创建进程 这里的创建进程指在操作系统内核初始化时直接创建进程，例如在init.c中\n1 2 3 // lab3: ENV_CREATE_PRIORITY(user_bare_loop, 1); ENV_CREATE_PRIORITY(user_bare_loop, 2); ​\t创建新进程由env_create完成\nExercise 3.7 env_create\n分配一个新的Env结构体 设置进程控制块 并将程序载入到该进程的地址空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Env *env_create(const void *binary, size_t size, int priority) { struct Env *e; /* Step 1: Use 'env_alloc' to alloc a new env, with 0 as 'parent_id'. */ /* Exercise 3.7: Your code here. (1/3) */ env_alloc(\u0026e,0); /* Step 2: Assign the 'priority' to 'e' and mark its 'env_status' as runnable. */ /* Exercise 3.7: Your code here. (2/3) */ e-\u003eenv_pri = priority; e-\u003eenv_status = ENV_RUNNABLE; /* Step 3: Use 'load_icode' to load the image from 'binary', and insert 'e' into * 'env_sched_list' using 'TAILQ_INSERT_HEAD'. */ /* Exercise 3.7: Your code here. (3/3) */ load_icode(e,binary,size); TAILQ_INSERT_HEAD(\u0026env_sched_list,e,env_sched_link); return e; } 1.8 进程运行与切换 ​\tenv_run是进程运行使用的基本函数，它包括两个功能\n保存当前进程上下文（若当前没有运行进程则跳过） 恢复要启动的进程的上下文，然后运行该进程 这里的上下文指寄存器 ​\t我们要运行一个新进程往往意味着进程切换，进程切换需要对上下文（各种寄存器）进行保存，本实验中寄存器状态保存的地方是KSTACKTOP以下的一个sizeof(TrapFrame)的小的区域中\nExercise 3.8 env_run\n保存当前进程的上下文信息 切换curenv为即将运行的进程 设置全局变量cur_pgdir为当前进程页目录地址 调用env_pop)tf ：恢复现场，异常返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void env_run(struct Env *e) { assert(e-\u003eenv_status == ENV_RUNNABLE); // WARNING BEGIN: DO NOT MODIFY FOLLOWING LINES! #ifdef MOS_PRE_ENV_RUN MOS_PRE_ENV_RUN_STMT #endif // WARNING END /* Step 1: * If 'curenv' is NULL, this is the first time through. * If not, we may be switching from a previous env, so save its context into * 'curenv-\u003eenv_tf' first. */ if (curenv) { curenv-\u003eenv_tf = *((struct Trapframe *)KSTACKTOP - 1); } /* Step 2: Change 'curenv' to 'e'. */ curenv = e; curenv-\u003eenv_runs++; // lab6 /* Step 3: Change 'cur_pgdir' to 'curenv-\u003eenv_pgdir', switching to its address space. */ /* Exercise 3.8: Your code here. (1/2) */ cur_pgdir = curenv-\u003eenv_pgdir; /* Step 4: Use 'env_pop_tf' to restore the curenv's saved context (registers) and return/go * to user mode. * * Hint: * - You should use 'curenv-\u003eenv_asid' here. * - 'env_pop_tf' is a 'noreturn' function: it restores PC from 'cp0_epc' thus not * returning to the kernel caller, making 'env_run' a 'noreturn' function as well. */ /* Exercise 3.8: Your code here. (2/2) */ env_pop_tf(\u0026(curenv-\u003eenv_tf),curenv-\u003eenv_asid); } 2.中断与异常 回想上学期计组P7内容\n2.1 异常的分发 ​\t当发生异常时，处理器会进入一个用于分发异常的程序，这个程序的作用是检测发生了哪种异常并调用相应的异常处理程序。\nExercise 3.9 补全异常分发代码 entry.S\n异常分发的步骤如下：\n使用SAVE_ALL将上下文保存到内核的异常栈中 消除Status寄存器中的UM,EXL,IE位，保持内核态，关闭中断，允许嵌套异常（读、改、存） 取得Cause寄存器中2-6位，即对应的异常码部分，用来区别不同的异常 用取得的异常码作为索引在exception_handlers数组中找到对应的中断处理函数，跳转到对应的中断处理函数，这就是分发！ .section .text.exc_gen_entry exc_gen_entry: SAVE_ALL /* * Note: When EXL is set or UM is unset, the processor is in kernel mode. * When EXL is set, the value of EPC is not updated when a new exception occurs. * To keep the processor in kernel mode and enable exception reentrancy, * we unset UM and EXL, and unset IE to globally disable interrupts. */ mfc0 t0, CP0_STATUS and t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE) mtc0 t0, CP0_STATUS /* Exercise 3.9: Your code here. */ mfc0\tt0, CP0_CAUSE andi\tt0, 0x7c /*2-6位异常码*/ lw\tt0, exception_handlers(t0) jr\tt0 ​\tSAVE_ALL是用于将当前CPU上下文保存到内核的异常栈的宏，简单分析一下（和他相似定义的还有RESTORE_ALL，都定义在stackframe.h中）\n.macro SAVE_ALL .set noat .set noreorder mfc0 k0, CP0_STATUS andi k0, STATUS_UM beqz k0, 1f move k0, sp /* * If STATUS_UM is not set, the exception was triggered in kernel mode. * $sp is already a kernel stack pointer, we don't need to set it again. */ li sp, KSTACKTOP 1: subu sp, sp, TF_SIZE sw k0, TF_REG29(sp) mfc0 k0, CP0_STATUS sw k0, TF_STATUS(sp) mfc0 k0, CP0_CAUSE sw k0, TF_CAUSE(sp) mfc0 k0, CP0_EPC sw k0, TF_EPC(sp) mfc0 k0, CP0_BADVADDR sw k0, TF_BADVADDR(sp) mfhi k0 sw k0, TF_HI(sp) mflo k0 sw k0, TF_LO(sp) sw $0, TF_REG0(sp) sw $1, TF_REG1(sp) sw $2, TF_REG2(sp) sw $3, TF_REG3(sp) sw $4, TF_REG4(sp) sw $5, TF_REG5(sp) sw $6, TF_REG6(sp) sw $7, TF_REG7(sp) sw $8, TF_REG8(sp) sw $9, TF_REG9(sp) sw $10, TF_REG10(sp) sw $11, TF_REG11(sp) sw $12, TF_REG12(sp) sw $13, TF_REG13(sp) sw $14, TF_REG14(sp) sw $15, TF_REG15(sp) sw $16, TF_REG16(sp) sw $17, TF_REG17(sp) sw $18, TF_REG18(sp) sw $19, TF_REG19(sp) sw $20, TF_REG20(sp) sw $21, TF_REG21(sp) sw $22, TF_REG22(sp) sw $23, TF_REG23(sp) sw $24, TF_REG24(sp) sw $25, TF_REG25(sp) sw $26, TF_REG26(sp) sw $27, TF_REG27(sp) sw $28, TF_REG28(sp) sw $30, TF_REG30(sp) sw $31, TF_REG31(sp) .set at .set reorder .endm 首先检查我们需要处理的异常是否是在内核态被触发的（或者说是否是异常重入，异常重入正如它的字面意思：是不是在处理异常过程中(内核态)又发生了异常需要处理）\n我们通过检查Status寄存器的UM位实现检查是不是异常重入\n如果为0，说明该异常是在内核态被触发的，是异常重入 如果为1，说明该异常是在用户态被触发的，不是异常重入 如果是异常重入，则栈指针sp已经指向内核异常栈\n如果不是异常重入，则需要先将sp指向内核异常栈(借助MIPS中的延迟槽保存原来的sp值)\nbeqz k0, 1f move k0, sp /*保存原来的sp*/ li sp, KSTACKTOP /*指向异常处理栈*/ ​\t在我们的系统中，CPU发生异常后就会自动跳转到地址0x80000180处，发生用户态地址的TLB Miss异常时，会自动跳转到地址0x80000000，故我们需要将处理异常的代码.text.exc_gen_entry放到0x80000180处，将.text.tlb_miss_entry放到0x80000000处。这可以通过链接器实现，在kernel.lds中指定两个代码段的加载位置\nExercise 3.10 kernel.lds 指定两个异常处理代码的存放位置，用于CPU处理异常时跳转到对应位置，这里就相当于完成了包含两种异常的异常分发\n1 2 3 4 5 6 7 8 9 10 /* Exercise 3.10: Your code here. */ . = 0x80000000; .tlb_miss_entry : { *(.text.tlb_miss_entry) } . = 0x80000180; .exc_gen_entry : { *(.text.exc_gen_entry) } 2.2 异常向量组 ​\t异常分发程序通过exception_handlers数组定位中断处理程序(Cause)，而exception_handlers就称作异常向量组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 extern void handle_int(void); extern void handle_tlb(void); extern void handle_sys(void); extern void handle_mod(void); extern void handle_reserved(void); void (*exception_handlers[32])(void) = { [0 ... 31] = handle_reserved, [0] = handle_int, [2 ... 3] = handle_tlb, #if !defined(LAB) || LAB \u003e= 4 [1] = handle_mod, [8] = handle_sys, #endif }; GNU扩展语法：[first...last] = value对数组某个区间上的元素赋成同一个值 0号异常处理函数为handle_int：表示中断，由时钟中断、控制台中断等中断造成 1号异常处理函数为handle_mod：表示存储异常，进行存储操作时该页被标记为已读 2号异常处理函数为handle_tlb：表示TLB load异常 3号异常处理函数为handle_tlb：表示TLB store异常 8号异常处理函数为handle_sys：表示系统调用，syscall指令陷入内核 ​\t有异常产生，则其对应的处理函数就会执行，在lab3中主要使用0号对应的时钟异常，我们需要产生并处理时钟中断，并利用时钟中断进行抢占式进程调度（解析见实验报告）\n2.3 时钟中断 ​\tMOS系统中使用时间片轮转调度算法进行进程调度，每个进程运行一个时间片。MOS通过硬件计时器产生的时钟中断知晓一个进程的时间片结束，比如设定某个进程的时间片长度为200倍的时钟中断间隔(TIMER_INTERVAL)，那么当MOS记录发生了200次时钟中断后就知道该进程的时间片结束了，当前运行的进程被挂起(如果还没结束)，在调度队列中选取一个合适的进程运行。\n​\tMIPS-4Kc中的CP0内置了可产生中断的Timer，利用Timer产生时钟中断。CP0中存在两个用于控制Timer的寄存器，Count寄存器和Compare寄存器，Count寄存器按照与处理器频率相关的频率不断自增，Compare寄存器维持不变。当Count寄存器的值与Compare寄存器的值相等且非0时，时钟中断会被立即触发。\n​\t在include/kclock.h中实现了对Timer的初始化：\nCount寄存器清0 Compare寄存器配置为我们所期望的寄存器周期数 ​\t时钟中断的处理流程：\n系统将PC指向0x8000_0180，跳转到.text.exc_gen_entry代码段执行 通过.text_gen_entry对异常进行分发(我们实现的中断为异步异常)，最终调用中断处理handle_int函数进行中断处理 handle_int函数根据CAUSE寄存器的值判断是否为Timer对应的7号中断位引发的时钟中断，如果是，跳转到中断服务函数timer_irq，跳转到sechdule中执行 Exercise 3.11 RESET_KCLOCK宏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 .macro RESET_KCLOCK li t0, TIMER_INTERVAL /* * Hint: * Use 'mtc0' to write an appropriate value into the CP0_COUNT and CP0_COMPARE registers. * Writing to the CP0_COMPARE register will clear the timer interrupt. * The CP0_COUNT register increments at a fixed frequency. When the values of CP0_COUNT and * CP0_COMPARE registers are equal, the timer interrupt will be triggered. * */ /* Exercise 3.11: Your code here. */ mtc0\tzero, CP0_COUNT mtc0\tt0, CP0_COMPARE .endm 2.4 进程调度 ​\t我们使用的进程调度算法即为时间片轮转算法。时间片轮转算法中，时间片长度被量化为$time = N*TimerInterval$，这里的N为进程的优先级。\n​\t使用调度链表存储所有就绪的进程，即一个进程在调度链表中当且仅当它的状态为RUNNABLE。内核创建新进程时，将其插入调度链表的头部，当期阻塞或退出时，从调度链表中移除。\n​\t调度函数schedule被调用时，当前运行的进程被存储在全局变量curenv中，其剩余的时间片长度被存储在静态变量count中，需要进行进程切换的情况包括\n尚未调度过任何进程(curenv==NULL) 当前进程用完了时间片(count==0) 当前进程不再就绪(status!=RUNNABLE) yield参数指定必须发生切换 ​\t当无需进行切换时，我们只需要将剩余时间片count-1，然后调用env_run函数继续运行当前进程curenv。\n​\t在发生进程切换时，还需要判断当前进程是否仍然就绪(RUNNABLE)，如果是则将其移动到调度链表的尾部。之后我们选择调度链表首部的进程来调度运行，将剩余时间片长度设置为它的优先级。\nExercise 3.12 schedule 切换进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void schedule(int yield) { static int count = 0; // remaining time slices of current env struct Env *e = curenv; /* We always decrease the 'count' by 1. * * If 'yield' is set, or 'count' has been decreased to 0, or 'e' (previous 'curenv') is * 'NULL', or 'e' is not runnable, then we pick up a new env from 'env_sched_list' (list of * all runnable envs), set 'count' to its priority, and schedule it with 'env_run'. **Panic * if that list is empty**. * * (Note that if 'e' is still a runnable env, we should move it to the tail of * 'env_sched_list' before picking up another env from its head, or we will schedule the * head env repeatedly.) * * Otherwise, we simply schedule 'e' again. * * You may want to use macros below: * 'TAILQ_FIRST', 'TAILQ_REMOVE', 'TAILQ_INSERT_TAIL' */ /* Exercise 3.12: Your code here. */ if (yield|| count == 0 || e == NULL || e-\u003eenv_status != ENV_RUNNABLE) { if (e \u0026\u0026 e-\u003eenv_status == ENV_RUNNABLE) { TAILQ_REMOVE(\u0026env_sched_list,e,env_sched_link); TAILQ_INSERT_TAIL(\u0026env_sched_list,e,env_sched_link); } if (TAILQ_EMPTY(\u0026env_sched_list)) { panic(\"no runnable envs\"); } e = TAILQ_FIRST(\u0026env_sched_list); count = e-\u003eenv_pri; } count--; env_run(e); } 3. 总结 ​\t我们在lab3中学习了进程管理的相关内容，本实验中完成的功能可以由下图概括\nexception_handlers数组为异常向量组，负责分发异常。我们主要涉及到的是0号异常处理函数(中断处理函数)handle_int，1号异常处理函数handle_mod，2号/3号处理函数handle_tlb。初始化结束后，若有异常产生，则其对应的异常处理函数执行\nenv_create\n分配进程控制块\nenv_alloc从空闲链表中分配一个空闲控制块，并进行相应的初始化工作，初始化过程中调用env_setup_vm函数对虚拟地址空间进行初始化，这里包括复制模版页表base_pgdir。模版页表中包含了虚拟地址空间到物理地址空间pages/envs数组的映射，复制到新页表使得用户进程的地址空间中可以访问pages/envs数组\n调用load_icode函数将程序加载到新创建的地址空间中\nhandle_int\n根据CP0_CAUSE寄存器判断是否为时钟中断(7号中断)，并根据Status寄存器判断7号中断是否开启(全局中断使能\u0026\u0026时钟中断使能IM7)。如果是，则调用schedule函数，schedule函数进行进程调度，调用env_run来运行进程\nenv_run\n将正在执行的进程(curenv)的现场保存在对应的进程控制块中 选择一个可以运行的进程，恢复该进程上次被挂起时候的现场，即恢复env_tf，调用env_pop_tf完成 发生TLB Miss时的异常处理\n​\t硬件在取数据或取指令的时候，CPU发射虚拟地址给MMU进行地址转换。对于用户段虚拟地址的转换通过TLB完成，若TLB在转换的过程中发现TLB中还没有对应于该虚拟地址的映射(key--VPN/ASID)，则会产生TLB Miss异常。\n​\t硬件会打断访存过程并陷入内核态跳转到对应的异常处理程序(tlb_miss_entry : pc : 0x8000_0000)，由操作系统查找页表进行TLB重填(do_tlb_refill)，之后再从异常返回，继续访存.\n从软硬件的角度来看 硬件：在发生TLBMiss 异常的时候，4Kc CPU 会把引发 TLB Miss 的虚拟地址填 入到BadVAddr 寄存器中、虚页号填入到 EntryHi 寄存器的 VPN 域中，将 Cause 寄存 器中的ExcCode 域填写为 TLBL（读请求TLBMiss）或 TLBS（写请求 TLB Miss）。 软件：从BadVAddr 寄存器中获取引发 TLB Miss 的虚拟地址，接着在 cur_pgdir 中查找该虚拟地址对应的物理地址与权限位，然后将物理页面号和权限位填入到EntryLo 寄存器的PFN域和权限位中，再使用tlbwr（TLBWriteentry selected by Random）将 EntryHi 和 EntryLo 寄存器中的 VPN、PFN、ASID、权限位等随机地写入到TLB中，最 后调用ret_from_exception 从异常返回。 ​\n","wordCount":"2670","inLanguage":"en","datePublished":"2024-04-08T08:20:28+08:00","dateModified":"2024-04-08T08:20:28+08:00","author":{"@type":"Person","name":"sudo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://coder0xe.github.io/posts/os-lab3%E8%AF%BE%E4%B8%8B%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"coder0xe's blog","logo":{"@type":"ImageObject","url":"https://coder0xe.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://coder0xe.github.io/ accesskey=h title="coder0xe's blog (Alt + H)">coder0xe's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://coder0xe.github.io/ title=首页><span>首页</span></a></li><li><a href=https://coder0xe.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://coder0xe.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://coder0xe.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://coder0xe.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://coder0xe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://coder0xe.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">OS:lab3课下基础</h1><div class=post-description>OS-lab3</div><div class=post-meta><span title='2024-04-08 08:20:28 +0800 +0800'>April 8, 2024</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>sudo</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#oslab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80 aria-label=OS:lab3课下基础>OS:lab3课下基础</a><ul><li><a href=#1%e8%bf%9b%e7%a8%8b aria-label=1.进程>1.进程</a><ul><li><a href=#11-%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%9d%97 aria-label="1.1 进程控制块">1.1 进程控制块</a></li><li><a href=#12-%e7%b3%bb%e7%bb%9f%e5%90%af%e5%8a%a8-env_init aria-label="1.2 系统启动 env_init">1.2 系统启动 env_init</a></li><li><a href=#13-%e6%ae%b5%e5%9c%b0%e5%9d%80%e6%98%a0%e5%b0%84-map_segment aria-label="1.3 段地址映射 map_segment">1.3 段地址映射 map_segment</a></li><li><a href=#14-%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%a0%87%e8%af%86asid aria-label="1.4 进程的标识ASID">1.4 进程的标识ASID</a></li><li><a href=#15-%e8%ae%be%e7%bd%ae%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%9d%97 aria-label="1.5 设置进程控制块">1.5 设置进程控制块</a></li><li><a href=#16-%e5%8a%a0%e8%bd%bd%e4%ba%8c%e8%bf%9b%e5%88%b6%e9%95%9c%e5%83%8f aria-label="1.6 加载二进制镜像">1.6 加载二进制镜像</a></li><li><a href=#17-%e5%88%9b%e5%bb%ba%e8%bf%9b%e7%a8%8b aria-label="1.7 创建进程">1.7 创建进程</a></li><li><a href=#18-%e8%bf%9b%e7%a8%8b%e8%bf%90%e8%a1%8c%e4%b8%8e%e5%88%87%e6%8d%a2 aria-label="1.8 进程运行与切换">1.8 进程运行与切换</a></li></ul></li><li><a href=#2%e4%b8%ad%e6%96%ad%e4%b8%8e%e5%bc%82%e5%b8%b8 aria-label=2.中断与异常>2.中断与异常</a><ul><li><a href=#21-%e5%bc%82%e5%b8%b8%e7%9a%84%e5%88%86%e5%8f%91 aria-label="2.1 异常的分发">2.1 异常的分发</a></li><li><a href=#22-%e5%bc%82%e5%b8%b8%e5%90%91%e9%87%8f%e7%bb%84 aria-label="2.2 异常向量组">2.2 异常向量组</a></li><li><a href=#23-%e6%97%b6%e9%92%9f%e4%b8%ad%e6%96%ad aria-label="2.3 时钟中断">2.3 时钟中断</a></li><li><a href=#24-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6 aria-label="2.4 进程调度">2.4 进程调度</a></li></ul></li><li><a href=#3-%e6%80%bb%e7%bb%93 aria-label="3. 总结">3. 总结</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=oslab3课下基础>OS:lab3课下基础<a hidden class=anchor aria-hidden=true href=#oslab3课下基础>#</a></h1><h2 id=1进程>1.进程<a hidden class=anchor aria-hidden=true href=#1进程>#</a></h2><blockquote><p>由于没有实现线程，本实验中进程既是基本的分配单元，也是基本的执行单元</p></blockquote><h3 id=11-进程控制块>1.1 进程控制块<a hidden class=anchor aria-hidden=true href=#11-进程控制块>#</a></h3><p>​ 进程控制块(<code>Process Control Block</code>)是用来管理进程的数据结构，可以记录进程的变化过程，记录进程的外部特征。<strong>PCB是系统感知进程存在的唯一标志，进程与PCB是一一对应的</strong>。在MOS中，PCB定义为一个Env结构体</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> Env {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Trapframe env_tf;	 <span style=color:#6272a4>// saved context (registers) before switching
</span></span></span><span style=display:flex><span>	<span style=color:#50fa7b>LIST_ENTRY</span>(Env) env_link;	 <span style=color:#6272a4>// intrusive entry in &#39;env_free_list&#39;
</span></span></span><span style=display:flex><span>	u_int env_id;			 <span style=color:#6272a4>// unique environment identifier
</span></span></span><span style=display:flex><span>	u_int env_asid;			 <span style=color:#6272a4>// ASID of this env
</span></span></span><span style=display:flex><span>	u_int env_parent_id;		 <span style=color:#6272a4>// env_id of this env&#39;s parent
</span></span></span><span style=display:flex><span>	u_int env_status;		 <span style=color:#6272a4>// status of this env
</span></span></span><span style=display:flex><span>	Pde <span style=color:#ff79c6>*</span>env_pgdir;			 <span style=color:#6272a4>// page directory
</span></span></span><span style=display:flex><span>	<span style=color:#50fa7b>TAILQ_ENTRY</span>(Env) env_sched_link; <span style=color:#6272a4>// intrusive entry in &#39;env_sched_list&#39;
</span></span></span><span style=display:flex><span>	u_int env_pri;			 <span style=color:#6272a4>// schedule priority
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>env_tf </code>: 在发生进程调度，或当陷入内核时，会将当时的进程上下文环境保存在env_tf变量中</p><p><code>trap.h</code>中对于<code>Trapframe</code>结构体的定义如下</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> Trapframe {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Saved main processor registers. */</span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> regs[<span style=color:#bd93f9>32</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Saved special registers. */</span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> cp0_status;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> hi;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> lo;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> cp0_badvaddr;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> cp0_cause;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> cp0_epc;
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><p>可以知道，<strong>当发生进程调度时，对于上下文的保存主要是保存了32个通用寄存器以及协处理器寄存器中的内容，值得注意的是，cp0_epc相当于记录了当前执行到的指令位置</strong></p></li><li><p><code>env_link</code>：用来构建空闲进程链表<code>env_free_list</code>的链接域</p></li><li><p><code>env_id</code>：每个进程的id都不一样，是进程独一无二的标识符</p></li><li><p><code>env_parent_id</code>：本进程的父进程id</p></li><li><p><code>env_status</code>：该进程的状态，只有如下列举三种情况</p><ul><li><code>ENV_FREE</code>：表示该进程控制块没有被任何进程使用，<strong>即该进程控制块处于空闲链表中</strong></li><li><code>ENV_NOT_RUNNABLE</code>：表示该进程处于<strong>阻塞状态</strong></li><li><code>ENV_RUNNABLE</code>：表示该进程处于<strong>执行状态或就绪状态</strong></li></ul></li><li><p><code>env_pgdir</code>：保存了该进程<strong>页目录的内核虚拟地址</strong></p></li><li><p><code>env_sched_link</code>：用来构造调度队列<code>env_sched_list</code>的链接域</p></li><li><p><code>env_pri</code>：进程的优先级</p></li></ul><h3 id=12-系统启动-env_init>1.2 系统启动 env_init<a hidden class=anchor aria-hidden=true href=#12-系统启动-env_init>#</a></h3><p>​ 在实验中，存放进程控制块的物理内存在系统启动后就已经分配好，就是envs数组。一开始所有的进程控制块都是<strong>空闲</strong>的，因此要把他们都串联到<code>env_free_list</code>上。</p><ul><li>进程控制块空闲队列<code>env_free_list</code>使用了LIST结构</li><li>进程控制块调度队列<code>env_sched_list</code>使用了TAILQ结构，实现了<strong>双端队列</strong>，可以在头部或尾部插入和取出</li></ul><blockquote><p>Exercise 3.1 env_init</p><ul><li>将所有进程控制块逆序插入空闲链表，编号更小的进程控制块优先被分配</li></ul></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>env_init</span>(<span style=color:#8be9fd>void</span>) {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> i;
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1: Initialize &#39;env_free_list&#39; with &#39;LIST_INIT&#39; and &#39;env_sched_list&#39; with
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * &#39;TAILQ_INIT&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.1: Your code here. (1/2) */</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>LIST_INIT</span>(<span style=color:#ff79c6>&amp;</span>env_free_list);
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>TAILQ_INIT</span>(<span style=color:#ff79c6>&amp;</span>env_sched_list);
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 2: Traverse the elements of &#39;envs&#39; array, set their status to &#39;ENV_FREE&#39; and insert
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * them into the &#39;env_free_list&#39;. Make sure, after the insertion, the order of envs in the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * list should be the same as they are in the &#39;envs&#39; array. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.1: Your code here. (2/2) */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> NENV <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>; i <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>0</span>;i<span style=color:#ff79c6>--</span>) {
</span></span><span style=display:flex><span>		envs[i].env_status <span style=color:#ff79c6>=</span> ENV_FREE;
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>LIST_INSERT_HEAD</span>(<span style=color:#ff79c6>&amp;</span>env_free_list,<span style=color:#ff79c6>&amp;</span>envs[i],env_link);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/*
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * We want to map &#39;UPAGES&#39; and &#39;UENVS&#39; to *every* user space with PTE_G permission (without
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * PTE_D), then user programs can read (but cannot write) kernel data structures &#39;pages&#39; and
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * &#39;envs&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * Here we first map them into the *template* page directory &#39;base_pgdir&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * Later in &#39;env_setup_vm&#39;, we will copy them into each &#39;env_pgdir&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Page <span style=color:#ff79c6>*</span>p;
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>panic_on</span>(<span style=color:#50fa7b>page_alloc</span>(<span style=color:#ff79c6>&amp;</span>p));
</span></span><span style=display:flex><span>	p<span style=color:#ff79c6>-&gt;</span>pp_ref<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	base_pgdir <span style=color:#ff79c6>=</span> (Pde <span style=color:#ff79c6>*</span>)<span style=color:#50fa7b>page2kva</span>(p);
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>map_segment</span>(base_pgdir, <span style=color:#bd93f9>0</span>, <span style=color:#50fa7b>PADDR</span>(pages), UPAGES,
</span></span><span style=display:flex><span>		    <span style=color:#50fa7b>ROUND</span>(npage <span style=color:#ff79c6>*</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> Page), PAGE_SIZE), PTE_G);
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>map_segment</span>(base_pgdir, <span style=color:#bd93f9>0</span>, <span style=color:#50fa7b>PADDR</span>(envs), UENVS, <span style=color:#50fa7b>ROUND</span>(NENV <span style=color:#ff79c6>*</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> Env), PAGE_SIZE),
</span></span><span style=display:flex><span>		    PTE_G);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=13-段地址映射-map_segment>1.3 段地址映射 map_segment<a hidden class=anchor aria-hidden=true href=#13-段地址映射-map_segment>#</a></h3><p>​ <code>base_pgdir</code>为模版页表，<strong>所谓模版页表就是相当于为之后创建的进程的页表写了个板子，创建页表时先将这个模版复制过去</strong>。在<code>env_init</code>函数的最后，使用<code>page_alloc</code>函数为模版页表<code>base_pgdir</code>分配了一页物理内存，将其转换为内核虚拟地址后，<strong>使用<code>map_segment</code>函数将内核数组pages和envs映射到用户空间的UPAGES和UENVS处，以供用户程序读取</strong></p><ul><li><p>关于<code>map_segment</code>：在一级页表基地址<code>pgdir</code>对应的两级页表结构中<strong>按页</strong>做段地址映射，将虚拟地址段<code>va~va+size</code>映射到物理地址段<code>pa~pa+size</code></p><blockquote><p>Exercise 3.2 map_segment</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>map_segment</span>(Pde <span style=color:#ff79c6>*</span>pgdir, u_int asid, u_long pa, u_long va, u_int size, u_int perm) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>assert</span>(pa <span style=color:#ff79c6>%</span> PAGE_SIZE <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>assert</span>(va <span style=color:#ff79c6>%</span> PAGE_SIZE <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>assert</span>(size <span style=color:#ff79c6>%</span> PAGE_SIZE <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1: Map virtual address space to physical address space. */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> size; i <span style=color:#ff79c6>+=</span> PAGE_SIZE) {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>/*
</span></span></span><span style=display:flex><span><span style=color:#6272a4>		 * Hint:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>		 *  Map the virtual page &#39;va + i&#39; to the physical page &#39;pa + i&#39; using &#39;page_insert&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>		 *  Use &#39;pa2page&#39; to get the &#39;struct Page *&#39; of the physical address.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>		 */</span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>/* Exercise 3.2: Your code here. */</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>page_insert</span>(pgdir,asid,<span style=color:#50fa7b>pa2page</span>(pa <span style=color:#ff79c6>+</span> i),va <span style=color:#ff79c6>+</span> i,perm <span style=color:#ff79c6>|</span> PTE_V);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=14-进程的标识asid>1.4 进程的标识ASID<a hidden class=anchor aria-hidden=true href=#14-进程的标识asid>#</a></h3><p>​ 实验中对于不同进程的识别是通过进程标识符<code>env_id</code>实现的，每个进程的id是独一无二的，在进程创建时就被赋予。</p><blockquote><p>创建新env_id是通过mkenvid实现的</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>u_int <span style=color:#50fa7b>mkenvid</span>(<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>e) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>static</span> u_int i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> ((<span style=color:#ff79c6>++</span>i) <span style=color:#ff79c6>&lt;&lt;</span> (<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>+</span> LOG2NENV)) <span style=color:#ff79c6>|</span> (e <span style=color:#ff79c6>-</span> envs);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></blockquote><p>​ <code>env_id</code>已经可以唯一表示进程，包括进程虚拟地址空间，为什么还需要额外的域来作为虚拟地址空间的标识？</p><p>​ 系统中并发执行多个拥有不同虚拟地址空间的进程，具有不同的页表。CPU的MMU使用TLB缓存虚拟地址映射关系，不同页表拥有不同虚拟地址映射。<strong>当CPU切换页表，TLB中仍可能缓存有之前页表的虚拟地址映射关系，这些映射关系可能与当前页表所描述的不一致，即为无效映射关系</strong>。</p><p>​ <strong>为了避免TLB缓存的无效映射关系在页表切换后导致错误的地址翻译发生，早期操作系统实现在CPU每次切换页表时无效化所有TLB项，但效率较低，会造成很多TLB Miss</strong></p><p>​ 现代的CPU及操作系统，<strong>采用ASID解决上述问题</strong>。<strong>ASID用于标识虚拟地址空间，同时并发执行的多个进程具有不同ASID以便TLB标识其虚拟地址空间</strong></p><p>​ 在lab2中提到，TLB实质上构建了一个映射
$$
&lt;VPN,ASID>->&lt;PFN,N,D,V,G>
$$
​ TLB存储进程的ASID，作为key的一部分，用于区别不同地址空间中的映射，相当于每个进程都有自己虚拟地址空间（使用ASID标识）下的一套TLB缓存，每次切换页表不必再清空所有TLB表项。</p><blockquote><p>经过以上分析，我们知道对于在TLB中进行虚拟地址转换需要进行两步</p><ul><li>首先寻找虚拟地址对应的虚页号(&#187;12)</li><li>如果有再检查ASID域，检查是不是一个进程，是否能使用相应的映射关系</li></ul></blockquote><p>​ 同样ASID也具有唯一标识性，直到进程被销毁或TLB清空时，其ASID才可以被分配给其他进程，<code>MIPS-4Kc</code>中的ASID只有8个bit，即实验中可用的ASID只有256个，我们使用<code>asid_alloc</code>为进程分配ASID码，如果ASID已经耗尽还需要创建进程，内核会发生崩溃(panic)</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>asid_alloc</span>(u_int <span style=color:#ff79c6>*</span>asid) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> (u_int i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> NASID; <span style=color:#ff79c6>++</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd>int</span> index <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd>int</span> inner <span style=color:#ff79c6>=</span> i <span style=color:#ff79c6>&amp;</span> <span style=color:#bd93f9>31</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> ((asid_bitmap[index] <span style=color:#ff79c6>&amp;</span> (<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>&lt;&lt;</span> inner)) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>			asid_bitmap[index] <span style=color:#ff79c6>|=</span> <span style=color:#bd93f9>1</span> <span style=color:#ff79c6>&lt;&lt;</span> inner;
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>*</span>asid <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>E_NO_FREE_ENV;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=15-设置进程控制块>1.5 设置进程控制块<a hidden class=anchor aria-hidden=true href=#15-设置进程控制块>#</a></h3><p>创建进程的流程如下</p><ul><li>申请一个空闲的PCB：从<code>env_free_list</code>中索取一个空闲PCB块</li><li>手工初始化进程控制块</li><li>为新进程初始化页目录(<code>env_setup_vm</code>)</li><li>将PCB从共享页表摘除</li></ul><p>​ 首先介绍初始化新进程地址空间的函数<code>env_setup_vm</code></p><blockquote><p>Exercise 3.3 env_setup_vm</p><ul><li><p>首先为新进程分配一页物理页</p></li><li><p>将模版页表base_pgdir的内容(pages/envs数组)复制到新进程对应的地址空间</p><ul><li><p>复制到对应的地址空间memcpy，这里在虚拟地址空间中pages和envs存储位置在mmu.h中定义，如下图所示</p><p><img alt=image-20240421224528267 loading=lazy src=/img/image-20240421224528267.png></p></li><li><p>故只需要从UTOP复制到UVPT</p></li><li><p>ULIM是kseg0和kuseg的分界线，是系统给用户进程分配的最高地址，<strong>kseg0和kseg1的访问不经过TLB，这部分内存由内核管理，所有进程共享</strong>，MOS操作系统特意将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问</p></li><li><p>这里我们要暴露的是UTOP往上到UVPT之间所有进程共享的只读空间</p></li><li><p>UVPT往上到ULIM之间是进程自己的页表</p><p><img alt=image-20240421230919555 loading=lazy src=/img/image-20240421230919555.png></p></li></ul></li><li><p>将UVPT处的页表项设置为只读权限，故用户进程可以通过UVPT读自己的页表</p></li></ul></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>env_setup_vm</span>(<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>e) {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   Allocate a page for the page directory with &#39;page_alloc&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   Increase its &#39;pp_ref&#39; and assign its kernel address to &#39;e-&gt;env_pgdir&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * Hint:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   You can get the kernel address of a specified physical page using &#39;page2kva&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Page <span style=color:#ff79c6>*</span>p;
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>try</span>(<span style=color:#50fa7b>page_alloc</span>(<span style=color:#ff79c6>&amp;</span>p));
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.3: Your code here. */</span>
</span></span><span style=display:flex><span>	p<span style=color:#ff79c6>-&gt;</span>pp_ref<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_pgdir <span style=color:#ff79c6>=</span> (Pde<span style=color:#ff79c6>*</span>)<span style=color:#50fa7b>page2kva</span>(p);
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 2: Copy the template page directory &#39;base_pgdir&#39; to &#39;e-&gt;env_pgdir&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Hint:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   As a result, the address space of all envs is identical in [UTOP, UVPT).
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   See include/mmu.h for layout.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>memcpy</span>(e<span style=color:#ff79c6>-&gt;</span>env_pgdir <span style=color:#ff79c6>+</span> <span style=color:#50fa7b>PDX</span>(UTOP), base_pgdir <span style=color:#ff79c6>+</span> <span style=color:#50fa7b>PDX</span>(UTOP),
</span></span><span style=display:flex><span>	       <span style=color:#ff79c6>sizeof</span>(Pde) <span style=color:#ff79c6>*</span> (<span style=color:#50fa7b>PDX</span>(UVPT) <span style=color:#ff79c6>-</span> <span style=color:#50fa7b>PDX</span>(UTOP)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 3: Map its own page table at &#39;UVPT&#39; with readonly permission.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * As a result, user programs can read its page table through &#39;UVPT&#39; */</span>
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_pgdir[<span style=color:#50fa7b>PDX</span>(UVPT)] <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>PADDR</span>(e<span style=color:#ff79c6>-&gt;</span>env_pgdir) <span style=color:#ff79c6>|</span> PTE_V;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Exercise 3.4 env_alloc</p><ul><li>拿到一个空闲的进程控制块PCB</li><li>为新进程初始化地址空间</li><li>初始化env_id/parent_id/分配env_asid</li><li>初始化env_tp中的栈指针寄存器sp(通用寄存器第29个)和cp0_status寄存器，对于cp0寄存器中的设置后续说明</li><li>从空闲链表中移除PCB</li></ul></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>env_alloc</span>(<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>**</span>new, u_int parent_id) {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> r;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>e;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1: Get a free Env from &#39;env_free_list&#39; */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.4: Your code here. (1/4) */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (<span style=color:#50fa7b>LIST_EMPTY</span>(<span style=color:#ff79c6>&amp;</span>env_free_list)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>E_NO_FREE_ENV;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	e <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>LIST_FIRST</span>(<span style=color:#ff79c6>&amp;</span>env_free_list);
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 2: Call a &#39;env_setup_vm&#39; to initialize the user address space for this new Env. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.4: Your code here. (2/4) */</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>try</span>(<span style=color:#50fa7b>env_setup_vm</span>(e));
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 3: Initialize these fields for the new Env with appropriate values:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   &#39;env_user_tlb_mod_entry&#39; (lab4), &#39;env_runs&#39; (lab6), &#39;env_id&#39; (lab3), &#39;env_asid&#39; (lab3),
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   &#39;env_parent_id&#39; (lab3)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * Hint:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   Use &#39;asid_alloc&#39; to allocate a free asid.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   Use &#39;mkenvid&#39; to allocate a free envid.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_user_tlb_mod_entry <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; <span style=color:#6272a4>// for lab4
</span></span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_runs <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;	       <span style=color:#6272a4>// for lab6
</span></span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.4: Your code here. (3/4) */</span>
</span></span><span style=display:flex><span>	r <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>asid_alloc</span>(<span style=color:#ff79c6>&amp;</span>(e<span style=color:#ff79c6>-&gt;</span>env_asid));
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (r <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> r;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_id <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>mkenvid</span>(e);
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_parent_id <span style=color:#ff79c6>=</span> parent_id;
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 4: Initialize the sp and &#39;cp0_status&#39; in &#39;e-&gt;env_tf&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   Set the EXL bit to ensure that the processor remains in kernel mode during context
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * recovery. Additionally, set UM to 1 so that when ERET unsets EXL, the processor
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * transitions to user mode.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_tf.cp0_status <span style=color:#ff79c6>=</span> STATUS_IM7 <span style=color:#ff79c6>|</span> STATUS_IE <span style=color:#ff79c6>|</span> STATUS_EXL <span style=color:#ff79c6>|</span> STATUS_UM;
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Reserve space for &#39;argc&#39; and &#39;argv&#39;.
</span></span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_tf.regs[<span style=color:#bd93f9>29</span>] <span style=color:#ff79c6>=</span> USTACKTOP <span style=color:#ff79c6>-</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>int</span>) <span style=color:#ff79c6>-</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>char</span> <span style=color:#ff79c6>**</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 5: Remove the new Env from env_free_list. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.4: Your code here. (4/4) */</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>LIST_REMOVE</span>(e,env_link);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>*</span>new <span style=color:#ff79c6>=</span> e;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>​ 关于寄存器的设置：</p><ul><li><p>cp0_status：</p><p><img alt=image-20240421235817681 loading=lazy src=/img/image-20240421235817681.png></p><ul><li><p>IE位表示中断是否开启</p></li><li><p>IM7位表示是否响应时钟中断</p></li><li><p>EXL以及UM位表示处理器当前的运行状态(<code>当且仅当EXL=0且UM=1是为用户模式，其余均为内核模式</code>)，每当异常发生，EXL被置1，执行eret时EXL被置0。我们知道，每个进程在每一次被调度时，都会执行</p><pre tabindex=0><code>RESTORE_ALL(registers)
eret
</code></pre><p>首先要恢复env_tf中保存的所有寄存器的值，如果不设置EXL位，那么恢复完status寄存器的值后(此时EXL=0,UM=1)即进入用户模式，此时再访问内核地址段（例如恢复其他寄存器的值），执行特权指令，处理器就会立刻陷入异常。如果我们设置了EXL=1，则恢复完status寄存器的值后(EXL=1,UM=1)仍然处于内核态，不会发生错误。而在运行进程前，运行到eret时，就会将EXL设置为0，此时UM=IE=1表示在用户模式下且开启中断，之后进程成功以用户模式运行且操作系统正常响应中断。（<strong>实际上设置EXL位的目的就是避免在没有恢复完进程现场前就进入用户模式发生错误，控制住在eret时再回到用户模式</strong>）</p></li></ul></li><li><p>sp：设置栈指针，对应第29个通用寄存器，为argc和argv分配空间</p></li></ul><h3 id=16-加载二进制镜像>1.6 加载二进制镜像<a hidden class=anchor aria-hidden=true href=#16-加载二进制镜像>#</a></h3><p>​ ELF文件的类型有三种，可重定位文件、可执行文件和可被共享的对象文件。本节中需要将程序(可执行文件)加载到新进程的地址空间中。</p><p>​ 要想正确加载一个ELF文件到内存，只需将ELF文件中所有需要加载的程序段加载到对应的虚拟地址上。</p><blockquote><p>lab3中还没实现文件系统，无法直接操作磁盘中的ELF文件，这里将ELF文件内容转化为C数组形式，通过编译到内核中完成加载</p></blockquote><ul><li><code>load_icode</code>函数负责加载可执行文件binary到进程e的内存中</li><li><code>elf_from</code>函数完成了解析ELF文件头的部分</li><li><code>elf_load_seg</code>函数负责将ELF文件的一个segment加载到内存，它的最后两个参数用于接受一个自定义的回调函数<code>map_page</code>以及以及需要转递给回调函数的额外参数<code>data</code>，并由回调函数(这里为<code>load_icode_mapper</code>)完成单个页面的加载过程。</li></ul><p>​ <code>load_icode</code>函数会从ELF文件中解析出每个segment的段头ph，以及其在内存中的起始位置bin，再由elf_load_seg函数将参数指定的程序段加载到进程的地址空间中。</p><blockquote><p>Exercise 3.5 load_icode_mapper 回调函数将一页加载到用户内存空间中</p><ul><li>分配一个物理页面p</li><li>如果src非空，加载len字节到分配的物理页面p偏移量offset位置</li><li>将物理页面p插入到页表中</li></ul></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>load_icode_mapper</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>data, u_long va, <span style=color:#8be9fd>size_t</span> offset, u_int perm, <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>src,
</span></span><span style=display:flex><span>			     <span style=color:#8be9fd>size_t</span> len) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>env <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>)data;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Page <span style=color:#ff79c6>*</span>p;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> r;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1: Allocate a page with &#39;page_alloc&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.5: Your code here. (1/2) */</span>
</span></span><span style=display:flex><span>	r <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>page_alloc</span>(<span style=color:#ff79c6>&amp;</span>p);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (r <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> r;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 2: If &#39;src&#39; is not NULL, copy the &#39;len&#39; bytes started at &#39;src&#39; into &#39;offset&#39; at this
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * page. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Hint: You may want to use &#39;memcpy&#39;.
</span></span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (src <span style=color:#ff79c6>!=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>/* Exercise 3.5: Your code here. (2/2) */</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>memcpy</span>(<span style=color:#50fa7b>page2kva</span>(p) <span style=color:#ff79c6>+</span> offset,src,len);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 3: Insert &#39;p&#39; into &#39;env-&gt;env_pgdir&#39; at &#39;va&#39; with &#39;perm&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>page_insert</span>(env<span style=color:#ff79c6>-&gt;</span>env_pgdir, env<span style=color:#ff79c6>-&gt;</span>env_asid, p, va, perm);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Exercise 3.6 load_icode 加载ELF到进程</p><ul><li>首先使用elf_form将binary转换为ELF头的形式用于解析</li><li>将ELF中的每一段(loadable)加载到内存中，调用elf_load_seg</li><li>env_tf.cp0_epc字段指示了进程恢复运行时PC应当恢复到的位置，程序入口为e_entry</li></ul></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>load_icode</span>(<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>e, <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>binary, <span style=color:#8be9fd>size_t</span> size) {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1: Use &#39;elf_from&#39; to parse an ELF header from &#39;binary&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>const</span> Elf32_Ehdr <span style=color:#ff79c6>*</span>ehdr <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>elf_from</span>(binary, size);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>ehdr) {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>panic</span>(<span style=color:#f1fa8c>&#34;bad elf at %x&#34;</span>, binary);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 2: Load the segments using &#39;ELF_FOREACH_PHDR_OFF&#39; and &#39;elf_load_seg&#39;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * As a loader, we just care about loadable segments, so parse only program headers here.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>size_t</span> ph_off;
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>ELF_FOREACH_PHDR_OFF</span> (ph_off, ehdr) {
</span></span><span style=display:flex><span>		Elf32_Phdr <span style=color:#ff79c6>*</span>ph <span style=color:#ff79c6>=</span> (Elf32_Phdr <span style=color:#ff79c6>*</span>)(binary <span style=color:#ff79c6>+</span> ph_off);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> (ph<span style=color:#ff79c6>-&gt;</span>p_type <span style=color:#ff79c6>==</span> PT_LOAD) {
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// &#39;elf_load_seg&#39; is defined in lib/elfloader.c
</span></span></span><span style=display:flex><span>			<span style=color:#6272a4>// &#39;load_icode_mapper&#39; defines the way in which a page in this segment
</span></span></span><span style=display:flex><span>			<span style=color:#6272a4>// should be mapped.
</span></span></span><span style=display:flex><span>			<span style=color:#50fa7b>panic_on</span>(<span style=color:#50fa7b>elf_load_seg</span>(ph, binary <span style=color:#ff79c6>+</span> ph<span style=color:#ff79c6>-&gt;</span>p_offset, load_icode_mapper, e));
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 3: Set &#39;e-&gt;env_tf.cp0_epc&#39; to &#39;ehdr-&gt;e_entry&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.6: Your code here. */</span>
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_tf.cp0_epc <span style=color:#ff79c6>=</span> ehdr<span style=color:#ff79c6>-&gt;</span>e_entry;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=17-创建进程>1.7 创建进程<a hidden class=anchor aria-hidden=true href=#17-创建进程>#</a></h3><blockquote><p>这里的创建进程指在操作系统内核初始化时直接创建进程，例如在init.c中</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#6272a4>// lab3:
</span></span></span><span style=display:flex><span>	<span style=color:#50fa7b>ENV_CREATE_PRIORITY</span>(user_bare_loop, <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>ENV_CREATE_PRIORITY</span>(user_bare_loop, <span style=color:#bd93f9>2</span>);
</span></span></code></pre></td></tr></table></div></div></blockquote><p>​ 创建新进程由env_create完成</p><blockquote><p>Exercise 3.7 env_create</p><ul><li>分配一个新的Env结构体</li><li>设置进程控制块</li><li>并将程序载入到该进程的地址空间</li></ul></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span><span style=color:#50fa7b>env_create</span>(<span style=color:#ff79c6>const</span> <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>binary, <span style=color:#8be9fd>size_t</span> size, <span style=color:#8be9fd>int</span> priority) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>e;
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1: Use &#39;env_alloc&#39; to alloc a new env, with 0 as &#39;parent_id&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.7: Your code here. (1/3) */</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>env_alloc</span>(<span style=color:#ff79c6>&amp;</span>e,<span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 2: Assign the &#39;priority&#39; to &#39;e&#39; and mark its &#39;env_status&#39; as runnable. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.7: Your code here. (2/3) */</span>
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_pri <span style=color:#ff79c6>=</span> priority;
</span></span><span style=display:flex><span>	e<span style=color:#ff79c6>-&gt;</span>env_status <span style=color:#ff79c6>=</span> ENV_RUNNABLE;
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 3: Use &#39;load_icode&#39; to load the image from &#39;binary&#39;, and insert &#39;e&#39; into
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * &#39;env_sched_list&#39; using &#39;TAILQ_INSERT_HEAD&#39;. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.7: Your code here. (3/3) */</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>load_icode</span>(e,binary,size);
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>TAILQ_INSERT_HEAD</span>(<span style=color:#ff79c6>&amp;</span>env_sched_list,e,env_sched_link);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> e;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=18-进程运行与切换>1.8 进程运行与切换<a hidden class=anchor aria-hidden=true href=#18-进程运行与切换>#</a></h3><p>​ <code>env_run</code>是进程运行使用的基本函数，它包括两个功能</p><ul><li>保存当前进程上下文（<strong>若当前没有运行进程则跳过</strong>）</li><li>恢复要启动的进程的上下文，然后运行该进程</li><li><strong>这里的上下文指寄存器</strong></li></ul><p>​ 我们要运行一个新进程往往意味着<strong>进程切换</strong>，进程切换需要对上下文（各种寄存器）进行保存，本实验中寄存器状态保存的地方是KSTACKTOP以下的一个sizeof(TrapFrame)的小的区域中</p><blockquote><p>Exercise 3.8 env_run</p><ul><li>保存当前进程的上下文信息</li><li>切换curenv为即将运行的进程</li><li>设置全局变量cur_pgdir为当前进程页目录地址</li><li>调用env_pop)tf ：恢复现场，异常返回</li></ul></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>env_run</span>(<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>e) {
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>assert</span>(e<span style=color:#ff79c6>-&gt;</span>env_status <span style=color:#ff79c6>==</span> ENV_RUNNABLE);
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// WARNING BEGIN: DO NOT MODIFY FOLLOWING LINES!
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef MOS_PRE_ENV_RUN
</span></span></span><span style=display:flex><span>	MOS_PRE_ENV_RUN_STMT
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span>	<span style=color:#6272a4>// WARNING END
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 1:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   If &#39;curenv&#39; is NULL, this is the first time through.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   If not, we may be switching from a previous env, so save its context into
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   &#39;curenv-&gt;env_tf&#39; first.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (curenv) {
</span></span><span style=display:flex><span>		curenv<span style=color:#ff79c6>-&gt;</span>env_tf <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>((<span style=color:#ff79c6>struct</span> Trapframe <span style=color:#ff79c6>*</span>)KSTACKTOP <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 2: Change &#39;curenv&#39; to &#39;e&#39;. */</span>
</span></span><span style=display:flex><span>	curenv <span style=color:#ff79c6>=</span> e;
</span></span><span style=display:flex><span>	curenv<span style=color:#ff79c6>-&gt;</span>env_runs<span style=color:#ff79c6>++</span>; <span style=color:#6272a4>// lab6
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 3: Change &#39;cur_pgdir&#39; to &#39;curenv-&gt;env_pgdir&#39;, switching to its address space. */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.8: Your code here. (1/2) */</span>
</span></span><span style=display:flex><span>	cur_pgdir <span style=color:#ff79c6>=</span> curenv<span style=color:#ff79c6>-&gt;</span>env_pgdir;
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Step 4: Use &#39;env_pop_tf&#39; to restore the curenv&#39;s saved context (registers) and return/go
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * to user mode.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * Hint:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *  - You should use &#39;curenv-&gt;env_asid&#39; here.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *  - &#39;env_pop_tf&#39; is a &#39;noreturn&#39; function: it restores PC from &#39;cp0_epc&#39; thus not
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *    returning to the kernel caller, making &#39;env_run&#39; a &#39;noreturn&#39; function as well.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.8: Your code here. (2/2) */</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>env_pop_tf</span>(<span style=color:#ff79c6>&amp;</span>(curenv<span style=color:#ff79c6>-&gt;</span>env_tf),curenv<span style=color:#ff79c6>-&gt;</span>env_asid);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h2 id=2中断与异常>2.中断与异常<a hidden class=anchor aria-hidden=true href=#2中断与异常>#</a></h2><blockquote><p>回想上学期计组P7内容</p></blockquote><p><img alt=image-20240422111134009 loading=lazy src=/img/image-20240422111134009.png></p><h3 id=21-异常的分发>2.1 异常的分发<a hidden class=anchor aria-hidden=true href=#21-异常的分发>#</a></h3><p>​ 当发生异常时，处理器会进入一个用于分发异常的程序，这个程序的作用是检测发生了哪种异常并调用相应的异常处理程序。</p><blockquote><p>Exercise 3.9 补全异常分发代码 entry.S</p><p>异常分发的步骤如下：</p><ul><li>使用SAVE_ALL将上下文保存到内核的异常栈中</li><li>消除Status寄存器中的UM,EXL,IE位，保持内核态，关闭中断，允许嵌套异常（读、改、存）</li><li>取得Cause寄存器中2-6位，即对应的异常码部分，用来区别不同的异常</li><li><strong>用取得的异常码作为索引在exception_handlers数组中找到对应的中断处理函数，跳转到对应的中断处理函数，这就是分发！</strong></li></ul></blockquote><pre tabindex=0><code class=language-assembly data-lang=assembly>.section .text.exc_gen_entry
exc_gen_entry:
	SAVE_ALL
	/*
	* Note: When EXL is set or UM is unset, the processor is in kernel mode.
	* When EXL is set, the value of EPC is not updated when a new exception occurs.
	* To keep the processor in kernel mode and enable exception reentrancy,
	* we unset UM and EXL, and unset IE to globally disable interrupts.
	*/
	mfc0    t0, CP0_STATUS
	and     t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE)
	mtc0    t0, CP0_STATUS
/* Exercise 3.9: Your code here. */
	mfc0	t0, CP0_CAUSE
	andi	t0, 0x7c /*2-6位异常码*/
	lw		t0, exception_handlers(t0)
	jr		t0
</code></pre><p>​ SAVE_ALL是用于将当前CPU上下文保存到内核的异常栈的宏，简单分析一下（和他相似定义的还有RESTORE_ALL，都定义在stackframe.h中）</p><pre tabindex=0><code class=language-assembly data-lang=assembly>.macro SAVE_ALL
.set noat
.set noreorder
	mfc0    k0, CP0_STATUS
	andi    k0, STATUS_UM
	beqz    k0, 1f
	move    k0, sp
	/*
	* If STATUS_UM is not set, the exception was triggered in kernel mode.
	* $sp is already a kernel stack pointer, we don&#39;t need to set it again.
	*/
	li      sp, KSTACKTOP
1:
	subu    sp, sp, TF_SIZE
	sw      k0, TF_REG29(sp)
	mfc0    k0, CP0_STATUS
	sw      k0, TF_STATUS(sp)
	mfc0    k0, CP0_CAUSE
	sw      k0, TF_CAUSE(sp)
	mfc0    k0, CP0_EPC
	sw      k0, TF_EPC(sp)
	mfc0    k0, CP0_BADVADDR
	sw      k0, TF_BADVADDR(sp)
	mfhi    k0
	sw      k0, TF_HI(sp)
	mflo    k0
	sw      k0, TF_LO(sp)
	sw      $0, TF_REG0(sp)
	sw      $1, TF_REG1(sp)
	sw      $2, TF_REG2(sp)
	sw      $3, TF_REG3(sp)
	sw      $4, TF_REG4(sp)
	sw      $5, TF_REG5(sp)
	sw      $6, TF_REG6(sp)
	sw      $7, TF_REG7(sp)
	sw      $8, TF_REG8(sp)
	sw      $9, TF_REG9(sp)
	sw      $10, TF_REG10(sp)
	sw      $11, TF_REG11(sp)
	sw      $12, TF_REG12(sp)
	sw      $13, TF_REG13(sp)
	sw      $14, TF_REG14(sp)
	sw      $15, TF_REG15(sp)
	sw      $16, TF_REG16(sp)
	sw      $17, TF_REG17(sp)
	sw      $18, TF_REG18(sp)
	sw      $19, TF_REG19(sp)
	sw      $20, TF_REG20(sp)
	sw      $21, TF_REG21(sp)
	sw      $22, TF_REG22(sp)
	sw      $23, TF_REG23(sp)
	sw      $24, TF_REG24(sp)
	sw      $25, TF_REG25(sp)
	sw      $26, TF_REG26(sp)
	sw      $27, TF_REG27(sp)
	sw      $28, TF_REG28(sp)
	sw      $30, TF_REG30(sp)
	sw      $31, TF_REG31(sp)
.set at
.set reorder
.endm
</code></pre><ul><li><p>首先检查我们需要处理的异常是否是在内核态被触发的（或者说是否是<strong>异常重入</strong>，异常重入正如它的字面意思：是不是在处理异常过程中(内核态)又发生了异常需要处理）</p></li><li><p>我们通过检查Status寄存器的UM位实现检查是不是异常重入</p><ul><li>如果为0，说明该异常是在<strong>内核态</strong>被触发的，是<strong>异常重入</strong></li><li>如果为1，说明该异常是在<strong>用户态</strong>被触发的，不是异常重入</li></ul></li><li><p>如果是<strong>异常重入</strong>，则栈指针sp已经指向内核异常栈</p></li><li><p>如果不是异常重入，则需要先将sp指向内核异常栈(借助MIPS中的延迟槽保存原来的sp值)</p><pre tabindex=0><code class=language-assembly data-lang=assembly>	beqz    k0, 1f
	move    k0, sp /*保存原来的sp*/
	li      sp, KSTACKTOP /*指向异常处理栈*/
</code></pre></li></ul><p>​ 在我们的系统中，<strong>CPU发生异常后就会自动跳转到地址0x80000180处，发生用户态地址的TLB Miss异常时，会自动跳转到地址0x80000000</strong>，故我们需要将处理异常的代码<code>.text.exc_gen_entry</code>放到0x80000180处，将<code>.text.tlb_miss_entry</code>放到0x80000000处。<strong>这可以通过链接器实现，在kernel.lds中指定两个代码段的加载位置</strong></p><blockquote><p>Exercise 3.10 kernel.lds 指定两个异常处理代码的存放位置，用于CPU处理异常时跳转到对应位置，这里就相当于完成了包含两种异常的异常分发</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.10: Your code here. */</span>
</span></span><span style=display:flex><span>	. <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0x80000000</span>;
</span></span><span style=display:flex><span>	.<span style=color:#8be9fd;font-style:italic>tlb_miss_entry</span> : {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>*</span>(.text.tlb_miss_entry)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	. <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0x80000180</span>;
</span></span><span style=display:flex><span>	.<span style=color:#8be9fd;font-style:italic>exc_gen_entry</span> : {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>*</span>(.text.exc_gen_entry)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></td></tr></table></div></div><h3 id=22-异常向量组>2.2 异常向量组<a hidden class=anchor aria-hidden=true href=#22-异常向量组>#</a></h3><p>​ 异常分发程序通过<code>exception_handlers</code>数组定位中断处理程序(Cause)，而<code>exception_handlers</code>就称作异常向量组。</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>extern</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>handle_int</span>(<span style=color:#8be9fd>void</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>extern</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>handle_tlb</span>(<span style=color:#8be9fd>void</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>extern</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>handle_sys</span>(<span style=color:#8be9fd>void</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>extern</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>handle_mod</span>(<span style=color:#8be9fd>void</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>extern</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>handle_reserved</span>(<span style=color:#8be9fd>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> (<span style=color:#ff79c6>*</span>exception_handlers[<span style=color:#bd93f9>32</span>])(<span style=color:#8be9fd>void</span>) <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>0</span> ... <span style=color:#bd93f9>31</span>] <span style=color:#ff79c6>=</span> handle_reserved,
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>=</span> handle_int,
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>2</span> ... <span style=color:#bd93f9>3</span>] <span style=color:#ff79c6>=</span> handle_tlb,
</span></span><span style=display:flex><span><span style=color:#ff79c6>#if !defined(LAB) || LAB &gt;= 4
</span></span></span><span style=display:flex><span>    [<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> handle_mod,
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>8</span>] <span style=color:#ff79c6>=</span> handle_sys,
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><ul><li>GNU扩展语法：<code>[first...last] = value</code>对数组某个区间上的元素赋成同一个值</li><li><strong>0号异常</strong>处理函数为<code>handle_int</code>：表示中断，由时钟中断、控制台中断等中断造成</li><li><strong>1号异常</strong>处理函数为<code>handle_mod</code>：表示存储异常，进行存储操作时该页被标记为已读</li><li><strong>2号异常</strong>处理函数为<code>handle_tlb</code>：表示TLB load异常</li><li><strong>3号异常</strong>处理函数为<code>handle_tlb</code>：表示TLB store异常</li><li><strong>8号异常</strong>处理函数为<code>handle_sys</code>：表示系统调用，syscall指令陷入内核</li></ul><p>​ 有异常产生，则其对应的处理函数就会执行，在lab3中<strong>主要使用0号对应的时钟异常</strong>，我们需要产生并处理时钟中断，并利用时钟中断<strong>进行抢占式进程调度</strong>（解析见实验报告）</p><h3 id=23-时钟中断>2.3 时钟中断<a hidden class=anchor aria-hidden=true href=#23-时钟中断>#</a></h3><p>​ MOS系统中使用时间片轮转调度算法进行进程调度，每个进程运行一个时间片。<strong>MOS通过硬件计时器产生的时钟中断知晓一个进程的时间片结束，比如设定某个进程的时间片长度为200倍的时钟中断间隔(TIMER_INTERVAL)，那么当MOS记录发生了200次时钟中断后就知道该进程的时间片结束了</strong>，当前运行的进程被挂起(如果还没结束)，在调度队列中选取一个合适的进程运行。</p><p>​ MIPS-4Kc中的CP0内置了可产生中断的Timer，利用Timer产生时钟中断。CP0中存在两个用于控制Timer的寄存器，Count寄存器和Compare寄存器，<strong>Count寄存器按照与处理器频率相关的频率不断自增，Compare寄存器维持不变</strong>。<strong>当Count寄存器的值与Compare寄存器的值相等且非0时，时钟中断会被立即触发。</strong></p><p>​ 在<code>include/kclock.h</code>中实现了对Timer的初始化：</p><ul><li>Count寄存器清0</li><li>Compare寄存器配置为我们所期望的寄存器周期数</li></ul><p>​ 时钟中断的处理流程：</p><ul><li>系统将PC指向0x8000_0180，跳转到.text.exc_gen_entry代码段执行</li><li>通过.text_gen_entry对异常进行分发(<strong>我们实现的中断为异步异常</strong>)，最终调用中断处理handle_int函数进行中断处理</li><li>handle_int函数根据CAUSE寄存器的值判断是否为Timer对应的7号中断位引发的时钟中断，如果是，跳转到中断服务函数timer_irq，跳转到sechdule中执行</li></ul><blockquote><p>Exercise 3.11 RESET_KCLOCK宏</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>.macro RESET_KCLOCK
</span></span><span style=display:flex><span>	li 	t0, TIMER_INTERVAL
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/*
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * Hint:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   Use &#39;mtc0&#39; to write an appropriate value into the CP0_COUNT and CP0_COMPARE registers.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   Writing to the CP0_COMPARE register will clear the timer interrupt.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   The CP0_COUNT register increments at a fixed frequency. When the values of CP0_COUNT and
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   CP0_COMPARE registers are equal, the timer interrupt will be triggered.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.11: Your code here. */</span>
</span></span><span style=display:flex><span>	mtc0	zero, CP0_COUNT
</span></span><span style=display:flex><span>	mtc0	t0, CP0_COMPARE
</span></span><span style=display:flex><span>.endm
</span></span></code></pre></td></tr></table></div></div><h3 id=24-进程调度>2.4 进程调度<a hidden class=anchor aria-hidden=true href=#24-进程调度>#</a></h3><p>​ 我们使用的进程调度算法即为时间片轮转算法。时间片轮转算法中，时间片长度被量化为$time = N*TimerInterval$，<strong>这里的N为进程的优先级</strong>。</p><p>​ 使用<strong>调度链表</strong>存储所有就绪的进程，即一个进程在调度链表中当且仅当它的状态为RUNNABLE。内核创建新进程时，将其插入调度链表的头部，当期阻塞或退出时，从调度链表中移除。</p><p>​ 调度函数schedule被调用时，<strong>当前运行的进程被存储在全局变量curenv中，其剩余的时间片长度被存储在静态变量count中</strong>，需要进行进程切换的情况包括</p><ul><li>尚未调度过任何进程(<code>curenv==NULL</code>)</li><li>当前进程用完了时间片(<code>count==0</code>)</li><li>当前进程不再就绪(<code>status!=RUNNABLE</code>)</li><li>yield参数指定必须发生切换</li></ul><p>​ 当无需进行切换时，我们只需要将剩余时间片count-1，然后调用env_run函数继续运行当前进程curenv。</p><p>​ 在发生进程切换时，还需要判断当前进程是否仍然就绪(RUNNABLE)，如果是则将其移动到调度链表的尾部。之后我们选择调度链表首部的进程来调度运行，<strong>将剩余时间片长度设置为它的优先级</strong>。</p><blockquote><p>Exercise 3.12 schedule 切换进程</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>schedule</span>(<span style=color:#8be9fd>int</span> yield) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> count <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; <span style=color:#6272a4>// remaining time slices of current env
</span></span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Env <span style=color:#ff79c6>*</span>e <span style=color:#ff79c6>=</span> curenv;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* We always decrease the &#39;count&#39; by 1.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * If &#39;yield&#39; is set, or &#39;count&#39; has been decreased to 0, or &#39;e&#39; (previous &#39;curenv&#39;) is
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * &#39;NULL&#39;, or &#39;e&#39; is not runnable, then we pick up a new env from &#39;env_sched_list&#39; (list of
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * all runnable envs), set &#39;count&#39; to its priority, and schedule it with &#39;env_run&#39;. **Panic
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * if that list is empty**.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * (Note that if &#39;e&#39; is still a runnable env, we should move it to the tail of
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * &#39;env_sched_list&#39; before picking up another env from its head, or we will schedule the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * head env repeatedly.)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * Otherwise, we simply schedule &#39;e&#39; again.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * You may want to use macros below:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 *   &#39;TAILQ_FIRST&#39;, &#39;TAILQ_REMOVE&#39;, &#39;TAILQ_INSERT_TAIL&#39;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Exercise 3.12: Your code here. */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (yield<span style=color:#ff79c6>||</span> count <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>||</span> e <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#ff79c6>||</span> e<span style=color:#ff79c6>-&gt;</span>env_status <span style=color:#ff79c6>!=</span> ENV_RUNNABLE) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> (e <span style=color:#ff79c6>&amp;&amp;</span> e<span style=color:#ff79c6>-&gt;</span>env_status <span style=color:#ff79c6>==</span> ENV_RUNNABLE) {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>TAILQ_REMOVE</span>(<span style=color:#ff79c6>&amp;</span>env_sched_list,e,env_sched_link);
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>TAILQ_INSERT_TAIL</span>(<span style=color:#ff79c6>&amp;</span>env_sched_list,e,env_sched_link);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> (<span style=color:#50fa7b>TAILQ_EMPTY</span>(<span style=color:#ff79c6>&amp;</span>env_sched_list)) {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>panic</span>(<span style=color:#f1fa8c>&#34;no runnable envs&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		e <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>TAILQ_FIRST</span>(<span style=color:#ff79c6>&amp;</span>env_sched_list);
</span></span><span style=display:flex><span>		count <span style=color:#ff79c6>=</span> e<span style=color:#ff79c6>-&gt;</span>env_pri;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	count<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>env_run</span>(e);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h2 id=3-总结>3. 总结<a hidden class=anchor aria-hidden=true href=#3-总结>#</a></h2><p>​ 我们在lab3中学习了进程管理的相关内容，本实验中完成的功能可以由下图概括</p><p><img alt=image-20240422193008075 loading=lazy src=/img/image-20240422193008075.png></p><ul><li><p><code>exception_handlers</code>数组为<strong>异常向量组</strong>，负责分发异常。我们主要涉及到的是0号异常处理函数(中断处理函数)<code>handle_int</code>，1号异常处理函数<code>handle_mod</code>，2号/3号处理函数<code>handle_tlb</code>。初始化结束后，若有异常产生，则其对应的异常处理函数执行</p></li><li><p><code>env_create</code></p><ul><li><p>分配进程控制块</p><p>env_alloc从空闲链表中分配一个空闲控制块，并进行相应的初始化工作，初始化过程中调用env_setup_vm函数对虚拟地址空间进行初始化，这里包括<strong>复制模版页表base_pgdir</strong>。模版页表中包含了虚拟地址空间到物理地址空间pages/envs数组的映射，复制到新页表使得用户进程的地址空间中可以访问pages/envs数组</p></li><li><p>调用load_icode函数将程序加载到新创建的地址空间中</p></li></ul></li><li><p><code>handle_int</code></p><p>根据CP0_CAUSE寄存器判断是否为时钟中断(7号中断)，并根据Status寄存器判断7号中断是否开启(全局中断使能&&时钟中断使能IM7)。如果是，则调用schedule函数，schedule函数进行进程调度，调用env_run来运行进程</p></li><li><p><code>env_run</code></p><ul><li>将正在执行的进程(curenv)的现场保存在对应的进程控制块中</li><li>选择一个可以运行的进程，恢复该进程上次被挂起时候的现场，即恢复env_tf，调用env_pop_tf完成</li></ul></li><li><p>发生TLB Miss时的异常处理</p><p>​ 硬件在取数据或取指令的时候，CPU发射虚拟地址给MMU进行地址转换。对于用户段虚拟地址的转换通过TLB完成，若TLB在转换的过程中发现TLB中还没有对应于该虚拟地址的映射(<code>key--VPN/ASID</code>)，则会产生TLB Miss异常。</p><p>​ 硬件会<strong>打断访存过程</strong>并陷入内核态跳转到对应的异常处理程序(<code>tlb_miss_entry : pc : 0x8000_0000</code>)，由操作系统查找页表进行TLB重填(<code>do_tlb_refill</code>)，<strong>之后再从异常返回，继续访存</strong>.</p><ul><li>从软硬件的角度来看<ul><li>硬件：在发生TLBMiss 异常的时候，4Kc CPU 会把引发 TLB Miss 的虚拟地址填 入到BadVAddr 寄存器中、虚页号填入到 EntryHi 寄存器的 VPN 域中，将 Cause 寄存 器中的ExcCode 域填写为 TLBL（读请求TLBMiss）或 TLBS（写请求 TLB Miss）。</li><li>软件：从BadVAddr 寄存器中获取引发 TLB Miss 的虚拟地址，接着在 cur_pgdir 中查找该虚拟地址对应的物理地址与权限位，然后将物理页面号和权限位填入到EntryLo 寄存器的PFN域和权限位中，再使用tlbwr（TLBWriteentry selected by Random）将 EntryHi 和 EntryLo 寄存器中的 VPN、PFN、ASID、权限位等随机地写入到TLB中，最 后调用ret_from_exception 从异常返回。</li></ul></li></ul><p>​</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://coder0xe.github.io/tags/apr/>Apr</a></li></ul><nav class=paginav><a class=prev href=https://coder0xe.github.io/posts/oo-unit2-hw6/><span class=title>« Prev</span><br><span>OO-Unit2-HW6</span>
</a><a class=next href=https://coder0xe.github.io/posts/os-lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/><span class=title>Next »</span><br><span>OS:lab2实验报告</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share OS:lab3课下基础 on x" href="https://x.com/intent/tweet/?text=OS%3alab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f&amp;hashtags=Apr"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS:lab3课下基础 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f&amp;title=OS%3alab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80&amp;summary=OS%3alab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80&amp;source=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS:lab3课下基础 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f&title=OS%3alab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS:lab3课下基础 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS:lab3课下基础 on whatsapp" href="https://api.whatsapp.com/send?text=OS%3alab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80%20-%20https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS:lab3课下基础 on telegram" href="https://telegram.me/share/url?text=OS%3alab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OS:lab3课下基础 on ycombinator" href="https://news.ycombinator.com/submitlink?t=OS%3alab3%e8%af%be%e4%b8%8b%e5%9f%ba%e7%a1%80&u=https%3a%2f%2fcoder0xe.github.io%2fposts%2fos-lab3%25E8%25AF%25BE%25E4%25B8%258B%25E5%259F%25BA%25E7%25A1%2580%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://coder0xe.github.io/>coder0xe's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>