<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OO-Unit1-hw1 | coder0xe's blog</title><meta name=keywords content="OO-UNIT1-HW1"><meta name=description content="OO第一单元第一次作业"><meta name=author content="sudo"><link rel=canonical href=https://coder0xe.github.io/posts/oo-unit1-hw1/><link crossorigin=anonymous href=/assets/css/stylesheet.e4a36188e2c44563c1cc5ed1a2d0b8451a4f68c685114d738b97609f82dae050.css integrity="sha256-5KNhiOLERWPBzF7RotC4RRpPaMaFEU1zi5dgn4La4FA=" rel="preload stylesheet" as=style><link rel=icon href=https://coder0xe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://coder0xe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://coder0xe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://coder0xe.github.io/apple-touch-icon.png><link rel=mask-icon href=https://coder0xe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://coder0xe.github.io/posts/oo-unit1-hw1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://coder0xe.github.io/posts/oo-unit1-hw1/"><meta property="og:site_name" content="coder0xe's blog"><meta property="og:title" content="OO-Unit1-hw1"><meta property="og:description" content="OO第一单元第一次作业"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-26T16:37:33+08:00"><meta property="article:modified_time" content="2024-02-26T16:37:33+08:00"><meta property="article:tag" content="Feb"><meta name=twitter:card content="summary"><meta name=twitter:title content="OO-Unit1-hw1"><meta name=twitter:description content="OO第一单元第一次作业"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://coder0xe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OO-Unit1-hw1","item":"https://coder0xe.github.io/posts/oo-unit1-hw1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OO-Unit1-hw1","name":"OO-Unit1-hw1","description":"OO第一单元第一次作业","keywords":["OO-UNIT1-HW1"],"articleBody":"OO第一单元第一次作业 0.training 想要通过课程组提供的training获取一点点思路QWQ 0.1 training-1 第一部分通过正则表达式的方法将一个只包含数字和“+”“*”符号的表达式转化为后缀表达式\n思路梳理（已经提供好的代码）：\nMainclass：对于该类，分析得到其处理的思路为构建出可以描述每一项的正则表达式，而后在表达式中进行匹配，再分别对获得的每一项进行后缀化(toString)，最后整体后缀化(toString)并输出\n补充正则表达式如下\nprivate static final String patternTerm = \"\\\\d+(\\\\*\\\\d+)*\"; (该表达式描述了，一项中至少有一个数字以及\u003e=0个形如*number的部分)\n上机tips：关于正则表达式，可以右键之后选择第一项进行检查\nExpr：该类的重点为实现toString方法，由后缀化的项得到后缀化的表达式\n若表达式中只有一项，则该项即为转换后的表达式\n（例如 1 * 2 * 3）\n若表达式中大于等于两项，对于前两项需要特殊处理，后面的项补充为项*的后缀化形式\nStringBuilder sb = new StringBuilder(); sb.append(terms.get(0)); sb.append(\" \"); /* TODO */ sb.append(terms.get(1)); sb.append(\" \"); sb.append(\"+\"); for (int i = 2; i \u003c terms.size(); i++) { sb.append(\" \"); sb.append(terms.get(i)); sb.append(\" \"); sb.append(\"+\"); } Term：该类的重点为实现toString方法，将项转化为后缀表达形式\n在项的构造方法中对因子factors进行了划分，由于项只可能由数字或数字的乘积构成，使用*划分即可\nString[] factorStrs = s.split(\"\\\\*\"); 同Expr中toString方法，将第0个和第1个因子特判后缀化\n0.2 training-2 第二部分通过递归下降的方法对一层括号，只包含“+”“*”运算符的表达式进行处理，输出其后缀表达式\n思路梳理\n对表达式进行层次化建模（语法树）\nExpr Term Factor number Expr（括号的来源） 分析\nExpr的抽象结构\nterm+term+term…\nterm的抽象结构\nfactor * factor * factor\nfactor\nnumber factor最底层的结构 Expr从顶层向下调用 ​\t我们做打开括号并转化为后缀表达式的行为主要通过语法分析parser，词法分析lexer相当于parser的辅助类，本质上lexer可以选择在parser中完成，但是分成两个类可以显著降低耦合度。故我们分析的视角以parser展开。\n​\tparser英文即意为语法分析，我们做语法分析的过程显然为从左到右。在这个从左到右扫描的过程中，我们的读取不是以字符为单位，而是以token为单位，即文中的最小单位。这个token就由lexer类完成获取并传递给parser，帮助其理解当前句子的结构。(图片来自公众号oolens)\n​\t这里以列表的形式呈现，实际上在代码的实现中我们的思路是，parser需要知道后面的句子结构，lexer接着向右边扫描，得到的token传递给parser用来分析。即parser相当于“奴役”着lexer。\n​\t当我们理解了parser和lexer的协作关系，就可以尝试理解整体的工作思路。去掉括号后，我们的句子成分包括数字、+、*。我们最底层的“原子”即为数字，+以及*的位置可以通过输出时构建后缀表达式。我们可以得到数据结构上的关系\nExpr掌管terms，在代码实现中使用了HashSet进行管理(个人不是很理解，更加偏向使用ArrayList，使用HashSet会导致输出无序，但结果正确)\nterms掌管factors，HashSet(这里的factors为Number，若为Expr则进行递归调用)\n对于递归调用关系可以如下图所示，这也被称为自顶向下树。\n注：实际上，若将底层因子中的Expr递归调用关系补全，得到的会是一颗更深的树\n​\t在语法解析的过程中，遵循Expr-\u003eTerm-\u003eFactor ，下面以一个具体的问题为例进行分析\n例如题目中提供的例子(1+2)*(3+4) ​\t这个例子其实是“一项”，我们要想构建起完整的表达式，应当从底到顶进行，先获取因子，再获取项，再获取表达式，故我们在主函数中调用parseExpr，parseExpr中递归调用parseTerm…\n​\t我们分析示例parseExpr代码\npublic Expr parseExpr() { Expr expr = new Expr(); //添加表达式中的第一项项，递归调用 expr.addTerm(parseTerm()); //这里需要理解的是，上一行代码在递归调用过程中，分析完成一项，此时lexer也对应移动了一项，这时看拿到的token是不是+ // 即term + term + term ... while (lexer.peek().equals(\"+\")) { lexer.next(); expr.addTerm(parseTerm()); } return expr; } ​\t在示例中，只有一项，递归分析两个表达式因子。\n​\t需要注意的是，JAVA中的输出语句System.out.println在输出类对象时，会调用对应的toString方法，故我们需要在Expr,Term,Number层构建toString方法\n​\t我们只需要对每一个层次都建立起toString方法，在每一层中建立该层的后缀表达式，同样向下递归调用即可得到输出，例如在Expr层的toString\nterm term + (term +)* //需要注意的是第一项和第二项的特殊处理 总结来说：所谓递归下降算法，其实就是递归的思想 1.题目需求分析 ​\t读入一个包含加、减、乘、乘方以及括号（括号深度至多一层）的单变量表达式，输出恒等变形展开所有括号后的表达式\n对表达式进行层次化建模：Expr-\u003eTerm-\u003eFactor\n表达式(Expr)：由加法和减法运算符连接若干项组成\n注：在第一项之前可以带一个正号或负号，表示第一项的正负\n项(Term)：由乘法运算符连接若干因子组成\n注：在第一个因子之前可以带一个正号或负号，表示第一个因子的正负\n因子(Factor)：设置为接口Interface\n变量因子（幂函数）\n一般形式：x ^ n，n为非负带符号整数**(输入已经保证该带符号整数中不会出现-**) 省略形式：当n==1时简写为x 常数因子\n支持前导0的十进制带符号整数（+可以省略）\n表达式因子\n用一对小括号包裹起来的表达式，可以有指数形式（指数为非负带符号整数）\n2.问题处理流程分析 2.1 预处理 ​\t由于生成法中可能造成的输入字符串中包含连续冗余的+-，空格，前导0等，采用建立processer类的方法对表达式进行预处理，方便后面的语义分析。考虑到后面性能要求中的长度问题，预处理阶段尽量的将字符串长度缩短是好事，我在处理时采用以下的顺序\n删除字符串中的空白字符（空格、\\t） 删除连续的+-(其实就是为这个项确定出符号，或者说统计出负号的个数) 删除不必要的前导+ 删除前导0 ​\t这样的顺序要优于2,3颠倒\n2.2 语法分析 2.2.1 Lexer ​\tLexer主要进行词法分析，他负责从字符串中读到token并传递给Parser，这里我们的token可以用一个枚举类保存。\npublic enum TokenType { NUM,X,MULTI,EXP,ADD,SUB,LP,RP,NULL } ​\t同样沿用training代码中的逻辑，可以用switch语句等保存token。\n2.2.2 Parser ​\t对于parser部分的设计同样沿用了training中的三个方法，根据当前lexer扫描到的token进行语义分析，在我的设计中参考了学长博客中的设计，为项设置出符号属性，在解析表达式时将项的符号传入。这里同样需要注意的是number^pow的形式并不符合形式化表述，我的第一版代码中对这种形式进行了解析\n​\t该类中借鉴了training中代码的三个方法进行解析\nparseExpr parseTerm parseFactor ​\tparseFactor中需要注意的是，读到(，即读到表达式或读到x即读到幂函数，还要再向后读一个看是不是^，如果是则说明该因子有指数(要为表达式设置指数属性)\npublic Expr parseExpr() { Expr expr = new Expr(); int sign = 1;//标记项的符号 if (lexer.getCurTokenType() == TokenType.SUB) { //该项是负项 } else if (lexer.getCurTokenType() == TokenType.ADD) { //该项为正项 } expr.addTerm(parseTerm(sign)); while (//有下一项) { //正负项讨论 } return expr; } // parseExpr将项的符号传入 public Term parseTerm(int sign) { //... while (//有下一个因子) { //... } return term; } public Factor parseFactor() { if (//如果是左括号，说明是表达式) { //跳过LP lexer.next(); Expr expr = parseExpr(); //跳过RP lexer.next(); if (//如果是^) { // } return expr; } else if (//如果是数字) { //... } else if (//如果是减号，说明这是个负数) { //... } else { //如果读到x //如果读到x则还需要判断他的下一个token是不是^ } } 2.3 计算输出 2.3.1计算思路 ​\t在经过语法分析之后，我们已经对表达式自顶向下建立起表达式树，而我们的输出结果，可以表示为多项式的形式 $$ Expr = \\Sigma a_i x^{n_i} $$ ​\t因此我们可以考虑在每一个语法层级都将其转化为多项式形式(构造toPoly方法)，最终递归地得到计算结果。\n​\t为了实现计算，我们定义出单项式类Unit，多项式类Poly。每个单项式以数组的形式管理各个单项式。我们先不考虑各个类中具体的方法实现，先去大体认知这个与表达式树映射架构的多项式树。\n​\t我们的思路是将每一个层级都表现为多项式形式\nnumberFactor：对于数字因子，是树中的叶节点，我们可以简单的表示为只有一项的多项式： $$ numberfactor = numberfactor*x^{0} $$ 这一项即为一个单项式，我们的多项式类中的数组中只保管这一个单项式即可\npowFactor：对于幂函数因子，同样为树中的叶节点，我们可以简单的表示为只有一项的多项式： $$ powfactor = 1*x^{powfactor} $$ 这一项即为一个单项式，我们的多项式类中的数组中只保管这一个单项式即可\nTerm：将term类转换为多项式形式，我们知道，多项式的表达形式为factor*factor*factor，我们只需要将他的各个因子的多项式相乘即可 $$ TermPoly = \\Pi FactorPoly $$\nExpr：将expr类转换为多项式形式，表达式的形式为term + term + term （其中term中包含该项正负号），只需要将构成表达式的各个项的多项式相加即可 $$ ExprPoly = \\Sigma TermPoly $$\n​\t这样又构建起一个递归的过程，自底向上地构建起多项式树。\n​\t经过以上分析，我们知道需要新增的类有\nUnit\nPoly\n需要新增的方法有\n每一个层次的toPoly，包括Expr,Term,Factor\nPoly中的计算方法：\naddPoly multiPoly powPoly 用于最终输出的Unit类和Poly类中的toString\n2.3.2 计算方法实现思路 2.3.2.1 各层级toPoly方法的实现 首先定义出Unit单项式类，其中包含两个属性ceo（系数），pow（指数），Poly类中包含ArrayList unitlist ​\t先从比较简单的底层实现，即numberFactor和powFactor\nnumber toPoly\n$$ number*x^0 $$\n只有一项的多项式 pow toPoly\n$$ 1*x^{pow} $$\n只有一项的多项式 Term toPoly\npublic Poly toPoly() { //... for (Factor factor : factors) { //各个因子多项式相乘 } if (this.sign == -1) { //多项式中单项式变号 } return poly; } 需要注意的是，若项的符号为负号，则需要将项中的每一个单项式符号取反，在Poly类中构建方法negate()用于符号取反 Expr toPoly\npublic Poly toPoly() { //... for (Term term : terms) { //各个项多项式相加 } return poly; } 高层级调用低层级的toPoly，自底向上\n2.3.2.2 Poly中计算方法的实现 2.3.2.2.1 addPoly ​\t**计算思路：**我们对两个多项式进行加法，关键的步骤在于合并同类项，我们已知多项式中以数组的数据结构保存着，我们先将两个数组合并为一个数组，之后在一个数组中进行合并同类项。\npublic Poly addPoly(Poly another) { //将两个数组中的单项式合并到一个数组中 for(int i = 0; i \u003c units.size(); i++) { for(int j = i+1; j \u003c units.size(); j++) { //判断标准：指数相同，合并同类项 } } return new Poly(units); } ​\t在数组中进行遍历，若找到和i元素指数相同的j元素，则系数相加到i元素上，删除j元素，并将j回退一位，实际上是保证下次遍历从i+1开始。\n2.3.2.2.2 multiPoly ​\t**计算思路：**我们对两个多项式中各项相乘的结果加入新的多项式变量。这里注意：在我的实现方法中，是从底向上构建表达式，这样在相乘之前，项表达式是空的，需要进行判断，如果是空的，就返回当前因子表达式加入项表达式中，再继续与其他因子表达式相乘，当然还有另一种方法，就是在乘之前就先加进去一个因子表达式\npublic Poly multiPoly(Poly another) { //...这里需要判断是不是空 if(如果为空){ //... } else { for(Unit unit1 : this.unitlist) { for(Unit unit2 : another.unitlist) { //因子多项式相乘 } } return new Poly(units); } } 2.3.2.2.3 negate ​\t对多项式中的每一个单项式的符号进行取反，我采用两步实现，在Poly中进行Unit遍历，在Unit类中利用BigInteger的方法.negate()取反。\n2.3.3 输出思路及方法 ​\t我们在Unit类和Poly类中都要实现toString方法进行递归调用。\n2.3.3.1 unit toString ​\t将每个unit转化为 $$ coe*x^{pow} $$\n2.3.3.2 poly toString ​\t将各个项多项式连接起来，并进行优化输出，常见的优化输出有：\n系数为0：不输出\n系数为1：省略系数，x\n系数为-1：省略系数，-x\n指数为0：输出1\n指数为1：省略指数，x\n之后可以调用之前字符串预处理过程中的几个方法\n去掉连续的+-号\n若第一项为负，则从后面找一个正项放在前面，大概给出这个方法的伪代码，这个方法的思路是：先判断第一项是否为负项（第一个符号是否为负号），之后看是否能找到正项，如果能就把他俩换一下位置，字符串层级的操作要注意substring方法包含左字符不包含右字符\nif (this.input.charAt(0) == '-') { int addpos = -1; int i = 0; for (i = 0;i \u003c this.input.length();i++) { //找到+号，记录位置 } if (addpos != -1) { //如果找到了+，就找这一项后的符号，将这一项分割出来 for (i = addpos + 1;i \u003c this.input.length();i++) { //... } //处理字符串，将正项一道前面，之后会调用删除前导+的方法，使得表达式缩短一个字符，这么麻烦其实只缩短了一个字符hhhhhh } } 去掉不必要的前导+\n同时要注意如果输出长度为0，要补充输出“0”\n3.后续对于时间复杂度的优化 3.1 对于时间复杂度的分析 ​\t在第一版代码中，构建多项式过程中我们使用arraylist来存储单项式，之后在后续计算过程中的时间复杂度:\naddPoly:O(n^2) multiPoly:O(n^2) powPoly:调用multiPoly,约等于O(n^3) ​\t这样的时间复杂度在面对一些指数比较大的表达式时会出现TLE的情况，后来经过同学的提示，可以使用HashMap来存储单项式，key为指数，value为系数，这样的确可以大大简化时间复杂度，同时也可以省去一个类Unit(~~但是我没舍得删)。另外一个点：可以在每次乘法结束之后都进行一次合并同类项addPoly，这样可以更加减少时间复杂度\naddPoly:O(n) multiPoly:O(n^2) 3.2 具体方法的实现 3.2.1 addPoly public Poly addPoly(Poly another) { Iterator","wordCount":"782","inLanguage":"en","datePublished":"2024-02-26T16:37:33+08:00","dateModified":"2024-02-26T16:37:33+08:00","author":{"@type":"Person","name":"sudo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://coder0xe.github.io/posts/oo-unit1-hw1/"},"publisher":{"@type":"Organization","name":"coder0xe's blog","logo":{"@type":"ImageObject","url":"https://coder0xe.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://coder0xe.github.io/ accesskey=h title="coder0xe's blog (Alt + H)">coder0xe's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://coder0xe.github.io/ title=首页><span>首页</span></a></li><li><a href=https://coder0xe.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://coder0xe.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://coder0xe.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://coder0xe.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://coder0xe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://coder0xe.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">OO-Unit1-hw1</h1><div class=post-description>OO第一单元第一次作业</div><div class=post-meta><span title='2024-02-26 16:37:33 +0800 +0800'>February 26, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>sudo</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#oo%e7%ac%ac%e4%b8%80%e5%8d%95%e5%85%83%e7%ac%ac%e4%b8%80%e6%ac%a1%e4%bd%9c%e4%b8%9a aria-label=OO第一单元第一次作业>OO第一单元第一次作业</a><ul><li><a href=#0training aria-label=0.training>0.training</a><ul><li><a href=#01-training-1 aria-label="0.1 training-1">0.1 training-1</a></li><li><a href=#02-training-2 aria-label="0.2 training-2">0.2 training-2</a></li></ul></li><li><a href=#1%e9%a2%98%e7%9b%ae%e9%9c%80%e6%b1%82%e5%88%86%e6%9e%90 aria-label=1.题目需求分析>1.题目需求分析</a></li><li><a href=#2%e9%97%ae%e9%a2%98%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90 aria-label=2.问题处理流程分析>2.问题处理流程分析</a><ul><li><a href=#21-%e9%a2%84%e5%a4%84%e7%90%86 aria-label="2.1 预处理">2.1 预处理</a></li><li><a href=#22-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90 aria-label="2.2 语法分析">2.2 语法分析</a><ul><li><a href=#221-lexer aria-label="2.2.1 Lexer">2.2.1 Lexer</a></li><li><a href=#222-parser aria-label="2.2.2 Parser">2.2.2 Parser</a></li></ul></li><li><a href=#23-%e8%ae%a1%e7%ae%97%e8%be%93%e5%87%ba aria-label="2.3 计算输出">2.3 计算输出</a><ul><li><a href=#231%e8%ae%a1%e7%ae%97%e6%80%9d%e8%b7%af aria-label=2.3.1计算思路>2.3.1计算思路</a></li><li><a href=#232-%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af aria-label="2.3.2 计算方法实现思路">2.3.2 计算方法实现思路</a><ul><li><a href=#2321-%e5%90%84%e5%b1%82%e7%ba%a7topoly%e6%96%b9%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="2.3.2.1 各层级toPoly方法的实现">2.3.2.1 各层级toPoly方法的实现</a></li><li><a href=#2322-poly%e4%b8%ad%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="2.3.2.2 Poly中计算方法的实现">2.3.2.2 Poly中计算方法的实现</a><ul><li><a href=#23221-addpoly aria-label="2.3.2.2.1 addPoly">2.3.2.2.1 addPoly</a></li><li><a href=#23222-multipoly aria-label="2.3.2.2.2 multiPoly">2.3.2.2.2 multiPoly</a></li><li><a href=#23223-negate aria-label="2.3.2.2.3 negate">2.3.2.2.3 negate</a></li></ul></li></ul></li><li><a href=#233-%e8%be%93%e5%87%ba%e6%80%9d%e8%b7%af%e5%8f%8a%e6%96%b9%e6%b3%95 aria-label="2.3.3 输出思路及方法">2.3.3 输出思路及方法</a><ul><li><a href=#2331-unit-tostring aria-label="2.3.3.1 unit toString">2.3.3.1 unit toString</a></li><li><a href=#2332-poly-tostring aria-label="2.3.3.2 poly toString">2.3.3.2 poly toString</a></li></ul></li></ul></li></ul></li><li><a href=#3%e5%90%8e%e7%bb%ad%e5%af%b9%e4%ba%8e%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e7%9a%84%e4%bc%98%e5%8c%96 aria-label=3.后续对于时间复杂度的优化>3.后续对于时间复杂度的优化</a><ul><li><a href=#31-%e5%af%b9%e4%ba%8e%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e7%9a%84%e5%88%86%e6%9e%90 aria-label="3.1 对于时间复杂度的分析">3.1 对于时间复杂度的分析</a></li><li><a href=#32-%e5%85%b7%e4%bd%93%e6%96%b9%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="3.2 具体方法的实现">3.2 具体方法的实现</a><ul><li><a href=#321-addpoly aria-label="3.2.1 addPoly">3.2.1 addPoly</a></li><li><a href=#322-multipoly aria-label="3.2.2 multiPoly">3.2.2 multiPoly</a></li><li><a href=#323-negate aria-label="3.2.3 negate">3.2.3 negate</a></li></ul></li></ul></li><li><a href=#4-%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90 aria-label="4. 代码分析">4. 代码分析</a><ul><li><a href=#41-uml%e7%b1%bb%e5%9b%be%e5%88%86%e6%9e%90 aria-label="4.1 UML类图分析">4.1 UML类图分析</a></li><li><a href=#42-%e4%bb%a3%e7%a0%81%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90 aria-label="4.2 代码复杂度分析">4.2 代码复杂度分析</a></li></ul></li><li><a href=#5-bug%e4%bf%ae%e5%a4%8d aria-label="5. bug修复">5. bug修复</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=oo第一单元第一次作业><center>OO第一单元第一次作业</center><a hidden class=anchor aria-hidden=true href=#oo第一单元第一次作业>#</a></h1><h2 id=0training>0.training<a hidden class=anchor aria-hidden=true href=#0training>#</a></h2><ul><li>想要通过课程组提供的<code>training</code>获取一点点思路<code>QWQ</code></li></ul><h3 id=01-training-1>0.1 training-1<a hidden class=anchor aria-hidden=true href=#01-training-1>#</a></h3><ul><li><p>第一部分通过正则表达式的方法将一个只包含数字和“+”“*”符号的表达式转化为后缀表达式</p></li><li><p>思路梳理（已经提供好的代码）：</p><ul><li><p><code>Mainclass</code>：对于该类，分析得到其处理的思路为构建出可以描述每一项的正则表达式，而后在表达式中进行匹配，再分别对获得的每一项进行后缀化(<code>toString</code>)，最后整体后缀化(<code>toString</code>)并输出</p><p>补充正则表达式如下</p><pre tabindex=0><code>private static final String patternTerm = &#34;\\d+(\\*\\d+)*&#34;;
</code></pre><p>(该表达式描述了，一项中至少有一个数字以及<code>>=0</code>个形如<code>*number</code>的部分)</p><p><strong>上机tips：关于正则表达式，可以右键之后选择第一项进行检查</strong></p></li><li><p><code>Expr</code>：该类的重点为实现<code>toString</code>方法，由后缀化的项得到后缀化的表达式</p><ul><li><p>若表达式中只有一项，则该项即为转换后的表达式</p><p>（例如 1 * 2 * 3）</p></li><li><p>若表达式中大于等于两项，对于前两项需要特殊处理，后面的项补充为<code>项*</code>的后缀化形式</p><pre tabindex=0><code>StringBuilder sb = new StringBuilder();
            sb.append(terms.get(0));
            sb.append(&#34; &#34;);
            /* TODO */
            sb.append(terms.get(1));
            sb.append(&#34; &#34;);
            sb.append(&#34;+&#34;);
            for (int i = 2; i &lt; terms.size(); i++) {
                sb.append(&#34; &#34;);
                sb.append(terms.get(i));
                sb.append(&#34; &#34;);
                sb.append(&#34;+&#34;);
            }
</code></pre></li></ul></li><li><p><code>Term</code>：该类的重点为实现<code>toString</code>方法，将项转化为后缀表达形式</p><ul><li><p>在项的构造方法中对因子<code>factors</code>进行了划分，由于项只可能由数字或数字的乘积构成，使用<code>*</code>划分即可</p><pre tabindex=0><code>String[] factorStrs = s.split(&#34;\\*&#34;);
</code></pre></li><li><p>同<code>Expr</code>中<code>toString</code>方法，将第0个和第1个因子特判后缀化</p></li></ul></li></ul></li></ul><h3 id=02-training-2>0.2 training-2<a hidden class=anchor aria-hidden=true href=#02-training-2>#</a></h3><ul><li><p>第二部分通过<strong>递归下降</strong>的方法对<strong>一层括号，只包含“+”“*”运算符</strong>的表达式进行处理，输出其后缀表达式</p></li><li><p>思路梳理</p><p>对表达式进行层次化建模（语法树）</p><ul><li><code>Expr</code></li><li><code>Term</code></li><li><code>Factor</code><ul><li><code>number</code></li><li><code>Expr</code>（括号的来源）</li></ul></li></ul></li><li><p>分析</p><ul><li><p><strong>Expr</strong>的抽象结构</p><p><strong>term+term+term&mldr;</strong></p></li><li><p><strong>term</strong>的抽象结构</p><p><strong>factor * factor * factor</strong></p></li><li><p><strong>factor</strong></p><ul><li><code>number factor</code>最底层的结构</li><li><code>Expr</code>从顶层向下调用</li></ul></li></ul></li></ul><p>​ 我们做打开括号并转化为后缀表达式的行为主要通过语法分析<code>parser</code>，词法分析<code>lexer</code>相当于<code>parser</code>的辅助类，本质上<code>lexer</code>可以选择在<code>parser</code>中完成，但是分成两个类可以显著降低耦合度。故我们分析的视角以<code>parser</code>展开。</p><p>​ <code>parser</code>英文即意为语法分析，我们做语法分析的过程显然为从左到右。在这个从左到右扫描的过程中，我们的读取不是以字符为单位，而是以<code>token</code>为单位，即文中的最小单位。这个<code>token</code>就由<code>lexer</code>类完成获取并传递给<code>parser</code>，帮助其理解当前句子的结构。(<strong>图片来自公众号oolens</strong>)</p><p><img alt=640 loading=lazy src=/img/640.png></p><p>​ 这里以列表的形式呈现，实际上在代码的实现中我们的思路是，<code>parser</code>需要知道后面的句子结构，<code>lexer</code>接着向右边扫描，得到的<code>token</code>传递给<code>parser</code>用来分析。即<code>parser</code>相当于“奴役”着<code>lexer</code>。</p><p>​ 当我们理解了<code>parser</code>和<code>lexer</code>的协作关系，就可以尝试理解整体的工作思路。去掉括号后，我们的句子成分包括数字、<code>+</code>、<code>*</code>。我们最底层的“原子”即为数字，<code>+</code>以及<code>*</code>的位置可以通过输出时构建后缀表达式。我们可以得到数据结构上的关系</p><ul><li><p><code>Expr</code>掌管<code>terms</code>，在代码实现中使用了<code>HashSet</code>进行管理(个人不是很理解，更加偏向使用<code>ArrayList</code>，使用<code>HashSet</code>会导致输出无序，但结果正确)</p></li><li><p><code>terms</code>掌管<code>factors</code>，<code>HashSet</code>(这里的factors为<code>Number</code>，若为<code>Expr</code>则进行递归调用)</p><p>对于递归调用关系可以如下图所示，这也被称为<strong>自顶向下树</strong>。</p><p><img alt=image-20240227203049773 loading=lazy src=/img/image-20240227203049773.png></p></li></ul><p><strong>注：实际上，若将底层因子中的<code>Expr</code>递归调用关系补全，得到的会是一颗更深的树</strong></p><p>​ 在语法解析的过程中，遵循<code>Expr</code>-><code>Term</code>-><code>Factor</code> ，下面以一个具体的问题为例进行分析</p><ul><li>例如题目中提供的例子(1+2)*(3+4)</li></ul><p>​ 这个例子其实是“一项”，<strong>我们要想构建起完整的表达式，应当从底到顶进行，先获取因子，再获取项，再获取表达式</strong>，故我们在主函数中调用<code>parseExpr</code>，<code>parseExpr</code>中递归调用<code>parseTerm</code>&mldr;</p><p>​ 我们分析示例<code>parseExpr</code>代码</p><pre tabindex=0><code>    public Expr parseExpr() {
        Expr expr = new Expr();
        //添加表达式中的第一项项，递归调用
        expr.addTerm(parseTerm());
		//这里需要理解的是，上一行代码在递归调用过程中，分析完成一项，此时lexer也对应移动了一项，这时看拿到的token是不是+
		// 即term + term + term ...
        while (lexer.peek().equals(&#34;+&#34;)) {
            lexer.next();
            expr.addTerm(parseTerm());
        }
        return expr;
    }
</code></pre><p>​ 在示例中，只有一项，递归分析两个表达式因子。</p><p>​ <strong>需要注意的是，<code>JAVA</code>中的输出语句<code>System.out.println</code>在输出类对象时，会调用对应的<code>toString</code>方法，故我们需要在Expr,Term,Number层构建toString方法</strong></p><p>​ 我们只需要对每一个层次都建立起<code>toString</code>方法，在每一层中建立该层的后缀表达式，同样向下递归调用即可得到输出，例如在<code>Expr</code>层的<code>toString</code></p><pre tabindex=0><code>term term + (term +)* //需要注意的是第一项和第二项的特殊处理
</code></pre><ul><li><strong>总结来说：所谓递归下降算法，其实就是递归的思想</strong></li></ul><h2 id=1题目需求分析>1.题目需求分析<a hidden class=anchor aria-hidden=true href=#1题目需求分析>#</a></h2><p>​ 读入一个包含加、减、乘、乘方以及括号（<strong>括号深度至多一层</strong>）的单变量表达式，<strong>输出恒等变形展开所有括号后的表达式</strong></p><p><strong>对表达式进行层次化建模</strong>：<code>Expr->Term->Factor</code></p><ul><li><p><strong>表达式(Expr)</strong>：由<strong>加法</strong>和<strong>减法</strong>运算符连接若干<strong>项</strong>组成</p><p>注：在第一项之前可以带一个正号或负号，表示第一项的正负</p></li><li><p><strong>项(Term)</strong>：由<strong>乘法</strong>运算符连接若干因子组成</p><p>注：在第一个因子之前可以带一个正号或负号，表示第一个因子的正负</p></li><li><p><strong>因子(Factor)</strong>：<strong>设置为接口Interface</strong></p><ul><li><p><strong>变量因子（幂函数）</strong></p><ul><li>一般形式：<code>x ^ n</code>，n为非负带符号整数**(输入已经保证该带符号整数中不会出现<code>-</code>**)</li><li>省略形式：当<code>n==1</code>时简写为<code>x</code></li></ul></li><li><p><strong>常数因子</strong></p><p>支持前导0的十进制带符号整数（+可以省略）</p></li><li><p><strong>表达式因子</strong></p><p>用一对小括号包裹起来的表达式，可以有指数形式（指数为非负带符号整数）</p></li></ul></li></ul><p><img loading=lazy src=/img/image-20240227205055419.png></p><h2 id=2问题处理流程分析>2.问题处理流程分析<a hidden class=anchor aria-hidden=true href=#2问题处理流程分析>#</a></h2><h3 id=21-预处理>2.1 预处理<a hidden class=anchor aria-hidden=true href=#21-预处理>#</a></h3><p>​ 由于生成法中可能造成的输入字符串中包含连续冗余的<code>+-</code>，空格，前导0等，采用建立<code>processer</code>类的方法对表达式进行预处理，方便后面的语义分析。考虑到后面性能要求中的长度问题，预处理阶段尽量的将字符串长度缩短是好事，我在处理时采用以下的顺序</p><ul><li>删除字符串中的空白字符（空格、<code>\t</code>）</li><li>删除连续的<code>+-</code>(其实就是为这个项确定出符号，或者说统计出负号的个数)</li><li>删除不必要的前导<code>+</code></li><li>删除前导0</li></ul><p>​ 这样的顺序要优于2,3颠倒</p><h3 id=22-语法分析>2.2 语法分析<a hidden class=anchor aria-hidden=true href=#22-语法分析>#</a></h3><h4 id=221-lexer>2.2.1 Lexer<a hidden class=anchor aria-hidden=true href=#221-lexer>#</a></h4><p>​ <code>Lexer</code>主要进行词法分析，他负责从字符串中读到<code>token</code>并传递给<code>Parser</code>，这里我们的<code>token</code>可以用一个枚举类保存。</p><pre tabindex=0><code>public enum TokenType {
    NUM,X,MULTI,EXP,ADD,SUB,LP,RP,NULL
}
</code></pre><p>​ 同样沿用<code>training</code>代码中的逻辑，可以用<code>switch</code>语句等保存<code>token</code>。</p><h4 id=222-parser>2.2.2 Parser<a hidden class=anchor aria-hidden=true href=#222-parser>#</a></h4><p>​ 对于<code>parser</code>部分的设计同样沿用了<code>training</code>中的三个方法，根据当前<code>lexer</code>扫描到的<code>token</code>进行语义分析，在我的设计中参考了学长博客中的设计，为项设置出符号属性，在解析表达式时将项的符号传入。<del>这里同样需要注意的是<code>number^pow</code>的形式并不符合形式化表述，我的第一版代码中对这种形式进行了解析</del></p><p>​ 该类中借鉴了<code>training</code>中代码的三个方法进行解析</p><ul><li><code>parseExpr</code></li><li><code>parseTerm</code></li><li><code>parseFactor</code></li></ul><p>​ <strong>parseFactor中需要注意的是，读到(，即读到表达式或读到x即读到幂函数，还要再向后读一个看是不是^，如果是则说明该因子有指数(要为表达式设置指数属性)</strong></p><pre tabindex=0><code>    public Expr parseExpr() {
        Expr expr = new Expr();
        int sign = 1;//标记项的符号
        if (lexer.getCurTokenType() == TokenType.SUB) {
          //该项是负项
        } else if (lexer.getCurTokenType() == TokenType.ADD) {
           //该项为正项
        }
        expr.addTerm(parseTerm(sign));
        while (//有下一项)
        {
           //正负项讨论
        }
        return expr;
    }

    // parseExpr将项的符号传入
    public Term parseTerm(int sign) {
       //...
        while (//有下一个因子) {
           //...
        }
        return term;
    }

    public Factor parseFactor() {  
        if (//如果是左括号，说明是表达式) { 
            //跳过LP
            lexer.next();
            Expr expr = parseExpr();
            //跳过RP
            lexer.next();
            if (//如果是^) {
              //
            }
            return expr;
        } else if (//如果是数字) { 
            //...
        } else if (//如果是减号，说明这是个负数) {
           //...
        } else { //如果读到x
            //如果读到x则还需要判断他的下一个token是不是^
        }
    }
</code></pre><h3 id=23-计算输出>2.3 计算输出<a hidden class=anchor aria-hidden=true href=#23-计算输出>#</a></h3><h4 id=231计算思路>2.3.1计算思路<a hidden class=anchor aria-hidden=true href=#231计算思路>#</a></h4><p>​ 在经过语法分析之后，我们已经对表达式自顶向下建立起表达式树，而我们的输出结果，可以表示为多项式的形式
$$
Expr = \Sigma a_i x^{n_i}
$$
​ 因此我们可以考虑在每一个语法层级都将其转化为多项式形式(构造<code>toPoly</code>方法)，最终递归地得到计算结果。</p><p>​ 为了实现计算，我们定义出单项式类<code>Unit</code>，多项式类<code>Poly</code>。每个单项式以数组的形式管理各个单项式。我们先不考虑各个类中具体的方法实现，先去大体认知这个与表达式树映射架构的多项式树。</p><p>​ 我们的思路是将每一个层级都表现为多项式形式</p><ul><li><p><code>numberFactor</code>：对于数字因子，是树中的叶节点，我们可以简单的表示为只有一项的多项式：
$$
numberfactor = numberfactor*x^{0}
$$
这一项即为一个单项式，我们的多项式类中的数组中只保管这一个单项式即可</p></li><li><p><code>powFactor</code>：对于幂函数因子，同样为树中的叶节点，我们可以简单的表示为只有一项的多项式：
$$
powfactor = 1*x^{powfactor}
$$
这一项即为一个单项式，我们的多项式类中的数组中只保管这一个单项式即可</p></li><li><p><code>Term</code>：将<code>term</code>类转换为多项式形式，我们知道，多项式的表达形式为<code>factor*factor*factor</code>，我们只需要将他的各个因子的多项式相乘即可
$$
TermPoly = \Pi FactorPoly
$$</p></li><li><p><code>Expr</code>：将<code>expr</code>类转换为多项式形式，表达式的形式为<code>term + term + term </code>（其中<code>term</code>中包含该项正负号），只需要将构成表达式的各个项的多项式相加即可
$$
ExprPoly = \Sigma TermPoly
$$</p></li></ul><p>​ 这样又构建起一个<strong>递归</strong>的过程，<strong>自底向上</strong>地构建起多项式树。</p><p>​ 经过以上分析，我们知道需要新增的类有</p><ul><li><p><code>Unit</code></p></li><li><p><code>Poly</code></p><p>需要新增的方法有</p></li><li><p>每一个层次的<code>toPoly</code>，包括<code>Expr</code>,<code>Term</code>,<code>Factor</code></p></li><li><p><code>Poly</code>中的计算方法：</p><ul><li><code>addPoly</code></li><li><code>multiPoly</code></li><li><code>powPoly</code></li></ul></li><li><p>用于最终输出的<code>Unit</code>类和<code>Poly</code>类中的<code>toString</code></p></li></ul><h4 id=232-计算方法实现思路>2.3.2 计算方法实现思路<a hidden class=anchor aria-hidden=true href=#232-计算方法实现思路>#</a></h4><h5 id=2321-各层级topoly方法的实现>2.3.2.1 各层级toPoly方法的实现<a hidden class=anchor aria-hidden=true href=#2321-各层级topoly方法的实现>#</a></h5><ul><li>首先定义出<code>Unit</code>单项式类，其中包含两个属性<code>ceo</code>（系数），<code>pow</code>（指数），<code>Poly</code>类中包含<code>ArrayList &lt;Unit> unitlist</code></li></ul><p>​ 先从比较简单的底层实现，即<code>numberFactor</code>和<code>powFactor</code></p><ul><li><p><code>number toPoly</code></p><p>$$
number*x^0
$$</p><ul><li>只有一项的多项式</li></ul></li><li><p><code>pow toPoly</code></p><p>$$
1*x^{pow}
$$</p><ul><li>只有一项的多项式</li></ul></li><li><p><code>Term toPoly</code></p><pre tabindex=0><code>    public Poly toPoly() {
       //...
        for (Factor factor : factors) {
            //各个因子多项式相乘
        }
        if (this.sign == -1) {
            //多项式中单项式变号
        }
        return poly;
    }
</code></pre><ul><li><strong>需要注意的是，若项的符号为负号，则需要将项中的每一个单项式符号取反，在Poly类中构建方法negate()用于符号取反</strong></li></ul></li><li><p><code>Expr toPoly</code></p><pre tabindex=0><code>    public Poly toPoly() {
       //...
        for (Term term : terms) {
           //各个项多项式相加
        }
        return poly;
    }
</code></pre><p><strong>高层级调用低层级的toPoly，自底向上</strong></p></li></ul><h5 id=2322-poly中计算方法的实现>2.3.2.2 Poly中计算方法的实现<a hidden class=anchor aria-hidden=true href=#2322-poly中计算方法的实现>#</a></h5><h6 id=23221-addpoly>2.3.2.2.1 addPoly<a hidden class=anchor aria-hidden=true href=#23221-addpoly>#</a></h6><p>​ **计算思路：**我们对两个多项式进行加法，关键的步骤在于合并同类项，我们已知多项式中以数组的数据结构保存着，<strong>我们先将两个数组合并为一个数组，之后在一个数组中进行合并同类项。</strong></p><pre tabindex=0><code>    public Poly addPoly(Poly another) {
        //将两个数组中的单项式合并到一个数组中
        for(int i = 0; i &lt; units.size(); i++) {
            for(int j = i+1; j &lt; units.size(); j++) {
                //判断标准：指数相同，合并同类项
            }
        }
        return new Poly(units);
    }
</code></pre><p>​ 在数组中进行遍历，若找到和<code>i</code>元素指数相同的<code>j</code>元素，则系数相加到<code>i</code>元素上，删除<code>j</code>元素，并将<code>j</code>回退一位，实际上是保证下次遍历从<code>i+1</code>开始。</p><h6 id=23222-multipoly>2.3.2.2.2 multiPoly<a hidden class=anchor aria-hidden=true href=#23222-multipoly>#</a></h6><p>​ **计算思路：**我们对两个多项式中各项相乘的结果加入新的多项式变量。<strong>这里注意：在我的实现方法中，是从底向上构建表达式，这样在相乘之前，项表达式是空的，需要进行判断，如果是空的，就返回当前因子表达式加入项表达式中，再继续与其他因子表达式相乘，当然还有另一种方法，就是在乘之前就先加进去一个因子表达式</strong></p><pre tabindex=0><code>    public Poly multiPoly(Poly another) {
        //...这里需要判断是不是空
        if(如果为空){
        	//...
        } else {
        	for(Unit unit1 : this.unitlist) {
            	for(Unit unit2 : another.unitlist) {
                	//因子多项式相乘
            	}
        	}
        	return new Poly(units);
        }
    }
</code></pre><h6 id=23223-negate>2.3.2.2.3 negate<a hidden class=anchor aria-hidden=true href=#23223-negate>#</a></h6><p>​ 对多项式中的每一个单项式的符号进行取反，我采用两步实现，在<code>Poly</code>中进行<code>Unit</code>遍历，在<code>Unit</code>类中利用<code>BigInteger</code>的方法<code>.negate()</code>取反。</p><h4 id=233-输出思路及方法>2.3.3 输出思路及方法<a hidden class=anchor aria-hidden=true href=#233-输出思路及方法>#</a></h4><p>​ 我们在<code>Unit</code>类和<code>Poly</code>类中都要实现<code>toString</code>方法进行递归调用。</p><h5 id=2331-unit-tostring>2.3.3.1 unit toString<a hidden class=anchor aria-hidden=true href=#2331-unit-tostring>#</a></h5><p>​ 将每个<code>unit</code>转化为
$$
coe*x^{pow}
$$</p><h5 id=2332-poly-tostring>2.3.3.2 poly toString<a hidden class=anchor aria-hidden=true href=#2332-poly-tostring>#</a></h5><p>​ 将各个项多项式连接起来，并进行优化输出，常见的优化输出有：</p><ul><li><p>系数为0：不输出</p></li><li><p>系数为1：省略系数，<code>x</code></p></li><li><p>系数为-1：省略系数，<code>-x</code></p></li><li><p>指数为0：输出1</p></li><li><p>指数为1：省略指数，<code>x</code></p></li><li><p>之后可以调用之前字符串预处理过程中的几个方法</p><ul><li><p>去掉连续的+-号</p></li><li><p>若第一项为负，则从后面找一个正项放在前面，大概给出这个方法的伪代码，这个方法的思路是：<strong>先判断第一项是否为负项（第一个符号是否为负号），之后看是否能找到正项，如果能就把他俩换一下位置，字符串层级的操作要注意substring方法包含左字符不包含右字符</strong></p><pre tabindex=0><code> if (this.input.charAt(0) == &#39;-&#39;) {
            int addpos = -1;
            int i = 0;
            for (i = 0;i &lt; this.input.length();i++) {
                //找到+号，记录位置
            }
            if (addpos != -1) { //如果找到了+，就找这一项后的符号，将这一项分割出来
                for (i = addpos + 1;i &lt; this.input.length();i++) {
                    //...
                }
               //处理字符串，将正项一道前面，之后会调用删除前导+的方法，使得表达式缩短一个字符，这么麻烦其实只缩短了一个字符hhhhhh
            }
        }
</code></pre></li><li><p>去掉不必要的前导+</p></li><li><p><strong>同时要注意如果输出长度为0，要补充输出“0”</strong></p></li></ul></li></ul><h2 id=3后续对于时间复杂度的优化>3.后续对于时间复杂度的优化<a hidden class=anchor aria-hidden=true href=#3后续对于时间复杂度的优化>#</a></h2><h3 id=31-对于时间复杂度的分析>3.1 对于时间复杂度的分析<a hidden class=anchor aria-hidden=true href=#31-对于时间复杂度的分析>#</a></h3><p>​ 在第一版代码中，构建多项式过程中我们使用<code>arraylist</code>来存储单项式，之后在后续计算过程中的时间复杂度:</p><ul><li><strong>addPoly:O(n^2)</strong></li><li><strong>multiPoly:O(n^2)</strong></li><li><strong>powPoly:调用multiPoly,约等于O(n^3)</strong></li></ul><p>​ 这样的时间复杂度在面对一些指数比较大的表达式时会出现<code>TLE</code>的情况，后来经过同学的提示，<strong>可以使用HashMap来存储单项式，key为指数，value为系数</strong>，这样的确可以大大简化时间复杂度，同时也可以省去一个类<code>Unit</code>(~~但是我没舍得删)。<strong>另外一个点：可以在每次乘法结束之后都进行一次合并同类项addPoly，这样可以更加减少时间复杂度</strong></p><ul><li><strong>addPoly:O(n)</strong></li><li><strong>multiPoly:O(n^2)</strong></li></ul><h3 id=32-具体方法的实现>3.2 具体方法的实现<a hidden class=anchor aria-hidden=true href=#32-具体方法的实现>#</a></h3><h4 id=321-addpoly>3.2.1 addPoly<a hidden class=anchor aria-hidden=true href=#321-addpoly>#</a></h4><pre tabindex=0><code>public Poly addPoly(Poly another) {
        Iterator&lt;Map.Entry&lt;Integer, BigInteger&gt;&gt; iterator = this.unitmap.entrySet().iterator();
        while (((Iterator&lt;?&gt;) iterator).hasNext()) {
            Map.Entry&lt;Integer,BigInteger&gt; entry = iterator.next();
            int pow = entry.getKey();
            BigInteger coe = entry.getValue();
            if (another.unitmap.containsKey(pow)) {
                BigInteger coe1 = another.unitmap.get(pow).add(coe);
                another.unitmap.put(pow,coe1);
            } else {
                another.unitmap.put(pow,coe);
            }
            iterator.remove();
        }
        return another;
   }
</code></pre><p>​ <strong>主要思路是数学上的多项式合并思路，遍历一个多项式，在另一个多项式中检查是否有这个项的指数，如果有就合并，如果没有就加入到另一个多项式，最终返回另一个多项式</strong></p><ul><li><p>这里需要注意的是，关于<code>HashMap</code>边遍历边删除的需求，如果使用增强for循环，会报错。需要使用迭代器进行。</p><pre tabindex=0><code> Iterator&lt;...&gt; iterator = ...iterator();
 while (iterator.hasNext()) {
        //...
         iterator.remove();
 }
</code></pre></li></ul><h4 id=322-multipoly>3.2.2 multiPoly<a hidden class=anchor aria-hidden=true href=#322-multipoly>#</a></h4><pre tabindex=0><code> public Poly multiPoly(Poly another) {
        if (this.unitmap.isEmpty()) {
            return new Poly(another.unitmap);
        } else {
            HashMap&lt;Integer, BigInteger&gt; emptyMap = new HashMap&lt;&gt;();
            Poly emptypoly = new Poly(emptyMap);
            HashMap&lt;Integer, BigInteger&gt; hashMap = new HashMap&lt;&gt;();
            for (int pow1 : this.unitmap.keySet()) {
                for (int pow2 : another.unitmap.keySet()) {
                    int pow = pow1 + pow2;
                    BigInteger coe = this.unitmap.get(pow1).multiply(another.unitmap.get(pow2));
                    if (hashMap.containsKey(pow)) {
                        BigInteger coe1 = hashMap.get(pow).add(coe);
                        hashMap.put(pow,coe1);
                    } else {
                        hashMap.put(pow,coe);
                    }
                }
            }
            return new Poly(hashMap);
        }
    }
</code></pre><ul><li><p>这里不涉及到对于元素的删除等操作，可以使用增强for循环</p></li><li><p>这里需要明确<code>java</code>中<code>HashMap</code>的一个特性：当我们向<code>HashMap</code>中加入已经存在的<code>key</code>时，会覆盖掉原来的<code>value</code>，我利用这一点进行了<code>value</code>的更新</p><pre tabindex=0><code>there is a new &lt;newkey,newvalue&gt;
if (newkey exists) {
	find(key,value)
	value -&gt; newvalue
} else {
	put&lt;newkey,newvalue&gt;
}
</code></pre></li></ul><h4 id=323-negate>3.2.3 negate<a hidden class=anchor aria-hidden=true href=#323-negate>#</a></h4><ul><li><p>同样要注意对于存在的<code>key</code>的<code>value</code>的值的更新</p><pre tabindex=0><code>public void negate() {
    for (Integer pow : this.unitmap.keySet()) {
        BigInteger coe = this.unitmap.get(pow);
        this.unitmap.put(pow,coe.negate());
    }
}
</code></pre></li></ul><h2 id=4-代码分析>4. 代码分析<a hidden class=anchor aria-hidden=true href=#4-代码分析>#</a></h2><h3 id=41-uml类图分析>4.1 UML类图分析<a hidden class=anchor aria-hidden=true href=#41-uml类图分析>#</a></h3><p><img alt=image-20240319213020898 loading=lazy src=/img/image-20240319213020898.png></p><ul><li>从左到右大致可以分为三个部分，输入，解析，计算输出</li></ul><h3 id=42-代码复杂度分析>4.2 代码复杂度分析<a hidden class=anchor aria-hidden=true href=#42-代码复杂度分析>#</a></h3><p>​ 我使用Metricsreloaded进行分析，先对几个标准进行解释</p><ul><li><code>Cogc</code>：圈复杂度，程序中独立路径的数目</li><li><code>ev(G)</code>：本质复杂度，程序中必须要有的控制流程数目</li><li><code>iv(G)</code>：内在复杂度，程序本质上的复杂度</li><li><code>v(G)</code>：程序体积，程序中独立语句数目</li></ul><p>​ <strong>以下为程序中复杂度超标的方法</strong></p><p><img alt=image-20240319214056244 loading=lazy src=/img/image-20240319214056244.png></p><p>​ 可以看到复杂度主要集中在进行化简输出的部分或对输入字符串进行预处理的方法，字符串预处理方法需要对字符串进行循环遍历并在过程中条件判断，化简输出部分有对每一项指数、系数的讨论，复杂度均较高，其中语义解析部分parseFactor由于有多种因子，复杂度较高。</p><h2 id=5-bug修复>5. bug修复<a hidden class=anchor aria-hidden=true href=#5-bug修复>#</a></h2><p>​ 在第一次作业中强测以及互测均未出现bug，在互测环节中房友的优化输出出现bug，hack数据为<code>1+(x^8)^8</code></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://coder0xe.github.io/tags/feb/>Feb</a></li></ul><nav class=paginav><a class=prev href=https://coder0xe.github.io/posts/c-knowledge/><span class=title>« Prev</span><br><span>C-knowledge</span>
</a><a class=next href=https://coder0xe.github.io/posts/cotoos/><span class=title>Next »</span><br><span>COtoOS</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share OO-Unit1-hw1 on x" href="https://x.com/intent/tweet/?text=OO-Unit1-hw1&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f&amp;hashtags=Feb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OO-Unit1-hw1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f&amp;title=OO-Unit1-hw1&amp;summary=OO-Unit1-hw1&amp;source=https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OO-Unit1-hw1 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f&title=OO-Unit1-hw1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OO-Unit1-hw1 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OO-Unit1-hw1 on whatsapp" href="https://api.whatsapp.com/send?text=OO-Unit1-hw1%20-%20https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OO-Unit1-hw1 on telegram" href="https://telegram.me/share/url?text=OO-Unit1-hw1&amp;url=https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OO-Unit1-hw1 on ycombinator" href="https://news.ycombinator.com/submitlink?t=OO-Unit1-hw1&u=https%3a%2f%2fcoder0xe.github.io%2fposts%2foo-unit1-hw1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://coder0xe.github.io/>coder0xe's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>